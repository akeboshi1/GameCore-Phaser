(this["webpackJsonpTooqingCore"] = this["webpackJsonpTooqingCore"] || []).push([[0],[
/* 0 */,
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Logger; });
/* unused harmony export log */
/* unused harmony export error */
var __spreadArrays = (undefined && undefined.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
/* tslint:disable */
var Logger = /** @class */ (function () {
    function Logger() {
        this.mErrorList = [];
        this.mWarnList = [];
    }
    Logger.getInstance = function () {
        if (!Logger._instance)
            Logger._instance = new Logger();
        return Logger._instance;
    };
    Logger.prototype.fatal = function (message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        if (false) {}
        throw message;
    };
    Logger.prototype.log = function (message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        console.log.apply(console, __spreadArrays([message], optionalParams));
    };
    Logger.prototype.error = function (message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        console.error.apply(console, __spreadArrays([message], optionalParams));
        this.mErrorList.push(message);
    };
    Logger.prototype.warn = function (message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        console.warn.apply(console, __spreadArrays([message], optionalParams));
        this.mWarnList.push(message);
    };
    Logger.prototype.debug = function (message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        console.log.apply(console, __spreadArrays([message], optionalParams));
    };
    Logger.prototype.info = function (message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        console.info.apply(console, __spreadArrays([message], optionalParams));
    };
    Logger.prototype.getErrorList = function () {
        return this.mErrorList;
    };
    Logger.prototype.getWarnList = function () {
        return this.mWarnList;
    };
    return Logger;
}());

function log(message) {
    var optionalParams = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        optionalParams[_i - 1] = arguments[_i];
    }
    console.log.apply(console, __spreadArrays([message], optionalParams));
}
function error(message) {
    var optionalParams = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        optionalParams[_i - 1] = arguments[_i];
    }
    console.error.apply(console, __spreadArrays([message], optionalParams));
}


/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Pos; });
var Pos = /** @class */ (function () {
    function Pos(x, y, z, depth) {
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
        this.depth = depth | 0;
    }
    Pos.prototype.add = function (x, y, z) {
        this.x += x;
        this.x += y;
        this.z += z ? z : 0;
        return this;
    };
    Pos.prototype.equal = function (p) {
        return p.x === this.x && p.y === this.y && p.z === this.z && p.depth === this.depth;
    };
    Pos.prototype.toString = function () {
        return "Pos >> x: " + this.x + ", y: " + this.y + ", z: " + this.z + ", depth: " + this.depth;
    };
    Pos.prototype.toPoint = function () {
        return new Phaser.Geom.Point(this.x, this.y);
    };
    return Pos;
}());



/***/ }),
/* 7 */,
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "c", function() { return /* binding */ resUtil_Url; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ resUtil_ResUtils; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* binding */ WhiteButton; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ Border; });

// UNUSED EXPORTS: BlackButton, BlueButton, CloseButton, Background, TransparentButton

// CONCATENATED MODULE: ./src/const/constants.ts
var PI_EXTENSION_REGEX = /\.pi$/i;
var HTTP_REGEX = /^(http|https):/i;

// CONCATENATED MODULE: ./src/utils/resUtil.ts

var resUtil_Url = /** @class */ (function () {
    function Url() {
    }
    Url.getRes = function (value) {
        // 资源地址根路径 CONFIG.BUNDLE_RESOURCES_ROOT
        if (Object({"debug":true,"api_root":"http://172.18.0.100:17170/","osd":"https://osd.tooqing.com/","gateway":Object({"host":"172.18.0.103","port":12100,"secure":false}),"game_id":"5e9a7dace87abc390c4b1b73","virtual_world_id":"65541"}).BUNDLE_RESOURCES_ROOT) {
            return Object({"debug":true,"api_root":"http://172.18.0.100:17170/","osd":"https://osd.tooqing.com/","gateway":Object({"host":"172.18.0.103","port":12100,"secure":false}),"game_id":"5e9a7dace87abc390c4b1b73","virtual_world_id":"65541"}).BUNDLE_RESOURCES_ROOT
                + value;
        }
        return Url.RES_PATH + value;
    };
    Url.getUIRes = function (dpr, value) {
        if (Object({"debug":true,"api_root":"http://172.18.0.100:17170/","osd":"https://osd.tooqing.com/","gateway":Object({"host":"172.18.0.103","port":12100,"secure":false}),"game_id":"5e9a7dace87abc390c4b1b73","virtual_world_id":"65541"}).BUNDLE_RESOURCES_ROOT) {
            return Object({"debug":true,"api_root":"http://172.18.0.100:17170/","osd":"https://osd.tooqing.com/","gateway":Object({"host":"172.18.0.103","port":12100,"secure":false}),"game_id":"5e9a7dace87abc390c4b1b73","virtual_world_id":"65541"}).BUNDLE_RESOURCES_ROOT
                + dpr + "x" + value;
        }
        return Url.RESUI_PATH + (dpr + "x/" + value);
    };
    Url.getOsdRes = function (value) {
        if (Url.OSD_PATH) {
            if (HTTP_REGEX.test(Url.OSD_PATH)) {
                return Url.OSD_PATH + value;
            }
            return "https://osd.tooqing.com/" + value;
        }
        return value;
    };
    Url.OSD_PATH = "";
    Url.RES_PATH = "";
    Url.RESUI_PATH = "";
    return Url;
}());

var resUtil_ResUtils = /** @class */ (function () {
    function ResUtils() {
    }
    ResUtils.getPartName = function (value) {
        return value + "_png";
    };
    ResUtils.getPartUrl = function (value) {
        // TOOD 编辑器或调式会传入本地资源。Avatar资源只存在cdn
        if (HTTP_REGEX.test(resUtil_Url.OSD_PATH)) {
            return resUtil_Url.OSD_PATH + "avatar/part/" + value + ".png";
        }
        return "https://osd.tooqing.com/" + "avatar/part/" + value + ".png";
    };
    ResUtils.getGameConfig = function (value) {
        if (HTTP_REGEX.test(value)) {
            return value;
        }
        return resUtil_Url.OSD_PATH + value;
    };
    return ResUtils;
}());

var BlackButton = /** @class */ (function () {
    function BlackButton() {
    }
    BlackButton.getName = function () {
        return "black_button";
    };
    BlackButton.getPNG = function () {
        return resUtil_Url.getRes("ui/common/button.png");
    };
    BlackButton.getColumns = function () {
        return [4, 2, 4];
    };
    BlackButton.getRows = function () {
        return [4, 2, 4];
    };
    BlackButton.getConfig = function () {
        return {
            top: 4,
            left: 4,
            right: 4,
            bottom: 4
        };
    };
    return BlackButton;
}());

var BlueButton = /** @class */ (function () {
    function BlueButton() {
    }
    BlueButton.getName = function () {
        return "button_blue";
    };
    BlueButton.getPNG = function () {
        return resUtil_Url.getRes("ui/common/button_blue.png");
    };
    BlueButton.getJSON = function () {
        return resUtil_Url.getRes("ui/common/button_blue.json");
    };
    BlueButton.getColumns = function () {
        return [7, 1, 7];
    };
    BlueButton.getRows = function () {
        return [7, 1, 7];
    };
    BlueButton.getConfig = function () {
        return {
            left: 7,
            top: 7,
            right: 7,
            bottom: 7
        };
    };
    return BlueButton;
}());

var WhiteButton = /** @class */ (function () {
    function WhiteButton() {
    }
    WhiteButton.getName = function () {
        return "button_white";
    };
    WhiteButton.getPNG = function () {
        return resUtil_Url.getRes("ui/common/button_white.png");
    };
    WhiteButton.getJSON = function () {
        return resUtil_Url.getRes("ui/common/button_white.json");
    };
    WhiteButton.getColumns = function () {
        return [7, 1, 7];
    };
    WhiteButton.getRows = function () {
        return [7, 1, 7];
    };
    WhiteButton.getConfig = function () {
        return {
            left: 7,
            top: 7,
            right: 7,
            bottom: 7
        };
    };
    return WhiteButton;
}());

var CloseButton = /** @class */ (function () {
    function CloseButton() {
    }
    CloseButton.getName = function () {
        return "common_clsBtn";
    };
    CloseButton.getPNG = function () {
        return resUtil_Url.getRes("ui/common/common_clsBtn.png");
    };
    CloseButton.getJSON = function () {
        return resUtil_Url.getRes("ui/common/common_clsBtn.json");
    };
    CloseButton.getFrameConfig = function () {
        return { frameWidth: 16, frameHeight: 16, startFrame: 1, endFrame: 3 };
    };
    return CloseButton;
}());

var Background = /** @class */ (function () {
    function Background() {
    }
    Background.getName = function () {
        return "common_background";
    };
    Background.getPNG = function () {
        return resUtil_Url.getRes("ui/common/common_panelBg.png");
    };
    Background.getColumns = function () {
        return [11, 9, 11];
    };
    Background.getRows = function () {
        return [14, 13, 14];
    };
    Background.getConfig = function () {
        return {
            left: 10,
            top: 15,
            right: 10,
            bottom: 15,
        };
    };
    return Background;
}());

var Border = /** @class */ (function () {
    function Border() {
    }
    Border.getName = function () {
        return "common_border";
    };
    Border.getPNG = function () {
        return resUtil_Url.getRes("ui/common/common_border.png");
    };
    Border.getColumns = function () {
        return [4, 2, 4];
    };
    Border.getRows = function () {
        return [4, 2, 4];
    };
    Border.getConfig = function () {
        return {
            left: 4,
            top: 4,
            right: 4,
            bottom: 4
        };
    };
    return Border;
}());

var TransparentButton = /** @class */ (function () {
    function TransparentButton() {
    }
    TransparentButton.getName = function () {
        return "button_transparent";
    };
    TransparentButton.getPNG = function () {
        return resUtil_Url.getRes("ui/common/button_transparent.png");
    };
    TransparentButton.getJSON = function () {
        return resUtil_Url.getRes("ui/common/button_transparent.json");
    };
    TransparentButton.getConfig = function () {
        return {
            left: 4,
            top: 4,
            right: 4,
            bottom: 4
        };
    };
    return TransparentButton;
}());



/***/ }),
/* 9 */,
/* 10 */,
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "d", function() { return /* binding */ PlayerState; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ Direction; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* binding */ InputEnable; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ element_Element; });

// EXTERNAL MODULE: ./src/rooms/display/dragonbones.display.ts + 1 modules
var dragonbones_display = __webpack_require__(97);

// EXTERNAL MODULE: ./src/rooms/display/frames.display.ts
var frames_display = __webpack_require__(34);

// EXTERNAL MODULE: ./node_modules/pixelpai_proto/protocols.js
var protocols = __webpack_require__(2);

// EXTERNAL MODULE: ./src/utils/log.ts
var log = __webpack_require__(5);

// EXTERNAL MODULE: ./src/utils/pos.ts
var utils_pos = __webpack_require__(6);

// EXTERNAL MODULE: ./src/rooms/cameras/block.object.ts
var block_object = __webpack_require__(45);

// EXTERNAL MODULE: ./lib/rexui/lib/plugins/utils/object/IsArray.js
var IsArray = __webpack_require__(46);

// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/ninepatch/texture/SetTexture.js


var SetTexture = function (key, baseFrameName, columns, rows) {
    if (Object(IsArray["a" /* default */])(baseFrameName)) {
        rows = columns;
        columns = baseFrameName;
        baseFrameName = undefined;
    }

    if (baseFrameName === undefined) {
        baseFrameName = '__BASE';
    }

    this.textureKey = key;
    this.baseFrameName = baseFrameName;
    this.columns.data = columns;
    this.columns.count = (columns) ? columns.length : 0;
    this.columns.stretch = 0;
    this.columns.minWidth = 0;
    this.rows.data = rows;
    this.rows.count = (rows) ? rows.length : 0;
    this.rows.stretch = 0;
    this.rows.minHeight = 0;

    var texture = this.scene.textures.get(key);
    if (!texture) {
        this.clear();
        return this;
    }
    if (!columns || !rows) {
        this.clear();
        return this;
    }

    // Get remainder width/height for unknown width/height
    var baseFrame = texture.frames[baseFrameName];
    var remainderTextureWidth = baseFrame.width;
    var unknownColumnWidthCount = 0;
    for (var i = 0, cnt = columns.length; i < cnt; i++) {
        if (columns[i] === undefined) {
            unknownColumnWidthCount++;
        } else if (typeof (columns[i]) === 'number') {
            remainderTextureWidth -= columns[i];
        } else {
            remainderTextureWidth -= columns[i].width;
        }
    }
    var unknownColumnWidth = remainderTextureWidth / unknownColumnWidthCount;

    var remainderTextureHeight = baseFrame.height;
    var unknownRowHeightCount = 0;
    for (var i = 0, cnt = rows.length; i < cnt; i++) {
        if (rows[i] === undefined) {
            unknownRowHeightCount++;
        } else if (typeof (rows[i]) === 'number') {
            remainderTextureHeight -= rows[i];
        } else {
            remainderTextureHeight -= rows[i].width;
        }
    }
    var unknownRowHeight = remainderTextureHeight / unknownRowHeightCount;

    var row, col, rowHeight, colWidth, frameName;
    var offsetX = 0, offsetY = 0;
    for (var j = 0, jcnt = rows.length; j < jcnt; j++) {
        // Unknown height
        if (rows[j] === undefined) {
            rows[j] = unknownRowHeight;
        }

        if (typeof (rows[j]) === 'number') {
            rows[j] = {
                height: rows[j],
                stretch: (j % 2),
            }
        }

        row = rows[j];
        rowHeight = row.height;

        this.rows.stretch += (row.stretch | 0);
        this.rows.minHeight += (row.stretch > 0) ? 0 : rowHeight;

        offsetX = 0;
        for (var i = 0, icnt = columns.length; i < icnt; i++) {
            // Unknown width
            if (columns[i] === undefined) {
                columns[i] = unknownColumnWidth;
            }

            if (typeof (columns[i]) === 'number') {
                columns[i] = {
                    width: columns[i],
                    stretch: (i % 2),
                }
            }

            col = columns[i];
            colWidth = col.width;

            if (j === 0) {
                this.columns.stretch += (col.stretch | 0);
                this.columns.minWidth += (col.stretch > 0) ? 0 : colWidth;
            }

            if ((colWidth >= 1) && (rowHeight >= 1)) {
                frameName = this.getFrameNameCallback(i, j, baseFrameName);
                if (frameName) {
                    texture.add(
                        frameName, 0,
                        (offsetX + baseFrame.cutX), (offsetY + baseFrame.cutY),
                        colWidth, rowHeight
                    );
                    // Do nothing if frameName is existed
                }
            } else {
                console.warn(`Size of Grid(${i},${j}) = ${colWidth}x${rowHeight}, which is invalid`);
            }
            offsetX += colWidth;
        }
        offsetY += rowHeight;
    }

    this.updateTexture();
    return this;
}

/* harmony default export */ var texture_SetTexture = (SetTexture);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/renderTexture/MakeChildImageGameObject.js
var MakeChildImageGameObject = function (parent, key, className) {
    if (className === undefined) {
        className = 'image';
    }
    if (!parent[key]) {
        parent[key] = parent.scene.make[className]({
            add: false,
            origin: { x: 0, y: 0 },
        });
        parent.on('destroy', function () {
            if (parent[key]) {
                parent[key].destroy();
                parent[key] = undefined;
            }
        })
    }
    return parent[key];
}
/* harmony default export */ var renderTexture_MakeChildImageGameObject = (MakeChildImageGameObject);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/ninepatch/texture/UpdateTexture.js


var UpdateTexture = function () {
    this.clear();

    if (this.textureKey === undefined) {
        return this;
    }
    var texture = this.scene.textures.get(this.textureKey);
    if (!texture) {
        return this;
    }

    var stretchWidth = this.width - this.columns.minWidth;
    var proportionWidth, fixedPartScaleX;
    if (stretchWidth >= 0) {
        proportionWidth = (this.columns.stretch > 0) ? (stretchWidth / this.columns.stretch) : 0;
        fixedPartScaleX = 1;
    } else {
        proportionWidth = 0;
        fixedPartScaleX = (this.width / this.columns.minWidth);
    }

    var stretchHeight = this.height - this.rows.minHeight;
    var proportionHeight, fixedPartScaleY;
    if (stretchHeight >= 0) {
        proportionHeight = (this.rows.stretch > 0) ? (stretchHeight / this.rows.stretch) : 0;
        fixedPartScaleY = 1;
    } else {
        proportionHeight = 0;
        fixedPartScaleY = (this.height / this.rows.minHeight);
    }

    var frameName, col, row, colWidth, rowHeight;
    var offsetX = 0, offsetY = 0;
    var gameObject, imageType;
    for (var j = 0, jcnt = this.rows.count; j < jcnt; j++) {
        row = this.rows.data[j];
        rowHeight = (row.stretch === 0) ? (row.height * fixedPartScaleY) : (proportionHeight * row.stretch);

        offsetX = 0;
        for (var i = 0, icnt = this.columns.count; i < icnt; i++) {
            col = this.columns.data[i];
            colWidth = (col.stretch === 0) ? (col.width * fixedPartScaleX) : (proportionWidth * col.stretch);

            frameName = this.getFrameNameCallback(i, j, this.baseFrameName);
            if (frameName && (colWidth > 0) && (rowHeight > 0) && texture.has(frameName)) {
                if ((row.stretch === 0) && (col.stretch === 0)) { // Fixed parts
                    imageType = 0; // Draw image
                } else { // Stretchable parts
                    if (this.getStretchMode(i, j) === 0) { // Scaled image
                        imageType = 0; // Draw scaled image
                    } else { // Repeat tile-sprite
                        imageType = 1; // Draw tile-sprite
                    }
                }

                if (imageType === 0) {
                    gameObject = renderTexture_MakeChildImageGameObject(this, '_image', 'image');
                    gameObject
                        .setTexture(this.textureKey, frameName)
                        .setDisplaySize(colWidth, rowHeight);
                } else {
                    gameObject = renderTexture_MakeChildImageGameObject(this, '_tileSprite', 'tileSprite');
                    gameObject
                        .setTexture(this.textureKey, frameName)
                        .setSize(colWidth, rowHeight);
                }
            }

            if (gameObject) {
                this.draw(gameObject, offsetX, offsetY);
                gameObject = undefined;
            }
            offsetX += colWidth;
        }

        offsetY += rowHeight;
    }
}

/* harmony default export */ var texture_UpdateTexture = (UpdateTexture);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/ninepatch/texture/SetStretchMode.js
const IsPlainObject = Phaser.Utils.Objects.IsPlainObject;
const GetValue = Phaser.Utils.Objects.GetValue;

var SetStretchMode = function(mode) {
    if (IsPlainObject(mode)) {
        this.stretchMode.edge = parseMode(GetValue(mode, 'edge', 0));
        this.stretchMode.internal = parseMode(GetValue(mode, 'internal', 0));
    } else {
        mode = parseMode(mode);
        this.stretchMode.edge = mode;
        this.stretchMode.internal = mode;
    }
    return this;
};

var parseMode = function (mode) {
    if (typeof (mode) === 'string') {
        mode = EXTENDMODE[mode];
    }
    return mode;
}

const EXTENDMODE = {
    scale: 0,
    repeat: 1,
}

/* harmony default export */ var texture_SetStretchMode = (SetStretchMode);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/ninepatch/utils/IsEdge.js
var IsEdge = function (colIndex, rowIndex) {
    return (colIndex === 0) || (colIndex === (this.columns.count - 1)) ||
        (rowIndex === 0) || (rowIndex === (this.rows.count - 1));
}

/* harmony default export */ var utils_IsEdge = (IsEdge);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/ninepatch/texture/GetStretchMode.js


var GetStretchMode = function(colIndex, rowIndex) {
    return (utils_IsEdge.call(this, colIndex, rowIndex)) ? this.stretchMode.edge : this.stretchMode.internal;
};

/* harmony default export */ var texture_GetStretchMode = (GetStretchMode);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/ninepatch/texture/TextureMethods.js





/* harmony default export */ var TextureMethods = ({
    setTexture: texture_SetTexture,
    updateTexture: texture_UpdateTexture,
    setStretchMode: texture_SetStretchMode,
    getStretchMode: texture_GetStretchMode,
});
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/ninepatch/utils/DefaultGetFrameNameCallback.js
const DefaultBaseFrameName = '__BASE';

var GetFrameNameCallback = function (colIndex, rowIndex, baseFrameName) {
    if (baseFrameName === DefaultBaseFrameName) {
        return `${colIndex},${rowIndex}`;
    } else {
        return `${baseFrameName}_${colIndex},${rowIndex}`;
    }
}

/* harmony default export */ var DefaultGetFrameNameCallback = (GetFrameNameCallback);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/ninepatch/NinePatch.js




const RenderTexture = Phaser.GameObjects.RenderTexture;
const NinePatch_IsPlainObject = Phaser.Utils.Objects.IsPlainObject;
const NinePatch_GetValue = Phaser.Utils.Objects.GetValue;

class NinePatch_NinePatch extends RenderTexture {
    constructor(scene, x, y, width, height, key, baseFrame, columns, rows, config) {
        if (NinePatch_IsPlainObject(x)) {
            config = x;
            x = NinePatch_GetValue(config, 'x', 0);
            y = NinePatch_GetValue(config, 'y', 0);
            width = NinePatch_GetValue(config, 'width', 1);
            height = NinePatch_GetValue(config, 'height', 1);
            key = NinePatch_GetValue(config, 'key', undefined);
            baseFrame = NinePatch_GetValue(config, 'baseFrame', undefined);
            columns = NinePatch_GetValue(config, 'columns', undefined);
            rows = NinePatch_GetValue(config, 'rows', undefined);
        } else if (NinePatch_IsPlainObject(width)) {
            config = width;
            width = NinePatch_GetValue(config, 'width', 1);
            height = NinePatch_GetValue(config, 'height', 1);
            key = NinePatch_GetValue(config, 'key', undefined);
            baseFrame = NinePatch_GetValue(config, 'baseFrame', undefined);
            columns = NinePatch_GetValue(config, 'columns', undefined);
            rows = NinePatch_GetValue(config, 'rows', undefined);
        } else if (NinePatch_IsPlainObject(key)) {
            config = key;
            key = NinePatch_GetValue(config, 'key', undefined);
            baseFrame = NinePatch_GetValue(config, 'baseFrame', undefined);
            columns = NinePatch_GetValue(config, 'columns', undefined);
            rows = NinePatch_GetValue(config, 'rows', undefined);
        } else if (NinePatch_IsPlainObject(baseFrame)) {
            config = baseFrame;
            baseFrame = NinePatch_GetValue(config, 'baseFrame', undefined);
            columns = NinePatch_GetValue(config, 'columns', undefined);
            rows = NinePatch_GetValue(config, 'rows', undefined);
        } else if (Object(IsArray["a" /* default */])(baseFrame)) {
            config = rows;
            rows = columns;
            columns = baseFrame;
            baseFrame = NinePatch_GetValue(config, 'baseFrame', undefined);
        } else if (NinePatch_IsPlainObject(columns)) {
            config = columns;
            columns = NinePatch_GetValue(config, 'columns', undefined);
            rows = NinePatch_GetValue(config, 'rows', undefined);
        }

        super(scene, x, y, width, height);
        this.columns = {};
        this.rows = {};
        this.stretchMode = {};
        this._tileSprite = undefined; // Reserved for drawing image
        this._image = undefined; // Reserved for drawing image

        this.setOrigin(0.5, 0.5);
        this.setGetFrameNameCallback(NinePatch_GetValue(config, 'getFrameNameCallback', undefined));
        this.setStretchMode(NinePatch_GetValue(config, 'stretchMode', 0));
        this.setTexture(key, baseFrame, columns, rows); // Also update render texture
    }

    setGetFrameNameCallback(callback) {
        if (callback === undefined) {
            callback = DefaultGetFrameNameCallback;
        }
        this.getFrameNameCallback = callback;
        return this;
    }

    get minWidth() {
        return this.columns.minWidth;
    }

    get minHeight() {
        return this.rows.minHeight;
    }

    resize(width, height) {
        if ((this.width === width) && (this.height === height)) {
            return this;
        }

        super.resize(width, height);
        this.updateTexture();
        return this;
    }
}

Object.assign(
    NinePatch_NinePatch.prototype,
    TextureMethods
);

/* harmony default export */ var ninepatch_NinePatch = (NinePatch_NinePatch);
// CONCATENATED MODULE: ./src/ui/components/dynamic.ninepatch.ts

var dynamic_ninepatch_DynamicNinepatch = /** @class */ (function () {
    function DynamicNinepatch(mScene, mParent) {
        this.mScene = mScene;
        this.mParent = mParent;
    }
    DynamicNinepatch.prototype.load = function (value, config, completeCallBack, loadContext) {
        this.mLoadCompleteCallBack = completeCallBack;
        this.mLoadContext = loadContext;
        this.mConfig = config;
        this.mUrl = value;
        if (this.mScene.cache.obj.get(value)) {
            this.onLoadCompleteHandler();
        }
        else {
            this.mScene.load.image(this.mUrl, this.mUrl);
            this.mScene.load.once(Phaser.Loader.Events.COMPLETE, this.onLoadCompleteHandler, this);
            this.mScene.load.start();
        }
    };
    DynamicNinepatch.prototype.onLoadCompleteHandler = function () {
        this.mImage = new ninepatch_NinePatch(this.mScene, this.mConfig);
        if (this.mLoadCompleteCallBack) {
            this.mLoadCompleteCallBack.call(this.mLoadContext, this.mImage);
            this.mLoadCompleteCallBack = null;
            this.mLoadContext = null;
        }
    };
    Object.defineProperty(DynamicNinepatch.prototype, "image", {
        get: function () {
            return this.mImage;
        },
        enumerable: false,
        configurable: true
    });
    return DynamicNinepatch;
}());


// EXTERNAL MODULE: ./src/utils/resUtil.ts + 1 modules
var resUtil = __webpack_require__(8);

// EXTERNAL MODULE: ./src/utils/font.ts
var font = __webpack_require__(32);

// CONCATENATED MODULE: ./src/rooms/bubble/bubble.ts
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var bubble_Bubble = /** @class */ (function (_super) {
    __extends(Bubble, _super);
    function Bubble(scene, scale) {
        var _this = _super.call(this, scene) || this;
        _this.mMinWidth = 0;
        _this.mMinHeight = 0;
        _this.mScale = scale;
        _this.x = -40 * scale;
        return _this;
    }
    Bubble.prototype.show = function (text, bubble) {
        this.mChatContent = this.scene.make.text({
            text: text,
            style: {
                x: 0,
                y: 4 * this.mScale,
                fontFamily: font["a" /* Font */].DEFULT_FONT,
                fontSize: 14 * this.mScale,
                color: "#000000",
                origin: { x: 0, y: 0 },
                wordWrap: { width: 300, useAdvancedWrap: true }
            }
        }, false);
        this.add(this.mChatContent);
        this.mMinHeight = this.mChatContent.height + 26;
        this.mMinHeight = this.mMinHeight < 54 ? 54 : this.mMinHeight;
        this.mMinWidth = this.mChatContent.width + 40;
        this.mMinWidth = this.mMinWidth < 69 ? 69 : this.mMinWidth;
        this.mBubbleBg = new dynamic_ninepatch_DynamicNinepatch(this.scene, this);
        var res = resUtil["c" /* Url */].getOsdRes(bubble.bubbleResource || "platformitem/thumbnail/bubble_01.png");
        this.mBubbleBg.load(res, {
            width: this.mMinWidth,
            height: this.mMinHeight,
            key: res,
            columns: [34, 2, 32],
            rows: [42, 2, 9]
        }, this.onComplete, this);
    };
    Bubble.prototype.tweenTo = function (toY) {
        this.mToY = toY;
        this.scene.tweens.add({
            targets: this,
            y: toY,
            alpha: 1,
            duration: 200
        });
    };
    Bubble.prototype.durationRemove = function (duration, callback, callbackContext) {
        var _this = this;
        this.mTweenCompleteCallback = callback;
        this.mTweenCallContext = callbackContext;
        this.mRemoveDelay = setTimeout(function () {
            _this.removeTween();
        }, duration);
    };
    Bubble.prototype.removeTween = function () {
        var _this = this;
        var endY = this.mToY - 30;
        var tween = this.scene.tweens.add({
            targets: this,
            y: endY,
            alpha: 0,
            duration: 200,
            onComplete: function () {
                if (_this.mTweenCompleteCallback) {
                    _this.mTweenCompleteCallback.call(_this.mTweenCallContext, _this);
                }
            }
        });
    };
    Bubble.prototype.destroy = function () {
        if (this.mChatContent) {
            this.mChatContent.destroy(true);
        }
        this.mChatContent = null;
        this.mMinWidth = 0;
        this.mMinHeight = 0;
        this.mToY = 0;
        this.mTweenCompleteCallback = null;
        this.mTweenCallContext = null;
        if (this.mRemoveDelay) {
            clearTimeout(this.mRemoveDelay);
        }
        _super.prototype.destroy.call(this, true);
    };
    Bubble.prototype.onComplete = function (img) {
        if (img) {
            img.setOrigin(0, 0);
            this.addAt(img, 0);
            var bound = this.getBounds();
            this.mChatContent.x = this.mMinWidth - this.mChatContent.width >> 1;
            this.mChatContent.y = (this.mMinHeight - this.mChatContent.height >> 1) + 6;
        }
    };
    Object.defineProperty(Bubble.prototype, "minWidth", {
        get: function () {
            return this.mMinWidth;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Bubble.prototype, "minHeight", {
        get: function () {
            return this.mMinHeight;
        },
        enumerable: false,
        configurable: true
    });
    return Bubble;
}(Phaser.GameObjects.Container));


// EXTERNAL MODULE: ./src/ui/components/dynamic.image.ts
var dynamic_image = __webpack_require__(33);

// CONCATENATED MODULE: ./src/rooms/bubble/bubble.container.ts
var bubble_container_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var bubble_container_BubbleContainer = /** @class */ (function (_super) {
    bubble_container_extends(BubbleContainer, _super);
    function BubbleContainer(scene, scale) {
        var _this = _super.call(this, scene) || this;
        _this.mBubbles = [];
        _this.mScale = scale;
        _this.mArrow = new dynamic_image["a" /* DynamicImage */](_this.scene, 0, 0);
        _this.mArrow.scale = scale;
        _this.mArrow.load(resUtil["c" /* Url */].getRes("ui/chat/bubble_arrow.png"));
        _this.add(_this.mArrow);
        return _this;
    }
    BubbleContainer.prototype.addBubble = function (text, bubbleSetting) {
        var bubble = this.createBubble(bubbleSetting);
        var len = this.mBubbles.length;
        var bul = null;
        var h = 0;
        bubble.show(text, bubbleSetting);
        for (var i = len - 1; i >= 0; i--) {
            bul = this.mBubbles[i];
            h += bul.minHeight + 5 * this.mScale;
            bul.tweenTo(-h);
        }
        this.add(bubble);
        this.mArrow.y = 4 * this.mScale;
    };
    BubbleContainer.prototype.updatePos = function (x, y) {
        this.x = x * this.mScale;
        this.y = y * this.mScale;
    };
    BubbleContainer.prototype.destroy = function (fromScene) {
        if (!this.mBubbles)
            return;
        var len = this.mBubbles.length;
        var bul = null;
        for (var i = len - 1; i >= 0; i--) {
            bul = this.mBubbles[i];
            if (!bul)
                continue;
            bul.destroy();
        }
        this.mBubbles = null;
        this.removeFormParent();
        _super.prototype.destroy.call(this, fromScene);
    };
    BubbleContainer.prototype.removeFormParent = function () {
        if (this.parentContainer) {
            this.parentContainer.remove(this);
        }
    };
    BubbleContainer.prototype.createBubble = function (bubbleSetting) {
        if (!bubbleSetting)
            return;
        var bubble = new bubble_Bubble(this.scene, this.mScale);
        this.mBubbles.push(bubble);
        var duration = bubbleSetting.duration ? bubbleSetting.duration : 5000;
        bubble.durationRemove(duration, this.onRemoveBubble, this);
        return bubble;
    };
    BubbleContainer.prototype.onRemoveBubble = function (bubble) {
        if (!bubble) {
            return;
        }
        this.mBubbles = this.mBubbles.filter(function (val) { return bubble !== val; });
        this.remove(bubble);
        bubble.destroy();
        if (this.mBubbles.length === 0) {
            this.removeFormParent();
        }
    };
    return BubbleContainer;
}(Phaser.GameObjects.Container));


// EXTERNAL MODULE: ./node_modules/net-socket-packet/dist/index.js
var dist = __webpack_require__(3);

// EXTERNAL MODULE: ./src/const/MessageType.ts
var MessageType = __webpack_require__(12);

// CONCATENATED MODULE: ./src/rooms/element/shop/shop.entity.ts
var shop_entity_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var shop_entity_ShopEntity = /** @class */ (function (_super) {
    shop_entity_extends(ShopEntity, _super);
    function ShopEntity(mWorld) {
        var _this = _super.call(this) || this;
        _this.mWorld = mWorld;
        _this.mInitialize = false;
        _this.mConnect = _this.mWorld.connection;
        _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_RES_CLIENT_QUERY_PACKAGE, _this.handlerQueryPackage);
        return _this;
    }
    ShopEntity.prototype.initialize = function () {
        return this.mInitialize;
    };
    ShopEntity.prototype.register = function () {
        this.mConnect.addPacketListener(this);
    };
    ShopEntity.prototype.unRegister = function () {
        this.mConnect.removePacketListener(this);
    };
    ShopEntity.prototype.destroy = function () {
        this.unRegister();
        this.mInitialize = false;
        this.mConnect = null;
    };
    ShopEntity.prototype.handlerQueryPackage = function (packet) {
        var notice = packet.content;
        this.mWorld.emitter.emit(MessageType["a" /* MessageType */].QUERY_PACKAGE, notice);
    };
    ShopEntity.NAME = "ShopModel";
    return ShopEntity;
}(dist["PacketHandler"]));


// CONCATENATED MODULE: ./src/rooms/action/AIAction.ts
var AIAction = /** @class */ (function () {
    function AIAction() {
        this.isBreak = true;
        this.isEnd = false;
    }
    AIAction.prototype.nextAction = function () {
        this.isEnd = true;
        if (this.group) {
            this.group.nextAction();
        }
    };
    AIAction.prototype.destroy = function () {
        this.owner = null;
        this.group = null;
    };
    return AIAction;
}());


// CONCATENATED MODULE: ./src/rooms/action/ActionGroup.ts
var ActionGroup = /** @class */ (function () {
    function ActionGroup() {
    }
    ActionGroup.prototype.addAction = function (action) {
        if (!this.list)
            this.list = [];
        this.list.push(action);
    };
    ActionGroup.prototype.nextAction = function () {
        if (this.current) {
            this.current.destroy();
            this.current = null;
        }
        if (this.list && this.list.length > 0) {
            this.current = this.list.splice(0, 1)[0];
            this.current.isEnd = false;
            this.current.execute();
        }
    };
    ActionGroup.prototype.setComplHandler = function (handler) {
        this.compHandler = handler;
    };
    ActionGroup.prototype.clear = function () {
        if (this.list) {
            for (var _i = 0, _a = this.list; _i < _a.length; _i++) {
                var action = _a[_i];
                action.destroy();
            }
            this.list.length = 0;
        }
        if (this.current) {
            this.current.destroy();
            this.current = null;
        }
    };
    ActionGroup.prototype.stopCurrentAction = function () {
        if (this.current) {
            this.current.destroy();
            this.current = null;
        }
    };
    ActionGroup.prototype.isExecuting = function () {
        if (this.current && !this.current.isEnd)
            return true;
        return false;
    };
    ActionGroup.prototype.hasLast = function () {
        if (!this.list || this.list.length === 0)
            return false;
        else
            return true;
    };
    ActionGroup.prototype.breakAction = function () {
        for (var _i = 0, _a = this.list; _i < _a.length; _i++) {
            var action = _a[_i];
            action.destroy();
        }
        this.list.length = 0;
        if (this.current && this.current.isBreak) {
            this.current.destroy();
            this.current = null;
        }
    };
    ActionGroup.prototype.destroy = function () {
        this.clear();
        this.list = null;
        if (this.sleepAction) {
            this.sleepAction.destroy();
            this.sleepAction = null;
        }
        if (this.compHandler) {
            this.compHandler.clear();
            this.compHandler = null;
        }
    };
    return ActionGroup;
}());


// CONCATENATED MODULE: ./src/rooms/action/AI.ts
var AI_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var AI_AI = /** @class */ (function (_super) {
    AI_extends(AI, _super);
    function AI(owner) {
        var _this = _super.call(this) || this;
        _this.owner = owner;
        _this.group = new ActionGroup();
        return _this;
    }
    AI.prototype.execute = function () {
        this.group.nextAction();
    };
    AI.prototype.nextAction = function () {
        this.group.nextAction();
    };
    AI.prototype.addAction = function (action, isbreak) {
        if (isbreak === void 0) { isbreak = false; }
        action.group = this.group;
        action.owner = this.owner;
        if (isbreak && this.group.current && this.group.current.isBreak) {
            this.group.stopCurrentAction();
        }
        this.group.addAction(action);
        if (!this.group.isExecuting())
            this.group.nextAction();
    };
    AI.prototype.breakAction = function () {
        this.group.breakAction();
    };
    AI.prototype.destroy = function () {
        this.group.destroy();
        this.owner = null;
    };
    return AI;
}(AIAction));


// CONCATENATED MODULE: ./src/rooms/element/element.ts
var element_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();









var PlayerState;
(function (PlayerState) {
    PlayerState["IDLE"] = "idle";
    PlayerState["WALK"] = "walk";
    PlayerState["RUN"] = "run";
    PlayerState["ATTACK"] = "attack";
    PlayerState["JUMP"] = "jump";
    PlayerState["INJURED"] = "injured";
    PlayerState["FAILED"] = "failed";
    PlayerState["DANCE01"] = "dance01";
    PlayerState["DANCE02"] = "dance02";
    PlayerState["FISHING"] = "fishing";
    PlayerState["GREET01"] = "greet01";
    PlayerState["SIT"] = "sit";
    PlayerState["LIE"] = "lit";
    PlayerState["EMOTION01"] = "emotion01";
})(PlayerState || (PlayerState = {}));
var Direction;
(function (Direction) {
    Direction[Direction["north"] = 0] = "north";
    Direction[Direction["north_west"] = 1] = "north_west";
    Direction[Direction["west"] = 2] = "west";
    Direction[Direction["west_south"] = 3] = "west_south";
    Direction[Direction["south"] = 4] = "south";
    Direction[Direction["south_east"] = 5] = "south_east";
    Direction[Direction["east"] = 6] = "east";
    Direction[Direction["east_north"] = 7] = "east_north";
})(Direction || (Direction = {}));
var InputEnable;
(function (InputEnable) {
    InputEnable[InputEnable["Diasble"] = 0] = "Diasble";
    InputEnable[InputEnable["Enable"] = 1] = "Enable";
    InputEnable[InputEnable["Interactive"] = 2] = "Interactive";
})(InputEnable || (InputEnable = {}));
var element_Element = /** @class */ (function (_super) {
    element_extends(Element, _super);
    function Element(sprite, mElementManager) {
        var _this = _super.call(this, mElementManager.roomService) || this;
        _this.mElementManager = mElementManager;
        _this.mAnimationName = "";
        _this.mMoveData = {};
        _this.mCurState = PlayerState.IDLE;
        _this.mOffsetY = undefined;
        _this.mMoving = false;
        _this.mId = sprite.id;
        _this.model = sprite;
        _this.mAi = new AI_AI(_this);
        return _this;
    }
    Object.defineProperty(Element.prototype, "dir", {
        get: function () {
            return this.mDisplayInfo.avatarDir !== undefined ? this.mDisplayInfo.avatarDir : 3;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Element.prototype, "roomService", {
        get: function () {
            if (!this.mElementManager) {
                // Logger.getInstance().error("element manager is undefined");
                return;
            }
            return this.mElementManager.roomService;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Element.prototype, "id", {
        get: function () {
            return this.mId; // this.mDisplayInfo.id || 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Element.prototype, "model", {
        get: function () {
            return this.mModel;
        },
        set: function (val) {
            this.setModel(val);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Element.prototype, "scene", {
        get: function () {
            if (this.mElementManager) {
                return this.mElementManager.scene;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Element.prototype, "ai", {
        get: function () {
            return this.mAi;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Element.prototype, "eleMgr", {
        get: function () {
            if (this.mElementManager) {
                return this.mElementManager;
            }
        },
        enumerable: false,
        configurable: true
    });
    Element.prototype.load = function (displayInfo) {
        this.mDisplayInfo = displayInfo;
        this.loadDisplayInfo();
    };
    Element.prototype.setModel = function (model) {
        this.mModel = model;
        if (!model) {
            return;
        }
        // this.mDisplayInfo = this.mModel.displayInfo;
        this.mQueueAnimations = undefined;
        this.load(this.mModel.displayInfo);
        if (!this.mDisplay) {
            return;
        }
        if (this.mModel.pos) {
            this.setPosition(this.mModel.pos);
        }
        this.mDisplay.changeAlpha(this.mModel.alpha);
        // todo 暂时不显示，后续添加显示名字的协议
        // this.mDisplay.showNickname(this.mModel.nickname);
        this.setDirection(this.mModel.direction);
        // this.setRenderable(true);
        var frameModel = this.mDisplayInfo;
        if (this.mInputEnable === InputEnable.Interactive) {
            this.setInputEnable(this.mInputEnable);
        }
        if (frameModel && frameModel.shops) {
            this.mShopEntity = new shop_entity_ShopEntity(this.mElementManager.roomService.world);
            this.mShopEntity.register();
        }
    };
    Element.prototype.updateModel = function (model) {
        if (this.mModel.id !== model.id) {
            return;
        }
        if (model.hasOwnProperty("avatar")) {
            this.mModel.updateAvatar(model.avatar);
            this.load(this.mModel.displayInfo);
        }
        if (model.display && model.animations) {
            this.mModel.updateDisplay(model.display, model.animations);
            this.load(this.mModel.displayInfo);
        }
        if (model.hasOwnProperty("point3f")) {
            var pos = model.point3f;
            this.setPosition(new utils_pos["a" /* Pos */](pos.x, pos.y, pos.z));
        }
        if (model.hasOwnProperty("currentAnimationName")) {
            this.play(model.currentAnimationName);
            this.setInputEnable(this.mInputEnable);
            this.mModel.setAnimationQueue(undefined);
        }
        if (model.hasOwnProperty("direction")) {
            this.setDirection(model.direction);
        }
    };
    Element.prototype.scaleTween = function () {
        if (!this.mDisplay) {
            return;
        }
        this.mDisplay.scaleTween();
    };
    Element.prototype.play = function (animationName) {
        if (!this.mModel) {
            log["a" /* Logger */].getInstance().error(Element.name + ": sprite is empty");
            return;
        }
        if (this.mModel.currentAnimationName !== animationName) {
            // this.mAnimationName = animationName;
            this.mModel.currentAnimationName = animationName;
            if (this.mDisplay) {
                this.mDisplay.play(this.model.currentAnimation);
            }
        }
    };
    Element.prototype.setQueue = function (animations) {
        var _this = this;
        if (!this.mModel) {
            return;
        }
        var queue = [];
        for (var _i = 0, animations_1 = animations; _i < animations_1.length; _i++) {
            var animation = animations_1[_i];
            var aq = {
                name: animation.animationName,
                playTimes: animation.times,
            };
            if (animation.times > 0) {
                aq.complete = function () {
                    var anis = _this.model.animationQueue;
                    anis.shift();
                    var aniName = anis.length > 0 ? anis[0].name : PlayerState.IDLE;
                    _this.play(aniName);
                };
            }
            queue.push(aq);
        }
        this.mModel.setAnimationQueue(queue);
        if (queue.length > 0) {
            this.play(animations[0].animationName);
        }
    };
    Element.prototype.setDirection = function (val) {
        if (this.mDisplayInfo) {
            this.mDisplayInfo.avatarDir = val;
        }
        if (this.mDisplay && this.model) {
            this.model.direction = val;
            this.mDisplay.play(this.model.currentAnimation);
        }
    };
    Element.prototype.getDirection = function () {
        return this.mDisplayInfo && this.mDisplayInfo.avatarDir ? this.mDisplayInfo.avatarDir : 3;
    };
    Element.prototype.changeState = function (val) {
        if (this.mCurState === val)
            return;
        this.mCurState = val;
        if (!this.mDisplay) {
            return;
        }
        // if (!val) val = PlayerState.IDLE;
        if (!val) {
            val = PlayerState.IDLE;
        }
        this.play(this.mCurState);
        // this.mModel.currentAnimationName = this.mCurState;
        // this.mDisplay.play(this.mModel.currentAnimation);
    };
    Element.prototype.getState = function () {
        return this.mCurState;
    };
    Element.prototype.getRenderable = function () {
        return this.mRenderable;
    };
    Element.prototype.getDisplay = function () {
        return this.mDisplay;
    };
    Element.prototype.move = function (moveData) {
        if (!this.mElementManager) {
            return; // Logger.getInstance().error(`Element::move - Empty element-manager.`);
        }
        if (!this.mDisplay) {
            return; // Logger.getInstance().error("display is undefined");
        }
        this.mMoveData.arrivalTime = moveData.timestemp;
        // this.mMoveData.destPos = new Pos(
        //     Math.floor(moveData.destinationPoint3f.x),
        //     Math.floor(moveData.destinationPoint3f.y)
        // );
        this.mMoveData.posPath = [
            {
                x: moveData.destinationPoint3f.x,
                y: moveData.destinationPoint3f.y,
            },
        ];
        this._doMove();
    };
    Element.prototype.movePosition = function (pos, angel) {
        if (!this.mElementManager) {
            return;
        }
        if (!this.mDisplay) {
            return;
        }
        this.startMove();
        if (!pos.depth)
            pos.depth = this.getDepth();
        this.setPosition(pos);
        var direction = this.calculateDirectionByAngle(angel);
        if (direction !== -1 && direction !== this.model.direction) {
            this.setDirection(direction);
        }
    };
    Element.prototype.movePath = function (movePath) {
        var _this = this;
        if (!this.mElementManager) {
            return;
        }
        if (!this.mDisplay) {
            return;
        }
        var tmpPath = movePath.path;
        if (!tmpPath) {
            return;
        }
        this.mMoveData.arrivalTime = movePath.timestemp;
        var lastPos = new utils_pos["a" /* Pos */](this.mDisplay.x, this.mDisplay.y - this.offsetY);
        var paths = [];
        var angle = null;
        var point = null;
        var now = this.mElementManager.roomService.now();
        var duration = 0;
        var index = 0;
        for (var _i = 0, _a = movePath.path; _i < _a.length; _i++) {
            var path = _a[_i];
            point = path.point3f;
            if (!(point.y === lastPos.y && point.x === lastPos.x)) {
                angle = Math.atan2(point.y - lastPos.y, point.x - lastPos.x) * (180 / Math.PI);
            }
            now += duration;
            duration = path.timestemp - now;
            paths.push({
                x: point.x,
                y: point.y,
                duration: duration,
                onStartParams: angle,
                onStart: function (tween, target, params) {
                    _this.onCheckDirection(params);
                },
            });
            lastPos = new utils_pos["a" /* Pos */](point.x, point.y);
            index++;
        }
        this.mMoveData.posPath = paths;
        this._doMove();
    };
    Element.prototype.startMove = function () {
        this.changeState(PlayerState.WALK);
    };
    Element.prototype.stopMove = function () {
        this.mMoving = false;
        if (!this.mDisplay) {
            // Logger.getInstance().error(`can't stopMove, display does not exist`);
            return;
        }
        if (this.mMoveData && this.mMoveData.posPath) {
            // delete this.mMoveData.destPos;
            delete this.mMoveData.posPath;
            if (this.mMoveData.arrivalTime)
                this.mMoveData.arrivalTime = 0;
            if (this.mMoveData.tweenLineAnim) {
                this.mMoveData.tweenLineAnim.stop();
                this.mMoveData.tweenLineAnim.destroy();
            }
        }
        this.changeState(PlayerState.IDLE);
    };
    Element.prototype.setPosition = function (p) {
        if (this.mMoving) {
            this.stopMove();
        }
        if (this.mDisplay && p) {
            this.mDisplay.setPosition(p.x, p.y, p.z);
            this.mModel.setPosition(p.x, p.y);
            var depth = p.depth ? p.depth : 0;
            this.setDepth(depth);
        }
        this.updateBlock();
    };
    Element.prototype.getRootPosition = function () {
        return new utils_pos["a" /* Pos */](this.mDisplay.x, this.mDisplay.y, 0);
    };
    Element.prototype.showBubble = function (text, setting) {
        var scene = this.mElementManager.scene;
        if (!scene) {
            return;
        }
        if (!this.mBubble) {
            this.mBubble = new bubble_container_BubbleContainer(scene, this.roomService.world.scaleRatio);
        }
        this.mBubble.addBubble(text, setting);
        this.updateBubble();
        this.roomService.addToSceneUI(this.mBubble);
    };
    Element.prototype.clearBubble = function () {
        if (!this.mBubble) {
            return;
        }
        this.mBubble.destroy();
        this.mBubble = null;
    };
    Element.prototype.showNickName = function () {
        if (this.mDisplay && this.model) {
            this.mDisplay.showNickname(this.model.nickname);
        }
    };
    Element.prototype.showEffected = function () {
        if (this.mDisplay)
            this.mDisplay.showEffect();
    };
    Element.prototype.showNickname = function () {
        if (this.model && this.mDisplay) {
            this.mDisplay.showNickname(this.model.nickname);
        }
    };
    Element.prototype.toSprite = function () {
        var sprite = protocols["op_client"].Sprite.create();
        sprite.id = this.id;
        if (this.mDisplay) {
            sprite.point3f = protocols["op_def"].PBPoint3f.create();
            sprite.point3f.x = this.mDisplay.x;
            sprite.point3f.y = this.mDisplay.y;
            sprite.point3f.z = this.mDisplay.z;
        }
        return sprite;
    };
    Element.prototype.turn = function () {
        if (!this.mModel) {
            return;
        }
        this.mModel.turn();
        if (this.mDisplay)
            this.mDisplay.play(this.mModel.currentAnimation);
    };
    Element.prototype.setAlpha = function (val) {
        if (!this.mDisplay) {
            return;
        }
        this.mDisplay.setAlpha(val);
    };
    // public setConcomitant(ele: Element, isFollow: boolean = true) {
    //     if (!this.concomitants) this.concomitants = [];
    //     if (this.concomitants.indexOf(ele) !== -1) {
    //         this.concomitants.push(ele);
    //         if (isFollow)
    //             this.mDisplay.add(ele.mDisplay);
    //     }
    // }
    // public removeConcomitant(ele: Element, destroy: boolean = true) {
    //     if (this.concomitants) {
    //         const index = this.concomitants.indexOf(ele);
    //         if (index !== -1) {
    //             this.concomitants.slice(index, 1);
    //             if (destroy)
    //                 ele.destroy();
    //         }
    //     }
    // }
    Element.prototype.getDepth = function () {
        var depth = 0;
        if (this.model && this.model.pos) {
            depth = this.model.pos.depth ? this.model.pos.depth : 0;
        }
        return depth;
    };
    Element.prototype.destroy = function () {
        if (this.mMoveData && this.mMoveData.tweenAnim) {
            this.mMoveData.tweenAnim.stop();
            this.mMoveData.tweenAnim.remove();
            this.mMoveData.tweenAnim = null;
            this.mMoveData = null;
        }
        if (this.mDisplay) {
            if (this.mBlockable) {
                this.roomService.removeBlockObject(this);
            }
            this.mDisplay.destroy();
            this.mDisplay = null;
        }
        if (this.mBubble) {
            this.mBubble.destroy();
            this.mBubble = undefined;
        }
        if (this.mShopEntity) {
            this.mShopEntity.destroy();
            this.mShopEntity = null;
        }
        if (this.mAi) {
            this.mAi.destroy();
            this.mAi = null;
        }
        // if (this.concomitants) {
        //     for (const ele of this.concomitants) {
        //         ele.destroy();
        //     }
        //     this.concomitants.length = 0;
        //     this.concomitants = null;
        // }
        _super.prototype.destroy.call(this);
    };
    Element.prototype._doMove = function () {
        var _this = this;
        if (!this.mMoveData.posPath) {
            return;
        }
        // const tw: Tweens.Tween = this.mMoveData.tweenAnim;
        // if (tw) {
        //     tw.stop();
        //     tw.remove();
        // }
        // const time: number = this.mMoveData.arrivalTime - this.roomService.now();
        // this.mMoveData.tweenAnim = this.mElementManager.scene.tweens.add({
        //     targets: this.mDisplay,
        //     duration: time,
        //     ease: "Linear",
        //     props: {
        //         x: { value: this.mMoveData.destPos.x },
        //         y: { value: this.mMoveData.destPos.y }
        //     },
        //     onStart: () => {
        //         this.onMoveStart();
        //     },
        //     onComplete: (tween, targets, element) => {
        //         this.onMoveComplete();
        //     },
        //     onUpdate: (tween, targets, element) => {
        //         this.onMoving();
        //     },
        //     onCompleteParams: [this]
        // });
        var line = this.mMoveData.tweenLineAnim;
        if (line) {
            line.stop();
            line.destroy();
        }
        var posPath = this.mMoveData.posPath;
        // for (const path of posPath) {
        //     path.onStart = () => {
        //         this.onMoveStart();
        //     }
        // }
        // const time: number = (this.mMoveData.arrivalTime - this.roomService.now());
        this.mMoveData.tweenLineAnim = this.mElementManager.scene.tweens.timeline({
            targets: this.mDisplay,
            ease: "Linear",
            tweens: posPath,
            onStart: function () {
                _this.onMoveStart();
            },
            onComplete: function () {
                _this.onMoveComplete();
            },
            onUpdate: function () {
                _this.onMoving();
            },
            onCompleteParams: [this],
        });
    };
    Element.prototype.createDisplay = function () {
        if (!this.mDisplayInfo) {
            log["a" /* Logger */].getInstance().error("displayinfo does not exist, Create " + this.model.nickname + " failed");
            return;
        }
        if (this.mDisplay) {
            return this.mDisplay;
        }
        var scene = this.mElementManager.scene;
        if (scene) {
            if (this.mDisplayInfo.discriminator === "DragonbonesModel") {
                this.mDisplay = new dragonbones_display["a" /* DragonbonesDisplay */](scene, this.mElementManager.roomService, this);
            }
            else {
                this.mDisplay = new frames_display["a" /* FramesDisplay */](scene, this.mElementManager.roomService, this);
            }
            var pos = this.mModel.pos;
            if (pos)
                this.mDisplay.setPosition(pos.x, pos.y, pos.z);
            this.addToBlock();
        }
        return this.mDisplay;
    };
    Element.prototype.loadDisplayInfo = function () {
        if (!this.mDisplayInfo) {
            return;
        }
        if (!this.mDisplay) {
            this.createDisplay();
        }
        this.mDisplay.once("initialized", this.onDisplayReady, this);
        this.mDisplay.load(this.mDisplayInfo);
    };
    Element.prototype.addDisplay = function () {
        this.createDisplay();
        var room = this.roomService;
        if (!room || !this.mDisplay) {
            // Logger.getInstance().error("roomService is undefined");
            return;
        }
        room.addToSurface(this.mDisplay);
        var depth = 0;
        if (this.model && this.model.pos) {
            depth = this.model.pos.depth ? this.model.pos.depth : 0;
        }
        this.setDepth(depth);
    };
    Element.prototype.setDepth = function (depth) {
        if (this.mDisplay) {
            this.mDisplay.setDepth(depth);
            if (!this.roomService) {
                throw new Error("roomService is undefined");
            }
            var layerManager = this.roomService.layerManager;
            if (!layerManager) {
                throw new Error("layerManager is undefined");
            }
            layerManager.depthSurfaceDirty = true;
        }
    };
    Element.prototype.onDisplayReady = function () {
        if (this.mDisplay) {
            this.setInputEnable(this.mInputEnable);
            this.mDisplay.play(this.model.currentAnimation);
            var depth = 0;
            if (this.model && this.model.pos) {
                depth = this.model.pos.depth ? this.model.pos.depth : 0;
            }
            this.setDepth(depth);
            // this.mDisplay.showRefernceArea();
        }
    };
    Element.prototype.updateBubble = function () {
        if (!this.mBubble) {
            return;
        }
        var position = this.getPosition();
        if (!position) {
            return;
        }
        this.mBubble.updatePos(position.x, position.y - 80);
    };
    Element.prototype.onMoveStart = function () {
        this.mMoving = true;
    };
    Element.prototype.onMoveComplete = function () {
        // if (this.mMoveData.tweenLineAnim) this.mMoveData.tweenLineAnim.stop();
        this.stopMove();
    };
    Element.prototype.onMoving = function () {
        var now = this.roomService.now();
        if (now - (this.mMoveData.tweenLastUpdate || 0) >= 50) {
            var depth = 0;
            if (this.model && this.model.pos) {
                depth = this.model.pos.depth ? this.model.pos.depth : 0;
            }
            this.setDepth(depth);
            this.mMoveData.tweenLastUpdate = now;
            this.updateBubble();
            if (this.mDisplay)
                this.mDisplay.emit("posChange", this.scene);
            if (this.mBlockable) {
                this.roomService.updateBlockObject(this);
                // this.roomService.addBlockObject()
            }
        }
    };
    Object.defineProperty(Element.prototype, "offsetY", {
        get: function () {
            if (this.mOffsetY === undefined) {
                if (!this.mElementManager ||
                    !this.mElementManager.roomService ||
                    !this.mElementManager.roomService.roomSize) {
                    return 0;
                }
                // this.mOffsetY = 0;
                this.mOffsetY = this.mElementManager.roomService.roomSize.tileHeight >> 2;
            }
            return 0; // this.mOffsetY;
        },
        enumerable: false,
        configurable: true
    });
    Element.prototype.onCheckDirection = function (params) {
        if (typeof params !== "number") {
            return;
        }
        var direction = this.calculateDirectionByAngle(params);
        if (direction !== -1) {
            this.setDirection(direction);
        }
    };
    Element.prototype.calculateDirectionByAngle = function (angle) {
        var direction = -1;
        if (angle > 90) {
            direction = 3;
        }
        else if (angle >= 0) {
            direction = 5;
        }
        else if (angle >= -90) {
            direction = 7;
        }
        else {
            direction = 1;
        }
        return direction;
    };
    return Element;
}(block_object["a" /* BlockObject */]));



/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MessageType; });
/**
 * 系统消息定义
 * author aaron
 */
var MessageType = /** @class */ (function () {
    function MessageType() {
    }
    MessageType.CREATE_ROLE = "create_role";
    MessageType.APP_START = "app_start";
    MessageType.EDITOR_CHANGE_MODE = "editor_change_mode";
    MessageType.CLIENT_RESIZE = "app_client_resize";
    MessageType.SCENE_INITIALIZED = "SCENE_INITIALIZED";
    MessageType.SCENE_CLEARED = "SCENE_CLEARED";
    MessageType.SCENE_CHANGE_TO = "SCENE_CHANGE_TO";
    MessageType.SCENE_MOVE_TO = "scene_move_to";
    MessageType.SCENE_MOVE_STOP = "scene_move_stop";
    MessageType.CHANGE_ELEMENT_ANIMATION = "change_element_animation";
    MessageType.CHANGE_CHARACTER_ANIMATION = "change_character_animation";
    MessageType.CHAT_TO = "chat_to";
    MessageType.SHOW_CHAT_BUBBLE = "show_chat_bubble";
    MessageType.REMOVE_CHAT_BUBBLE = "remove_chat_bubble";
    MessageType.PROMPT_ALERT = "prompt_alert";
    MessageType.CHARACTER_TALING = "characterTaling";
    MessageType.CHARACTER_SHUT_UP = "characterShutUp";
    /// never start
    MessageType.QCLOUD_AUTH = "qcloud_auth";
    MessageType.ENTER_SCENE = "enter_scene";
    /// never end
    MessageType.SCENE_ADD_PLAYER = "scene_add_player";
    MessageType.SCENE_REMOVE_PLAYER = "scene_remove_player";
    MessageType.SCENE_UPDATE_PLAYER = "scene_update_player";
    MessageType.SCENE_ADD_ELEMENT = "scene_add_element";
    MessageType.SCENE_ADD_TERRAIN = "scene_add_terrain";
    MessageType.SCENE_ADD_TERRAIN_END = "scene_add_terrain_end";
    MessageType.SCENE_ADD_ALL_TERRAIN = "scene_add_all_terrain";
    MessageType.SCENE_REMOVE_ELEMENT = "scene_remove_element";
    MessageType.SCENE_REMOVE_TERRAIN = "scene_remove_terrain";
    MessageType.SCENE_REMOVE_ALL_TERRAIN = "scene_remove_all_terrain";
    MessageType.SCENE_MOUSE_FOLLOW = "scene_mouse_follow";
    MessageType.SCENE_SELECT_ELEMENT = "scene_select_element";
    MessageType.SCENE_FIXED_TO_ELEMENT = "scene_fixed_to_element";
    MessageType.SCENE_UPDATE_ELEMENT = "sceneUpdateElement";
    MessageType.SCENE_SYNCHRO_PACKAGE = "sceneSynchroPackage";
    MessageType.SCENE_VISIBLE_GRID = "sceneVisibleGrid";
    MessageType.PLAYER_SELECT_CHARACTER = "player_select_character";
    MessageType.PLAYER_DATA_INITIALIZE = "player_data_initialize";
    MessageType.SCENE_DATA_INITIALIZE = "scene_data_initialize";
    MessageType.PACKAGE_ITEM_ADD = "package_item_add";
    MessageType.PACKAGE_ITEM_REMOVE = "package_item_remove";
    MessageType.PACKAGE_EXCHANGE_ITEM_POS = "package_exchange_item_pos";
    MessageType.SCENE_BACKGROUND_CLICK = "SCENE_BACKGROUND_CLICK";
    MessageType.CHANGE_SELF_AVATAR = "CHANGE_SELF_AVATAR";
    MessageType.DRAG_TO_DROP = "DRAG_TO_DROP";
    MessageType.DRAG_OVER_DROP = "DRAG_OVER_DROP";
    MessageType.QUERY_PACKAGE = "query_package";
    MessageType.SYNC_USER_BALANCE = "syncUserBalance";
    MessageType.UPDATED_CHARACTER_PACKAGE = "updatedCharacterPackage";
    MessageType.SHOW_EFFECT = "showEffect";
    MessageType.EDIT_MODE_QUERY_PACKAGE = "editModeQueryPackage";
    MessageType.PRESS_ELEMENT = "PRESS_ELEMENT";
    // 旋转物件
    MessageType.TURN_ELEMENT = "turnElement";
    // 回收
    MessageType.RECYCLE_ELEMENT = "recycleElement";
    // 放置
    MessageType.PUT_ELEMENT = "putElement";
    MessageType.CANCEL_PUT = "cancelPut";
    // 展开物件容器
    MessageType.EDIT_PACKAGE_EXPANED = "editPackageExpaned";
    // 收起物件容器
    MessageType.EDIT_PACKAGE_COLLAPSE = "editPackageCollapse";
    MessageType.SELECTED_DECORATE_ELEMENT = "selectedDecorateElement";
    MessageType.CANCEL_DECORATE_ELEMENT = "cancelDecorateElement";
    MessageType.ADD_ICON_TO_TOP = "addIconToTop";
    MessageType.REMOVE_ICON_FROM_TOP = "removeIconFromTop";
    MessageType.SHOW_UI = "showUI";
    MessageType.SHOW_NOTICE = "showNotice";
    return MessageType;
}());



/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Sprite; });
/* harmony import */ var _utils_pos__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var _display_dragonbones_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(77);
/* harmony import */ var pixelpai_proto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2);
/* harmony import */ var pixelpai_proto__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(pixelpai_proto__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _display_frames_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(35);
/* harmony import */ var _display_animation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(49);
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(47);
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(5);
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(11);








var Sprite = /** @class */ (function () {
    function Sprite(obj, nodeType) {
        this.mID = obj.id;
        if (obj.point3f) {
            var point = obj.point3f;
            this.mPos = new _utils_pos__WEBPACK_IMPORTED_MODULE_0__[/* Pos */ "a"](point.x, point.y, point.z);
        }
        this.mAttrs = obj.attrs;
        if (obj.avatar) {
            this.updateAvatar(obj.avatar);
            // if (attrs && attrs.length > 0) {
            //     for (const att of attrs) {
            //         if (att.key === "minecart") {
            //             this.mAvatar.stalkerId = att.value;
            //         }
            //     }
            // }
        }
        if (obj.display) {
            this.updateDisplay(obj.display, obj.animations, obj.currentAnimationName);
        }
        if (obj.sn) {
            this.mSn = obj.sn;
        }
        this.tryRegisterAnimation(obj.animationRegistrationMap);
        this.mCurrentAnimationName = obj.currentAnimationName || "idle";
        this.direction = obj.direction || 3;
        this.mNickname = obj.nickname;
        this.mBindID = obj.bindId;
        this.mAlpha = obj.opacity === undefined ? 1 : obj.opacity / 100;
        this.mDisplayBadgeCards = obj.displayBadgeCards;
        this.mNodeType = nodeType;
        if (obj.version) {
            this.mVersion = obj.version;
        }
        if (obj.isMoss !== undefined) {
            this.isMoss = obj.isMoss;
        }
    }
    Sprite.prototype.toSprite = function () {
        var sprite = pixelpai_proto__WEBPACK_IMPORTED_MODULE_2__["op_client"].Sprite.create();
        sprite.id = this.id;
        sprite.nickname = this.mNickname;
        if (this.mDisplayInfo instanceof _display_frames_model__WEBPACK_IMPORTED_MODULE_3__[/* FramesModel */ "a"]) {
            sprite.display = this.mDisplayInfo.display;
            sprite.currentAnimationName = this.currentAnimationName;
            var point3f = pixelpai_proto__WEBPACK_IMPORTED_MODULE_2__["op_def"].PBPoint3f.create();
            point3f.x = this.pos.x;
            point3f.y = this.pos.y;
            point3f.z = this.pos.z;
            sprite.point3f = point3f;
            sprite.animations = this.displayInfo.toClient();
        }
        sprite.direction = this.direction;
        sprite.bindId = this.bindID;
        sprite.sn = this.sn;
        sprite.version = this.mVersion;
        return sprite;
    };
    Sprite.prototype.newID = function () {
        this.mID = _utils_helpers__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].genId();
    };
    Sprite.prototype.setPosition = function (x, y) {
        if (!this.mPos) {
            this.mPos = new _utils_pos__WEBPACK_IMPORTED_MODULE_0__[/* Pos */ "a"]();
        }
        this.mPos.x = x;
        this.mPos.y = y;
    };
    Sprite.prototype.turn = function () {
        if (!this.mDisplayInfo) {
            return;
        }
        var dirable = this.dirable(this.mCurrentAnimationName);
        var index = dirable.indexOf(this.mDirection);
        if (index > -1) {
            this.direction = dirable[(index + 1) % dirable.length];
        }
        else {
            _utils_log__WEBPACK_IMPORTED_MODULE_6__[/* Logger */ "a"].getInstance().error(Sprite.name + ": error dir " + this.mDirection);
        }
        return this;
    };
    Sprite.prototype.updateAvatar = function (avatar) {
        if (this.mDisplayInfo) {
            this.mDisplayInfo.destroy();
        }
        this.mAvatar = { id: avatar.id };
        this.mAvatar = Object.assign(this.mAvatar, avatar);
        this.mDisplayInfo = new _display_dragonbones_model__WEBPACK_IMPORTED_MODULE_1__[/* DragonbonesModel */ "a"](this);
    };
    Sprite.prototype.updateDisplay = function (display, animations, defAnimation) {
        if (!display || !animations) {
            return;
        }
        if (this.mDisplayInfo) {
            this.mDisplayInfo.destroy();
        }
        if (display) {
            var anis = [];
            var objAnis = animations;
            for (var _i = 0, objAnis_1 = objAnis; _i < objAnis_1.length; _i++) {
                var ani = objAnis_1[_i];
                anis.push(new _display_animation__WEBPACK_IMPORTED_MODULE_4__[/* Animation */ "a"](ani));
            }
            defAnimation = defAnimation || this.mCurrentAnimationName || "";
            this.mDisplayInfo = new _display_frames_model__WEBPACK_IMPORTED_MODULE_3__[/* FramesModel */ "a"]({
                animations: {
                    defaultAnimationName: defAnimation,
                    display: display,
                    animationData: anis,
                },
            });
            if (defAnimation) {
                this.currentAnimationName = defAnimation;
            }
        }
    };
    Sprite.prototype.setAnimationQueue = function (queue) {
        this.mAnimationQueue = queue;
    };
    Sprite.prototype.updateAttr = function (attrs) {
        this.mAttrs = attrs;
    };
    Sprite.prototype.setAnimationName = function (name) {
        if (this.mDisplayInfo) {
            this.mDisplayInfo.animationName = name;
        }
        this.mCurrentAnimationName = name;
        var ani = this.setAnimationData(name, this.direction);
        return ani;
    };
    Object.defineProperty(Sprite.prototype, "id", {
        get: function () {
            return this.mID;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "pos", {
        get: function () {
            return this.mPos;
        },
        set: function (pos) {
            this.mPos = pos;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "avatar", {
        get: function () {
            return this.mAvatar;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "currentAnimationName", {
        get: function () {
            return this.mCurrentAnimationName;
        },
        set: function (animationName) {
            if (this.mDisplayInfo) {
                this.mDisplayInfo.animationName = animationName;
            }
            this.mCurrentAnimationName = animationName;
            this.setAnimationData(animationName, this.direction);
            // this.mCurrentAnimation = this.findAnimation(animationName, this.mDirection);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "direction", {
        get: function () {
            return this.mDirection;
        },
        set: function (val) {
            this.mDirection = val;
            if (!this.mDisplayInfo) {
                return;
            }
            this.setAnimationData(this.mCurrentAnimationName, val);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "nickname", {
        get: function () {
            return this.mNickname;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "bindID", {
        get: function () {
            return this.mBindID;
        },
        set: function (id) {
            this.mBindID = id;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "sn", {
        get: function () {
            return this.mSn;
        },
        set: function (value) {
            this.mSn = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "alpha", {
        get: function () {
            return this.mAlpha;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "package", {
        get: function () {
            return this.mPackage;
        },
        set: function (value) {
            this.mPackage = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "sceneId", {
        get: function () {
            return this.mSceneId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "uuid", {
        get: function () {
            return this.mUuid;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "displayBadgeCards", {
        get: function () {
            return this.mDisplayBadgeCards;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "platformId", {
        get: function () {
            return this.mPlatformId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "displayInfo", {
        get: function () {
            return this.mDisplayInfo;
        },
        set: function (displayInfo) {
            this.mDisplayInfo = displayInfo;
            if (this.currentAnimationName) {
                this.mDisplayInfo.animationName = this.currentAnimationName;
                this.setAnimationData(this.currentAnimationName, this.direction);
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "isMoss", {
        get: function () {
            return this.mIsMoss;
        },
        set: function (val) {
            this.mIsMoss = val;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "animationQueue", {
        get: function () {
            return this.mAnimationQueue;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "nodeType", {
        get: function () {
            return this.mNodeType;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "currentAnimation", {
        get: function () {
            return this.mCurrentAnimation;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "currentCollisionArea", {
        get: function () {
            if (!this.mCurrentCollisionArea) {
                this.mCurrentCollisionArea = this.getCollisionArea();
            }
            return this.mCurrentCollisionArea;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "currentWalkableArea", {
        get: function () {
            if (!this.mCurrentWalkableArea) {
                this.mCurrentWalkableArea = this.getWalkableArea();
            }
            return this.mCurrentWalkableArea;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "currentCollisionPoint", {
        get: function () {
            if (!this.mCurrentCollisionPoint) {
                this.mCurrentCollisionPoint = this.getOriginPoint();
            }
            return this.mCurrentCollisionPoint;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "hasInteractive", {
        get: function () {
            if (!this.mDisplayInfo || !this.mCurrentAnimation) {
                return false;
            }
            var animationName = this.mCurrentAnimation.animationName;
            var area = this.mDisplayInfo.getInteractiveArea(animationName);
            if (area && area.length > 0) {
                return true;
            }
            return false;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "animationMap", {
        get: function () {
            if (!this.mRegisterAnimation) {
                this.mRegisterAnimation = new Map();
            }
            return this.mRegisterAnimation;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "originCollisionPoint", {
        get: function () {
            return this._originCollisionPoint;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "originWalkPoint", {
        get: function () {
            return this._originWalkPoint;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "attrs", {
        get: function () {
            return this.mAttrs;
        },
        enumerable: false,
        configurable: true
    });
    Sprite.prototype.setOriginCollisionPoint = function (value) {
        if (this._originCollisionPoint === undefined) {
            this._originCollisionPoint = new Phaser.Geom.Point();
        }
        if (value && value.length > 1) {
            this._originCollisionPoint.x = value[0];
            this._originCollisionPoint.y = value[1];
        }
    };
    Sprite.prototype.setOriginWalkPoint = function (value) {
        if (this._originWalkPoint === undefined) {
            this._originWalkPoint = new Phaser.Geom.Point();
        }
        if (value && value.length > 1) {
            this._originWalkPoint.x = value[0];
            this._originWalkPoint.y = value[1];
        }
    };
    Sprite.prototype.getInteracviveArea = function () {
        if (!this.mDisplayInfo || !this.mCurrentAnimation) {
            return;
        }
        var animationName = this.mCurrentAnimation.animationName;
        return this.mDisplayInfo.getInteractiveArea(animationName);
    };
    Sprite.prototype.setAnimationData = function (animationName, direction) {
        if (!this.displayInfo) {
            return;
        }
        var baseAniName = animationName.split("_")[0];
        if (this.mRegisterAnimation) {
            if (this.mRegisterAnimation.has(baseAniName)) {
                baseAniName = this.mRegisterAnimation.get(baseAniName);
            }
        }
        this.mCurrentAnimation = this.displayInfo.findAnimation(baseAniName, direction);
        if (this.mAnimationQueue && this.mAnimationQueue.length > 0)
            this.mCurrentAnimation.playingQueue = this.mAnimationQueue[0];
        if (this.mCurrentCollisionArea) {
            this.setArea();
        }
        return this.mCurrentAnimation;
        // Logger.getInstance().log("play animation name: ", this.mCurrentAnimation.animationName, this.mCurrentAnimation.flip, this.mDirection);
        // if (animationName !== this.mCurrentAnimation.animationName) {
        //     Logger.getInstance().error(`${Sprite.name}: play animationName: ${this.mCurrentAnimation.animationName}, recieve: ${this.mCurrentAnimationName}, direction: ${direction}`);
        // }
    };
    Sprite.prototype.checkDirectionAnimation = function (baseAniName, dir) {
        var aniName = baseAniName + "_" + dir;
        if (this.mDisplayInfo.existAnimation(aniName)) {
            return aniName;
        }
        return null;
    };
    Sprite.prototype.setArea = function () {
        this.mCurrentCollisionArea = this.getCollisionArea();
        this.mCurrentWalkableArea = this.getWalkableArea();
        this.mCurrentCollisionPoint = this.getOriginPoint();
    };
    Sprite.prototype.getCollisionArea = function () {
        if (!this.mDisplayInfo || !this.mCurrentAnimation) {
            return;
        }
        var _a = this.mCurrentAnimation, animationName = _a.animationName, flip = _a.flip;
        return this.mDisplayInfo.getCollisionArea(animationName, flip);
    };
    Sprite.prototype.getWalkableArea = function () {
        if (!this.mDisplayInfo || !this.mCurrentAnimation) {
            return;
        }
        var _a = this.mCurrentAnimation, animationName = _a.animationName, flip = _a.flip;
        return this.mDisplayInfo.getWalkableArea(animationName, flip);
    };
    Sprite.prototype.getOriginPoint = function () {
        if (!this.mDisplayInfo || !this.mCurrentAnimation) {
            return;
        }
        var _a = this.mCurrentAnimation, animationName = _a.animationName, flip = _a.flip;
        return this.mDisplayInfo.getOriginPoint(animationName, flip);
    };
    Sprite.prototype.dirable = function (aniName) {
        var baseAniName = aniName.split("_")[0];
        var dirs = [3, 5];
        if (this.checkDirectionAnimation(baseAniName, _element__WEBPACK_IMPORTED_MODULE_7__[/* Direction */ "a"].east_north)) {
            dirs.push(7, 1);
            // dirs = [1, 3, 5, 7];
        }
        return dirs;
    };
    Sprite.prototype.tryRegisterAnimation = function (anis) {
        if (!anis || anis.length < 1) {
            return;
        }
        this.mRegisterAnimation = new Map();
        for (var _i = 0, anis_1 = anis; _i < anis_1.length; _i++) {
            var ani = anis_1[_i];
            this.mRegisterAnimation.set(ani.key, ani.value);
        }
    };
    return Sprite;
}());



/***/ }),
/* 14 */,
/* 15 */,
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BasicScene; });
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var BasicScene = /** @class */ (function (_super) {
    __extends(BasicScene, _super);
    function BasicScene(config) {
        return _super.call(this, config) || this;
    }
    BasicScene.prototype.setViewPort = function (x, y, width, height) {
        this.cameras.main.setViewport(x, y, width, height);
    };
    return BasicScene;
}(Phaser.Scene));



/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Position45; });
/* harmony import */ var _pos__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);

var Position45 = /** @class */ (function () {
    function Position45() {
    }
    Position45.transformTo90 = function (point, position) {
        var offsetX = position.rows * (position.tileWidth / 2); // + position.tileWidth / 2;
        return new _pos__WEBPACK_IMPORTED_MODULE_0__[/* Pos */ "a"]((point.x - point.y) * (position.tileWidth / 2) + offsetX, ((point.x + point.y)) * (position.tileHeight / 2));
    };
    Position45.transformTo45 = function (point3, position) {
        var offsetX = position.rows * (position.tileWidth / 2);
        // const offsetX = position.sceneWidth / 2; // - position.tileWidth / 2;
        return new _pos__WEBPACK_IMPORTED_MODULE_0__[/* Pos */ "a"](Math.floor((point3.y + point3.z) / position.tileHeight + (point3.x - offsetX) / position.tileWidth), Math.floor((point3.y + point3.z) / position.tileHeight - (point3.x - offsetX) / position.tileWidth));
    };
    return Position45;
}());



/***/ }),
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LoadingScene; });
/* harmony import */ var _utils_size__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25);
/* harmony import */ var _utils_resUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
/* harmony import */ var _basic_scene__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var LoadingScene = /** @class */ (function (_super) {
    __extends(LoadingScene, _super);
    function LoadingScene() {
        var _this = _super.call(this, { key: LoadingScene.name }) || this;
        _this.mRequestCom = false;
        return _this;
    }
    LoadingScene.prototype.preload = function () {
        // atlas可以用于webgl渲染，和canvas渲染，spritesheet只能用于canvas
        // this.load.image("loading_bg", Url.getRes(""))
        var dpr = 2;
        if (this.mWorld) {
            dpr = this.mWorld.uiRatio || 2;
        }
        _utils_log__WEBPACK_IMPORTED_MODULE_2__[/* Logger */ "a"].getInstance().log("has Texture: ", this.game.textures.exists("loading_bg"));
        if (this.game.device.os.desktop === false) {
            this.load.image("loading_bg", _utils_resUtil__WEBPACK_IMPORTED_MODULE_1__[/* Url */ "c"].getUIRes(dpr, "loading/loading_bg.jpg"));
        }
        this.load.atlas("loading", _utils_resUtil__WEBPACK_IMPORTED_MODULE_1__[/* Url */ "c"].getUIRes(dpr, "loading/loading.png"), _utils_resUtil__WEBPACK_IMPORTED_MODULE_1__[/* Url */ "c"].getUIRes(dpr, "loading/loading.json"));
        this.load.script("webfont", "./resources/scripts/webfont/1.6.26/webfont.js");
        // this.load.spritesheet("rabbit00.png", "./resources/rabbit00.png", { frameWidth: 150, frameHeight: 150 });
    };
    LoadingScene.prototype.init = function (data) {
        var element = document.createElement("style");
        document.head.appendChild(element);
        var sheet = element.sheet;
        var styles = "@font-face { font-family: 'Source Han Sans'; src: url('./resources/fonts/otf/SourceHanSansTC-Regular.otf') format('opentype'); }\n";
        sheet.insertRule(styles, 0);
        this.mWorld = data.world;
        this.mRoom = data.room;
        this.mRequestCom = false;
        this.mCallback = data.callBack;
    };
    LoadingScene.prototype.create = function () {
        try {
            WebFont.load({
                custom: {
                    families: ["Source Han Sans"]
                },
            });
        }
        catch (error) {
            _utils_log__WEBPACK_IMPORTED_MODULE_2__[/* Logger */ "a"].getInstance().warn("webfont failed to load");
        }
        if (this.mRoom)
            this.mRoom.startLoad();
        var width = this.scale.gameSize.width;
        var height = this.scale.gameSize.height;
        // this.bg = this.add.graphics();
        // this.bg.fillStyle(0x616161);
        // this.bg.fillRect(0, 0, width, height);
        // const framesObj: {} = this.textures.get("loading").frames;
        // const tmpFrames: any[] = [];
        // for (const key in framesObj) {
        //   if (key === "__BASE") continue;
        //   const frame = framesObj[key];
        //   if (!frame) continue;
        //   tmpFrames.push(key);
        // }
        // 手动把json配置中的frames给予anims
        this.anims.create({
            key: "loading_anmis",
            // frames: this.anims.generateFrameNumbers("loading", { start: 0, end: 59, frames: tmpFrames }),
            frames: this.anims.generateFrameNames("loading", { prefix: "loading_", start: 1, end: 59, zeroPad: 3, suffix: ".png" }),
            frameRate: 16,
            yoyo: false,
            repeat: -1
        });
        this.bg = this.add.image(width / 2, height / 2, "loading_bg");
        this.bg.scale = this.mWorld.uiScale;
        this.lo = this.add.sprite(0, 0, "loading");
        // this.lo.setScale(this.mWorld.uiScale);
        this.scale.on("resize", this.checkSize, this);
        this.lo.play("loading_anmis");
        this.checkSize(new _utils_size__WEBPACK_IMPORTED_MODULE_0__[/* Size */ "a"](width, height));
        if (this.mCallback) {
            this.mCallback.call(this, this);
            this.mCallback = undefined;
        }
        // this.mLoadingManager.startup();
    };
    // update() {
    // if (this.mRoom) {
    //   if (this.mRoom.world.clock.clockSync && !this.mRequestCom) {
    //     this.mRequestCom = true;
    //     this.mRoom.completeLoad();
    //   }
    // }
    // }
    LoadingScene.prototype.awake = function () {
        this.scale.on("resize", this.checkSize, this);
        this.scene.wake();
    };
    LoadingScene.prototype.sleep = function () {
        this.scale.off("resize", this.checkSize, this);
        this.scene.sleep();
    };
    LoadingScene.prototype.getKey = function () {
        return this.sys.config.key;
    };
    LoadingScene.prototype.checkSize = function (size) {
        var width = size.width, height = size.height;
        this.lo.x = width / 2;
        this.lo.y = height / 2;
    };
    return LoadingScene;
}(_basic_scene__WEBPACK_IMPORTED_MODULE_3__[/* BasicScene */ "a"]));



/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Size; });
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Size = /** @class */ (function (_super) {
    __extends(Size, _super);
    function Size(width, height) {
        return _super.call(this, width, height) || this;
    }
    return Size;
}(Phaser.Structs.Size));



/***/ }),
/* 26 */,
/* 27 */,
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/input/StopPropagationTouchEvents.js
var StopPropagationTouchEvents = function (element) {
    // Don't propagate touch/mouse events to parent(game canvas)
    element.addEventListener("touchstart", callback, false);
    element.addEventListener("touchmove", callback, false);
    element.addEventListener("touchend", callback, false);
    element.addEventListener("mousedown", callback, false);
    element.addEventListener("mouseup", callback, false);
    element.addEventListener("mousemove", callback, false);
}

var callback = function (e) {
    e.stopPropagation();
}
/* harmony default export */ var input_StopPropagationTouchEvents = (StopPropagationTouchEvents);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/inputtext/InputText.js


const DOMElement = Phaser.GameObjects.DOMElement;
const IsPlainObject = Phaser.Utils.Objects.IsPlainObject;
const GetValue = Phaser.Utils.Objects.GetValue;

class InputText_InputText extends DOMElement {
    constructor(scene, x, y, width, height, config) {
        if (IsPlainObject(x)) {
            config = x;
            x = GetValue(config, 'x', 0);
            y = GetValue(config, 'y', 0);
            width = GetValue(config, 'width', undefined);
            height = GetValue(config, 'height', undefined);
        } else if (IsPlainObject(width)) {
            config = width;
            width = GetValue(config, 'width', undefined);
            height = GetValue(config, 'height', undefined);
        }

        if (config === undefined) {
            config = {};
        }
        var autoRound = scene.scale.autoRound;
        if (width !== undefined) {
            if (autoRound) {
                width = Math.floor(width);
            }
            config.width = width + 'px';
        }
        if (height !== undefined) {
            if (autoRound) {
                height = Math.floor(height);
            }
            config.height = height + 'px';
        }

        var element;
        var textType = GetValue(config, 'type', 'text');
        if (textType === 'textarea') {
            element = document.createElement("textarea");
            element.style.resize = 'none';
        } else {
            element = document.createElement("input");
            element.type = textType;
        }

        // Apply registed style properties
        var elemProp, elemPropValue;
        for (var key in ElementProperties) {
            elemProp = ElementProperties[key];
            elemPropValue = GetValue(config, key, elemProp[1]);
            if (elemPropValue !== undefined) {
                element[elemProp[0]] = elemPropValue;
            }
        }

        var style = GetValue(config, 'style', undefined);
        if (style === undefined) {
            style = {};
        }
        // Apply registed style properties
        var styleProp, stylePropValue;
        for (var key in StyleProperties) {
            styleProp = StyleProperties[key];
            stylePropValue = GetValue(config, key, styleProp[1]);
            if (stylePropValue !== undefined) {
                style[styleProp[0]] = stylePropValue;
            }
        }
        // Apply other style properties
        var elementStyle = element.style;
        for (var key in config) {
            if ((key in ElementProperties) || (key in StyleProperties)) {
                continue;
            } else if (key in elementStyle) {
                style[key] = config[key];
            }
        }
        style['box-sizing'] = 'border-box';
        super(scene, x, y, element, style);
        this.type = 'rexInputText';

        // Apply events
        for (let eventName in ElementEvents) { // Note: Don't use `var` here
            this.node[ElementEvents[eventName]] = (function () {
                this.emit(eventName, this);
            }).bind(this);
        }

        // Don't propagate touch/mouse events to parent(game canvas)
        input_StopPropagationTouchEvents(this.node);
    }

    resize(width, height) {
        var style = this.node.style;
        style.width = width + 'px';
        style.height = height + 'px';
        this.updateSize();
        return this;
    }

    get text() {
        return this.node.value;
    }

    set text(value) {
        this.node.value = value;
    }

    setText(value) { // Override
        this.text = value;
        return this;
    }

    selectText() {
        this.node.select();
        return this;
    }

    get placeholder() {
        return this.node.placeholder;
    }

    set placeholder(value) {
        this.node.placeholder = value;
    }

    setPlaceholder(value) {
        this.placeholder = value;
        return this;
    }

    get tooltip() {
        return this.node.title;
    }

    set tooltip(value) {
        this.node.title = value;
    }

    setTooltip(value) {
        this.tooltip = value;
        return this;
    }

    setTextChangedCallback(callback) {
        this.onTextChanged = callback;
        return this;
    }

    get readOnly() {
        return this.node.readOnly;
    }

    set readOnly(value) {
        this.node.readOnly = value;
    }

    setReadOnly(value) {
        if (value === undefined) {
            value = true;
        }
        this.readOnly = value;
        return this;
    }

    get spellCheck() {
        return this.node.spellcheck;
    }

    set spellCheck(value) {
        this.node.spellcheck = value;
    }

    setSpellCheck(value) {
        this.spellCheck = value;
        return this;
    }

    setStyle(key, value) {
        this.node.style[key] = value;
        return this;
    }

    getStyle(key) {
        return this.node.style[key];
    }

    scrollToBottom() {
        this.node.scrollTop = this.node.scrollHeight;
        return this;
    }

    setEnabled(enabled) {
        if (enabled === undefined) {
            enabled = true;
        }
        this.node.disabled = !enabled;
        return this;
    }

    setBlur() {
        this.node.blur();
        return this;
    }

    setFocus() {
        this.node.focus();
        return this;
    }
}

const ElementProperties = {
    id: ['id', undefined],
    text: ['value', undefined],
    placeholder: ['placeholder', undefined],
    tooltip: ['title', undefined],
    readOnly: ['readonly', false],
    spellCheck: ['spellcheck', false],
    autoComplete: ['autocomplete', 'off'],
};

const StyleProperties = {
    align: ['textAlign', undefined],
    width: ['width', undefined],
    height: ['height', undefined],
    fontFamily: ['fontFamily', undefined],
    fontSize: ['font-size', undefined],
    color: ['color', '#ffffff'],
    backgroundColor: ['backgroundColor', 'transparent'],
    borderColor: ['borderColor', 'transparent'],
    outline: ['outline', 'none'],
};

const ElementEvents = {
    textchange: 'oninput',
    click: 'onclick',
    dblclick: 'ondblclick',
    focus: 'onfocus',
    blur: 'onblur',
};

/* harmony default export */ var inputtext_InputText = __webpack_exports__["a"] = (InputText_InputText);

/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ display_object_DisplayObject; });

// UNUSED EXPORTS: DisplayField

// EXTERNAL MODULE: ./src/utils/font.ts
var font = __webpack_require__(32);

// CONCATENATED MODULE: ./src/ui/components/dynamic.sprite.ts
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var DynamicSprite = /** @class */ (function (_super) {
    __extends(DynamicSprite, _super);
    function DynamicSprite(scene, x, y) {
        var _this = _super.call(this, scene, x, y, undefined) || this;
        scene.sys.updateList.add(_this);
        return _this;
    }
    DynamicSprite.prototype.load = function (textureURL, atlasURL, loadContext, completeCallBack, errorCallBack) {
        this.mLoadCompleteCallbak = completeCallBack;
        this.mLoadErrorCallback = errorCallBack;
        this.mLoadContext = loadContext;
        this.mUrl = textureURL + atlasURL;
        if (this.scene.cache.obj.get(this.mUrl)) {
            this.onLoadComplete();
        }
        else {
            this.scene.load.atlas(this.mUrl, textureURL, atlasURL);
            this.scene.load.once(Phaser.Loader.Events.COMPLETE, this.onLoadComplete, this);
            this.scene.load.once(Phaser.Loader.Events.FILE_LOAD_ERROR, this.onLoadError, this);
            this.scene.load.start();
        }
    };
    DynamicSprite.prototype.destroy = function (fromScene) {
        this.scene.sys.updateList.remove(this);
        _super.prototype.destroy.call(this, fromScene);
    };
    DynamicSprite.prototype.onLoadComplete = function () {
        if (this.mLoadCompleteCallbak) {
            var cb = this.mLoadCompleteCallbak;
            this.mLoadCompleteCallbak = null;
            cb.call(this.mLoadContext);
            this.mLoadContext = null;
        }
        this.scene.anims.create({
            key: this.mUrl,
            frames: this.scene.anims.generateFrameNames(this.mUrl),
            repeat: 1
        });
        this.play(this.mUrl);
        // this.setTexture(this.mUrl);
    };
    DynamicSprite.prototype.onLoadError = function (file) {
        if (this.mUrl === file.url) {
            if (this.mLoadErrorCallback) {
                var cb = this.mLoadErrorCallback;
                this.mLoadErrorCallback = null;
                cb.call(this.mLoadContext);
                this.mLoadContext = null;
            }
        }
    };
    return DynamicSprite;
}(Phaser.GameObjects.Sprite));


// EXTERNAL MODULE: ./src/ui/components/dynamic.image.ts
var dynamic_image = __webpack_require__(33);

// EXTERNAL MODULE: ./src/utils/resUtil.ts + 1 modules
var resUtil = __webpack_require__(8);

// EXTERNAL MODULE: ./src/rooms/editor/reference.area.ts
var reference_area = __webpack_require__(76);

// CONCATENATED MODULE: ./src/rooms/display/display.object.ts
var display_object_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();





var DisplayField;
(function (DisplayField) {
    DisplayField[DisplayField["BACKEND"] = 1] = "BACKEND";
    DisplayField[DisplayField["STAGE"] = 2] = "STAGE";
    DisplayField[DisplayField["FRONTEND"] = 3] = "FRONTEND";
    DisplayField[DisplayField["FLAG"] = 4] = "FLAG";
})(DisplayField || (DisplayField = {}));
var display_object_DisplayObject = /** @class */ (function (_super) {
    display_object_extends(DisplayObject, _super);
    function DisplayObject(scene, roomService, element, antial) {
        if (antial === void 0) { antial = false; }
        var _this = _super.call(this, scene) || this;
        /**
         * 实际透明度，避免和tween混淆
         */
        _this.mAlpha = 1;
        _this.mDirection = 3;
        _this.mAntial = false;
        _this.mElement = element;
        _this.mRoomService = roomService;
        _this.mAntial = antial;
        return _this;
    }
    DisplayObject.prototype.changeAlpha = function (val) {
        if (this.mAlpha === val) {
            return;
        }
        this.alpha = val;
        this.mAlpha = val;
    };
    DisplayObject.prototype.removeFromParent = function () {
        if (this.parentContainer) {
            this.parentContainer.remove(this);
        }
    };
    DisplayObject.prototype.fadeIn = function (callback) {
    };
    DisplayObject.prototype.fadeOut = function (callback) {
    };
    DisplayObject.prototype.load = function (data, field) {
    };
    DisplayObject.prototype.play = function (animationName, field) {
    };
    DisplayObject.prototype.setDirection = function (val) {
        if (this.mDirection !== val) {
            this.mDirection = val;
            if (val === 5 || val === 7) {
                this.scaleX = -1;
            }
            else {
                this.scaleX = 1;
            }
        }
    };
    DisplayObject.prototype.destroy = function (fromScene) {
        if (this.mFlagContainer) {
            if (this.mNickname) {
                this.mNickname.destroy();
                this.mNickname = undefined;
            }
            if (this.mBackEffect) {
                this.mBackEffect.destroy();
                this.mBackEffect = undefined;
            }
            if (this.mFrontEffect) {
                this.mFrontEffect.destroy();
                this.mFrontEffect = undefined;
            }
            this.clearBadges();
            this.mFlagContainer.destroy();
            this.mFlagContainer = undefined;
        }
        if (this.mReferenceArea) {
            this.mReferenceArea.destroy();
            this.mReferenceArea = undefined;
        }
        if (this.mChildMap) {
            this.mChildMap.clear();
            this.mChildMap = null;
        }
        // this.removeAll(true);
        _super.prototype.destroy.call(this, fromScene);
    };
    DisplayObject.prototype.showNickname = function (val) {
        if (!this.mNickname) {
            this.mNickname = this.scene.make.text({ style: { font: font["a" /* Font */].YAHEI_14_BOLD } }, false).setOrigin(0.5, 0.5);
            this.mNickname.setStroke("#0", 2);
            if (this.mAntial) {
                this.mNickname.setShadow(2, 2, "#0", 4, true, true);
            }
            this.flagContainer.add(this.mNickname);
        }
        this.mNickname.setText(val);
        this.layouFlag();
    };
    DisplayObject.prototype.setDisplayBadges = function (cards) {
        if (!this.mBadges)
            this.mBadges = [];
        else
            this.clearBadges();
        for (var _i = 0, cards_1 = cards; _i < cards_1.length; _i++) {
            var card = cards_1[_i];
            var badge = new dynamic_image["a" /* DynamicImage */](this.scene, 0, 0);
            badge.load(resUtil["c" /* Url */].getOsdRes(card.thumbnail), this, this.layouFlag);
            this.flagContainer.add(badge);
            this.mBadges.push(badge);
        }
    };
    DisplayObject.prototype.showRefernceArea = function () {
        if (!this.mReferenceArea) {
            this.mReferenceArea = new reference_area["a" /* ReferenceArea */](this.scene, this.mRoomService);
            this.addChildMap("reference", this.mReferenceArea);
        }
        if (!this.mCollisionArea || this.mCollisionArea.length <= 0)
            return;
        this.mReferenceArea.draw(this.mCollisionArea, this.mOriginPoint);
        this.addAt(this.mReferenceArea, 0);
    };
    DisplayObject.prototype.hideRefernceArea = function () {
        if (this.mReferenceArea) {
            this.mReferenceArea.destroy();
            this.mReferenceArea = undefined;
        }
    };
    DisplayObject.prototype.scaleTween = function () { };
    DisplayObject.prototype.showEffect = function () {
        this.addEffect(this.mBackEffect, resUtil["c" /* Url */].getRes("ui/vip/vip_effect_back.png"), resUtil["c" /* Url */].getRes("ui/vip/vip_effect_back.json"), true, 15, false, true);
        this.addEffect(this.mFrontEffect, resUtil["c" /* Url */].getRes("ui/vip/vip_effect_front.png"), resUtil["c" /* Url */].getRes("ui/vip/vip_effect_front.json"), true, 15, false, true);
    };
    DisplayObject.prototype.getElement = function (key) {
        if (!this.mChildMap) {
            return;
        }
        return this.mChildMap.get(key);
    };
    DisplayObject.prototype.addEffect = function (target, textureURL, atlasURL, isBack, framerate, loop, killComplete) {
        if (!target) {
            target = new DynamicSprite(this.scene, 0, 0);
        }
        target.load(textureURL, atlasURL);
        target.y = -20;
        if (isBack) {
            this.addAt(target, DisplayField.BACKEND);
        }
        else {
            this.addAt(target, DisplayField.FRONTEND);
        }
        // target.play(textureURL + atlasURL);
        target.once(Phaser.Animations.Events.SPRITE_ANIMATION_COMPLETE, function () {
            target.destroy();
        });
    };
    DisplayObject.prototype.layouFlag = function (offset) {
        if (offset === void 0) { offset = 4; }
        if (!this.mFlagContainer)
            return;
        this.mFlagContainer.y = -96;
        this.bringToTop(this.mNickname);
        var children = this.mFlagContainer.list;
        var _x = 0;
        for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
            var child = children_1[_i];
            child["x"] = _x;
            if (child["width"])
                _x = child["width"];
        }
    };
    DisplayObject.prototype.clearBadges = function () {
        if (!this.mBadges)
            return;
        for (var _i = 0, _a = this.mBadges; _i < _a.length; _i++) {
            var badge = _a[_i];
            badge.destroy();
        }
        this.mBadges.length = 0;
    };
    Object.defineProperty(DisplayObject.prototype, "flagContainer", {
        get: function () {
            if (this.mFlagContainer)
                return this.mFlagContainer;
            this.mFlagContainer = this.scene.make.container(undefined, false);
            this.addAt(this.mFlagContainer, DisplayField.FLAG);
            return this.mFlagContainer;
        },
        enumerable: false,
        configurable: true
    });
    DisplayObject.prototype.addChildMap = function (key, display) {
        if (!this.mChildMap) {
            this.mChildMap = new Map();
        }
        this.mChildMap.set(key, display);
    };
    DisplayObject.prototype.removeChildMap = function (key) {
        if (!this.mChildMap) {
            return;
        }
        this.mChildMap.delete(key);
    };
    Object.defineProperty(DisplayObject.prototype, "baseLoc", {
        get: function () {
            return this.mBaseLoc || new Phaser.Geom.Point();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "sortX", {
        get: function () {
            return this.x;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "sortY", {
        get: function () {
            return this.y;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "sortZ", {
        get: function () {
            return this.z || 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "element", {
        get: function () {
            return this.mElement;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "collisionArea", {
        get: function () {
            return this.mCollisionArea;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "originPoint", {
        get: function () {
            return this.mOriginPoint;
        },
        enumerable: false,
        configurable: true
    });
    return DisplayObject;
}(Phaser.GameObjects.Container));



/***/ }),
/* 30 */,
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ElementManager; });
/* harmony import */ var net_socket_packet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var net_socket_packet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(net_socket_packet__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var pixelpai_proto__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11);
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5);
/* harmony import */ var _utils_pos__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6);
/* harmony import */ var _sprite__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(13);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();






var NodeType = pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__["op_def"].NodeType;
var ElementManager = /** @class */ (function (_super) {
    __extends(ElementManager, _super);
    function ElementManager(mRoom) {
        var _this = _super.call(this) || this;
        _this.mRoom = mRoom;
        _this.hasAddComplete = false;
        _this.mElements = new Map();
        if (_this.connection) {
            _this.connection.addPacketListener(_this);
            _this.addHandlerFun(pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_ADD_SPRITE, _this.onAdd);
            _this.addHandlerFun(pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_ADD_SPRITE_END, _this.addComplete);
            _this.addHandlerFun(pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_DELETE_SPRITE, _this.onRemove);
            _this.addHandlerFun(pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_MOVE_SPRITE, _this.onMove);
            _this.addHandlerFun(pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_ADJUST_POSITION, _this.onAdjust);
            _this.addHandlerFun(pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_SYNC_SPRITE, _this.onSync);
            _this.addHandlerFun(pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__["op_client"].OPCODE._OP_VIRTUAL_WORLD_RES_CLIENT_ONLY_BUBBLE, _this.onShowBubble);
            _this.addHandlerFun(pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__["op_client"].OPCODE._OP_VIRTUAL_WORLD_RES_CLIENT_ONLY_BUBBLE_CLEAN, _this.onClearBubbleHandler);
            _this.addHandlerFun(pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_CHANGE_SPRITE_ANIMATION, _this.onChangeAnimation);
            _this.addHandlerFun(pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_SET_SPRITE_POSITION, _this.onSetPosition);
        }
        if (_this.mRoom && _this.mRoom.world) {
            _this.mGameConfig = _this.mRoom.world.elementStorage;
        }
        var size = _this.mRoom.miniSize;
        _this.mMap = new Array(size.cols);
        for (var i = 0; i < _this.mMap.length; i++) {
            _this.mMap[i] = new Array(size.rows).fill(-1);
        }
        return _this;
    }
    ElementManager.prototype.init = function () {
        // this.destroy();
    };
    ElementManager.prototype.get = function (id) {
        var element = this.mElements.get(id);
        if (!element) {
            return;
        }
        return element;
    };
    ElementManager.prototype.remove = function (id) {
        var element = this.mElements.get(id);
        if (element) {
            this.mElements.delete(id);
            element.destroy();
            this.removeMap(element.model);
        }
        return element;
    };
    ElementManager.prototype.getElements = function () {
        return Array.from(this.mElements.values());
    };
    ElementManager.prototype.add = function (sprites, addMap) {
        for (var _i = 0, sprites_1 = sprites; _i < sprites_1.length; _i++) {
            var sprite = sprites_1[_i];
            this._add(sprite, addMap);
        }
    };
    ElementManager.prototype.destroy = function () {
        var _this = this;
        if (this.connection) {
            this.connection.removePacketListener(this);
        }
        if (!this.mElements)
            return;
        this.mElements.forEach(function (element) { return _this.remove(element.id); });
        this.mElements.clear();
    };
    ElementManager.prototype.update = function (time, delta) { };
    ElementManager.prototype.addMap = function (sprite) { };
    ElementManager.prototype.removeMap = function (sprite) { };
    Object.defineProperty(ElementManager.prototype, "camera", {
        get: function () {
            return this.mRoom.cameraService.camera;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ElementManager.prototype, "connection", {
        get: function () {
            if (this.mRoom) {
                return this.mRoom.connection;
            }
            _utils_log__WEBPACK_IMPORTED_MODULE_3__[/* Logger */ "a"].getInstance().log("roomManager is undefined");
            return;
        },
        enumerable: false,
        configurable: true
    });
    ElementManager.prototype.onAdjust = function (packet) {
        var content = packet.content;
        var sprites = content.spritePositions;
        var type = content.nodeType;
        if (type !== NodeType.ElementNodeType) {
            return;
        }
        var ele;
        var point;
        for (var _i = 0, sprites_2 = sprites; _i < sprites_2.length; _i++) {
            var sprite = sprites_2[_i];
            ele = this.mElements.get(sprite.id);
            if (!ele) {
                continue;
            }
            point = sprite.point3f;
            ele.setPosition(new _utils_pos__WEBPACK_IMPORTED_MODULE_4__[/* Pos */ "a"](point.x || 0, point.y || 0, point.z || 0));
        }
    };
    ElementManager.prototype.onAdd = function (packet) {
        if (!this.mRoom.layerManager) {
            _utils_log__WEBPACK_IMPORTED_MODULE_3__[/* Logger */ "a"].getInstance().error("layer manager does not exist");
            return;
        }
        if (!this.mGameConfig) {
            _utils_log__WEBPACK_IMPORTED_MODULE_3__[/* Logger */ "a"].getInstance().error("gameConfig does not exist");
            return;
        }
        var content = packet.content;
        var objs = content.sprites;
        if (!objs)
            return;
        var type = content.nodeType;
        if (type !== NodeType.ElementNodeType) {
            return;
        }
        var point;
        var sprite = null;
        var ids = [];
        for (var _i = 0, objs_1 = objs; _i < objs_1.length; _i++) {
            var obj = objs_1[_i];
            point = obj.point3f;
            if (point) {
                sprite = new _sprite__WEBPACK_IMPORTED_MODULE_5__[/* Sprite */ "a"](obj, content.nodeType);
                if (!sprite.displayInfo) {
                    if (!this.checkDisplay(sprite)) {
                        ids.push(sprite.id);
                    }
                }
                this._add(sprite);
            }
        }
        this.fetchDisplay(ids);
    };
    ElementManager.prototype._add = function (sprite, addMap) {
        if (addMap === undefined)
            addMap = true;
        var ele = this.mElements.get(sprite.id);
        if (ele) {
            ele.model = sprite;
        }
        else {
            ele = new _element__WEBPACK_IMPORTED_MODULE_2__[/* Element */ "b"](sprite, this);
            ele.setInputEnable(_element__WEBPACK_IMPORTED_MODULE_2__[/* InputEnable */ "c"].Interactive);
        }
        // if (!ele) ele = new Element(sprite, this);
        if (addMap)
            this.addMap(sprite);
        this.mElements.set(ele.id || 0, ele);
        return ele;
    };
    ElementManager.prototype.addComplete = function (packet) {
        this.hasAddComplete = true;
    };
    ElementManager.prototype.checkDisplay = function (sprite) {
        if (!sprite.displayInfo) {
            var displayInfo = this.roomService.world.elementStorage.getDisplayModel(sprite.bindID || sprite.id);
            if (displayInfo) {
                sprite.displayInfo = displayInfo;
                return displayInfo;
            }
        }
    };
    ElementManager.prototype.fetchDisplay = function (ids) {
        var packet = new net_socket_packet__WEBPACK_IMPORTED_MODULE_0__["PBpacket"](pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__["op_virtual_world"].OPCODE._OP_REQ_VIRTUAL_WORLD_QUERY_SPRITE_RESOURCE);
        var content = packet.content;
        content.ids = ids;
        this.connection.send(packet);
    };
    Object.defineProperty(ElementManager.prototype, "roomService", {
        get: function () {
            return this.mRoom;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ElementManager.prototype, "scene", {
        get: function () {
            if (this.mRoom) {
                return this.mRoom.scene;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ElementManager.prototype, "map", {
        get: function () {
            return this.mMap;
        },
        enumerable: false,
        configurable: true
    });
    ElementManager.prototype.onSetPosition = function (packet) {
        var content = packet.content;
        var type = content.nodeType;
        var id = content.id;
        if (type !== NodeType.ElementNodeType) {
            return;
        }
        var ele = this.get(id);
        ele.setPosition(new _utils_pos__WEBPACK_IMPORTED_MODULE_4__[/* Pos */ "a"](content.position.x, content.position.y, content.position.z));
    };
    ElementManager.prototype.onRemove = function (packet) {
        var content = packet.content;
        var type = content.nodeType;
        var ids = content.ids;
        if (type !== NodeType.ElementNodeType) {
            return;
        }
        for (var _i = 0, ids_1 = ids; _i < ids_1.length; _i++) {
            var id = ids_1[_i];
            this.remove(id);
        }
    };
    ElementManager.prototype.onSync = function (packet) {
        var content = packet.content;
        if (content.nodeType !== NodeType.ElementNodeType) {
            return;
        }
        var element = null;
        var sprites = content.sprites;
        var command = content.command;
        for (var _i = 0, sprites_3 = sprites; _i < sprites_3.length; _i++) {
            var sprite = sprites_3[_i];
            element = this.get(sprite.id);
            if (element) {
                if (command === pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__["op_def"].OpCommand.OP_COMMAND_UPDATE) {
                    element.model = new _sprite__WEBPACK_IMPORTED_MODULE_5__[/* Sprite */ "a"](sprite);
                }
                else if (command === pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__["op_def"].OpCommand.OP_COMMAND_PATCH) {
                    element.updateModel(sprite);
                }
                // const sp = new Sprite(sprite, content.nodeType);
                // element.model = sp;
                // this.addMap(sp);
            }
        }
    };
    ElementManager.prototype.onMove = function (packet) {
        var content = packet.content;
        if (content.moveData) {
            var moveDataList = content.moveData;
            var len = moveDataList.length;
            var type = content.nodeType || null;
            var moveData = void 0;
            var elementID = void 0;
            var element = void 0;
            for (var i = 0; i < len; i++) {
                moveData = moveDataList[i];
                elementID = moveData.moveObjectId;
                element = this.get(elementID);
                // Console.log(player.x + "," + player.y + ":" + moveData.destinationPoint3f.x + "," + moveData.destinationPoint3f.y + ":" + moveData.timeSpan);
                if (!element) {
                    continue;
                }
                element.move(moveData);
            }
        }
    };
    ElementManager.prototype.onShowBubble = function (packet) {
        var content = packet.content;
        var element = this.get(content.receiverid);
        if (element) {
            element.showBubble(content.context, content.chatsetting);
        }
    };
    ElementManager.prototype.onClearBubbleHandler = function (packet) {
        var content = packet.content;
        var element = this.get(content.receiverid);
        if (element) {
            element.clearBubble();
        }
    };
    ElementManager.prototype.onChangeAnimation = function (packet) {
        var content = packet.content;
        if (content.nodeType !== NodeType.ElementNodeType) {
            return;
        }
        var ele = null;
        var ids = content.ids;
        for (var _i = 0, ids_2 = ids; _i < ids_2.length; _i++) {
            var id = ids_2[_i];
            ele = this.get(id);
            if (ele) {
                ele.setQueue(content.changeAnimation);
            }
        }
    };
    return ElementManager;
}(net_socket_packet__WEBPACK_IMPORTED_MODULE_0__["PacketHandler"]));



/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Font; });
var Font = /** @class */ (function () {
    function Font() {
    }
    Font.YAHEI_14_BOLD = "bold 14px YaHei";
    Font.YAHEI_16_BOLD = "bold 16px YaHei";
    Font.YAHEI_18_BOLD = "bold 18px YaHei";
    Font.YAHEI_20_BOLD = "bold 20px YaHei";
    // static readonly DEFULT_FONT = "-apple-system, 'Noto Sans', 'Helvetica Neue', Helvetica, 'Nimbus Sans L', Arial, 'Liberation Sans', 'PingFang SC', 'Hiragino Sans GB', 'Noto Sans CJK SC', 'Source Han Sans SC', 'Source Han Sans CN', 'Microsoft YaHei'";
    Font.DEFULT_FONT = "'Source Han Sans'";
    return Font;
}());



/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DynamicImage; });
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var DynamicImage = /** @class */ (function (_super) {
    __extends(DynamicImage, _super);
    function DynamicImage(scene, x, y) {
        return _super.call(this, scene, x, y, undefined) || this;
    }
    DynamicImage.prototype.load = function (value, loadContext, completeCallBack, errorCallBack) {
        this.mLoadCompleteCallbak = completeCallBack;
        this.mLoadErrorCallback = errorCallBack;
        this.mLoadContext = loadContext;
        if (!this.scene) {
            _utils_log__WEBPACK_IMPORTED_MODULE_0__[/* Logger */ "a"].getInstance().fatal(DynamicImage.name + " Create failed does not exist");
            return;
        }
        this.mUrl = value;
        if (this.scene.textures.exists(value)) {
            this.onLoadComplete(value);
        }
        else {
            this.scene.load.image(value, value);
            this.scene.load.on(Phaser.Loader.Events.FILE_COMPLETE, this.onLoadComplete, this);
            this.scene.load.on(Phaser.Loader.Events.FILE_LOAD_ERROR, this.onLoadError, this);
            this.scene.load.start();
        }
    };
    DynamicImage.prototype.destroy = function (fromScene) {
        if (fromScene === void 0) { fromScene = false; }
        this.mLoadCompleteCallbak = null;
        this.mLoadContext = null;
        this.mLoadErrorCallback = null;
        this.mUrl = "";
        if (this.scene) {
            this.scene.load.off(Phaser.Loader.Events.FILE_COMPLETE, this.onLoadComplete, this);
            this.scene.load.off(Phaser.Loader.Events.FILE_LOAD_ERROR, this.onLoadError, this);
        }
        _super.prototype.destroy.call(this, fromScene);
    };
    DynamicImage.prototype.onLoadComplete = function (file) {
        if (file === this.mUrl) {
            this.scene.load.off(Phaser.Loader.Events.FILE_COMPLETE, this.onLoadComplete, this);
            this.scene.load.off(Phaser.Loader.Events.FILE_LOAD_ERROR, this.onLoadError, this);
            this.setTexture(this.mUrl);
            if (this.mLoadCompleteCallbak) {
                var cb = this.mLoadCompleteCallbak;
                this.mLoadCompleteCallbak = null;
                cb.call(this.mLoadContext);
                this.mLoadContext = null;
            }
        }
    };
    DynamicImage.prototype.onLoadError = function (file) {
        if (this.mUrl === file.url) {
            if (this.mLoadErrorCallback) {
                var cb = this.mLoadErrorCallback;
                this.mLoadErrorCallback = null;
                cb.call(this.mLoadContext);
                this.mLoadContext = null;
            }
        }
    };
    return DynamicImage;
}(Phaser.GameObjects.Image));



/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export DisplayField */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FramesDisplay; });
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _display_object__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29);
/* harmony import */ var _utils_resUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var DisplayField;
(function (DisplayField) {
    DisplayField[DisplayField["BACKEND"] = 1] = "BACKEND";
    DisplayField[DisplayField["STAGE"] = 2] = "STAGE";
    DisplayField[DisplayField["FRONTEND"] = 3] = "FRONTEND";
})(DisplayField || (DisplayField = {}));
/**
 * 序列帧显示对象
 */
var FramesDisplay = /** @class */ (function (_super) {
    __extends(FramesDisplay, _super);
    function FramesDisplay() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.mDisplayDatas = new Map();
        _this.mSprites = new Map();
        _this.mHasAnimation = false;
        return _this;
    }
    // private mAnimations: Map<DisplayField, Map<string, Phaser.Types.Animations.Animation>> = new Map<DisplayField, Map<string, Phaser.Types.Animations.Animation>>();
    FramesDisplay.prototype.setPosition = function (x, y, z) {
        _super.prototype.setPosition.call(this, x, y, z);
        this.setDepth(this.x + this.baseLoc.x + this.y + this.baseLoc.y);
        return this;
    };
    FramesDisplay.prototype.load = function (displayInfo, field) {
        field = !field ? DisplayField.STAGE : field;
        var data = displayInfo;
        if (!data || !data.gene)
            return;
        var currentDisplay = this.mDisplayDatas.get(field);
        if (currentDisplay && currentDisplay.gene === displayInfo.gene) {
            return;
        }
        this.mDisplayDatas.set(field, data);
        if (this.scene.textures.exists(data.gene)) {
            this.onLoadCompleted(field);
        }
        else {
            var display = data.display;
            if (!display) {
                _utils_log__WEBPACK_IMPORTED_MODULE_0__[/* Logger */ "a"].getInstance().error("display is undefined");
            }
            this.scene.load.atlas(data.gene, _utils_resUtil__WEBPACK_IMPORTED_MODULE_2__[/* Url */ "c"].OSD_PATH + display.texturePath, _utils_resUtil__WEBPACK_IMPORTED_MODULE_2__[/* Url */ "c"].OSD_PATH + display.dataPath);
            // this.scene.load.once(Phaser.Loader.Events.FILE_LOAD_ERROR, (imageFile: ImageFile) => {
            //     Logger.error(`Loading Error: key = ${imageFile} >> ${imageFile.url}`);
            // }, this);
            this.scene.textures.on(Phaser.Textures.Events.ADD, this.onAddTextureHandler, this);
            this.scene.load.start();
        }
    };
    FramesDisplay.prototype.play = function (animation, field) {
        this.mActionName = animation;
        if (!animation)
            return;
        field = !field ? DisplayField.STAGE : field;
        var data = this.mDisplayDatas.get(field);
        var sprite = this.mSprites.get(field);
        var ani = data.getAnimations(animation.animationName);
        if (!ani) {
            return;
        }
        if (sprite) {
            if (sprite instanceof Phaser.GameObjects.Sprite) {
                sprite.off(Phaser.Animations.Events.ANIMATION_REPEAT, this.onAnimationRepeatHander, this);
                if (ani.frameName.length > 1) {
                    sprite.play(data.gene + "_" + animation.animationName);
                    // if (animation.playTimes !== undefined) {
                    //     sprite.anims.setRepeat(animation.playTimes);
                    if (animation.playingQueue && animation.playingQueue.complete) {
                        sprite.on(Phaser.Animations.Events.ANIMATION_REPEAT, this.onAnimationRepeatHander, this);
                    }
                    // }
                }
                else {
                    sprite.anims.stop();
                    sprite.setTexture(data.gene, ani.frameName[0]);
                }
            }
            else {
                sprite.setTexture(data.gene, ani.frameName[0]);
            }
            this.scaleX = animation.flip ? -1 : 1;
            // this.flipX = animation.flip;
        }
        this.initBaseLoc(field, animation.animationName);
    };
    FramesDisplay.prototype.fadeIn = function (callback) {
        if (this.mAlpha === 0) {
            return;
        }
        this.alpha = 0;
        this.clearFadeTween();
        this.mFadeTween = this.scene.tweens.add({
            targets: this,
            alpha: this.mAlpha,
            duration: 1200,
            onComplete: function () {
                if (callback)
                    callback();
            },
        });
    };
    FramesDisplay.prototype.fadeOut = function (callback) {
        this.clearFadeTween();
        this.mFadeTween = this.scene.tweens.add({
            targets: this,
            alpha: 0,
            duration: 1200,
            onComplete: function () {
                if (callback)
                    callback();
            },
        });
    };
    FramesDisplay.prototype.scaleTween = function () {
        var _this = this;
        var display = this.mSprites.get(DisplayField.STAGE);
        if (!display) {
            return;
        }
        if (this.mScaleTween) {
            return;
        }
        var tmp = display.scale;
        this.mScaleTween = this.scene.tweens.add({
            targets: display,
            duration: 100,
            scale: tmp * 1.25,
            yoyo: true,
            repeat: 0,
            onComplete: function () {
                display.scale = 1;
                if (_this.mScaleTween) {
                    // this.mScaleTween.destroy();
                    _this.mScaleTween = undefined;
                }
            },
        });
    };
    FramesDisplay.prototype.setInteractive = function (shape, callback, dropZone) {
        // super.setInteractive(shape, callback, dropZone);
        this.mSprites.forEach(function (sprite) {
            sprite.setInteractive({ pixelPerfect: true });
        });
        return this;
    };
    FramesDisplay.prototype.disableInteractive = function () {
        // super.disableInteractive();
        this.mSprites.forEach(function (sprite) {
            sprite.disableInteractive();
        });
        return this;
    };
    FramesDisplay.prototype.destroy = function () {
        this.mSprites.forEach(function (sprite) { return sprite.destroy(); });
        this.mSprites.clear();
        if (this.mFadeTween) {
            this.clearFadeTween();
            this.mFadeTween = undefined;
        }
        if (this.mScaleTween) {
            this.mScaleTween.stop();
            this.mScaleTween = undefined;
        }
        this.mDisplayDatas.clear();
        _super.prototype.destroy.call(this);
    };
    FramesDisplay.prototype.clearFadeTween = function () {
        if (this.mFadeTween) {
            this.mFadeTween.stop();
            this.mFadeTween.remove();
        }
    };
    FramesDisplay.prototype.onAddTextureHandler = function (key) {
        var data = this.mDisplayDatas.get(DisplayField.STAGE);
        if (data && data.gene === key) {
            this.scene.textures.off(Phaser.Textures.Events.ADD, this.onAddTextureHandler, this);
            this.onLoadCompleted(DisplayField.STAGE);
        }
    };
    FramesDisplay.prototype.onLoadCompleted = function (field) {
        var data = this.mDisplayDatas.get(field);
        if (!data) {
            return;
        }
        if (this.scene.textures.exists(data.gene)) {
            this.makeAnimations(field);
            this.createDisplay(field);
        }
    };
    FramesDisplay.prototype.makeAnimations = function (field) {
        var data = this.mDisplayDatas.get(field);
        if (!data)
            return;
        var animations = Array.from(data.animations.values());
        for (var _i = 0, animations_1 = animations; _i < animations_1.length; _i++) {
            var ani = animations_1[_i];
            this.makeAnimation(field, ani);
        }
    };
    FramesDisplay.prototype.makeAnimation = function (field, animation) {
        var data = this.mDisplayDatas.get(field);
        if (!animation || !data || !data.gene)
            return;
        if (animation.frameName.length <= 1)
            return;
        // Didn't find a good way to create an animation with frame names without a pattern.
        var frames = [];
        animation.frameName.forEach(function (frame) {
            frames.push({ key: data.gene, frame: frame });
        });
        var key = data.gene + "_" + animation.name;
        var config = {
            key: key,
            frames: frames,
            frameRate: animation.frameRate,
            repeat: animation.loop ? -1 : 0,
        };
        this.mHasAnimation = true;
        this.scene.anims.create(config);
    };
    FramesDisplay.prototype.initBaseLoc = function (field, aniName) {
        var data = this.mDisplayDatas.get(field);
        var sprite = this.mSprites.get(field);
        if (!sprite || !data || !data.animations)
            return;
        var animations = data.getAnimations(aniName);
        if (!animations)
            return;
        this.mBaseLoc = animations.baseLoc;
        this.mCollisionArea = animations.collisionArea;
        this.mOriginPoint = animations.originPoint;
        sprite.x = this.baseLoc.x + sprite.width / 2;
        sprite.y = this.baseLoc.y + sprite.height / 2;
    };
    FramesDisplay.prototype.createDisplay = function (field) {
        var data = this.mDisplayDatas.get(field);
        if (!data || !data.gene)
            return;
        var sprite = this.mSprites.get(field);
        // Create Sprite
        if (!sprite) {
            if (this.mHasAnimation) {
                sprite = this.scene.make.sprite(undefined, false);
            }
            else {
                sprite = this.scene.make.image(undefined, false);
                // sprite.setTexture(data.gene);
            }
            this.mSprites.set(field, sprite);
        }
        this.play({ animationName: data.animationName, flip: false }, field);
        sprite.x = this.baseLoc.x + sprite.width / 2;
        sprite.y = this.baseLoc.y + sprite.height / 2;
        if (this.mAntial) {
            sprite.texture.setFilter(Phaser.Textures.FilterMode.NEAREST);
        }
        this.addAt(sprite, field);
        // sprite.setInteractive({ pixelPerfect: true });
        this.setData("id", data.id);
        // this.mSprites.set(field, sprite);
        this.emit("initialized", this);
    };
    FramesDisplay.prototype.onAnimationRepeatHander = function () {
        var queue = this.mActionName.playingQueue;
        if (queue.playedTimes === undefined) {
            queue.playedTimes = 1;
        }
        else {
            queue.playedTimes++;
        }
        if (queue.playedTimes >= queue.playTimes) {
            var sprite = this.mSprites.get(DisplayField.STAGE);
            if (sprite) {
                sprite.off(Phaser.Animations.Events.ANIMATION_REPEAT, this.onAnimationRepeatHander, this);
            }
            // this.emit("animationComplete");
            if (queue.complete) {
                queue.complete.call(this);
                delete queue.complete;
            }
        }
    };
    Object.defineProperty(FramesDisplay.prototype, "spriteWidth", {
        get: function () {
            var sprite = this.mSprites.get(DisplayField.STAGE);
            if (sprite) {
                return sprite.width;
            }
            return 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FramesDisplay.prototype, "spriteHeight", {
        get: function () {
            var sprite = this.mSprites.get(DisplayField.STAGE);
            if (sprite) {
                return sprite.height;
            }
            return 0;
        },
        enumerable: false,
        configurable: true
    });
    return FramesDisplay;
}(_display_object__WEBPACK_IMPORTED_MODULE_1__[/* DisplayObject */ "a"]));



/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FramesModel; });
/* harmony import */ var pixelpai_proto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var pixelpai_proto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pixelpai_proto__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var simple_sha1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(133);
/* harmony import */ var simple_sha1__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(simple_sha1__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(47);
/* harmony import */ var _element_sprite__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(13);
/* harmony import */ var _element_element__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(11);






var FramesModel = /** @class */ (function () {
    function FramesModel(data) {
        this.discriminator = "FramesModel";
        // TODO 定义IElement接口
        this.id = data.id || 0;
        this.type = data.sn || "";
        var anis = data.animations;
        if (anis) {
            this.animationName = anis.defaultAnimationName;
            this.setDisplay(anis.display);
            this.setAnimationData(anis.animationData);
        }
    }
    FramesModel.prototype.setInfo = function (val) {
        for (var key in val) {
            if (val.hasOwnProperty(key)) {
                this[key] = val[key];
            }
        }
    };
    FramesModel.prototype.getAnimationData = function () {
        return this.animations;
    };
    FramesModel.prototype.existAnimation = function (aniName) {
        if (!this.animations)
            return false;
        return this.animations.has(aniName);
    };
    FramesModel.prototype.getAnimations = function (name) {
        if (!this.animations)
            return;
        return this.animations.get(name);
    };
    FramesModel.prototype.destroy = function () {
        if (this.animations)
            this.animations.clear();
    };
    Object.defineProperty(FramesModel.prototype, "gene", {
        get: function () {
            return this.mGen;
        },
        enumerable: false,
        configurable: true
    });
    FramesModel.prototype.toClient = function () {
        var anis = [];
        this.animations.forEach(function (ani) {
            anis.push(ani.toClient());
        }, this);
        return anis;
    };
    FramesModel.prototype.getCollisionArea = function (aniName, flip) {
        if (flip === void 0) { flip = false; }
        var ani = this.getAnimations(aniName);
        if (ani) {
            if (flip) {
                return _utils_helpers__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].flipArray(ani.collisionArea);
            }
            return ani.collisionArea;
        }
    };
    FramesModel.prototype.getWalkableArea = function (aniName, flip) {
        if (flip === void 0) { flip = false; }
        var ani = this.getAnimations(aniName);
        if (flip) {
            return _utils_helpers__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].flipArray(ani.walkableArea);
        }
        return ani.walkableArea;
    };
    FramesModel.prototype.getInteractiveArea = function (aniName) {
        var ani = this.getAnimations(aniName);
        return ani ? ani.interactiveArea : undefined;
    };
    FramesModel.prototype.getOriginPoint = function (aniName, flip) {
        if (flip === void 0) { flip = false; }
        var ani = this.getAnimations(aniName);
        if (ani) {
            var originPoint = ani.originPoint;
            if (flip) {
                return new Phaser.Geom.Point(originPoint.y, originPoint.x);
            }
            return originPoint;
        }
    };
    FramesModel.prototype.getDirable = function () { };
    FramesModel.prototype.createSprite = function (properties) {
        var nodeType = properties.nodeType, x = properties.x, y = properties.y, z = properties.z, id = properties.id, dir = properties.dir, isMoss = properties.isMoss;
        var spr = pixelpai_proto__WEBPACK_IMPORTED_MODULE_0__["op_client"].Sprite.create();
        if (id) {
            spr.id = id;
        }
        else {
            spr.id = _utils_helpers__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].genId();
        }
        spr.display = this.display;
        spr.currentAnimationName = this.animationName;
        var point3f = pixelpai_proto__WEBPACK_IMPORTED_MODULE_0__["op_def"].PBPoint3f.create();
        point3f.x = x;
        point3f.y = y;
        if (z) {
            point3f.z = z;
        }
        spr.point3f = point3f;
        spr.animations = this.toClient();
        if (dir) {
            spr.direction = dir;
        }
        if (isMoss !== undefined) {
            spr.isMoss = isMoss;
        }
        return new _element_sprite__WEBPACK_IMPORTED_MODULE_4__[/* Sprite */ "a"](spr, nodeType);
    };
    FramesModel.prototype.findAnimation = function (baseName, dir) {
        var animationName = this.checkDirectionAnimation(baseName, dir);
        var flip = false;
        if (animationName) {
            return { animationName: animationName, flip: flip };
        }
        switch (dir) {
            case _element_element__WEBPACK_IMPORTED_MODULE_5__[/* Direction */ "a"].west_south:
            case _element_element__WEBPACK_IMPORTED_MODULE_5__[/* Direction */ "a"].east_north:
                animationName = this.getDefaultAnimation(baseName);
                break;
            case _element_element__WEBPACK_IMPORTED_MODULE_5__[/* Direction */ "a"].south_east:
                animationName = this.getDefaultAnimation(baseName);
                flip = true;
                break;
            case _element_element__WEBPACK_IMPORTED_MODULE_5__[/* Direction */ "a"].north_west:
                animationName = this.checkDirectionAnimation(baseName, _element_element__WEBPACK_IMPORTED_MODULE_5__[/* Direction */ "a"].east_north);
                if (animationName === null) {
                    animationName = this.getDefaultAnimation(baseName);
                }
                flip = true;
                break;
        }
        return { animationName: animationName, flip: flip };
    };
    FramesModel.prototype.setDisplay = function (display) {
        if (!display) {
            _utils_log__WEBPACK_IMPORTED_MODULE_1__[/* Logger */ "a"].getInstance().error(this.type + " display does not exist");
            return;
        }
        this.display = {
            dataPath: display.dataPath,
            texturePath: display.texturePath,
        };
        this.mGen = simple_sha1__WEBPACK_IMPORTED_MODULE_2__["sync"](display.dataPath + display.texturePath);
    };
    FramesModel.prototype.setAnimationData = function (aniDatas) {
        if (!aniDatas) {
            _utils_log__WEBPACK_IMPORTED_MODULE_1__[/* Logger */ "a"].getInstance().error(this.id + " animationData does not exist");
            return;
        }
        this.animations = new Map();
        // let ani: IAnimationData;
        for (var _i = 0, aniDatas_1 = aniDatas; _i < aniDatas_1.length; _i++) {
            var aniData = aniDatas_1[_i];
            // const baseLoc = aniData.baseLoc;
            // ani = {
            //     name: aniData.name,
            //     frameName: aniData.frameName,
            //     frameRate: aniData.frameRate,
            //     loop: aniData.loop,
            //     baseLoc: new Phaser.Geom.Point(baseLoc.x, baseLoc.y),
            //     // walkableArea: aniData.walkableArea || [],
            //     collisionArea: aniData.collisionArea || [],
            //     originPoint: aniData.originPoint
            // };
            this.animations.set(aniData.name, aniData);
            // this.animations.set(aniData.name + "_7", aniData);
            // this.animations.set(aniData.name + "_1", aniData);
            // this.animations.set(aniData.name + "_5", aniData);
        }
    };
    FramesModel.prototype.checkDirectionAnimation = function (baseAniName, dir) {
        var aniName = baseAniName + "_" + dir;
        if (this.existAnimation(aniName)) {
            return aniName;
        }
        return null;
    };
    FramesModel.prototype.getDefaultAnimation = function (baseName) {
        var animationName = this.checkDirectionAnimation(baseName, _element_element__WEBPACK_IMPORTED_MODULE_5__[/* Direction */ "a"].west_south);
        if (animationName === null) {
            if (this.existAnimation(baseName)) {
                animationName = baseName;
            }
            else {
                _utils_log__WEBPACK_IMPORTED_MODULE_1__[/* Logger */ "a"].getInstance().warn(FramesModel.name + ": can't find animation " + baseName);
                animationName = "idle";
            }
        }
        return animationName;
    };
    return FramesModel;
}());



/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _element__WEBPACK_IMPORTED_MODULE_0__["b"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "b", function() { return _element__WEBPACK_IMPORTED_MODULE_0__["d"]; });




/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PlayScene; });
/* harmony import */ var _main_ui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(80);
/* harmony import */ var _basic_scene__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
/* harmony import */ var _rooms_cameras_play_camera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(81);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



// 游戏正式运行用 Phaser.Scene
var PlayScene = /** @class */ (function (_super) {
    __extends(PlayScene, _super);
    function PlayScene(config) {
        return _super.call(this, config || { key: PlayScene.name }) || this;
    }
    PlayScene.prototype.preload = function () { };
    PlayScene.prototype.init = function (data) {
        if (data) {
            this.mRoom = data.room;
        }
    };
    PlayScene.prototype.create = function () {
        var scene = this.game.scene.getScene(_main_ui__WEBPACK_IMPORTED_MODULE_0__[/* MainUIScene */ "a"].name);
        var oldCamera = this.cameras.main;
        this.cameras.addExisting(new _rooms_cameras_play_camera__WEBPACK_IMPORTED_MODULE_2__[/* PlayCamera */ "a"](0, 0, this.sys.scale.width, this.sys.scale.height, this.mRoom.world.scaleRatio), true);
        this.cameras.remove(oldCamera);
        if (!scene.scene.isActive()) {
            this.scene.launch(_main_ui__WEBPACK_IMPORTED_MODULE_0__[/* MainUIScene */ "a"].name, {
                room: this.mRoom,
            });
        }
        this.scene.sendToBack();
        this.scale.on("orientationchange", this.checkOriention, this);
        this.scale.on("resize", this.checkSize, this);
        if (this.mRoom)
            this.mRoom.startPlay();
    };
    PlayScene.prototype.update = function (time, delta) {
        // if (this.cameras.main) {
        //   this.cameras.main.emit("renderer", this.cameras.main);
        // }
        if (this.mRoom) {
            this.mRoom.update(time, delta);
        }
    };
    PlayScene.prototype.setViewPort = function (x, y, width, height) {
        _super.prototype.setViewPort.call(this, x, y, width, height);
        this.cameras.main.zoom = Math.ceil(window.devicePixelRatio);
    };
    PlayScene.prototype.getKey = function () {
        return this.sys.config.key;
    };
    PlayScene.prototype.checkOriention = function (orientation) {
        if (orientation === Phaser.Scale.PORTRAIT) {
        }
        else if (orientation === Phaser.Scale.LANDSCAPE) {
        }
    };
    PlayScene.prototype.checkSize = function (size) {
        var width = size.width;
        var height = size.height;
    };
    return PlayScene;
}(_basic_scene__WEBPACK_IMPORTED_MODULE_1__[/* BasicScene */ "a"]));



/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BaseUI; });
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var BaseUI = /** @class */ (function (_super) {
    __extends(BaseUI, _super);
    function BaseUI(scene, dpr, scale) {
        var _this = _super.call(this, scene) || this;
        /**
         * 是否静音
         */
        _this.silent = false;
        /**
         * 移动端像素密度
         */
        _this.dpr = 1;
        /**
         * 是否初始化
         */
        _this.mInitialized = false;
        _this.interactiveBoo = false;
        _this.mShow = false;
        _this.scene = scene;
        _this.dpr = dpr || 1;
        _this.scale = scale || 1;
        _this.soundMap = new Map();
        _this.disInteractive();
        return _this;
    }
    BaseUI.prototype.setFollow = function (gameObject, froscene, posFunc) {
        this.mFollow = gameObject;
        this.mFroscene = froscene;
        if (posFunc)
            this.posFunc = posFunc;
    };
    BaseUI.prototype.updatePos = function () {
        if (!this.mShow)
            return;
        if (this.posFunc) {
            this.posFunc({
                scene: this.mFroscene,
                followX: this.mFollow.x,
                followY: this.mFollow.y,
                baseX: this.x,
                baseY: this.y
            });
        }
        else {
            var camera = this.mFroscene.cameras.main;
            var px = this.x - camera.scrollX;
            var py = this.y - camera.scrollY;
            this.x = px;
            this.y = py;
        }
    };
    BaseUI.prototype.setInteractive = function (shape, callback, dropZone) {
        this.interactiveBoo = true;
        _super.prototype.setInteractive.call(this, shape, callback, dropZone);
        return this;
    };
    BaseUI.prototype.disInteractive = function () {
        this.interactiveBoo = false;
        _super.prototype.disableInteractive.call(this);
    };
    BaseUI.prototype.addListen = function () {
        // if (!this.mInitialized) return;
        // let sizeBoo: boolean = true;
        // if (this.width === 0 || this.height === 0) {
        //     sizeBoo = false;
        // }
        // if (this.interactiveBoo) {
        //     if (sizeBoo) {
        //         this.setInteractive(new Phaser.Geom.Rectangle(0, 0, this.width, this.height), Phaser.Geom.Rectangle.Contains);
        //         this.on("pointerup", this.uiClick, this);
        //     }
        //     this.scene.input.off("pointerup", this.sceneClick, this);
        // } else {
        //     if (sizeBoo) {
        //         this.disableInteractive();
        //         this.off("pointerup", this.uiClick, this);
        //     }
        //     this.scene.input.on("pointerup", this.sceneClick, this);
        // }
    };
    BaseUI.prototype.removeListen = function () {
        // if (!this.mInitialized) return;
        // this.scene.input.off("pointerup", this.sceneClick, this);
        // this.off("pointerup", this.uiClick, this);
    };
    BaseUI.prototype.playSound = function (config) {
        if (this.silent)
            return;
        // if (config.key === undefined) {
        //     if (typeof config.urls === "string") {
        //         config.key = config.urls;
        //     } else {
        //         config.key = config.urls[0];
        //     }
        // }
        var key = config.key;
        // const urls = config.urls;
        if (this.scene.cache.audio.exists(key)) {
            this.startPlay(config);
        }
        else {
            // this.scene.load.once(`filecomplete-audio-${key}`, () => {
            //     this.startPlay(config);
            // }, this);
            // this.scene.load.audio(key, urls);
            // this.scene.load.start();
        }
    };
    BaseUI.prototype.startPlay = function (config) {
        if (this.silent)
            return;
        var key = config.key;
        var sound = this.soundMap.get(key);
        if (!sound) {
            sound = this.scene.sound.add(key, config.soundConfig);
            this.soundMap.set(key, sound);
        }
        if (sound.isPlaying) {
            return;
        }
        sound.play();
    };
    BaseUI.prototype.stopSound = function () {
        if (this.silent)
            return;
        this.soundMap.forEach(function (sound) {
            if (sound.isPlaying)
                sound.stop();
        });
    };
    BaseUI.prototype.pauseSound = function () {
        if (this.silent)
            return;
        this.soundMap.forEach(function (sound) {
            if (!sound.isPaused)
                sound.pause();
        });
    };
    BaseUI.prototype.resumeSound = function () {
        if (this.silent)
            return;
        this.soundMap.forEach(function (sound) {
            if (sound.isPaused)
                sound.resume();
        });
    };
    BaseUI.prototype.setSilent = function (boo) {
        this.silent = boo;
    };
    BaseUI.prototype.destroy = function () {
        this.soundMap.forEach(function (sound) {
            if (sound.isPlaying)
                sound.stop();
        });
        this.mInitialized = false;
        this.interactiveBoo = false;
        this.silent = false;
        this.removeListen();
        _super.prototype.destroy.call(this);
    };
    // protected sceneClick(pointer: Phaser.Input.Pointer) {
    //     if (Tool.checkPointerContains(this, pointer) && this.checkPointerDelection(pointer)) {
    //         this.emit("uiClick");
    //     }
    // }
    // protected uiClick(pointer: Phaser.Input.Pointer) {
    //     if (this.checkPointerDelection(pointer)) {
    //         this.emit("uiClick");
    //     }
    // }
    BaseUI.prototype.checkPointerDelection = function (pointer) {
        if (!this.scene)
            return true;
        return Math.abs(pointer.downX - pointer.upX) < 10 * this.dpr * this.scale ||
            Math.abs(pointer.downY - pointer.upY) < 10 * this.dpr * this.scale;
    };
    return BaseUI;
}(Phaser.GameObjects.Container));



/***/ }),
/* 39 */,
/* 40 */,
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ BasePanel_BasePanel; });

// EXTERNAL MODULE: ./src/utils/resUtil.ts + 1 modules
var resUtil = __webpack_require__(8);

// CONCATENATED MODULE: ./lib/rexui/lib/ui/tool/Tool.ts
var GetValue = Phaser.Utils.Objects.GetValue;
var Tool = /** @class */ (function () {
    function Tool() {
    }
    Tool.checkPointerContains = function (gameObject, pointer) {
        var left = -gameObject.width / 2;
        var right = gameObject.width / 2;
        var top = -gameObject.height / 2;
        var bottom = gameObject.height / 2;
        if (pointer) {
            var worldMatrix = gameObject.getWorldTransformMatrix();
            var x = pointer.x - worldMatrix.tx;
            var y = pointer.y - worldMatrix.ty;
            if (left <= x && right >= x && top <= y && bottom >= y) {
                return true;
            }
            return false;
        }
        return false;
    };
    Tool.getTransfrom = function (config) {
        return !config ? undefined : config.transform;
    };
    Tool.getPos = function (transform) {
        var pos = { x: 0, y: 0 };
        if (!transform) {
            return pos;
        }
        var tmpValue;
        var width = GetValue(transform, "width", 0);
        var height = GetValue(transform, "height", 0);
        if (transform.x === undefined) {
            transform.x = 0;
        }
        if (transform.y === undefined) {
            transform.y = 0;
        }
        if (typeof (transform.x) === "string") {
            tmpValue = GetValue(transform, "x", "100%");
            pos.x = Number(tmpValue.split("%")[0]) * width;
        }
        else {
            pos.x = GetValue(transform, "x", 0);
        }
        if (typeof (transform.y) === "string") {
            tmpValue = GetValue(transform, "y", "100%");
            pos.y = Number(tmpValue.split("%")[0]) * height;
        }
        else {
            pos.y = GetValue(transform, "y", 0);
        }
        return pos;
    };
    Tool.checkNinePatch = function (align) {
        if (align.top || align.bottom || align.right || align.left) {
            return true;
        }
        return false;
    };
    return Tool;
}());


// EXTERNAL MODULE: ./lib/rexui/lib/ui/baseUI/BaseUI.ts
var BaseUI = __webpack_require__(38);

// CONCATENATED MODULE: ./lib/rexui/lib/ui/panel/Panel.ts
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var Panel_Panel = /** @class */ (function (_super) {
    __extends(Panel, _super);
    function Panel(scene, world, music) {
        var _this = _super.call(this, scene, world.dpr, world.uiScaleNew) || this;
        /**
         * 是否正在加载中，加载中的ui不走show流程
         */
        _this.mPreLoad = false;
        _this.mTweening = false;
        _this.mReloadTimes = 0;
        _this.mTweenBoo = true;
        _this.mMute = false;
        _this.mEnabled = true;
        _this.soundMap = new Map();
        _this.scene = scene;
        _this.mWorld = world;
        _this.soundGroup = music;
        _this.mInitialized = false;
        _this.setTween(false);
        return _this;
    }
    Panel.prototype.addListen = function () {
        if (!this.mInitialized)
            return;
        this.removeListen();
        _super.prototype.addListen.call(this);
    };
    Panel.prototype.removeListen = function () {
        if (!this.mInitialized)
            return;
        _super.prototype.removeListen.call(this);
    };
    Panel.prototype.setFollow = function (gameObject, froscene, posFunc) {
        this.mFollow = gameObject;
        this.mFroscene = froscene;
        if (posFunc)
            this.posFunc = posFunc;
    };
    Panel.prototype.isShow = function () {
        return this.mShow;
    };
    Panel.prototype.hide = function () {
        if (this.soundGroup && this.soundGroup.close)
            this.playSound(this.soundGroup.close);
        if (!this.mTweening && this.mTweenBoo) {
            this.showTween(false);
        }
        else {
            this.destroy();
        }
    };
    Panel.prototype.destroy = function () {
        if (this.mPanelTween) {
            this.mPanelTween.stop();
            this.mPanelTween.remove();
            this.mPanelTween = undefined;
        }
        if (this.mResources) {
            this.mResources.clear();
            this.mResources = undefined;
        }
        this.mMute = false;
        this.mInitialized = false;
        this.mShow = false;
        this.width = 0;
        this.height = 0;
        this.mReloadTimes = 0;
        this.offLoad();
        _super.prototype.destroy.call(this);
    };
    Panel.prototype.resize = function (wid, hei) {
    };
    Panel.prototype.show = function (param) {
        this.mShowData = param;
        if (this.mPreLoad)
            return;
        if (!this.mInitialized) {
            this.preload();
            return;
        }
        if (this.mShow)
            return;
        if (this.soundGroup && this.soundGroup.open)
            this.playSound(this.soundGroup.open);
        if (!this.mTweening && this.mTweenBoo) {
            this.showTween(true);
        }
        else {
            this.mShow = true;
        }
        this.addListen();
    };
    Panel.prototype.update = function (param) {
        this.mShowData = param;
    };
    Panel.prototype.tweenExpand = function (tweenBoo) {
    };
    Panel.prototype.setTween = function (boo) {
        this.mTweenBoo = boo;
    };
    Object.defineProperty(Panel.prototype, "showData", {
        get: function () {
            return this.mShowData;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Panel.prototype, "interactive", {
        get: function () {
            return this.mEnabled;
        },
        enumerable: false,
        configurable: true
    });
    Panel.prototype.showTween = function (show) {
        var _this = this;
        this.mTweening = true;
        var scale = show ? this.scale : 0;
        this.scale = scale;
        if (this.mPanelTween) {
            this.mPanelTween.stop();
        }
        this.mPanelTween = this.scene.tweens.add({
            targets: this,
            duration: 200,
            ease: "Linear",
            props: {
                scaleX: { value: scale },
                scaleY: { value: scale },
            },
            onComplete: function () {
                _this.tweenComplete(show);
            },
            onCompleteParams: [this]
        });
    };
    Panel.prototype.tweenComplete = function (show) {
        this.mTweening = false;
        this.mPanelTween.stop();
        this.mShow = show;
        if (!show) {
            this.destroy();
        }
    };
    Panel.prototype.init = function () {
        this.mInitialized = true;
        if (this.mResources) {
            this.mResources.clear();
            this.mResources = null;
        }
        this.show(this.mShowData);
    };
    Panel.prototype.addAtlas = function (key, texture, data) {
        if (!this.mResources) {
            this.mResources = new Map();
        }
        this.mResources.set(key, {
            dpr: this.dpr,
            type: "atlas",
            texture: texture,
            data: data
        });
    };
    Panel.prototype.addImage = function (key, value) {
        if (!this.mResources) {
            this.mResources = new Map();
        }
        if (value === undefined)
            value = key;
        this.mResources.set(key, {
            dpr: this.dpr,
            type: "image",
            texture: value
        });
    };
    Panel.prototype.preload = function () {
        var _this = this;
        this.mPreLoad = true;
        if (!this.scene) {
            return;
        }
        if (this.mResources) {
            this.mResources.forEach(function (resource, key) {
                _this.addResources(key, resource);
            }, this);
        }
        this.startLoad();
    };
    Panel.prototype.loadComplete = function (loader, totalComplete, totalFailed) {
        this.mPreLoad = false;
        if (this.mInitialized) {
            return;
        }
        if (totalFailed > 0 && this.mResources && this.mResources.size > 0) {
            this.reload();
            return;
        }
        this.offLoad();
        this.init();
    };
    Panel.prototype.loadError = function (file) {
        if (!this.mResources) {
            return;
        }
        var resource = this.mResources.get(file.key);
        if (!resource) {
            return;
        }
        resource.dpr = 2;
        if (!this.mReLoadResources) {
            this.mReLoadResources = new Map();
        }
        this.mReLoadResources.set(file.key, resource);
    };
    Panel.prototype.onFileKeyComplete = function (key) {
        if (!this.mResources) {
            return;
        }
        if (this.mResources.has(key)) {
            this.mResources.delete(key);
        }
    };
    Panel.prototype.addResources = function (key, resource) {
        // TODO Add IResource interface
        if (!this.scene) {
            return;
        }
        // TODO add load type
        // if (resource.data) this.scene.load.atlas(key, Url.getUIRes(resource.dpr, resource.texture), Url.getUIRes(resource.dpr, resource.data));
    };
    Panel.prototype.reload = function () {
        var _this = this;
        if (!this.mReLoadResources || this.mReLoadResources.size <= 0) {
            return;
        }
        if (++this.mReloadTimes > 1) {
            return;
        }
        this.mReLoadResources.forEach(function (resource, key) {
            _this.addResources(key, resource);
        }, this);
        this.startLoad();
    };
    Panel.prototype.startLoad = function () {
        if (!this.scene) {
            return;
        }
        this.scene.load.on(Phaser.Loader.Events.FILE_KEY_COMPLETE, this.onFileKeyComplete, this);
        this.scene.load.once(Phaser.Loader.Events.COMPLETE, this.loadComplete, this);
        this.scene.load.on(Phaser.Loader.Events.FILE_LOAD_ERROR, this.loadError, this);
        this.scene.load.start();
    };
    Panel.prototype.offLoad = function () {
        if (!this.scene) {
            return;
        }
        this.scene.load.off(Phaser.Loader.Events.FILE_KEY_COMPLETE, this.onFileKeyComplete, this);
        this.scene.load.off(Phaser.Loader.Events.COMPLETE, this.loadComplete, this);
        this.scene.load.off(Phaser.Loader.Events.FILE_LOAD_ERROR, this.loadError, this);
    };
    Panel.prototype.sceneClick = function (pointer) {
        if (Tool.checkPointerContains(this, pointer) && this.checkPointerDelection(pointer)) {
            this.emit("panelClick", pointer);
        }
    };
    Panel.prototype.uiClick = function (pointer) {
        if (this.checkPointerDelection(pointer)) {
            this.emit("panelClick", pointer);
        }
    };
    return Panel;
}(BaseUI["a" /* BaseUI */]));


// CONCATENATED MODULE: ./src/ui/components/BasePanel.ts
var BasePanel_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var BasePanel_BasePanel = /** @class */ (function (_super) {
    BasePanel_extends(BasePanel, _super);
    function BasePanel(scene, world) {
        var _this = _super.call(this, scene, world) || this;
        _this.mTweening = false;
        _this.mWidth = 0;
        _this.mHeight = 0;
        _this.mReloadTimes = 0;
        _this.mScene = scene;
        _this.mWorld = world;
        _this.mInitialized = false;
        if (world) {
            _this.dpr = Math.round(world.uiRatio || 1);
            _this.scale = _this.mWorld.uiScale;
        }
        return _this;
    }
    BasePanel.prototype.addResources = function (key, resource) {
        _super.prototype.addResources.call(this, key, resource);
        if (resource.type) {
            if (this.scene.load[resource.type]) {
                this.scene.load[resource.type](key, resUtil["c" /* Url */].getUIRes(resource.dpr, resource.texture), resUtil["c" /* Url */].getUIRes(resource.dpr, resource.data));
            }
        }
    };
    Object.defineProperty(BasePanel.prototype, "screenWidth", {
        get: function () {
            this.scale = (this.mWorld ? this.mWorld.uiScale : 1);
            var width = this.scene.cameras.main.width / this.scale;
            return width;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BasePanel.prototype, "screenHeight", {
        get: function () {
            this.scale = (this.mWorld ? this.mWorld.uiScale : 1);
            var height = this.scene.cameras.main.height / this.scale;
            return height;
        },
        enumerable: false,
        configurable: true
    });
    return BasePanel;
}(Panel_Panel));



/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ nine_patch_NinePatch; });

// CONCATENATED MODULE: ./src/ui/components/patches.config.ts
var normalizePatchesConfig = function (config) {
    config.bottom = (config.bottom !== undefined) ? config.bottom : config.top;
    config.left = (config.left !== undefined) ? config.left : config.top;
    config.right = (config.right !== undefined) ? config.right : config.left;
    return config;
};


// CONCATENATED MODULE: ./src/ui/components/nine.patch.ts
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var nine_patch_NinePatch = /** @class */ (function (_super) {
    __extends(NinePatch, _super);
    function NinePatch(scene, x, y, width, height, key, frame, config) {
        var _this = _super.call(this, scene, x, y) || this;
        _this.config = config || _this.scene.cache.custom.ninePatch.get(frame ? "" + frame : key);
        // 对于config进行取整
        _this.config.top = Math.round(_this.config.top);
        if (_this.config.right)
            _this.config.right = Math.round(_this.config.right);
        if (_this.config.bottom)
            _this.config.bottom = Math.round(_this.config.bottom);
        if (_this.config.left)
            _this.config.left = Math.round(_this.config.left);
        normalizePatchesConfig(_this.config);
        _this.setSize(width, height);
        _this.setTexture(key, frame);
        return _this;
    }
    NinePatch.prototype.resize = function (width, height) {
        width = Math.round(width);
        height = Math.round(height);
        if (!this.config) {
            return this;
        }
        if (this.width === width && this.height === height) {
            return this;
        }
        // 增加中间区域尺寸 1
        width = Math.max(width, this.config.left + this.config.right + 1);
        height = Math.max(height, this.config.top + this.config.bottom + 1);
        this.setSize(width, height);
        this.drawPatches();
        return;
    };
    NinePatch.prototype.setTexture = function (key, frame) {
        this.originTexture = this.scene.textures.get(key);
        this.setFrame(frame);
        return this;
    };
    NinePatch.prototype.setFrame = function (frame) {
        this.originFrame = this.originTexture.frames[frame] || this.originTexture.frames[NinePatch.__BASE];
        this.createPatches();
        this.drawPatches();
        return this;
    };
    NinePatch.prototype.setSize = function (width, height) {
        _super.prototype.setSize.call(this, width, height);
        this.finalXs = [0, this.config.left, this.width - this.config.right, this.width];
        this.finalYs = [0, this.config.top, this.height - this.config.bottom, this.height];
        return this;
    };
    NinePatch.prototype.setTint = function (tint) {
        this.tint = tint;
        return this;
    };
    NinePatch.prototype.setTintFill = function (tint) {
        this.tint = tint;
        this.tintFill = true;
        return this;
    };
    Object.defineProperty(NinePatch.prototype, "tintFill", {
        get: function () {
            return this.first && this.first.tintFill;
        },
        set: function (value) {
            this.each(function (patch) { return patch.tintFill = value; });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NinePatch.prototype, "tint", {
        set: function (value) {
            this.each(function (patch) { return patch.setTint(value); });
            this.internalTint = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NinePatch.prototype, "isTinted", {
        get: function () {
            return this.first && this.first.isTinted;
        },
        enumerable: false,
        configurable: true
    });
    NinePatch.prototype.clearTint = function () {
        this.each(function (patch) { return patch.clearTint(); });
    };
    NinePatch.prototype.createPatches = function () {
        // The positions we want from the base texture
        var textureXs = [0, this.config.left, this.originFrame.width - this.config.right, this.originFrame.width];
        var textureYs = [0, this.config.top, this.originFrame.height - this.config.bottom, this.originFrame.height];
        var patchIndex = 0;
        for (var yi = 0; yi < 3; yi++) {
            for (var xi = 0; xi < 3; xi++) {
                this.createPatchFrame(this.getPatchNameByIndex(patchIndex), textureXs[xi], // x
                textureYs[yi], // y
                textureXs[xi + 1] - textureXs[xi], // width
                textureYs[yi + 1] - textureYs[yi] // height
                );
                ++patchIndex;
            }
        }
    };
    // private drawPatches(): void {
    //     const tintFill = this.tintFill;
    //     this.removeAll(true);
    //     let patchIndex = 0;
    //     for (let yi = 0; yi < 3; yi++) {
    //         for (let xi = 0; xi < 3; xi++) {
    //             const patch: Phaser.Textures.Frame = this.originTexture.frames[this.getPatchNameByIndex(patchIndex)];
    //             const patchImg = new Phaser.GameObjects.Image(this.scene, 0, 0, patch.texture.key, patch.name);
    //             patchImg.setOrigin(0);
    //             patchImg.setPosition(this.finalXs[xi] - this.width * this.originX, this.finalYs[yi] - this.height * this.originY);
    //             patchImg.setScale(
    //                 (this.finalXs[xi + 1] - this.finalXs[xi]) / patch.width,
    //                 (this.finalYs[yi + 1] - this.finalYs[yi]) / patch.height
    //             );
    //             this.add(patchImg);
    //             patchImg.setTint(this.internalTint);
    //             patchImg.tintFill = tintFill;
    //             ++patchIndex;
    //         }
    //     }
    // }
    NinePatch.prototype.drawPatches = function () {
        var tintFill = this.tintFill;
        this.removeAll(true);
        var patchIndex = 0;
        // const info = [];
        for (var yi = 0; yi < 3; yi++) {
            for (var xi = 0; xi < 3; xi++) {
                var patch = this.originTexture.frames[this.getPatchNameByIndex(patchIndex)];
                var patchImg = new Phaser.GameObjects.Image(this.scene, 0, 0, patch.texture.key, patch.name);
                patchImg.setOrigin(0);
                patchImg.setPosition((this.finalXs[xi] * 1000 - this.width * this.originX * 1000) / 1000, (this.finalYs[yi] * 1000 - this.height * this.originY * 1000) / 1000);
                // patchImg.setScale(
                //     (this.finalXs[xi + 1] * 1000 - this.finalXs[xi] * 1000) / patch.width / 1000,
                //     (this.finalYs[yi + 1] * 1000 - this.finalYs[yi] * 1000) / patch.height / 1000
                // );
                // 直接设置displayWidth即最终显示宽度
                patchImg.displayWidth = this.finalXs[xi + 1] - this.finalXs[xi];
                patchImg.displayHeight = this.finalYs[yi + 1] - this.finalYs[yi];
                this.add(patchImg);
                patchImg.setTint(this.internalTint);
                patchImg.tintFill = tintFill;
                ++patchIndex;
                // info.push({ x: patchImg.x, y: patchImg.y, w: patchImg.width, h: patchImg.height, s: patchImg.scale, sx: patchImg.scaleX, sy: patchImg.scaleY });
            }
        }
        // Logger.getInstance().log("ZW-- drawPatches: ", info);
        // Logger.getInstance().log("ZW-- lines: " + (info[0].w * info[0].sx + info[0].x) + "; " + (info[1].w * info[1].sx + info[1].x));
    };
    NinePatch.prototype.createPatchFrame = function (patch, x, y, width, height) {
        if (this.originTexture.frames.hasOwnProperty(patch)) {
            return;
        }
        this.originTexture.add(patch, this.originFrame.sourceIndex, this.originFrame.cutX + x, this.originFrame.cutY + y, width, height);
    };
    NinePatch.prototype.getPatchNameByIndex = function (index) {
        return this.originFrame.name + "|" + NinePatch.patches[index];
    };
    NinePatch.__BASE = "__BASE";
    NinePatch.patches = ["[0][0]", "[1][0]", "[2][0]", "[0][1]", "[1][1]", "[2][1]", "[0][2]", "[1][2]", "[2][2]"];
    return NinePatch;
}(Phaser.GameObjects.Container));



/***/ }),
/* 43 */,
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Tool; });
/* harmony import */ var _pos__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);

var Tool = /** @class */ (function () {
    function Tool() {
    }
    /**
     * scene之间坐标转换
     * @param fromScene 当前所在scene
     * @param pos 需要转换去scene上的position
     */
    Tool.getPosByScenes = function (fromScene, pos) {
        var camera = fromScene.cameras.main;
        var px = pos.x - camera.scrollX;
        var py = pos.y - camera.scrollY;
        return new _pos__WEBPACK_IMPORTED_MODULE_0__[/* Pos */ "a"](px, py);
    };
    /*
    * 两点之间距离公式
    */
    Tool.twoPointDistance = function (p1, p2) {
        var dis = Math.sqrt(Math.pow((p1.x - p2.x), 2) + Math.pow((p1.y - p2.y), 2));
        return dis;
    };
    /**
     * 两点之间弧度
     * @param baseP
     * @param moveP
     */
    Tool.twoPointRadin = function (baseP, moveP) {
        var x = baseP.x - moveP.x;
        var y = baseP.y - moveP.y;
        var dis = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
        var rad = Math.acos(x / dis);
        // 注意：当触屏的位置Y坐标<摇杆的Y坐标，我们要去反值-0~-180
        if (moveP.y < baseP.y) {
            rad = -rad;
        }
        return rad;
    };
    Tool.formatChineseString = function (context, fontSize, lineWidth) {
        if (typeof fontSize === "string")
            fontSize = parseInt(fontSize, 10);
        var wrapWidth = Math.floor(lineWidth / fontSize);
        return this.chunk(context, wrapWidth).join(" ");
    };
    Tool.checkChinese = function (name) {
        var pattern = /[\u4e00-\u9fa5]+/;
        var arr = name.split("");
        for (var i = 0, len = arr.length; i < len; i++) {
            if (pattern.test(arr[i])) {
                return true;
            }
        }
        return false;
    };
    Tool.checkItemName = function (name, checkStr) {
        var checkStrList = checkStr.split("") || [];
        var checkBoo = false;
        checkStrList.forEach(function (str) {
            if (str) {
                var pattern = new RegExp(str);
                var arr = name.split("");
                for (var i = 0, len = arr.length; i < len; i++) {
                    if (pattern.test(arr[i])) {
                        checkBoo = true;
                        break;
                    }
                }
            }
        });
        return checkBoo;
    };
    Tool.checkPointerContains = function (gameObject, pointer) {
        if (!gameObject)
            return false;
        var left = -gameObject.width / 2;
        var right = gameObject.width / 2;
        var top = -gameObject.height / 2;
        var bottom = gameObject.height / 2;
        if (pointer) {
            var worldMatrix = gameObject.getWorldTransformMatrix();
            var x = pointer.x - worldMatrix.tx - gameObject.x;
            var y = pointer.y - worldMatrix.ty - gameObject.y;
            if (left <= x && right >= x && top <= y && bottom >= y) {
                return true;
            }
            return false;
        }
        return false;
    };
    Tool.baseName = function (str) {
        var base = new String(str).substring(str.lastIndexOf("/") + 1);
        if (base.lastIndexOf(".") !== -1)
            base = base.substring(0, base.lastIndexOf("."));
        return base;
    };
    Tool.chunk = function (str, n) {
        var result = [];
        for (var i = 0; i < str.length; i += n) {
            result.push(str.substr(i, n));
        }
        return result;
    };
    return Tool;
}());



/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BlockObject; });
/* harmony import */ var _element_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11);
/* harmony import */ var _utils_pos__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);


var BlockObject = /** @class */ (function () {
    function BlockObject(mRoomService) {
        this.mRoomService = mRoomService;
        this.isUsed = false;
        this.mRenderable = false;
        this.mBlockable = true;
        this.mInputEnable = _element_element__WEBPACK_IMPORTED_MODULE_0__[/* InputEnable */ "c"].Diasble;
        this.isUsed = true;
    }
    BlockObject.prototype.setRenderable = function (isRenderable, delay) {
        var _this = this;
        if (delay === void 0) { delay = 0; }
        if (this.mRenderable !== isRenderable) {
            this.mRenderable = isRenderable;
            if (isRenderable) {
                this.addDisplay();
                if (delay > 0) {
                    this.fadeIn();
                }
                return;
            }
            else {
                if (delay > 0) {
                    this.fadeOut(function () {
                        _this.removeDisplay();
                    });
                }
                else {
                    this.removeDisplay();
                }
            }
        }
    };
    BlockObject.prototype.getPosition = function () {
        var pos;
        if (this.mDisplay) {
            pos = new _utils_pos__WEBPACK_IMPORTED_MODULE_1__[/* Pos */ "a"](this.mDisplay.x, this.mDisplay.y, this.mDisplay.z);
        }
        else {
            pos = new _utils_pos__WEBPACK_IMPORTED_MODULE_1__[/* Pos */ "a"]();
        }
        return pos;
    };
    BlockObject.prototype.getPosition45 = function () {
        var pos = this.getPosition();
        if (!pos)
            return new _utils_pos__WEBPACK_IMPORTED_MODULE_1__[/* Pos */ "a"]();
        return this.mRoomService.transformTo45(pos);
    };
    BlockObject.prototype.getRenderable = function () {
        return this.mRenderable;
    };
    BlockObject.prototype.fadeIn = function (callback) {
        if (!this.mDisplay)
            return;
        this.mDisplay.fadeIn(callback);
    };
    BlockObject.prototype.fadeOut = function (callback) {
        if (!this.mDisplay)
            return;
        this.mDisplay.fadeOut(callback);
    };
    BlockObject.prototype.fadeAlpha = function (alpha) {
        if (!this.mDisplay)
            return;
        // this.mDisplay.alpha = alpha;
    };
    BlockObject.prototype.setInputEnable = function (val) {
        // if (this.mInputEnable !== val) {
        this.mInputEnable = val;
        if (this.mDisplay) {
            switch (val) {
                case _element_element__WEBPACK_IMPORTED_MODULE_0__[/* InputEnable */ "c"].Interactive:
                    if (this.mModel && this.mModel.hasInteractive) {
                        this.mDisplay.setInteractive();
                    }
                    break;
                case _element_element__WEBPACK_IMPORTED_MODULE_0__[/* InputEnable */ "c"].Enable:
                    this.mDisplay.setInteractive();
                    break;
                default:
                    this.mDisplay.disableInteractive();
                    break;
            }
        }
        // }
    };
    BlockObject.prototype.setBlockable = function (val) {
        if (this.mBlockable !== val) {
            this.mBlockable = val;
            if (this.mDisplay && this.mRoomService) {
                if (val) {
                    this.mRoomService.addBlockObject(this);
                }
                else {
                    this.mRoomService.removeBlockObject(this);
                }
            }
        }
        return this;
    };
    BlockObject.prototype.destroy = function () {
        if (this.mDisplay) {
            this.mDisplay.destroy();
            this.mDisplay = null;
        }
    };
    BlockObject.prototype.clear = function () {
        this.isUsed = false;
    };
    BlockObject.prototype.addDisplay = function () { };
    BlockObject.prototype.removeDisplay = function () {
        if (!this.mDisplay) {
            return;
        }
        this.mDisplay.removeFromParent();
    };
    BlockObject.prototype.addToBlock = function () {
        if (this.mBlockable) {
            this.mRoomService.addBlockObject(this);
        }
        else {
            this.addDisplay();
        }
    };
    BlockObject.prototype.updateBlock = function () {
        if (this.mBlockable) {
            this.mRoomService.updateBlockObject(this);
        }
    };
    Object.defineProperty(BlockObject.prototype, "id", {
        get: function () {
            return -1;
        },
        enumerable: false,
        configurable: true
    });
    return BlockObject;
}());



/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var IsArray = function(obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
}
/* harmony default export */ __webpack_exports__["a"] = (IsArray);

/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var chance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48);
/* harmony import */ var chance__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(chance__WEBPACK_IMPORTED_MODULE_0__);
var __spreadArrays = (undefined && undefined.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

var Helpers = /** @class */ (function () {
    function Helpers() {
    }
    Helpers.genId = function () {
        return new chance__WEBPACK_IMPORTED_MODULE_0__().natural({
            min: 10000,
            max: Helpers.MAX_ID
        });
    };
    Helpers.flipArray = function (source) {
        if (!source)
            return;
        var array = __spreadArrays(source);
        var result = [];
        if (array.length > 0) {
            var len = array[0].length;
            for (var i = 0; i < len; i++) {
                result[i] = [];
                for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
                    var j = array_1[_i];
                    result[i].push(j[i]);
                }
            }
        }
        return result;
    };
    Helpers.MAX_ID = Math.pow(2, 31);
    return Helpers;
}());
/* harmony default export */ __webpack_exports__["a"] = (Helpers);


/***/ }),
/* 48 */,
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Animation; });
/* harmony import */ var pixelpai_proto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var pixelpai_proto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pixelpai_proto__WEBPACK_IMPORTED_MODULE_0__);

var Animation = /** @class */ (function () {
    function Animation(ani) {
        var tmpBaseLoc = null;
        if (typeof ani.baseLoc === "string") {
            tmpBaseLoc = ani.baseLoc.split(",");
        }
        else {
            tmpBaseLoc = [ani.baseLoc.x, ani.baseLoc.y];
        }
        this.mID = ani.id;
        this.mBaseLoc = tmpBaseLoc;
        this.mName = ani.name;
        this.mFrameName = ani.frameName;
        if (!ani.frameName || this.mFrameName.length < 1) {
            // Logger.getInstance().fatal(`Animation: ${ani.id} frames is invalid`);
        }
        this.mLoop = ani.loop;
        if (!ani.loop) {
            // Logger.getInstance().fatal(`Animation: ${ani.id} loop is invalid`);
        }
        if (!ani.frameRate) {
            // Logger.getInstance().fatal(`Animation: ${ani.id} frameRate is invalid`);
        }
        if (ani.originPoint) {
            // Logger.getInstance().fatal(`Animation: ${ani.id} originPoint is invalid`);
        }
        if (!ani.baseLoc) {
            // Logger.getInstance().fatal(`Animation: ${ani.id} baseLoc is invalid`);
        }
        this.mFrameRate = ani.frameRate;
        this.mBaseLoc = new Phaser.Geom.Point(parseInt(tmpBaseLoc[0], 10), parseInt(tmpBaseLoc[1], 10));
        var origin = ani.originPoint;
        if (Array.isArray(origin)) {
            this.mOriginPoint = new Phaser.Geom.Point(origin[0], origin[1]);
        }
        else {
            this.mOriginPoint = new Phaser.Geom.Point(origin.x, origin.y);
        }
        if (typeof ani.collisionArea === "string") {
            this.mCollisionArea = this.stringToArray(ani.collisionArea, ",", "&") || [[0]];
        }
        else {
            this.mCollisionArea = ani.collisionArea || [[0]];
        }
        if (typeof ani.walkableArea === "string") {
            this.mWalkableArea = this.stringToArray(ani.walkableArea, ",", "&") || [[0]];
        }
        else {
            this.mWalkableArea = ani.walkableArea || [[0]];
        }
        // this.mInteractiveArea = [{x: 0, y: 0}];
        this.mInteractiveArea = ani.interactiveArea;
    }
    Animation.prototype.toClient = function () {
        var ani = pixelpai_proto__WEBPACK_IMPORTED_MODULE_0__["op_gameconfig"].Animation.create();
        ani.id = this.id;
        ani.baseLoc = this.baseLoc.x + "," + this.baseLoc.y;
        ani.name = this.name;
        ani.loop = this.loop;
        ani.frameRate = this.frameRate;
        ani.frameName = this.frameName;
        ani.originPoint = [this.originPoint.x, this.originPoint.y];
        ani.walkOriginPoint = [this.originPoint.x, this.originPoint.y];
        ani.walkableArea = this.arrayToString(this.mWalkableArea, ",", "&");
        ani.collisionArea = this.arrayToString(this.mCollisionArea, ",", "&");
        ani.interactiveArea = this.mInteractiveArea;
        return ani;
    };
    Animation.prototype.stringToArray = function (string, fristJoin, lastJoin) {
        if (!string) {
            return;
        }
        var tmp = string.split(lastJoin);
        var result = [];
        for (var _i = 0, tmp_1 = tmp; _i < tmp_1.length; _i++) {
            var ary = tmp_1[_i];
            var tmpAry = ary.split(fristJoin);
            result.push(tmpAry.map(function (value) { return parseInt(value, 10); }));
        }
        return result;
    };
    Animation.prototype.arrayToString = function (array, fristJoin, lastJoin) {
        if (!array)
            return "";
        var tmp = [];
        for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
            var ary = array_1[_i];
            tmp.push(ary.join(fristJoin));
        }
        return tmp.join(lastJoin);
    };
    Object.defineProperty(Animation.prototype, "baseLoc", {
        get: function () {
            return this.mBaseLoc;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animation.prototype, "id", {
        get: function () {
            return this.mID;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animation.prototype, "frameName", {
        get: function () {
            return this.mFrameName;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animation.prototype, "frameRate", {
        get: function () {
            return this.mFrameRate;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animation.prototype, "loop", {
        get: function () {
            return this.mLoop;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animation.prototype, "name", {
        get: function () {
            return this.mName;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animation.prototype, "collisionArea", {
        get: function () {
            return this.mCollisionArea;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animation.prototype, "walkableArea", {
        get: function () {
            return this.mWalkableArea;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animation.prototype, "originPoint", {
        get: function () {
            return this.mOriginPoint;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Animation.prototype, "interactiveArea", {
        get: function () {
            return this.mInteractiveArea;
        },
        enumerable: false,
        configurable: true
    });
    return Animation;
}());



/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TerrainManager; });
/* harmony import */ var net_socket_packet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var net_socket_packet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(net_socket_packet__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var pixelpai_proto__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _terrain__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(79);
/* harmony import */ var _element_sprite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var NodeType = pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__["op_def"].NodeType;
var TerrainManager = /** @class */ (function (_super) {
    __extends(TerrainManager, _super);
    function TerrainManager(mRoom, listener) {
        var _this = _super.call(this) || this;
        _this.mRoom = mRoom;
        _this.hasAddComplete = false;
        _this.mTerrains = new Map();
        // add by 7 ----
        _this.mPacketFrameCount = 0;
        _this.mListener = listener;
        if (_this.connection) {
            _this.connection.addPacketListener(_this);
            _this.addHandlerFun(pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_ADD_SPRITE, _this.onAdd);
            _this.addHandlerFun(pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_ADD_SPRITE_END, _this.addComplete);
            _this.addHandlerFun(pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_DELETE_SPRITE, _this.onRemove);
            _this.addHandlerFun(pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_SYNC_SPRITE, _this.onSyncSprite);
            _this.addHandlerFun(pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_CHANGE_SPRITE_ANIMATION, _this.onChangeAnimation);
        }
        if (_this.mRoom && _this.mRoom.world) {
            _this.mGameConfig = _this.mRoom.world.elementStorage;
        }
        var miniSize = _this.roomService.miniSize;
        _this.mMap = new Array(miniSize.cols);
        for (var i = 0; i < miniSize.rows; i++) {
            _this.mMap[i] = new Array(miniSize.rows).fill(0);
        }
        return _this;
    }
    TerrainManager.prototype.init = function () {
        // this.destroy();
    };
    TerrainManager.prototype.destroy = function () {
        var _this = this;
        if (this.connection) {
            this.connection.removePacketListener(this);
        }
        if (!this.mTerrains)
            return;
        this.mTerrains.forEach(function (terrain) { return _this.remove(terrain.id); });
        this.mTerrains.clear();
    };
    TerrainManager.prototype.get = function (id) {
        var terrain = this.mTerrains.get(id);
        if (!terrain) {
            return;
        }
        return terrain;
    };
    TerrainManager.prototype.add = function (sprites) {
        for (var _i = 0, sprites_1 = sprites; _i < sprites_1.length; _i++) {
            var sprite = sprites_1[_i];
            this._add(sprite);
        }
    };
    TerrainManager.prototype.remove = function (id) {
        if (!this.mTerrains)
            return;
        var terrain = this.mTerrains.get(id);
        if (terrain) {
            this.mTerrains.delete(id);
            terrain.destroy();
        }
        return terrain;
    };
    TerrainManager.prototype.getElements = function () {
        return Array.from(this.mTerrains.values());
    };
    TerrainManager.prototype.onAdd = function (packet) {
        this.mPacketFrameCount++;
        if (!this.mGameConfig) {
            return;
        }
        var content = packet.content;
        var sprites = content.sprites;
        var type = content.nodeType;
        var pf = content.packet;
        if (type !== pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__["op_def"].NodeType.TerrainNodeType) {
            return;
        }
        var point;
        var ids = [];
        // sprites 服务端
        for (var _i = 0, sprites_2 = sprites; _i < sprites_2.length; _i++) {
            var sprite = sprites_2[_i];
            point = sprite.point3f;
            if (point) {
                var s = new _element_sprite__WEBPACK_IMPORTED_MODULE_3__[/* Sprite */ "a"](sprite, type);
                if (!s.displayInfo) {
                    this.checkTerrainDisplay(s);
                }
                if (!s.displayInfo) {
                    ids.push(s.id);
                }
                this._add(s);
            }
        }
        this.fetchDisplay(ids);
        if (this.mListener && this.mPacketFrameCount === pf.totalFrame) {
            this.mListener.onFullPacketReceived(type);
        }
    };
    TerrainManager.prototype._add = function (sprite) {
        var terrain = this.mTerrains.get(sprite.id);
        if (!terrain) {
            terrain = new _terrain__WEBPACK_IMPORTED_MODULE_2__[/* Terrain */ "a"](sprite, this);
        }
        else {
            terrain.model = sprite;
        }
        // this.addMap(sprite);
        this.mTerrains.set(terrain.id || 0, terrain);
        return terrain;
    };
    TerrainManager.prototype.addComplete = function (packet) {
        this.hasAddComplete = true;
    };
    TerrainManager.prototype.onRemove = function (packet) {
        var content = packet.content;
        var type = content.nodeType;
        var ids = content.ids;
        if (type !== pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__["op_def"].NodeType.TerrainNodeType) {
            return;
        }
        for (var _i = 0, ids_1 = ids; _i < ids_1.length; _i++) {
            var id = ids_1[_i];
            this.remove(id);
        }
        // Logger.getInstance().log("remove terrain length: ", ids.length);
    };
    TerrainManager.prototype.onSyncSprite = function (packet) {
        var content = packet.content;
        if (content.nodeType !== pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__["op_def"].NodeType.TerrainNodeType) {
            return;
        }
        var terrain = null;
        var sprites = content.sprites;
        for (var _i = 0, sprites_3 = sprites; _i < sprites_3.length; _i++) {
            var sprite = sprites_3[_i];
            terrain = this.get(sprite.id);
            if (terrain) {
                var sp = new _element_sprite__WEBPACK_IMPORTED_MODULE_3__[/* Sprite */ "a"](sprite, content.nodeType);
                terrain.model = sp;
                // this.addMap(sp);
                // terrain.setRenderable(true);
            }
        }
    };
    TerrainManager.prototype.checkDisplay = function (sprite) {
        if (!sprite.displayInfo) {
            var displayInfo = this.roomService.world.elementStorage.getDisplayModel(sprite.bindID || sprite.id);
            if (displayInfo) {
                sprite.displayInfo = displayInfo;
                return displayInfo;
            }
        }
    };
    TerrainManager.prototype.checkTerrainDisplay = function (sprite) {
        if (!sprite.displayInfo) {
            var palette = this.roomService.world.elementStorage.getTerrainPaletteByBindId(sprite.bindID);
            if (palette) {
                sprite.displayInfo = palette;
            }
        }
    };
    TerrainManager.prototype.fetchDisplay = function (ids) {
        if (ids.length === 0) {
            return;
        }
        var packet = new net_socket_packet__WEBPACK_IMPORTED_MODULE_0__["PBpacket"](pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__["op_virtual_world"].OPCODE._OP_REQ_VIRTUAL_WORLD_QUERY_SPRITE_RESOURCE);
        var content = packet.content;
        content.ids = ids;
        this.connection.send(packet);
    };
    TerrainManager.prototype.removeMap = function (sprite) {
        this.setMap(sprite, 1);
    };
    TerrainManager.prototype.addMap = function (sprite) {
        this.setMap(sprite, 0);
    };
    TerrainManager.prototype.setMap = function (sprite, type) {
        var displayInfo = sprite.displayInfo;
        if (!displayInfo) {
            return;
        }
        var curAni = sprite.currentAnimation;
        var aniName = curAni.animationName;
        var flip = false;
        var collisionArea = displayInfo.getCollisionArea(aniName, flip);
        var walkArea = displayInfo.getWalkableArea(aniName, flip);
        var origin = displayInfo.getOriginPoint(aniName, flip);
        var rows = collisionArea.length;
        var cols = collisionArea[0].length;
        var hasCollisionArea = true;
        if (rows === 1 && cols === 1) {
            rows = 2;
            cols = 2;
            hasCollisionArea = false;
        }
        var pos = sprite.pos;
        for (var i = 0; i < rows; i++) {
            for (var j = 0; j < cols; j++) {
                // if ((!hasCollisionArea) || collisionArea[i][j] === 1 && walkArea[i][j] === 1) {
                // this.mMap[pos.x + i - origin.x][pos.y + j - origin.y] = type;
                // }
            }
        }
    };
    TerrainManager.prototype.onChangeAnimation = function (packet) {
        var content = packet.content;
        if (content.nodeType !== NodeType.TerrainNodeType) {
            return;
        }
        var anis = content.changeAnimation;
        var ids = content.ids;
        var terrain = null;
        for (var _i = 0, ids_2 = ids; _i < ids_2.length; _i++) {
            var id = ids_2[_i];
            terrain = this.get(id);
            if (terrain) {
                // terrain.play(ani.animationName);
            }
        }
    };
    Object.defineProperty(TerrainManager.prototype, "connection", {
        get: function () {
            if (this.mRoom) {
                return this.mRoom.connection;
            }
            // Logger.getInstance().error("room manager is undefined");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TerrainManager.prototype, "roomService", {
        get: function () {
            return this.mRoom;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TerrainManager.prototype, "scene", {
        get: function () {
            if (this.mRoom) {
                return this.mRoom.scene;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TerrainManager.prototype, "camera", {
        get: function () {
            return this.camera;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TerrainManager.prototype, "map", {
        get: function () {
            return this.mMap;
        },
        enumerable: false,
        configurable: true
    });
    return TerrainManager;
}(net_socket_packet__WEBPACK_IMPORTED_MODULE_0__["PacketHandler"]));



/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TerrainDisplay; });
/* harmony import */ var _frames_display__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(34);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var TerrainDisplay = /** @class */ (function (_super) {
    __extends(TerrainDisplay, _super);
    function TerrainDisplay() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // public fadeIn(callback?: () => void) {
    //     // this.y += 50;
    //     this.alpha = 0;
    //     if (this.mFadeTween) {
    //         this.mFadeTween.stop();
    //         this.mFadeTween.remove();
    //     }
    //     this.mFadeTween = this.scene.tweens.add({
    //         targets: this,
    //         alpha: 1,
    //         // y: this.y + 50,
    //         duration: 1200,
    //         onComplete: () => {
    //             if (callback) callback();
    //         }
    //     });
    // }
    //
    // public fadeOut(callback?: () => void) {
    //     if (this.mFadeTween) {
    //         this.mFadeTween.stop();
    //         this.mFadeTween.remove();
    //     }
    //     this.mFadeTween = this.scene.tweens.add({
    //         targets: this,
    //         alpha: 0,
    //         // y: this.y + 50,
    //         duration: 1200,
    //         onComplete: () => {
    //             if (callback) callback();
    //         }
    //     });
    // }
    TerrainDisplay.prototype.showRefernceArea = function () {
    };
    return TerrainDisplay;
}(_frames_display__WEBPACK_IMPORTED_MODULE_0__[/* FramesDisplay */ "a"]));



/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Handler; });
var Handler = /** @class */ (function () {
    /**
     * 根据指定的属性值，创建一个 <code>Handler</code> 类的实例。
     * @param	caller 执行域。
     * @param	method 处理函数。
     * @param	args 函数参数。
     * @param	once 是否只执行一次。
     */
    function Handler(caller, method, args, once) {
        if (caller === void 0) { caller = null; }
        if (method === void 0) { method = null; }
        if (args === void 0) { args = null; }
        if (once === void 0) { once = false; }
        this.once = false;
        this._id = 0;
        this.setTo(caller, method, args, once);
    }
    /**
     * 从对象池内创建一个Handler，默认会执行一次并立即回收，如果不需要自动回收，设置once参数为false。
     * @param	caller 执行域(this)。
     * @param	method 回调方法。
     * @param	args 携带的参数。
     * @param	once 是否只执行一次，如果为true，回调后执行recover()进行回收，默认为true。
     * @return  返回创建的handler实例。
     */
    Handler.create = function (caller, method, args, once) {
        if (args === void 0) { args = null; }
        if (once === void 0) { once = true; }
        if (Handler._pool.length)
            return Handler._pool.pop().setTo(caller, method, args, once);
        return new Handler(caller, method, args, once);
    };
    /**
     * 设置此对象的指定属性值。
     * @param	caller 执行域(this)。
     * @param	method 回调方法。
     * @param	args 携带的参数。
     * @param	once 是否只执行一次，如果为true，执行后执行recover()进行回收。
     * @return  返回 handler 本身。
     */
    Handler.prototype.setTo = function (caller, method, args, once) {
        this._id = Handler._gid++;
        this.caller = caller;
        this.method = method;
        this.args = args;
        this.once = once;
        return this;
    };
    /**
     * 执行处理器。
     */
    Handler.prototype.run = function () {
        if (this.method == null)
            return null;
        var id = this._id;
        var result = this.method.apply(this.caller, this.args);
        // tslint:disable-next-line: no-unused-expression
        this._id === id && this.once && this.recover();
        return result;
    };
    /**
     * 执行处理器，携带额外数据。
     * @param	data 附加的回调数据，可以是单数据或者Array(作为多参)。
     */
    Handler.prototype.runWith = function (data) {
        if (this.method == null)
            return null;
        var id = this._id;
        if (data == null)
            // tslint:disable-next-line: no-var-keyword
            var result = this.method.apply(this.caller, this.args);
        else if (!this.args && !(data instanceof Array))
            result = this.method.call(this.caller, data);
        // tslint:disable-next-line: comment-format
        else if (this.args)
            result = this.method.apply(this.caller, this.args.concat(data));
        else
            result = this.method.apply(this.caller, data);
        // tslint:disable-next-line: no-unused-expression
        this._id === id && this.once && this.recover();
        return result;
    };
    /**
     * 清理对象引用。
     */
    Handler.prototype.clear = function () {
        this.caller = null;
        this.method = null;
        this.args = null;
        return this;
    };
    /**
     * 清理并回收到 Handler 对象池内。
     */
    Handler.prototype.recover = function () {
        if (this._id > 0) {
            this._id = 0;
            Handler._pool.push(this.clear());
        }
    };
    /*[DISABLE-ADD-VARIABLE-DEFAULT-VALUE]*/
    Handler._pool = [];
    Handler._gid = 1;
    return Handler;
}());



/***/ }),
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return NinePatchButton; });
/* harmony import */ var _nine_patch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(42);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var NinePatchButton = /** @class */ (function (_super) {
    __extends(NinePatchButton, _super);
    function NinePatchButton(scene, x, y, width, height, key, frame, text, config, data) {
        var _this = _super.call(this, scene, x, y) || this;
        _this.mScene = scene;
        _this.mKey = key;
        _this.mFrame = frame ? frame : "__BASE";
        _this.initFrame();
        _this.setSize(width, height);
        _this.mNingBg = new _nine_patch__WEBPACK_IMPORTED_MODULE_0__[/* NinePatch */ "a"](_this.scene, 0, 0, width, height, key, _this.mFrame_nrmal, config);
        _this.add(_this.mNingBg);
        if (data) {
            _this.btnData = data;
        }
        _this.mLabel = _this.scene.make.text(undefined, false)
            .setOrigin(0.5, 0.5)
            .setSize(_this.width, _this.height)
            .setAlign("center")
            .setText(text);
        _this.add(_this.mLabel);
        // this.setSize(this.mNingBg.width, this.mNingBg.height);
        _this.setInteractive(new Phaser.Geom.Rectangle(0, 0, width, height), Phaser.Geom.Rectangle.Contains);
        _this.on("pointerdown", _this.onPointerDown, _this);
        _this.on("pointerup", _this.onPointerUp, _this);
        return _this;
        // this.on("pointerout", this.changeNormal, this);
        // this.on("pointerover", this.changeOver, this);
    }
    Object.defineProperty(NinePatchButton.prototype, "enable", {
        set: function (value) {
            if (value) {
                this.mNingBg.clearTint();
                this.setInteractive();
            }
            else {
                this.mNingBg.setTintFill(0x666666);
                this.removeInteractive();
            }
        },
        enumerable: false,
        configurable: true
    });
    NinePatchButton.prototype.getBtnData = function () {
        return this.btnData;
    };
    NinePatchButton.prototype.setText = function (text) {
        this.mLabel.setText(text);
    };
    NinePatchButton.prototype.getText = function () {
        return this.mLabel.text;
    };
    NinePatchButton.prototype.setTextStyle = function (style) {
        this.mLabel.setStyle(style);
    };
    NinePatchButton.prototype.setFontStyle = function (val) {
        this.mLabel.setFontStyle(val);
    };
    NinePatchButton.prototype.setTextOffset = function (x, y) {
        this.mLabel.setPosition(x, y);
    };
    NinePatchButton.prototype.setFrame = function (frame) {
        this.mNingBg.setFrame(frame);
        return this;
    };
    NinePatchButton.prototype.destroy = function (fromScene) {
        if (this.mLabel)
            this.mLabel.destroy();
        _super.prototype.destroy.call(this, fromScene);
    };
    NinePatchButton.prototype.setFrameNormal = function (normal, down, over) {
        this.mFrame_nrmal = normal;
        this.mFrame_down = (down ? down : normal);
        this.mFrame_over = (over ? over : normal);
        this.changeNormal();
        return this;
    };
    // public setState(val: string) {
    // }
    NinePatchButton.prototype.changeNormal = function () {
        this.setFrame(this.mFrame_nrmal);
    };
    NinePatchButton.prototype.changeDown = function () {
        // this.scale = 0.9;
        this.setFrame(this.mFrame_down);
    };
    NinePatchButton.prototype.changeOver = function () {
        // this.setTexture()
        this.setFrame(this.mFrame_over);
    };
    NinePatchButton.prototype.isExists = function (frame) {
        var originTexture = this.scene.textures.get(this.mKey);
        if (originTexture && originTexture.has(frame))
            return true;
        return false;
    };
    NinePatchButton.prototype.onPointerDown = function (pointer) {
        this.changeDown();
    };
    NinePatchButton.prototype.onPointerUp = function (pointer) {
        this.changeNormal();
        this.emit("click", pointer, this);
    };
    Object.defineProperty(NinePatchButton.prototype, "label", {
        get: function () {
            return this.mLabel;
        },
        enumerable: false,
        configurable: true
    });
    NinePatchButton.prototype.scaleHandler = function () {
        this.mScene.tweens.add({
            targets: this,
            duration: 50,
            ease: "Linear",
            props: {
                scaleX: { value: .5 },
                scaleY: { value: .5 },
            },
            yoyo: true,
            repeat: 0,
        });
        this.scaleX = this.scaleY = 1;
    };
    NinePatchButton.prototype.initFrame = function () {
        var frame = this.mFrame ? this.mFrame : this.mKey;
        this.mFrame_nrmal = frame + "_normal";
        var down = frame + "_down";
        if (!this.isExists(down)) {
            down = frame + "_normal";
        }
        this.mFrame_down = down;
        var over = frame + "_over";
        if (!this.isExists(over)) {
            over = frame + "_normal";
        }
        this.mFrame_over = over;
    };
    return NinePatchButton;
}(Phaser.GameObjects.Container));



/***/ }),
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ tool["a" /* Tool */]; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ position45["a" /* Position45 */]; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ log["a" /* Logger */]; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* reexport */ load; });

// UNUSED EXPORTS: Pos, log, error, Size

// EXTERNAL MODULE: ./src/utils/pos.ts
var pos = __webpack_require__(6);

// EXTERNAL MODULE: ./src/utils/tool.ts
var tool = __webpack_require__(44);

// EXTERNAL MODULE: ./src/utils/position45.ts
var position45 = __webpack_require__(17);

// EXTERNAL MODULE: ./src/utils/log.ts
var log = __webpack_require__(5);

// EXTERNAL MODULE: ./src/utils/size.ts
var size = __webpack_require__(25);

// CONCATENATED MODULE: ./src/utils/http.ts
function load(path, responseType) {
    return new Promise(function (resolve, reject) {
        var http = new XMLHttpRequest();
        http.onload = function (response) {
            resolve(response.currentTarget);
        };
        http.onerror = function () {
            // Logger.getInstance().warn(`${path} load error`);
            reject(path + " load error");
        };
        http.open("GET", path);
        http.responseType = responseType || "";
        http.send();
    });
}
function checkIsFriend(uids) {
    var data = {
        body: JSON.stringify({ uids: uids }),
        method: "POST",
        headers: {
            "X-Pixelpai-TK": ""
        }
    };
    return fetch("http://172.18.0.100:17170/" + "/user/check_followed", data);
}
function get(input, init) {
    return fetch(input, init);
}

// CONCATENATED MODULE: ./src/utils/index.ts








/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ clock_Clock; });

// EXTERNAL MODULE: ./node_modules/net-socket-packet/dist/index.js
var dist = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/pixelpai_proto/protocols.js
var protocols = __webpack_require__(2);

// CONCATENATED MODULE: ./src/utils/algorithm.ts
var Algorithm = /** @class */ (function () {
    function Algorithm() {
    }
    Algorithm.median = function (arr) {
        var op_arr = arr.sort(function (x, y) {
            return y - x;
        });
        var med = Math.floor(op_arr.length / 2);
        if (op_arr.length % 2 === 0) {
            var h = op_arr[med - 1], l = op_arr[med];
            return (h + l) / 2;
        }
        return op_arr[med];
    };
    return Algorithm;
}());


// CONCATENATED MODULE: ./src/rooms/clock.ts
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var LATENCY_SAMPLES = 7; // Latency Array length
var MIN_READY_SAMPLES = 2;
var CHECK_INTERVAL = 8000; // (ms)
var MAX_DELAY = 500; // (ms)
var clock_Clock = /** @class */ (function (_super) {
    __extends(Clock, _super);
    function Clock(conn, listener) {
        var _this = _super.call(this) || this;
        // clock是否同步完成
        _this.mClockSync = false;
        _this.mAutoSync = false;
        _this.mTimestamp = 0; // The timestamp in JavaScript is expressed in milliseconds.
        _this.mLatency = [];
        _this.mConn = conn;
        _this.mConn.addPacketListener(_this);
        _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_RES_CLIENT_SYNC_TIME, _this.proof);
        _this.mListener = listener;
        _this._check();
        return _this;
    }
    Object.defineProperty(Clock.prototype, "sysUnixTime", {
        get: function () {
            return new Date().getTime();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Clock.prototype, "unixTime", {
        get: function () {
            return this.mTimestamp;
        },
        set: function (t) {
            this.mTimestamp = t;
        },
        enumerable: false,
        configurable: true
    });
    Clock.prototype.sync = function (times) {
        if (times === void 0) { times = 1; }
        if (!this.mConn)
            return;
        if (times < 0) {
            times = 1;
        }
        for (var i = 0; i < times; ++i) {
            var pkt = new dist["PBpacket"](protocols["op_virtual_world"].OPCODE._OP_CLIENT_REQ_VIRTUAL_WORLD_SYNC_TIME);
            var ct = pkt.content;
            ct.clientStartTs = this.sysUnixTime;
            this.mConn.send(pkt);
        }
    };
    Clock.prototype.update = function (time, delta) {
        if (!this.mTimestamp)
            this.mTimestamp = time;
        else
            this.mTimestamp += delta;
    };
    Clock.prototype.clearTime = function () {
        this.mClockSync = false;
        if (this.mIntervalId) {
            clearInterval(this.mIntervalId);
        }
        this.mTimestamp = 0;
        this._check();
    };
    Clock.prototype.destroy = function () {
        if (this.mConn) {
            this.mConn.removePacketListener(this);
            this.mConn = undefined;
        }
        if (this.mIntervalId) {
            clearInterval(this.mIntervalId);
        }
        this.mLatency = undefined;
    };
    Object.defineProperty(Clock.prototype, "clockSync", {
        get: function () {
            return this.mClockSync;
        },
        enumerable: false,
        configurable: true
    });
    Clock.prototype._check = function () {
        var self = this;
        this.mIntervalId = setInterval(function () {
            self.sync();
        }, CHECK_INTERVAL);
    };
    Clock.prototype.proof = function (packet) {
        var ct = packet.content;
        var local_receive = this.sysUnixTime, local_send = ct.clientStartTs, remote_receive = ct.serverReceiveTs, remote_send = ct.serverSendTs, server_run = remote_send - remote_receive, total_delay = (local_receive - local_send) - server_run, latency = Math.round(total_delay / 2);
        var timeSychronDelta = 0;
        if (latency < 0)
            return;
        this.mLatency.push(latency);
        if (this.mLatency.length > LATENCY_SAMPLES) {
            this.mLatency.shift();
        }
        var median_latency = Algorithm.median(this.mLatency);
        timeSychronDelta = median_latency + server_run;
        var remote_time = remote_send - timeSychronDelta; // the real remote-time.
        var mistake = Math.abs(remote_time - this.mTimestamp);
        // update timesychron
        if (mistake > MAX_DELAY) {
            this.mTimestamp = remote_time;
            this.mAutoSync = true;
            // Logger.getInstance().debug("正在同步clock");
            // if (this.mAutoSync) {
            this.sync(-1);
            return;
            //  }
        }
        this.mAutoSync = false;
        if (this.mListener && this.mLatency.length >= MIN_READY_SAMPLES && !this.mAutoSync) {
            this.mClockSync = true;
            // Logger.getInstance().debug("clock同步完成");
            this.mListener.onClockReady();
        }
        // Logger.getInstance().debug(`total_delay: ${total_delay} / latency: ${latency} | timeSychronDelta: ${timeSychronDelta} / remote_time: ${remote_time} / mistake: ${mistake}`);
    };
    Object.defineProperty(Clock.prototype, "medianLatency", {
        get: function () {
            return Algorithm.median(this.mLatency);
        },
        enumerable: false,
        configurable: true
    });
    return Clock;
}(dist["PacketHandler"]));



/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ layer_manager_LayerManager; });

// EXTERNAL MODULE: ./src/utils/pos.ts
var pos = __webpack_require__(6);

// CONCATENATED MODULE: ./src/rooms/layer/grid.layer.ts
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var grid_layer_GridLayer = /** @class */ (function (_super) {
    __extends(GridLayer, _super);
    function GridLayer(scene) {
        return _super.call(this, scene) || this;
    }
    GridLayer.prototype.draw = function (room) {
        this.clear();
        if (!room || !room.roomSize)
            return;
        this.lineStyle(1, 0xFFFFFF);
        var rows = room.roomSize.rows;
        var cols = room.roomSize.cols;
        for (var i = 0; i <= rows; i++) {
            this.drawLine(room.transformTo90(new pos["a" /* Pos */](0, i)), room.transformTo90(new pos["a" /* Pos */](cols, i)));
        }
        for (var i = 0; i <= cols; i++) {
            this.drawLine(room.transformTo90(new pos["a" /* Pos */](i, 0)), room.transformTo90(new pos["a" /* Pos */](i, rows)));
        }
    };
    GridLayer.prototype.drawLine = function (startPos, endPos) {
        // this.moveTo(startPos.x, startPos.y);
        // this.lineTo(endPos.x, endPos.y);
        this.lineBetween(startPos.x, startPos.y, endPos.x, endPos.y);
    };
    return GridLayer;
}(Phaser.GameObjects.Graphics));


// CONCATENATED MODULE: ./src/rooms/layer/layer.manager.ts

var layer_manager_LayerManager = /** @class */ (function () {
    function LayerManager(room) {
        this.room = room;
        this.mSurfaceInteractived = true;
        this.mDelta = 0;
        var zoom = 1;
        if (!room) {
            return;
        }
        if (room.world) {
            zoom = room.world.scaleRatio;
        }
        this.mScene = room.scene;
        // ==========背景层
        this.mGroundClickLayer = this.mScene.add.container(0, 0);
        // this.totalLayerList.push(this.mGroundClickLayer);
        this.mUGroundLayer2 = this.mScene.add.container(0, 0);
        // ==========舞台层
        this.mGroundLayer = this.mScene.add.container(0, 0).setScale(zoom);
        this.mTileLayer = new grid_layer_GridLayer(this.mScene).setScale(zoom);
        this.mScene.sys.displayList.add(this.mTileLayer);
        this.mMiddleLayer = this.mScene.add.container(0, 0).setScale(zoom);
        this.mSurfaceLayer = this.mScene.add.container(0, 0).setScale(zoom);
        this.mAtmosphere = this.mScene.add.container(0, 0);
        // ==========UI层
        this.mSceneUILayer = this.mScene.add.container(0, 0);
        this.mUILayer = this.mScene.add.container(0, 0).setScrollFactor(0);
        // this.mUILayer.setInteractive(new Geom.Rectangle(0, 0, window.innerWidth, window.innerHeight), Phaser.Geom.Rectangle.Contains);
    }
    LayerManager.prototype.addToGround = function (ele, index) {
        if (index !== undefined) {
            this.mGroundLayer.addAt(ele, index);
        }
        else {
            if (Array.isArray(ele)) {
                this.mGroundLayer.add(ele);
            }
            else {
                this.mGroundLayer.add([ele]);
            }
        }
        // this.mGroundLayer.add(Array.from(tmp, (display: ElementDisplay) => display.GameObject));
        // Logger.log("terrain num: ", this.mGroundLayer.list.length);
    };
    LayerManager.prototype.addToSurface = function (ele) {
        if (Array.isArray(ele)) {
            this.mSurfaceLayer.add(ele);
        }
        else {
            this.mSurfaceLayer.add([ele]);
        }
        // Logger.log("surface num: ", this.mSurfaceLayer.list.length);
        // this.mSurfaceLayer.add(Array.from(tmp, (display: ElementDisplay) => display.GameObject));
    };
    LayerManager.prototype.addToSceneToUI = function (child) {
        this.mSceneUILayer.add(child);
    };
    LayerManager.prototype.addToUI = function (child) {
        this.mUILayer.add(child);
    };
    LayerManager.prototype.addToAtmosphere = function (child) {
        this.mAtmosphere.add(child);
    };
    LayerManager.prototype.addToMiddle = function (child) {
        this.mMiddleLayer.add(child);
    };
    LayerManager.prototype.resize = function (width, height) {
        // todo
    };
    LayerManager.prototype.addMouseListen = function () {
        // this.mGroundClickLayer.setInteractive(new Geom.Rectangle(0, 0, window.innerWidth, window.innerHeight), Phaser.Geom.Rectangle.Contains);
    };
    LayerManager.prototype.sortSurface = function () {
        this.mSurfaceLayer.sort("depth");
    };
    LayerManager.prototype.changeScene = function () {
        this._clearLayer();
    };
    LayerManager.prototype.drawGrid = function (room) {
        if (this.mTileLayer) {
            this.mTileLayer.draw(room);
        }
    };
    LayerManager.prototype.setGridVisible = function (visible) {
        if (this.mTileLayer) {
            this.mTileLayer.setVisible(visible);
        }
    };
    LayerManager.prototype.update = function (time, delta) {
        // if (time - this.mDelta < 3000) {
        //     return;
        // }
        this.mDelta = time;
        if (this.mDepthGround) {
            this.mGroundLayer.sort("depth");
            this.mDepthGround = false;
        }
        if (this.mDepthSurface) {
            this.mDepthSurface = false;
            // this.mSurfaceLayer.sort("depth");
            this.mSurfaceLayer.sort("depth", function (displayA, displayB) {
                // Logger.debug(displayA, displayB);
                // const sortA = displayA.sortRectangle;
                // const sortB = displayB.sortRectangle;
                // Logger.log("sort x: ", displayA, displayA.sortX, displayA.sortY);
                // Logger.log("sortB: ", displayB, displayB.sortX, displayB.sortY);
                var depthA = displayA.depth ? displayA.depth : 0;
                var depthB = displayB.depth ? displayB.depth : 0;
                if (depthA > depthB) {
                    return 1;
                }
                var angle = Math.atan2(displayA.sortY - displayB.sortY, displayA.sortX - displayB.sortX);
                if (angle * (180 * Math.PI) >= 70) {
                    return 1;
                }
                // if (displayA.sortY > displayB.sortY) {
                //     return 1;
                // }
                // if (displayB.y + sortB.top.y > displayA.y + sortA.left.y) {
                //     return 1;
                // }
                return -1;
            });
        }
    };
    LayerManager.prototype.setSurfaceInteractive = function (val) {
        if (this.mSurfaceInteractived === val) {
            return;
        }
        this.mSurfaceInteractived = val;
        var list = this.mSurfaceLayer.list;
        if (val) {
            // this.mSurfaceLayer.setInteractive();
            list.forEach(function (obj) {
                obj.setInteractive();
            });
        }
        else {
            list.forEach(function (obj) {
                obj.disableInteractive();
            });
            // this.mSurfaceLayer.disableInteractive();
        }
    };
    LayerManager.prototype.destroy = function () {
        this.mDelta = 0;
        this._clearLayer();
    };
    LayerManager.prototype._clearLayer = function () {
        this.clearLayer(this.mGroundClickLayer);
        this.clearLayer(this.mGroundLayer);
        this.clearLayer(this.mSurfaceLayer);
        this.clearLayer(this.mUGroundLayer2);
        this.clearLayer(this.mUILayer);
        this.clearLayer(this.mAtmosphere);
        this.mTileLayer.destroy(true);
    };
    LayerManager.prototype.clearLayer = function (container, destroy) {
        if (destroy === void 0) { destroy = false; }
        var list = container.list;
        if (list) {
            var len = list.length;
            var child = void 0;
            for (var i = 0; i < len; i++) {
                child = list[i];
                if (child) {
                    child.destroy(destroy);
                    child = null;
                }
            }
        }
        container.destroy(destroy);
    };
    Object.defineProperty(LayerManager.prototype, "depthSurfaceDirty", {
        set: function (val) {
            this.mDepthSurface = val;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LayerManager.prototype, "depthGroundDirty", {
        set: function (val) {
            this.mDepthGround = val;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LayerManager.prototype, "layer", {
        get: function () {
            return this.mGroundLayer;
        },
        enumerable: false,
        configurable: true
    });
    return LayerManager;
}());



/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ cameras_manager_CamerasManager; });

// EXTERNAL MODULE: ./node_modules/net-socket-packet/dist/index.js
var dist = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/pixelpai_proto/protocols.js
var protocols = __webpack_require__(2);

// EXTERNAL MODULE: ./src/utils/log.ts
var log = __webpack_require__(5);

// CONCATENATED MODULE: ./src/utils/rectangle45.ts
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Rectangle = Phaser.Geom.Rectangle;
var Rectangle45 = /** @class */ (function (_super) {
    __extends(Rectangle45, _super);
    function Rectangle45(row, col, endRow, endCol) {
        var _this = _super.call(this, row, col, endRow, endCol) || this;
        _this.row = row;
        _this.col = col;
        _this.endRow = endRow;
        _this.endCol = endCol;
        return _this;
    }
    return Rectangle45;
}(Rectangle));


// EXTERNAL MODULE: ./src/utils/pos.ts
var utils_pos = __webpack_require__(6);

// CONCATENATED MODULE: ./src/rooms/cameras/cameras.manager.ts
var cameras_manager_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();





var cameras_manager_CamerasManager = /** @class */ (function (_super) {
    cameras_manager_extends(CamerasManager, _super);
    function CamerasManager(mRoomService) {
        var _this = _super.call(this) || this;
        _this.mRoomService = mRoomService;
        _this.MINI_VIEW_SIZE = 30;
        _this.VIEW_PORT_SIZE = 30;
        _this.viewPort = new Phaser.Geom.Rectangle();
        _this.miniViewPort = new Phaser.Geom.Rectangle();
        _this.zoom = 1;
        if (_this.mRoomService && _this.mRoomService.world) {
            _this.zoom = _this.mRoomService.world.scaleRatio;
        }
        _this.mCameras = [];
        return _this;
        // this.zoom = this.mRoomService.world.scaleRatio;
    }
    CamerasManager.prototype.getViewPort = function () {
        if (!this.mMain)
            return;
        var worldView = this.mMain.worldView;
        // const out = new Phaser.Geom.Rectangle(worldView.x, worldView.y, worldView.width, worldView.height);
        // out.x -= out.width >> 1;
        // out.y -= out.height >> 1;
        // out.width *= 2;
        // out.height *= 2;
        // out.x -= 200;
        // out.y -= 200;
        // out.width += 400;
        // out.height += 400;
        // this.viewPort.setPosition(worldView.x - worldView.width / 2, worldView.y - worldView.height / 2);
        this.viewPort.x = worldView.x / this.zoom + (worldView.width / this.zoom - this.viewPort.width >> 1);
        this.viewPort.y = worldView.y / this.zoom + (worldView.height / this.zoom - this.viewPort.height >> 1);
        return this.viewPort;
    };
    CamerasManager.prototype.getMiniViewPort = function () {
        if (!this.mMain)
            return;
        var worldView = this.mMain.worldView;
        this.miniViewPort.x = worldView.x / this.zoom + (worldView.width / this.zoom - this.miniViewPort.width >> 1);
        this.miniViewPort.y = worldView.y / this.zoom + (worldView.height / this.zoom - this.miniViewPort.height >> 1);
        var pos = this.mRoomService.transformTo45(new utils_pos["a" /* Pos */](this.miniViewPort.x + (this.miniViewPort.width >> 1), this.miniViewPort.y));
        return new Rectangle45(pos.x, pos.y, this.MINI_VIEW_SIZE, this.MINI_VIEW_SIZE);
    };
    Object.defineProperty(CamerasManager.prototype, "camera", {
        get: function () {
            return this.mMain;
        },
        set: function (camera) {
            this.mMain = camera;
            this.addCamera(camera);
            this.setViewPortSize();
        },
        enumerable: false,
        configurable: true
    });
    CamerasManager.prototype.resize = function (width, height) {
        this.resetCameraSize(width, height);
    };
    CamerasManager.prototype.setScroll = function (x, y) {
        if (!this.mMain) {
            return;
        }
        for (var _i = 0, _a = this.mCameras; _i < _a.length; _i++) {
            var camera = _a[_i];
            camera.setScroll(x, y);
        }
        // this.mMain.setScroll(x, y);
    };
    CamerasManager.prototype.offsetScroll = function (x, y) {
        if (!this.mMain) {
            return;
        }
        for (var _i = 0, _a = this.mCameras; _i < _a.length; _i++) {
            var camera = _a[_i];
            camera.scrollX += x / this.camera.zoom;
            camera.scrollY += y / this.camera.zoom;
        }
        this.moving = true;
        // this.mCamera.setScroll(x, y);
    };
    CamerasManager.prototype.startFollow = function (target) {
        this.mTarget = target;
        if (this.mMain && target) {
            for (var _i = 0, _a = this.mCameras; _i < _a.length; _i++) {
                var camera = _a[_i];
                camera.startFollow(target);
            }
            // this.mMain.startFollow(target);
        }
    };
    CamerasManager.prototype.stopFollow = function () {
        this.mTarget = null;
        if (this.mMain) {
            for (var _i = 0, _a = this.mCameras; _i < _a.length; _i++) {
                var camera = _a[_i];
                camera.stopFollow();
            }
            // this.mMain.stopFollow();
        }
    };
    CamerasManager.prototype.addCamera = function (camera) {
        var index = this.mCameras.indexOf(camera);
        if (index === -1) {
            this.mCameras.push(camera);
        }
        if (this.mTarget) {
            camera.startFollow(this.mTarget);
        }
    };
    CamerasManager.prototype.removeCamera = function (camera) {
        var index = this.mCameras.indexOf(camera);
        if (index > -1) {
            this.mCameras.splice(index, 1);
        }
    };
    CamerasManager.prototype.setBounds = function (x, y, width, height, centerOn) {
        if (!this.mMain) {
            log["a" /* Logger */].getInstance().error("camera does not exist");
            return;
        }
        for (var _i = 0, _a = this.mCameras; _i < _a.length; _i++) {
            var camera = _a[_i];
            camera.setBounds(x, y, width, height, centerOn);
        }
        // this.mMain.setBounds(x, y, width, height, centerOn);
    };
    CamerasManager.prototype.setPosition = function (x, y) {
        if (!this.mMain) {
            return;
        }
        for (var _i = 0, _a = this.mCameras; _i < _a.length; _i++) {
            var camera = _a[_i];
            camera.setPosition(x, y);
        }
        // this.mMain.setPosition(x, y);
    };
    CamerasManager.prototype.syncToEditor = function () {
        if (!this.mMain) {
            return;
        }
        var cameraView = this.mMain.worldView;
        var pkt = new dist["PBpacket"](protocols["op_editor"].OPCODE._OP_CLIENT_REQ_EDITOR_RESET_CAMERA);
        var content = pkt.content;
        content.x = cameraView.x;
        content.y = cameraView.y;
        content.width = cameraView.width;
        content.height = cameraView.height;
        this.connection.send(pkt);
    };
    CamerasManager.prototype.centerCameas = function () {
    };
    CamerasManager.prototype.syncCamera = function () {
        if (!this.mMain) {
            return;
        }
        var packet = new dist["PBpacket"](protocols["op_virtual_world"].OPCODE._OP_CLIENT_REQ_VIRTUAL_WORLD_RESET_CAMERA_SIZE);
        var size = packet.content;
        size.width = this.mMain.width / this.mMain.zoom;
        size.height = this.mMain.height / this.mMain.zoom;
        this.connection.send(packet);
    };
    CamerasManager.prototype.syncCameraScroll = function () {
        if (!this.mMain) {
            return;
        }
        var pkt = new dist["PBpacket"](protocols["op_virtual_world"].OPCODE._OP_CLIENT_REQ_VIRTUAL_WORLD_SET_CAMERA_POSITION);
        var content = pkt.content;
        var pos = protocols["op_def"].PBPoint3f.create();
        pos.x = this.mMain.scrollX / Math.ceil(window.devicePixelRatio);
        pos.y = this.mMain.scrollY / Math.ceil(window.devicePixelRatio);
        content.pos = pos;
        this.connection.send(pkt);
    };
    CamerasManager.prototype.scrollTargetPoint = function (x, y) {
        if (!this.mMain) {
            return;
        }
        this.setScroll(x * this.mRoomService.world.scaleRatio - this.mMain.width / 2, y * this.mRoomService.world.scaleRatio - this.mMain.height / 2);
    };
    CamerasManager.prototype.resetCameraSize = function (width, height) {
        if (!this.connection) {
            log["a" /* Logger */].getInstance().error("connection is undefined");
            return;
        }
        this.syncCamera();
    };
    CamerasManager.prototype.setViewPortSize = function () {
        if (!this.mMain) {
            log["a" /* Logger */].getInstance().error("camera does not exist");
            return;
        }
        var size = this.mRoomService.roomSize;
        if (!size) {
            log["a" /* Logger */].getInstance().error("room size does not exist");
            return;
        }
        var viewW = (this.VIEW_PORT_SIZE + this.VIEW_PORT_SIZE) * (size.tileWidth / 2);
        var viewH = (this.VIEW_PORT_SIZE + this.VIEW_PORT_SIZE) * (size.tileHeight / 2);
        this.viewPort.setSize(viewW, viewH);
        var miniViewW = (this.MINI_VIEW_SIZE + this.MINI_VIEW_SIZE) * (size.tileWidth / 2);
        var miniviewH = (this.MINI_VIEW_SIZE + this.MINI_VIEW_SIZE) * (size.tileHeight / 2);
        this.miniViewPort.setSize(miniViewW, miniviewH);
    };
    Object.defineProperty(CamerasManager.prototype, "connection", {
        get: function () {
            if (!this.mRoomService) {
                log["a" /* Logger */].getInstance().error("room service is undefined");
                return;
            }
            return this.mRoomService.connection;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CamerasManager.prototype, "moving", {
        get: function () {
            return this.mMoving;
        },
        set: function (val) {
            this.mMoving = val;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CamerasManager.prototype, "targetFollow", {
        get: function () {
            return this.mTarget;
        },
        enumerable: false,
        configurable: true
    });
    return CamerasManager;
}(dist["PacketHandler"]));



/***/ }),
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ReferenceArea; });
/* harmony import */ var _utils_pos__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var _utils_position45__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var ReferenceArea = /** @class */ (function (_super) {
    __extends(ReferenceArea, _super);
    function ReferenceArea(scene, mRoomService) {
        var _this = _super.call(this, scene) || this;
        _this.mRoomService = mRoomService;
        return _this;
    }
    ReferenceArea.prototype.draw = function (area, origin) {
        this.clear();
        if (area.length === 0 || area[0].length === 0) {
            return;
        }
        var p1;
        var p2;
        var p3;
        var p4;
        var rows = area.length;
        var cols = area[0].length;
        var roomSize = this.mRoomService.roomSize;
        var tileWidth = roomSize.tileWidth / 2;
        var tileHeight = roomSize.tileHeight / 2;
        this.mOrigin = origin;
        this.mSize = {
            rows: rows,
            cols: cols,
            tileWidth: tileWidth,
            tileHeight: tileHeight,
            sceneWidth: (rows + cols) * (tileWidth / 2),
            sceneHeight: (rows + cols) * (tileHeight / 2)
        };
        this.beginPath();
        for (var y = 0; y < rows; y++) {
            for (var x = 0; x < cols; x++) {
                this.lineStyle(2, 0);
                p1 = _utils_position45__WEBPACK_IMPORTED_MODULE_1__[/* Position45 */ "a"].transformTo90(new _utils_pos__WEBPACK_IMPORTED_MODULE_0__[/* Pos */ "a"](x, y), this.mSize);
                p2 = _utils_position45__WEBPACK_IMPORTED_MODULE_1__[/* Position45 */ "a"].transformTo90(new _utils_pos__WEBPACK_IMPORTED_MODULE_0__[/* Pos */ "a"](x + 1, y), this.mSize);
                p3 = _utils_position45__WEBPACK_IMPORTED_MODULE_1__[/* Position45 */ "a"].transformTo90(new _utils_pos__WEBPACK_IMPORTED_MODULE_0__[/* Pos */ "a"](x + 1, y + 1), this.mSize);
                p4 = _utils_position45__WEBPACK_IMPORTED_MODULE_1__[/* Position45 */ "a"].transformTo90(new _utils_pos__WEBPACK_IMPORTED_MODULE_0__[/* Pos */ "a"](x, y + 1), this.mSize);
                this.beginPath();
                this.fillStyle(area[y][x] === 1 ? 0x00FF00 : 0xFF0000);
                this.strokePoints([p1.toPoint(), p2.toPoint(), p3.toPoint(), p4.toPoint()], true, true);
                this.fillPath();
            }
        }
        this.setPosition(0, 0);
    };
    ReferenceArea.prototype.setPosition = function (x, y, z, w) {
        if (!this.mSize)
            return;
        var _x = x - this.mSize.rows * (this.mSize.tileWidth >> 1) - (this.mOrigin.x - this.mOrigin.y) * (this.mSize.tileWidth >> 1);
        var _y = y - (this.mOrigin.x + this.mOrigin.y) * (this.mSize.tileHeight >> 1);
        return _super.prototype.setPosition.call(this, _x, _y, z, w);
    };
    Object.defineProperty(ReferenceArea.prototype, "size", {
        get: function () {
            return this.mSize;
        },
        enumerable: false,
        configurable: true
    });
    return ReferenceArea;
}(Phaser.GameObjects.Graphics));



/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DragonbonesModel; });
/* harmony import */ var _element_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11);

var DragonbonesModel = /** @class */ (function () {
    function DragonbonesModel(data) {
        this.discriminator = "DragonbonesModel";
        // this.id = id;
        // this.avatar = avatar;
        if (data) {
            this.id = data.id;
            this.avatar = data.avatar;
        }
    }
    DragonbonesModel.prototype.setInfo = function (val) {
        for (var key in val) {
            if (val.hasOwnProperty(key)) {
                this[key] = val[key];
            }
        }
    };
    DragonbonesModel.prototype.destroy = function () {
    };
    DragonbonesModel.prototype.getCollisionArea = function (aniName) {
        return [[1, 1], [1, 1]];
    };
    DragonbonesModel.prototype.getWalkableArea = function () {
        return [[1, 1], [1, 1]];
    };
    DragonbonesModel.prototype.getOriginPoint = function (aniName) {
        return new Phaser.Geom.Point(1, 1);
    };
    DragonbonesModel.prototype.getInteractiveArea = function () {
        return undefined;
    };
    DragonbonesModel.prototype.existAnimation = function (aniName) {
        return true;
    };
    DragonbonesModel.prototype.findAnimation = function (baseName, dir) {
        var flip = false;
        switch (dir) {
            case _element_element__WEBPACK_IMPORTED_MODULE_0__[/* Direction */ "a"].south_east:
                flip = true;
                dir = _element_element__WEBPACK_IMPORTED_MODULE_0__[/* Direction */ "a"].west_south;
                break;
            case _element_element__WEBPACK_IMPORTED_MODULE_0__[/* Direction */ "a"].east_north:
                flip = true;
                dir = _element_element__WEBPACK_IMPORTED_MODULE_0__[/* Direction */ "a"].north_west;
                break;
        }
        var addName = "";
        if ((dir >= _element_element__WEBPACK_IMPORTED_MODULE_0__[/* Direction */ "a"].north && dir < _element_element__WEBPACK_IMPORTED_MODULE_0__[/* Direction */ "a"].west) || dir > _element_element__WEBPACK_IMPORTED_MODULE_0__[/* Direction */ "a"].east && dir <= _element_element__WEBPACK_IMPORTED_MODULE_0__[/* Direction */ "a"].east_north)
            addName = "_back";
        return { animationName: "" + baseName + addName, flip: flip };
    };
    return DragonbonesModel;
}());



/***/ }),
/* 78 */,
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Terrain; });
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _display_terrain_display__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(51);
/* harmony import */ var _cameras_block_object__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45);
/* harmony import */ var pixelpai_proto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2);
/* harmony import */ var pixelpai_proto__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(pixelpai_proto__WEBPACK_IMPORTED_MODULE_3__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var Terrain = /** @class */ (function (_super) {
    __extends(Terrain, _super);
    function Terrain(sprite, mElementManager) {
        var _this = _super.call(this, mElementManager.roomService) || this;
        _this.mElementManager = mElementManager;
        _this.mId = sprite.id;
        _this.model = sprite;
        return _this;
    }
    Terrain.prototype.setModel = function (val) {
        this.mModel = val;
        if (!val) {
            return;
        }
        this.load(this.mModel.displayInfo);
        // this.mDisplayInfo = <IFramesModel> this.mModel.displayInfo;
        // this.createDisplay();
        if (!this.mDisplay) {
            return;
        }
        this.setPosition45(this.mModel.pos);
        // this.addDisplay();
    };
    Terrain.prototype.updateModel = function (val) {
    };
    Terrain.prototype.load = function (displayInfo) {
        this.mDisplayInfo = displayInfo;
        if (!this.mDisplayInfo) {
            return;
        }
        if (!this.mDisplay) {
            this.createDisplay();
        }
        this.mDisplayInfo = displayInfo;
        this.mDisplay.once("initialized", this.onInitializedHandler, this);
        this.mDisplay.load(this.mDisplayInfo);
    };
    Terrain.prototype.play = function (animationName) {
        if (!this.mModel) {
            _utils_log__WEBPACK_IMPORTED_MODULE_0__[/* Logger */ "a"].getInstance().error(Terrain.name + ": sprite is empty");
            return;
        }
        if (this.mModel.currentAnimationName !== animationName) {
            // this.mAnimationName = animationName;
            this.mModel.currentAnimationName = animationName;
            if (this.mDisplay) {
                this.mDisplay.play(this.model.currentAnimation);
            }
        }
    };
    Terrain.prototype.setDirection = function (val) {
        if (this.mDisplayInfo && this.mDisplayInfo.avatarDir)
            this.mDisplayInfo.avatarDir = val;
    };
    Terrain.prototype.getDirection = function () {
        return this.mDisplayInfo && this.mDisplayInfo.avatarDir ? this.mDisplayInfo.avatarDir : 3;
    };
    Terrain.prototype.setPosition = function (p) {
        if (this.mDisplay) {
            this.mDisplay.setPosition(p.x, p.y, p.z);
        }
        this.setDepth();
    };
    Terrain.prototype.getDisplay = function () {
        return this.mDisplay;
    };
    Terrain.prototype.showNickname = function () { };
    Terrain.prototype.showEffected = function () { };
    Terrain.prototype.toSprite = function () {
        var sprite = pixelpai_proto__WEBPACK_IMPORTED_MODULE_3__["op_client"].Sprite.create();
        sprite.id = this.id;
        if (this.mDisplay) {
            var pos45 = this.getPosition45();
            this.mDisplay.x = pos45.x;
            this.mDisplay.y = pos45.y;
        }
        return sprite;
    };
    Terrain.prototype.turn = function () { };
    Terrain.prototype.setAlpha = function (val) { };
    Terrain.prototype.scaleTween = function () { };
    Terrain.prototype.setQueue = function () { };
    Terrain.prototype.destroy = function () {
        if (this.mBlockable && this.mDisplay) {
            this.roomService.removeBlockObject(this);
        }
        _super.prototype.destroy.call(this);
    };
    Terrain.prototype.createDisplay = function () {
        if (!this.mDisplayInfo) {
            // Logger.getInstance().error("displayinfo does not exist, Create display failed");
            return;
        }
        if (this.mDisplay) {
            return this.mDisplay;
        }
        var scene = this.mElementManager.scene;
        if (scene) {
            this.mDisplay = new _display_terrain_display__WEBPACK_IMPORTED_MODULE_1__[/* TerrainDisplay */ "a"](scene, this.mElementManager.roomService, this);
            this.setPosition45(this.model.pos);
            this.addToBlock();
            // this.mDisplay.load(this.mDisplayInfo);
        }
        return this.mDisplay;
    };
    Terrain.prototype.addDisplay = function () {
        this.createDisplay();
        if (!this.mDisplay) {
            // Logger.getInstance().error("display does not exist");
            return;
        }
        if (!this.mElementManager) {
            _utils_log__WEBPACK_IMPORTED_MODULE_0__[/* Logger */ "a"].getInstance().error("element manager does not exist");
            return;
        }
        var room = this.mElementManager.roomService;
        if (!room) {
            _utils_log__WEBPACK_IMPORTED_MODULE_0__[/* Logger */ "a"].getInstance().error("roomService does not exist");
            return;
        }
        room.addToGround(this.mDisplay);
        this.setDepth();
    };
    Terrain.prototype.setDepth = function () {
        if (this.mDisplay) {
            this.mDisplay.setDepth(this.mDisplay.y);
            if (!this.roomService) {
                throw new Error("roomService is undefined");
            }
            var layerManager = this.roomService.layerManager;
            if (!layerManager) {
                throw new Error("layerManager is undefined");
            }
            layerManager.depthGroundDirty = true;
        }
    };
    Terrain.prototype.onInitializedHandler = function () {
        if (this.mDisplay) {
            // this.mDisplay.setInteractive();
        }
    };
    Terrain.prototype.setPosition45 = function (pos) {
        if (!this.roomService) {
            _utils_log__WEBPACK_IMPORTED_MODULE_0__[/* Logger */ "a"].getInstance().error("roomService does not exist");
            return;
        }
        var point = this.roomService.transformTo90(pos);
        this.setPosition(point);
    };
    Object.defineProperty(Terrain.prototype, "id", {
        get: function () {
            return this.mId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Terrain.prototype, "dir", {
        get: function () {
            return this.mDisplayInfo.avatarDir !== undefined ? this.mDisplayInfo.avatarDir : 3;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Terrain.prototype, "roomService", {
        get: function () {
            if (!this.mElementManager) {
                _utils_log__WEBPACK_IMPORTED_MODULE_0__[/* Logger */ "a"].getInstance().error("element manager is undefined");
                return;
            }
            return this.mElementManager.roomService;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Terrain.prototype, "model", {
        get: function () {
            return this.mModel;
        },
        set: function (val) {
            this.setModel(val);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Terrain.prototype, "currentAnimationName", {
        get: function () {
            if (this.mModel) {
                return this.mModel.currentAnimationName;
            }
            return "";
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Terrain.prototype, "scene", {
        get: function () {
            if (this.mElementManager) {
                return this.mElementManager.scene;
            }
        },
        enumerable: false,
        configurable: true
    });
    return Terrain;
}(_cameras_block_object__WEBPACK_IMPORTED_MODULE_2__[/* BlockObject */ "a"]));



/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MainUIScene; });
/* harmony import */ var _utils_font__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(32);
/* harmony import */ var _basic_scene__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var MainUIScene = /** @class */ (function (_super) {
    __extends(MainUIScene, _super);
    function MainUIScene() {
        var _this = _super.call(this, { key: MainUIScene.name }) || this;
        _this.timeOutID = 0;
        _this.timeOutCancelMap = {};
        _this.timeOutCallerList = [];
        _this.timeOutTimeMap = {};
        return _this;
    }
    MainUIScene.prototype.preload = function () {
    };
    MainUIScene.prototype.init = function (data) {
        this.mRoom = data.room;
    };
    MainUIScene.prototype.create = function () {
        this.fps = this.add.text(10, 10, "", { style: { color: "#64DD17", } });
        this.fps.setStroke("0x0", 1);
        this.fps.setFontFamily(_utils_font__WEBPACK_IMPORTED_MODULE_0__[/* Font */ "a"].DEFULT_FONT);
        this.fps.setFontSize(20 * window.devicePixelRatio);
        this.sizeTF = this.add.text(10, 50, "", { style: { color: "#64DD17" }, wordWrap: { width: 800, useAdvancedWrap: true } });
        this.sizeTF.setFontSize(20 * window.devicePixelRatio);
        this.sizeTF.setFontFamily(_utils_font__WEBPACK_IMPORTED_MODULE_0__[/* Font */ "a"].DEFULT_FONT);
        this.sizeTF.setStroke("#0", 3);
        var world = this.mRoom.world;
        if (world.game.device.os.desktop) {
        }
        else {
            if (world.inputManager) {
                world.inputManager.setScene(this);
            }
        }
        world.uiManager.setScene(this);
        // this.checkSize(this.mRoom.world.getSize());
        // this.mRoom.world.game.scale.on("orientationchange", this.checkOriention, this);
        // this.scale.on("resize", this.checkSize, this);
    };
    MainUIScene.prototype.setTimeout = function (caller, time) {
        var begin = Date.now();
        this.timeOutCallerList[++this.timeOutID] = caller;
        this.timeOutTimeMap[this.timeOutID] = { now: begin, delay: time };
        return this.timeOutID;
    };
    MainUIScene.prototype.clearTimeout = function (id) {
        this.timeOutCancelMap[id] = true;
    };
    MainUIScene.prototype.update = function (time, delta) {
        this.fps.setText(this.game.loop.actualFps.toFixed());
        // const orientation: string = this.mRoom.world.getSize().width > this.mRoom.world.getSize().height ? "LANDSCAPE" : "PORTRAIT";
        // this.sizeTF.text = "width:" + this.mRoom.world.getSize().width +
        //   "\n" + "height:" + this.mRoom.world.getSize().height + `\npixelRatio: ${window.devicePixelRatio} \nscene Scale: ${this.mRoom.world.scaleRatio} \nuiscale：${Math.round(this.mRoom.world.scaleRatio)}`;
    };
    MainUIScene.prototype.getKey = function () {
        return this.sys.config.key;
    };
    // private checkOriention(orientation) {
    //   this.sizeTF.text = "width:" + this.mRoom.world.getSize().width + "\n" + "height:" + this.mRoom.world.getSize().height + "\n" + "orientation:" + orientation + "\n" + "orientationChange:" + orientation;
    // }
    MainUIScene.prototype.checkSize = function (size) {
        var width = size.width;
        var height = size.height;
        var world = this.mRoom.world;
        var gameSize = world.getSize();
        this.sizeTF.text = "CSS size: " + world.getConfig().width + " " + world.getConfig().height + "\n    Game size: " + gameSize.width.toFixed(2) + " " + gameSize.height.toFixed(2) + "\n    deviceRatio: " + window.devicePixelRatio + "\n    scene ratio: " + world.scaleRatio + "\n    ui ratio: " + world.uiRatio + "\n    ui scale: " + world.uiScale.toFixed(5) + "\n    ";
        //  this.sizeTF.text = "width:" + size.width + ";height:" + size.height;
    };
    return MainUIScene;
}(_basic_scene__WEBPACK_IMPORTED_MODULE_1__[/* BasicScene */ "a"]));



/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PlayCamera; });
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var PlayCamera = /** @class */ (function (_super) {
    __extends(PlayCamera, _super);
    function PlayCamera(x, y, width, height, pixelRatio, moveRatio) {
        var _this = _super.call(this, x, y, width, height) || this;
        _this.pixelRatio = pixelRatio;
        _this.moveRatio = moveRatio || 1;
        return _this;
    }
    PlayCamera.prototype.startFollow = function (target, roundPixels, lerpX, lerpY, offsetX, offsetY) {
        if (roundPixels === undefined) {
            roundPixels = false;
        }
        if (lerpX === undefined) {
            lerpX = 1;
        }
        if (lerpY === undefined) {
            lerpY = lerpX;
        }
        if (offsetX === undefined) {
            offsetX = 0;
        }
        if (offsetY === undefined) {
            offsetY = offsetX;
        }
        this._follow = target;
        this.roundPixels = roundPixels;
        // lerpX = Clamp(lerpX, 0, 1);
        // lerpY = Clamp(lerpY, 0, 1);
        this.lerp.set(lerpX, lerpY);
        this.followOffset.set(offsetX, offsetY);
        var originX = this.width / 2;
        var originY = this.height / 2;
        var fx = target.x * this.pixelRatio * this.moveRatio - offsetX;
        var fy = target.y * this.pixelRatio * this.moveRatio - offsetY;
        this.midPoint.set(fx, fy);
        this.scrollX = fx - originX;
        this.scrollY = fy - originY;
        if (this.useBounds) {
            this.scrollX = this.clampX(this.scrollX);
            this.scrollY = this.clampY(this.scrollY);
        }
        return this;
    };
    PlayCamera.prototype.preRender = function (resolution) {
        var width = this.width;
        var height = this.height;
        var halfWidth = width * 0.5;
        var halfHeight = height * 0.5;
        var zoom = this.zoom * resolution;
        var matrix = this.matrix;
        var originX = width * this.originX;
        var originY = height * this.originY;
        var follow = this._follow;
        var deadzone = this.deadzone;
        var sx = this.scrollX;
        var sy = this.scrollY;
        if (deadzone) {
            // CenterOn(deadzone, this.midPoint.x, this.midPoint.y);
        }
        if (follow && !this.panEffect.isRunning) {
            var fx = (follow.x * this.pixelRatio * this.moveRatio - this.followOffset.x);
            var fy = (follow.y * this.pixelRatio * this.moveRatio - this.followOffset.y);
            if (deadzone) {
                if (fx < deadzone.x) {
                    sx = this.linear(sx, sx - (deadzone.x - fx), this.lerp.x);
                }
                else if (fx > deadzone.right) {
                    sx = this.linear(sx, sx + (fx - deadzone.right), this.lerp.x);
                }
                if (fy < deadzone.y) {
                    sy = this.linear(sy, sy - (deadzone.y - fy), this.lerp.y);
                }
                else if (fy > deadzone.bottom) {
                    sy = this.linear(sy, sy + (fy - deadzone.bottom), this.lerp.y);
                }
            }
            else {
                sx = this.linear(sx, fx - originX, this.lerp.x);
                sy = this.linear(sy, fy - originY, this.lerp.y);
            }
        }
        if (this.useBounds) {
            sx = this.clampX(sx);
            sy = this.clampY(sy);
        }
        if (this.roundPixels) {
            originX = Math.round(originX);
            originY = Math.round(originY);
        }
        //  Values are in pixels and not impacted by zooming the Camera
        this.scrollX = sx;
        this.scrollY = sy;
        var midX = sx + halfWidth;
        var midY = sy + halfHeight;
        //  The center of the camera, in world space, so taking zoom into account
        //  Basically the pixel value of what it's looking at in the middle of the cam
        this.midPoint.set(midX, midY);
        var displayWidth = width / zoom;
        var displayHeight = height / zoom;
        this.worldView.setTo(midX - (displayWidth / 2), midY - (displayHeight / 2), displayWidth, displayHeight);
        matrix.applyITRS(this.x + originX, this.y + originY, this.rotation, zoom, zoom);
        matrix.translate(-originX, -originY);
        this.shakeEffect.preRender();
    };
    PlayCamera.prototype.linear = function (p0, p1, t) {
        return (p1 - p0) * t + p0;
    };
    return PlayCamera;
}(Phaser.Cameras.Scene2D.Camera));



/***/ }),
/* 82 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EditScene; });
/* harmony import */ var _play__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

// 编辑器用 Phaser.Scene
var EditScene = /** @class */ (function (_super) {
    __extends(EditScene, _super);
    function EditScene() {
        return _super.call(this, { key: EditScene.name }) || this;
    }
    EditScene.prototype.create = function () {
        this.mRoom.startPlay();
        this.scene.sendToBack();
    };
    return EditScene;
}(_play__WEBPACK_IMPORTED_MODULE_0__[/* PlayScene */ "a"]));



/***/ }),
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ decorate_room_DecorateRoom; });

// EXTERNAL MODULE: ./src/rooms/cameras/viewblock.manager.ts + 1 modules
var viewblock_manager = __webpack_require__(98);

// EXTERNAL MODULE: ./src/rooms/cameras/cameras.manager.ts + 1 modules
var cameras_manager = __webpack_require__(67);

// EXTERNAL MODULE: ./src/rooms/layer/layer.manager.ts + 1 modules
var layer_manager = __webpack_require__(66);

// EXTERNAL MODULE: ./src/utils/position45.ts
var position45 = __webpack_require__(17);

// EXTERNAL MODULE: ./node_modules/pixelpai_proto/protocols.js
var protocols = __webpack_require__(2);

// EXTERNAL MODULE: ./src/utils/pos.ts
var utils_pos = __webpack_require__(6);

// EXTERNAL MODULE: ./node_modules/net-socket-packet/dist/index.js
var dist = __webpack_require__(3);

// EXTERNAL MODULE: ./src/scenes/loading.ts
var loading = __webpack_require__(24);

// EXTERNAL MODULE: ./src/scenes/play.ts
var play = __webpack_require__(37);

// EXTERNAL MODULE: ./src/utils/log.ts
var log = __webpack_require__(5);

// EXTERNAL MODULE: ./src/rooms/display/display.object.ts + 1 modules
var display_object = __webpack_require__(29);

// EXTERNAL MODULE: ./src/rooms/display/terrain.display.ts
var terrain_display = __webpack_require__(51);

// EXTERNAL MODULE: ./src/rooms/element/element.manager.ts
var element_manager = __webpack_require__(31);

// EXTERNAL MODULE: ./src/rooms/element/sprite.ts
var element_sprite = __webpack_require__(13);

// EXTERNAL MODULE: ./src/rooms/element/element.ts + 16 modules
var element_element = __webpack_require__(11);

// CONCATENATED MODULE: ./src/rooms/element/decorate.element.manager.ts
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var NodeType = protocols["op_def"].NodeType;
var decorate_element_manager_DecorateElementManager = /** @class */ (function (_super) {
    __extends(DecorateElementManager, _super);
    function DecorateElementManager(room) {
        return _super.call(this, room) || this;
    }
    DecorateElementManager.prototype.addMap = function (sprite) {
        var displayInfo = sprite.displayInfo;
        if (!displayInfo) {
            return;
        }
        if (this.mRoom.selectedSprite && this.mRoom.selectedSprite.id === sprite.id) {
            return;
        }
        var curAni = sprite.currentAnimation;
        var aniName = curAni.animationName;
        var flip = curAni.flip;
        var collisionArea = displayInfo.getCollisionArea(aniName, flip);
        var walkArea = displayInfo.getWalkableArea(aniName, flip);
        var origin = displayInfo.getOriginPoint(aniName, flip);
        var rows = collisionArea.length;
        var cols = collisionArea[0].length;
        var pos = this.mRoom.transformToMini45(sprite.pos);
        if (!walkArea) {
            walkArea = new Array(rows);
            for (var i = 0; i < rows; i++) {
                walkArea[i] = new Array(cols).fill(0);
            }
        }
        var row = 0;
        var col = 0;
        for (var i = 0; i < rows; i++) {
            row = pos.y + i - origin.x;
            for (var j = 0; j < cols; j++) {
                if (collisionArea[i][j] === 1 && (i >= walkArea.length || j >= walkArea[i].length || walkArea[i][j] === 0)) {
                    col = pos.x + j - origin.y;
                    if (row >= 0 && row < this.mMap.length && col >= 0 && col < this.mMap[row].length) {
                        this.mMap[row][col] = 0;
                    }
                }
            }
        }
    };
    DecorateElementManager.prototype.removeMap = function (sprite) {
        var displayInfo = sprite.displayInfo;
        if (!displayInfo) {
            return;
        }
        var curAni = sprite.currentAnimation;
        var aniName = curAni.animationName;
        var flip = curAni.flip;
        var collisionArea = displayInfo.getCollisionArea(aniName, flip);
        var origin = displayInfo.getOriginPoint(aniName, flip);
        var rows = collisionArea.length;
        var cols = collisionArea[0].length;
        var pos = this.mRoom.transformToMini45(sprite.pos);
        var row = 0;
        var col = 0;
        for (var i = 0; i < rows; i++) {
            row = pos.y + i - origin.x;
            for (var j = 0; j < cols; j++) {
                col = pos.x + j - origin.y;
                if (collisionArea[i][j] === 1) {
                    if (row >= 0 && row < this.mMap.length && col >= 0 && col < this.mMap[row].length) {
                        this.mMap[pos.y + i - origin.x][pos.x + j - origin.y] = -1;
                    }
                }
            }
        }
    };
    DecorateElementManager.prototype._add = function (sprite, addMap) {
        if (addMap === undefined)
            addMap = true;
        var ele = this.mElements.get(sprite.id);
        if (ele) {
            ele.model = sprite;
        }
        else {
            ele = new element_element["b" /* Element */](sprite, this);
            ele.setInputEnable(element_element["c" /* InputEnable */].Enable);
        }
        // if (!ele) ele = new Element(sprite, this);
        if (addMap)
            this.addMap(sprite);
        this.mElements.set(ele.id || 0, ele);
        return ele;
    };
    DecorateElementManager.prototype.onSync = function (packet) {
        var content = packet.content;
        if (content.nodeType !== NodeType.ElementNodeType) {
            return;
        }
        var element = null;
        var sprites = content.sprites;
        for (var _i = 0, sprites_1 = sprites; _i < sprites_1.length; _i++) {
            var sprite = sprites_1[_i];
            element = this.get(sprite.id);
            if (element) {
                var sp = new element_sprite["a" /* Sprite */](sprite, content.nodeType);
                element.model = sp;
                this.addMap(sp);
            }
        }
    };
    Object.defineProperty(DecorateElementManager.prototype, "map", {
        get: function () {
            return this.mMap;
        },
        enumerable: false,
        configurable: true
    });
    return DecorateElementManager;
}(element_manager["a" /* ElementManager */]));


// EXTERNAL MODULE: ./src/const/MessageType.ts
var MessageType = __webpack_require__(12);

// EXTERNAL MODULE: ./src/rooms/terrain/terrain.manager.ts
var terrain_manager = __webpack_require__(50);

// CONCATENATED MODULE: ./src/rooms/terrain/decorate.terrain.manager.ts
var decorate_terrain_manager_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var decorate_terrain_manager_DecorateTerrainManager = /** @class */ (function (_super) {
    decorate_terrain_manager_extends(DecorateTerrainManager, _super);
    function DecorateTerrainManager(roomService) {
        var _this = _super.call(this, roomService) || this;
        var miniSize = roomService.miniSize;
        _this.mMap = new Array(miniSize.cols);
        for (var i = 0; i < miniSize.rows; i++) {
            _this.mMap[i] = new Array(miniSize.rows).fill(0);
        }
        return _this;
    }
    DecorateTerrainManager.prototype.remove = function (id) {
        var terrain = _super.prototype.remove.call(this, id);
        if (terrain) {
            this.removeMap(terrain.model);
        }
        return terrain;
    };
    DecorateTerrainManager.prototype._add = function (sprite) {
        var terrain = _super.prototype._add.call(this, sprite);
        var displayInfo = sprite.displayInfo;
        if (displayInfo) {
            this.addMap(sprite);
        }
        return terrain;
    };
    DecorateTerrainManager.prototype.onSyncSprite = function (packet) {
        var content = packet.content;
        if (content.nodeType !== protocols["op_def"].NodeType.TerrainNodeType) {
            return;
        }
        var terrain = null;
        var sprites = content.sprites;
        for (var _i = 0, sprites_1 = sprites; _i < sprites_1.length; _i++) {
            var sprite = sprites_1[_i];
            terrain = this.get(sprite.id);
            if (terrain) {
                var sp = new element_sprite["a" /* Sprite */](sprite, content.nodeType);
                terrain.model = sp;
                if (sp.displayInfo) {
                    this.addMap(sp);
                }
                // terrain.setRenderable(true);
            }
        }
    };
    DecorateTerrainManager.prototype.addMap = function (sprite) {
        this.setMap(sprite, 1);
    };
    DecorateTerrainManager.prototype.removeMap = function (sprite) {
        this.setMap(sprite, 0);
    };
    DecorateTerrainManager.prototype.setMap = function (sprite, type) {
        var displayInfo = sprite.displayInfo;
        if (!displayInfo) {
            return;
        }
        var curAni = sprite.currentAnimation;
        var aniName = curAni.animationName;
        var flip = curAni.flip;
        var collisionArea = displayInfo.getCollisionArea(aniName, flip);
        var walkArea = displayInfo.getWalkableArea(aniName, flip);
        var origin = displayInfo.getOriginPoint(aniName, flip);
        var rows = collisionArea.length;
        var cols = collisionArea[0].length;
        var hasCollisionArea = true;
        if (rows === 1 && cols === 1) {
            rows = 2;
            cols = 2;
            hasCollisionArea = false;
        }
        var pos = sprite.pos;
        var _x = 0;
        var _y = 0;
        for (var i = 0; i < rows; i++) {
            _x = pos.x + i - origin.x;
            for (var j = 0; j < cols; j++) {
                if ((!hasCollisionArea) || collisionArea[i][j] === 1 && walkArea[i][j] === 1) {
                    _y = pos.y + j - origin.y;
                    if (_x >= this.mMap.length || _y >= this.mMap[_x].length) {
                        continue;
                    }
                    this.mMap[pos.x + i - origin.x][pos.y + j - origin.y] = type;
                }
            }
        }
    };
    return DecorateTerrainManager;
}(terrain_manager["a" /* TerrainManager */]));


// EXTERNAL MODULE: ./src/rooms/display/frames.model.ts
var frames_model = __webpack_require__(35);

// EXTERNAL MODULE: ./src/rooms/display/animation.ts
var display_animation = __webpack_require__(49);

// CONCATENATED MODULE: ./src/rooms/decorate/spawn.point.ts




var spawn_point_SpawnPoint = /** @class */ (function () {
    function SpawnPoint() {
        this.id = 100;
        this.nodeType = protocols["op_def"].NodeType.SpawnPointType;
        this.pos = new utils_pos["a" /* Pos */]();
        this.displayInfo = new frames_model["a" /* FramesModel */]({
            id: 0,
            animations: {
                defaultAnimationName: "idle",
                display: this.display,
                animationData: [new display_animation["a" /* Animation */](this.animation)]
            }
        });
        this.currentAnimation = {
            animationName: "idle",
            flip: false
        };
        this.direction = 3;
        this.nickname = "出生点";
        this.alpha = 1;
    }
    SpawnPoint.prototype.newID = function () {
        throw new Error("Method not implemented.");
    };
    SpawnPoint.prototype.setPosition = function (x, y) {
        this.pos.x = x;
        this.pos.y = y;
    };
    SpawnPoint.prototype.turn = function () {
        throw new Error("Method not implemented.");
    };
    SpawnPoint.prototype.toSprite = function () {
        throw new Error("Method not implemented.");
    };
    SpawnPoint.prototype.updateAvatar = function (avatar) {
        throw new Error("Method not implemented.");
    };
    SpawnPoint.prototype.updateDisplay = function (display, animations, defAnimation) {
        throw new Error("Method not implemented.");
    };
    SpawnPoint.prototype.setAnimationName = function () {
        throw new Error("Method not implemented.");
    };
    SpawnPoint.prototype.setAnimationQueue = function () {
        throw new Error("Method not implemented.");
    };
    Object.defineProperty(SpawnPoint.prototype, "display", {
        get: function () {
            var display = protocols["op_gameconfig"].Display.create();
            display.texturePath =
                "pixelpai/SpawnPointNode/5cc42f6417553727db1d2bba/1/5cc42f6417553727db1d2bba.png";
            display.dataPath =
                "pixelpai/SpawnPointNode/5cc42f6417553727db1d2bba/1/5cc42f6417553727db1d2bba.json";
            return display;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpawnPoint.prototype, "animation", {
        get: function () {
            var animation = protocols["op_gameconfig"].Animation.create();
            animation.id = 10000;
            animation.name = "idle";
            animation.frameRate = 5;
            animation.collisionArea = "1,1&1,1";
            animation.loop = true;
            animation.baseLoc = "-30,-30";
            animation.originPoint = [0, 0];
            animation.frameName = ["switch_0027_3_01.png"];
            return animation;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpawnPoint.prototype, "currentCollisionArea", {
        get: function () {
            return [[1, 1], [1, 1]];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpawnPoint.prototype, "currentWalkableArea", {
        get: function () {
            return [[0]];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpawnPoint.prototype, "currentCollisionPoint", {
        get: function () {
            return new Phaser.Geom.Point(0, 0);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpawnPoint.prototype, "hasInteractive", {
        get: function () {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    return SpawnPoint;
}());


// EXTERNAL MODULE: ./src/ui/components/BasePanel.ts + 2 modules
var BasePanel = __webpack_require__(41);

// EXTERNAL MODULE: ./lib/rexui/lib/ui/baseUI/BaseUI.ts
var BaseUI = __webpack_require__(38);

// CONCATENATED MODULE: ./lib/rexui/lib/ui/interface/event/MouseEvent.ts
var CoreUI;
(function (CoreUI) {
    var MouseEvent;
    (function (MouseEvent) {
        MouseEvent["Click"] = "click";
        MouseEvent["Up"] = "Up";
        MouseEvent["Down"] = "Down";
        MouseEvent["Hold"] = "Hold";
        MouseEvent["Tap"] = "Tap";
        MouseEvent["Move"] = "Move";
        MouseEvent["Over"] = "Over";
        MouseEvent["Out"] = "Out";
        MouseEvent["DragStart"] = "DragStart";
        MouseEvent["DragStop"] = "DragStop";
    })(MouseEvent = CoreUI.MouseEvent || (CoreUI.MouseEvent = {}));
})(CoreUI || (CoreUI = {}));

// CONCATENATED MODULE: ./lib/rexui/lib/ui/button/Button.ts
var Button_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var ButtonState;
(function (ButtonState) {
    ButtonState["Normal"] = "normal";
    ButtonState["Over"] = "over";
    ButtonState["Select"] = "select";
    ButtonState["Disable"] = "disable";
})(ButtonState || (ButtonState = {}));
var ButtonSoundKey;
(function (ButtonSoundKey) {
})(ButtonSoundKey || (ButtonSoundKey = {}));
var GetValue = Phaser.Utils.Objects.GetValue;
var Button_Button = /** @class */ (function (_super) {
    Button_extends(Button, _super);
    function Button(scene, key, frame, downFrame, text, music) {
        var _this = _super.call(this, scene) || this;
        _this.mDownTime = 0;
        _this.mPressDelay = 1000;
        _this.mIsMove = false;
        _this.soundGroup = {
            up: {
                key: "click",
            }
        };
        Object.assign(_this.soundGroup, music);
        _this.mKey = key;
        _this.mFrame = frame;
        _this.mDownFrame = downFrame;
        _this.mBackground = scene.make.image({
            key: key,
            frame: frame
        }, false);
        _this.setSize(_this.mBackground.width, _this.mBackground.height);
        _this.add(_this.mBackground);
        if (text) {
            _this.mText = _this.scene.make.text(undefined, false)
                .setOrigin(0.5, 0.5)
                .setText(text)
                .setSize(_this.mBackground.width, _this.mBackground.height);
            _this.add(_this.mText);
        }
        _this.setInteractive();
        _this.addListen();
        return _this;
    }
    Object.defineProperty(Button.prototype, "background", {
        get: function () {
            return this.mBackground;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Button.prototype, "text", {
        get: function () {
            return this.mText;
        },
        enumerable: false,
        configurable: true
    });
    Button.prototype.addListen = function () {
        this.removeListen();
        this.on("pointerdown", this.onPointerDownHandler, this);
        this.on("pointerup", this.onPointerUpHandler, this);
        this.on("pointermove", this.onPointerMoveHandler, this);
    };
    Button.prototype.removeListen = function () {
        this.off("pointerdown", this.onPointerDownHandler, this);
        this.off("pointerup", this.onPointerUpHandler, this);
        this.off("pointermove", this.onPointerMoveHandler, this);
    };
    Button.prototype.mute = function (boo) {
        this.silent = boo;
    };
    Button.prototype.changeNormal = function () {
        this.setBgFrame(this.mFrame);
    };
    Button.prototype.changeDown = function () {
        if (this.mDownFrame) {
            this.setBgFrame(this.mDownFrame);
        }
    };
    Button.prototype.setFrame = function (frame) {
        if (this.mBackground) {
            this.setBgFrame(frame);
        }
    };
    Button.prototype.setText = function (val) {
        if (this.mText) {
            this.mText.setText(val);
        }
    };
    Button.prototype.setTextStyle = function (style) {
        if (this.mText) {
            this.mText.setStyle(style);
        }
    };
    Button.prototype.setFontStyle = function (val) {
        if (this.mText) {
            this.mText.setFontStyle(val);
        }
    };
    Button.prototype.setTextOffset = function (x, y) {
        if (this.mText) {
            this.mText.setPosition(x, y);
        }
    };
    Button.prototype.setTextColor = function (color) {
        if (this.mText) {
            this.mText.setColor(color);
        }
    };
    Button.prototype.setBgFrame = function (frame) {
        this.mBackground.setFrame(frame);
        this.setSize(this.mBackground.width, this.mBackground.height);
    };
    Button.prototype.buttonStateChange = function (state) {
        switch (state) {
            case ButtonState.Normal:
                this.changeNormal();
                break;
            case ButtonState.Over:
                break;
            case ButtonState.Select:
                this.changeDown();
                break;
            case ButtonState.Disable:
                break;
        }
    };
    Button.prototype.onPointerMoveHandler = function (pointer) {
        if (this.soundGroup && this.soundGroup.move)
            this.playSound(this.soundGroup.move);
        if (!this.interactiveBoo)
            return;
        this.mIsMove = true;
        this.emit(CoreUI.MouseEvent.Move);
    };
    Button.prototype.onPointerUpHandler = function (pointer) {
        if (!this.interactiveBoo) {
            if (this.soundGroup && this.soundGroup.disabled)
                this.playSound(this.soundGroup.disabled);
            return;
        }
        this.buttonStateChange(ButtonState.Normal);
        if (!this.mIsMove || (Date.now() - this.mDownTime > this.mPressTime)) {
            if (Math.abs(pointer.downX - pointer.upX) < 30 && Math.abs(pointer.downY - pointer.upY) < 30) {
                if (this.soundGroup && this.soundGroup.up)
                    this.playSound(this.soundGroup.up);
                this.emit(CoreUI.MouseEvent.Tap, pointer, this);
            }
        }
        clearTimeout(this.mPressDelay);
        this.mIsMove = false;
        this.mDownTime = 0;
    };
    Button.prototype.onPointerDownHandler = function (pointer) {
        var _this = this;
        if (!this.interactiveBoo) {
            if (this.soundGroup && this.soundGroup.disabled)
                this.playSound(this.soundGroup.disabled);
            return;
        }
        if (this.soundGroup && this.soundGroup.down)
            this.playSound(this.soundGroup.down);
        this.buttonStateChange(ButtonState.Select);
        this.mDownTime = Date.now();
        this.mPressTime = setTimeout(function () {
            _this.emit(CoreUI.MouseEvent.Hold, _this);
        }, this.mPressTime);
        this.emit(CoreUI.MouseEvent.Down, this);
    };
    return Button;
}(BaseUI["a" /* BaseUI */]));


// CONCATENATED MODULE: ./src/ui/decorate/decorate.panel.ts
var decorate_panel_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();






var decorate_panel_DecoratePanel = /** @class */ (function (_super) {
    decorate_panel_extends(DecoratePanel, _super);
    function DecoratePanel(scene, mRoomService) {
        var _this = _super.call(this, scene, mRoomService.world) || this;
        _this.mRoomService = mRoomService;
        _this.resKey = "decorate";
        _this.minGrid = 2;
        _this.maxGrid = 10;
        _this.key = "decorate_edit_menu";
        _this.offset = new utils_pos["a" /* Pos */]();
        _this.mScaleRatio = 1;
        _this.setTween(false);
        if (_this.mWorld)
            _this.mScaleRatio = _this.mWorld.scaleRatio;
        return _this;
    }
    DecoratePanel.prototype.show = function (param) {
        this.mShowData = param;
        if (!this.mInitialized) {
            this.preload();
            return;
        }
        if (this.mShow)
            return;
        if (this.soundGroup && this.soundGroup.open)
            this.playSound(this.soundGroup.open);
        if (!this.mTweening && this.mTweenBoo) {
            this.showTween(true);
        }
        else {
            this.mShow = true;
        }
    };
    DecoratePanel.prototype.addListen = function () {
        if (this.mCancelBtn)
            this.mCancelBtn.on("pointerup", this.onCancelHandler, this);
        if (this.mOkBtn)
            this.mOkBtn.on("pointerup", this.onAddHandler, this);
        if (this.mRecycleBtn)
            this.mRecycleBtn.on("pointerup", this.onRecycleHandler, this);
        if (this.mTurnBtn)
            this.mTurnBtn.on("pointerup", this.onTurnHandler, this);
        if (this.mMoveBtn)
            this.mMoveBtn.on("pointerup", this.onShowMoveMenuHandler, this);
        if (this.mRepeatBtn)
            this.mRepeatBtn.on("pointerup", this.onShowRepeatHandler, this);
        if (this.mExtendBtn)
            this.mExtendBtn.on("pointerup", this.onShowExtendsHandler, this);
        if (this.mMoveMenuContainer) {
            this.mMoveMenuContainer.register();
            this.mMoveMenuContainer.on("move", this.onMoveHandler, this);
        }
        if (this.mRepeatMenuContainer) {
            this.mRepeatMenuContainer.register();
            this.mRepeatMenuContainer.on("move", this.onRepeatHandler, this);
            this.mRepeatMenuContainer.on("hold", this.onHoldRepeatHandler, this);
        }
    };
    DecoratePanel.prototype.removeListen = function () {
        if (this.mCancelBtn)
            this.mCancelBtn.off("pointerup", this.onCancelHandler, this);
        if (this.mOkBtn)
            this.mOkBtn.off("pointerup", this.onAddHandler, this);
        if (this.mRecycleBtn)
            this.mRecycleBtn.off("pointerup", this.onRecycleHandler, this);
        if (this.mTurnBtn)
            this.mTurnBtn.off("pointerup", this.onTurnHandler, this);
        if (this.mMoveBtn)
            this.mMoveBtn.off("pointerup", this.onShowMoveMenuHandler, this);
        if (this.mRepeatBtn)
            this.mRepeatBtn.off("pointerup", this.onShowRepeatHandler, this);
        if (this.mExtendBtn)
            this.mExtendBtn.off("pointerup", this.onShowExtendsHandler, this);
        if (this.mMoveMenuContainer) {
            this.mMoveMenuContainer.unRegister();
            this.mMoveMenuContainer.off("move", this.onMoveHandler, this);
        }
        if (this.mRepeatMenuContainer) {
            this.mRepeatMenuContainer.unRegister();
            this.mRepeatMenuContainer.off("move", this.onRepeatHandler, this);
            this.mRepeatMenuContainer.off("hold", this.onHoldRepeatHandler, this);
        }
    };
    DecoratePanel.prototype.setElement = function (ele) {
        this.mDisplayObject = ele;
        this.mSprite = ele.model;
        if (!this.mInitialized) {
            return;
        }
        var pos = this.mDisplayObject.getPosition();
        this.x = pos.x;
        this.y = pos.y;
        this.updateArrowPos(ele);
        this.addListen();
    };
    DecoratePanel.prototype.canPUt = function (val) {
        if (val !== this.mCanPut) {
            this.mCanPut = val;
            if (!this.mOkBtn) {
                return;
            }
            if (val) {
                this.mOkBtn.clearTint();
            }
            else {
                this.mOkBtn.setTint(0x666666);
            }
        }
    };
    DecoratePanel.prototype.setPos = function (x, y, z) {
        this.x = x * this.mScaleRatio;
        this.y = (y + this.offset.y) * this.mScaleRatio;
        this.z = z || 0;
        return this;
    };
    DecoratePanel.prototype.preload = function () {
        // this.scene.load.image(Border.getName(), Border.getPNG());
        // this.scene.load.image("arrow", Url.getRes("ui/common/common_arrow.png"));
        // this.scene.load.atlas(this.resKey, Url.getRes("ui/decorate/decorate_atlas.png"), Url.getRes("ui/decorate/decorate_atlas.json"));
        this.addAtlas(this.key, "decorate_edit_menu/decorate_edit_menu.png", "decorate_edit_menu/decorate_edit_menu.json");
        _super.prototype.preload.call(this);
    };
    DecoratePanel.prototype.init = function () {
        var w = this.scene.cameras.main.width / this.scale;
        var h = this.scene.cameras.main.height / this.scale;
        this.mMainMenus = [];
        this.mMenuContainer = this.scene.make.container({
            x: w >> 1,
        }, false);
        this.mSubMenus = this.scene.make.container({
            x: w >> 1,
            y: 60 * this.dpr
        }, false);
        this.mOkBtn = this.scene.make.image({
            key: this.key,
            frame: "ok_btn.png"
        }, false).setInteractive().setOrigin(0);
        this.mRecycleBtn = this.scene.make.image({
            key: this.key,
            frame: "recycly_btn.png"
        }, false).setInteractive().setOrigin(0);
        this.mTurnBtn = this.scene.make.image({
            key: this.key,
            frame: "turn_btn.png"
        }, false).setInteractive().setOrigin(0);
        this.mCancelBtn = this.scene.make.image({
            key: this.key,
            frame: "cancel_btn.png"
        }, false).setInteractive().setOrigin(0);
        // this.add([this.mControllContainer, this.mArrow1, this.mArrow7, this.mArrow3, this.mArrow5]);
        this.mHorizontalBtn = this.scene.make.image({
            key: this.key,
            frame: "horizontal_btn.png"
        }, false).setInteractive().setOrigin(0);
        this.mMoveBtn = this.scene.make.image({
            key: this.key,
            frame: "move_btn.png"
        }, false).setInteractive().setOrigin(0);
        this.mRepeatBtn = this.scene.make.image({
            key: this.key,
            frame: "repeat_btn.png"
        }, false).setInteractive().setOrigin(0);
        this.mExtendBtn = this.scene.make.image({
            key: this.key,
            frame: "extend_btn.png"
        }, false).setInteractive().setOrigin(0);
        this.mMoveMenuContainer = new decorate_panel_MoveMenu(this.scene, this.key, this.dpr, this.scale);
        this.mMoveMenuContainer.y = this.mSubMenus.y + 60 * this.dpr + this.mMoveMenuContainer.height / 2;
        this.mRepeatMenuContainer = new decorate_panel_MoveMenu(this.scene, this.key, this.dpr, this.scale);
        this.mRepeatMenuContainer.y = this.mMoveMenuContainer.y;
        var zoom = this.scale;
        // this.add(this.mMenuGroup);
        // this.mMenuGroup.addMultiple([this.mOkBtn, this.mTurnBtn, this.mRecycleBtn, this.mCancelBtn])
        // this.mMainMenus = ;
        // this.mSubMenus = ;
        this.add([this.mMenuContainer, this.mSubMenus]);
        this.mMenuContainer.add([this.mOkBtn, this.mTurnBtn, this.mRecycleBtn, this.mCancelBtn]);
        this.mSubMenus.add([this.mHorizontalBtn, this.mMoveBtn, this.mRepeatBtn, this.mExtendBtn]);
        // this.add(this.mSubMenus);
        var mainMenuW = w - 55 * this.dpr * this.mWorld.uiScale * 2;
        this.mMenuContainer.x = -mainMenuW >> 1;
        var list = this.mMenuContainer.list;
        list.map(function (btn) { return mainMenuW -= btn.width; });
        var margin = mainMenuW / (list.length - 1) / zoom;
        for (var i = 1; i < list.length; i++) {
            var preButton = list[i - 1];
            var button = list[i];
            button.x = preButton.width + preButton.x + margin;
        }
        mainMenuW = w - 70 * this.dpr * this.mWorld.uiScale * 2;
        this.mSubMenus.x = -mainMenuW >> 1;
        var subList = this.mSubMenus.list;
        subList.map(function (btn) { return mainMenuW -= btn.width; });
        margin = mainMenuW / (subList.length - 1) / zoom;
        for (var i = 1; i < subList.length; i++) {
            var preButton = subList[i - 1];
            var button = subList[i];
            button.x = preButton.width + preButton.x + margin;
        }
        this.mMoveMenuContainer.x = this.mSubMenus.x + this.mMoveBtn.x + this.mMoveBtn.width / 2 + 29 * this.dpr;
        this.mRepeatMenuContainer.x = this.mSubMenus.x + this.mRepeatBtn.x + this.mRepeatBtn.width / 2 + 29 * this.dpr;
        if (this.mCanPut) {
            this.mOkBtn.clearTint();
        }
        else {
            this.mOkBtn.setTint(0x666666);
        }
        // this.mControllContainer.add([border, this.mTurnBtn, this.mRecycleBtn, this.mConfirmBtn]);
        _super.prototype.init.call(this);
        this.setElement(this.mDisplayObject);
    };
    // protected register() {
    //     if (!this.mInitialized) {
    //         return;
    //     }
    //     this.mCancelBtn.on("pointerup", this.onCancelHandler, this);
    //     this.mOkBtn.on("pointerup", this.onAddHandler, this);
    //     this.mRecycleBtn.on("pointerup", this.onRecycleHandler, this);
    //     this.mTurnBtn.on("pointerup", this.onTurnHandler, this);
    //     this.mMoveBtn.on("pointerup", this.onShowMoveMenuHandler, this);
    //     this.mRepeatBtn.on("pointerup", this.onShowRepeatHandler, this);
    //     this.mExtendBtn.on("pointerup", this.onShowExtendsHandler, this);
    //     this.mMoveMenuContainer.register();
    //     this.mMoveMenuContainer.on("move", this.onMoveHandler, this);
    //     this.mRepeatMenuContainer.register();
    //     this.mRepeatMenuContainer.on("move", this.onRepeatHandler, this);
    //     this.mRepeatMenuContainer.on("hold", this.onHoldRepeatHandler, this);
    //     // this.mTurnBtn.on("pointerup", this.onTurnHandler, this);
    //     // this.mRecycleBtn.on("pointerup", this.onRecycleHandler, this);
    //     // this.mOkBtn.on("pointerup", this.onPutHandler, this);
    // }
    // protected unregister() {
    //     if (!this.mInitialized) {
    //         return;
    //     }
    //     this.mCancelBtn.off("pointerup", this.onCancelHandler, this);
    //     this.mOkBtn.off("pointerup", this.onAddHandler, this);
    //     this.mRecycleBtn.off("pointerup", this.onRecycleHandler, this);
    //     this.mTurnBtn.off("pointerup", this.onTurnHandler, this);
    //     this.mMoveBtn.off("pointerup", this.onShowMoveMenuHandler, this);
    //     this.mRepeatBtn.off("pointerup", this.onShowRepeatHandler, this);
    //     this.mExtendBtn.off("pointerup", this.onShowExtendsHandler, this);
    //     this.mMoveMenuContainer.off("move", this.onMoveHandler, this);
    //     this.mMoveMenuContainer.unRegister();
    //     this.mRepeatMenuContainer.off("move", this.onRepeatHandler, this);
    //     this.mRepeatMenuContainer.off("hold", this.onHoldRepeatHandler, this);
    //     this.mRepeatMenuContainer.unRegister();
    //     // this.mTurnBtn.off("pointerup", this.onTurnHandler, this);
    //     // this.mRecycleBtn.off("pointerup", this.onRecycleHandler, this);
    //     // this.mOkBtn.off("pointerup", this.onPutHandler, this);
    // }
    DecoratePanel.prototype.onLeftUpHandler = function () {
        if (!this.mDisplayObject) {
            return;
        }
        var pos45 = this.mRoomService.transformToMini45(this.mDisplayObject.getPosition());
        pos45.x -= 1;
        this.onMoveElement(pos45);
    };
    DecoratePanel.prototype.onLeftDownHandler = function () {
        var pos45 = this.mRoomService.transformToMini45(this.mDisplayObject.getPosition());
        pos45.y += 1;
        this.onMoveElement(pos45);
    };
    DecoratePanel.prototype.onRightUpHandler = function () {
        var pos45 = this.mRoomService.transformToMini45(this.mDisplayObject.getPosition());
        pos45.y -= 1;
        this.onMoveElement(pos45);
    };
    DecoratePanel.prototype.onRightDownHandler = function () {
        var pos45 = this.mRoomService.transformToMini45(this.mDisplayObject.getPosition());
        pos45.x = pos45.x + 1;
        this.onMoveElement(pos45);
    };
    DecoratePanel.prototype.getNorthWestPoints = function (count) {
        if (count === void 0) { count = 10; }
        var area = this.mSprite.currentCollisionArea;
        var origin = this.mSprite.currentCollisionPoint;
        var posList = [];
        var pos45 = this.mRoomService.transformToMini45(this.mSprite.pos);
        for (var i = 0; i < count; i++) {
            posList[i] = this.mRoomService.transformToMini90(pos45);
            pos45.x -= area[0].length;
        }
        return this.checkNextPos(posList, area, origin);
    };
    DecoratePanel.prototype.getWestSouthPoints = function (count) {
        if (count === void 0) { count = 10; }
        var area = this.mSprite.currentCollisionArea;
        var origin = this.mSprite.currentCollisionPoint;
        var posList = [];
        var pos45 = this.mRoomService.transformToMini45(this.mSprite.pos);
        for (var i = 0; i < count; i++) {
            posList[i] = this.mRoomService.transformToMini90(pos45);
            pos45.y += area.length;
        }
        return this.checkNextPos(posList, area, origin);
    };
    DecoratePanel.prototype.getSouthEastPoints = function (count) {
        if (count === void 0) { count = 10; }
        var area = this.mSprite.currentCollisionArea;
        var origin = this.mSprite.currentCollisionPoint;
        var posList = [];
        var pos45 = this.mRoomService.transformToMini45(this.mSprite.pos);
        for (var i = 0; i < count; i++) {
            posList[i] = this.mRoomService.transformToMini90(pos45);
            pos45.x += area[0].length;
        }
        return this.checkNextPos(posList, area, origin);
    };
    DecoratePanel.prototype.getEastNorthPoints = function (count) {
        if (count === void 0) { count = 10; }
        var area = this.mSprite.currentCollisionArea;
        var origin = this.mSprite.currentCollisionPoint;
        var posList = [];
        var pos45 = this.mRoomService.transformToMini45(this.mSprite.pos);
        for (var i = 0; i < count; i++) {
            posList[i] = this.mRoomService.transformToMini90(pos45);
            pos45.y -= area.length;
        }
        return this.checkNextPos(posList, area, origin);
    };
    DecoratePanel.prototype.checkNextPos = function (pos45, collisionArea, origin) {
        var result = [];
        for (var _i = 0, pos45_1 = pos45; _i < pos45_1.length; _i++) {
            var pos = pos45_1[_i];
            var nextPos = this.getNextRepeatPos(pos, collisionArea, origin);
            if (nextPos) {
                result.push(nextPos);
            }
            else {
                break;
            }
        }
        return result;
    };
    DecoratePanel.prototype.getNextRepeatPos = function (pos, collisionArea, origin) {
        if (this.mRoomService.canPut(pos, collisionArea, origin)) {
            return pos;
        }
    };
    DecoratePanel.prototype.onMoveElement = function (pos45) {
        if (!this.mDisplayObject) {
            return;
        }
        var position = this.mRoomService.transformToMini90(pos45);
        this.emit("moveElement", position);
    };
    DecoratePanel.prototype.createImage = function (key, frame, x, y) {
        return this.scene.make.image({ key: key, frame: frame, x: x, y: y }, false).setInteractive().setOrigin(0);
    };
    DecoratePanel.prototype.validateGrid = function (val) {
        if (val > this.maxGrid) {
            val = this.maxGrid;
        }
        if (val < this.minGrid) {
            val = this.minGrid;
        }
        return val;
    };
    DecoratePanel.prototype.updateArrowPos = function (ele) {
        var _a;
        if (!ele || !ele.model || !ele.getDisplay()) {
            return;
        }
        // return;
        var display = ele.getDisplay();
        var rows = ele.model.currentCollisionArea.length;
        var cols = ele.model.currentCollisionArea[0].length;
        rows = this.validateGrid(rows);
        cols = this.validateGrid(cols);
        if (ele.getDisplay().scaleX === -1) {
            _a = [cols, rows], rows = _a[0], cols = _a[1];
        }
        var miniSize = this.mRoomService.roomSize;
        var position = {
            rows: rows,
            cols: cols,
            tileWidth: miniSize.tileWidth / 2,
            tileHeight: miniSize.tileHeight / 2,
        };
        // const reference = ele.getElement("reference");
        // if (!reference) {
        //     return;
        // }
        var sprite = ele.model;
        var pos = position45["a" /* Position45 */].transformTo90(new utils_pos["a" /* Pos */](cols - sprite.currentCollisionPoint.y, rows - sprite.currentCollisionPoint.x), position);
        this.offset.y = pos.y;
        // let pos = Position45.transformTo90(new Pos(cols, (rows / 2)), position);
        // if (this.mArrow5) {
        //     this.mArrow5.x = pos.x + reference.x;
        //     this.mArrow5.y = pos.y + reference.y;
        // }
        // pos = Position45.transformTo90(new Pos((cols / 2), rows), position);
        // if (this.mArrow3) {
        //     this.mArrow3.x = pos.x - this.mArrow3.width + reference.x;
        //     this.mArrow3.y = pos.y + reference.y;
        // }
        // pos = Position45.transformTo90(new Pos(0, (rows / 2)), position);
        // if (this.mArrow1) {
        //     this.mArrow1.x = pos.x - this.mArrow1.width + reference.x;
        //     this.mArrow1.y = pos.y - this.mArrow1.height + reference.y;
        // }
        // pos = Position45.transformTo90(new Pos((cols / 2), 0), position);
        // if (this.mArrow7) {
        //     this.mArrow7.x = pos.x + reference.x;
        //     this.mArrow7.y = pos.y - this.mArrow7.height + reference.y;
        // }
    };
    DecoratePanel.prototype.onTurnHandler = function () {
        this.mWorld.emitter.emit(MessageType["a" /* MessageType */].TURN_ELEMENT, this.mDisplayObject);
    };
    DecoratePanel.prototype.onRecycleHandler = function () {
        this.mWorld.emitter.emit(MessageType["a" /* MessageType */].RECYCLE_ELEMENT, this.mDisplayObject);
    };
    DecoratePanel.prototype.onCancelHandler = function () {
        this.mWorld.emitter.emit(MessageType["a" /* MessageType */].CANCEL_PUT, this.mDisplayObject);
    };
    DecoratePanel.prototype.onAddHandler = function () {
        if (this.mCanPut) {
            this.mWorld.emitter.emit(MessageType["a" /* MessageType */].PUT_ELEMENT, this.mDisplayObject);
        }
    };
    DecoratePanel.prototype.onMoveHandler = function (dir) {
        if (typeof dir !== "number") {
            return;
        }
        switch (dir) {
            case element_element["a" /* Direction */].north_west:
                this.onLeftUpHandler();
                break;
            case element_element["a" /* Direction */].west_south:
                this.onLeftDownHandler();
                break;
            case element_element["a" /* Direction */].south_east:
                this.onRightDownHandler();
                break;
            case element_element["a" /* Direction */].east_north:
                this.onRightUpHandler();
                break;
        }
    };
    DecoratePanel.prototype.onPutHandler = function () {
        this.mWorld.emitter.emit(MessageType["a" /* MessageType */].PUT_ELEMENT, this.mDisplayObject);
    };
    DecoratePanel.prototype.onRepeatHandler = function (dir) {
        var result = null;
        switch (dir) {
            case element_element["a" /* Direction */].north_west:
                result = this.getNorthWestPoints(2);
                break;
            case element_element["a" /* Direction */].west_south:
                result = this.getWestSouthPoints(2);
                break;
            case element_element["a" /* Direction */].south_east:
                result = this.getSouthEastPoints(2);
                break;
            case element_element["a" /* Direction */].east_north:
                result = this.getEastNorthPoints(2);
                break;
        }
        this.onSendAddSingleSprite(result);
    };
    DecoratePanel.prototype.onHoldRepeatHandler = function (dir) {
        var result = null;
        switch (dir) {
            case element_element["a" /* Direction */].north_west:
                result = this.getNorthWestPoints();
                break;
            case element_element["a" /* Direction */].west_south:
                result = this.getWestSouthPoints();
                break;
            case element_element["a" /* Direction */].south_east:
                result = this.getSouthEastPoints();
                break;
            case element_element["a" /* Direction */].east_north:
                result = this.getEastNorthPoints();
                break;
        }
        this.onSendAddSprites(result);
    };
    DecoratePanel.prototype.onShowMoveMenuHandler = function () {
        this.add(this.mMoveMenuContainer);
        this.remove(this.mRepeatMenuContainer);
    };
    DecoratePanel.prototype.onShowRepeatHandler = function () {
        this.add(this.mRepeatMenuContainer);
        this.remove(this.mMoveMenuContainer);
    };
    DecoratePanel.prototype.onShowExtendsHandler = function () {
        // this.mRoomService.canPut()
        // this.mDisplayObject.
    };
    DecoratePanel.prototype.onSendAddSprites = function (points) {
        if (points.length > 1) {
            this.emit("addSprite", this.mSprite, points);
        }
    };
    DecoratePanel.prototype.onSendAddSingleSprite = function (points) {
        if (points.length > 1) {
            this.emit("addSingleSprite", this.mSprite, points);
        }
    };
    return DecoratePanel;
}(BasePanel["a" /* BasePanel */]));

var decorate_panel_MoveMenu = /** @class */ (function (_super) {
    decorate_panel_extends(MoveMenu, _super);
    function MoveMenu(scene, key, dpr, uiScale) {
        if (dpr === void 0) { dpr = 1; }
        if (uiScale === void 0) { uiScale = 1; }
        var _this = _super.call(this, scene) || this;
        var bg = scene.make.image({
            key: key,
            frame: "bg.png"
        }, false);
        _this.setSize(bg.displayWidth, bg.displayHeight);
        // this.mArrow1 = scene.make.image({
        //     key,
        //     frame: "arrow_1.png"
        // }, false).setInteractive().setData("dir", 1);
        // this.mArrow3 = scene.make.image({
        //     key,
        //     frame: "arrow_3.png"
        // }, false).setInteractive().setData("dir", 3);
        // this.mArrow5 = scene.make.image({
        //     key,
        //     frame: "arrow_5.png"
        // }, false).setInteractive().setData("dir", 5);
        // this.mArrow7 = scene.make.image({
        //     key,
        //     frame: "arrow_7.png"
        // }, false).setInteractive().setData("dir", 7);
        _this.mArrow1 = new Button_Button(_this.scene, key, "arrow_1.png");
        _this.mArrow1.setData("dir", element_element["a" /* Direction */].north_west);
        _this.mArrow3 = new Button_Button(_this.scene, key, "arrow_3.png");
        _this.mArrow3.setData("dir", element_element["a" /* Direction */].west_south);
        _this.mArrow5 = new Button_Button(_this.scene, key, "arrow_5.png");
        _this.mArrow5.setData("dir", element_element["a" /* Direction */].south_east);
        _this.mArrow7 = new Button_Button(_this.scene, key, "arrow_7.png");
        _this.mArrow7.setData("dir", element_element["a" /* Direction */].east_north);
        _this.mBtns = [_this.mArrow1, _this.mArrow3, _this.mArrow5, _this.mArrow7];
        _this.add(bg);
        _this.add(_this.mBtns);
        var w = _this.width;
        var totalWidth = _this.width - 20 * dpr;
        _this.mBtns.map(function (btn) { return totalWidth -= btn.displayWidth; });
        var space = totalWidth = totalWidth / (_this.mBtns.length - 1);
        var arrowH = (3 * dpr);
        for (var i = 0; i < _this.mBtns.length; i++) {
            if (i === 0) {
                _this.mBtns[i].x = 10 * dpr + _this.mBtns[i].width / 2 - _this.width / 2;
            }
            else {
                _this.mBtns[i].x = space + _this.mBtns[i - 1].x + _this.mBtns[i - 1].width;
            }
            _this.mBtns[i].y = arrowH;
        }
        _this.setInteractive();
        return _this;
    }
    MoveMenu.prototype.register = function () {
        // for (const btn of this.mBtns) {
        //     btn.on("pointerup", this.onArrowHandler, this);
        // }
        this.mArrow1.on("Hold", this.onHoldHandler, this);
        this.mArrow1.on("Tap", this.onClickHandler, this);
        this.mArrow3.on("Hold", this.onHoldHandler, this);
        this.mArrow3.on("Tap", this.onClickHandler, this);
        this.mArrow5.on("Hold", this.onHoldHandler, this);
        this.mArrow5.on("Tap", this.onClickHandler, this);
        this.mArrow7.on("Hold", this.onHoldHandler, this);
        this.mArrow7.on("Tap", this.onClickHandler, this);
        // this.mArrow1.on("pointerup", this.onArrow1Handler, this);
        // this.mArrow3.on("pointerup", this.onArrow3Handler, this);
        // this.mArrow5.on("pointerup", this.onArrow5Handler, this);
        // this.mArrow7.on("pointerup", this.onArrow7Handler, this);
    };
    MoveMenu.prototype.unRegister = function () {
        this.mArrow1.off("Hold", this.onHoldHandler, this);
        this.mArrow1.off("Tap", this.onClickHandler, this);
        this.mArrow3.off("Hold", this.onHoldHandler, this);
        this.mArrow3.off("Tap", this.onClickHandler, this);
        this.mArrow5.off("Hold", this.onHoldHandler, this);
        this.mArrow5.off("Tap", this.onClickHandler, this);
        this.mArrow7.off("Hold", this.onHoldHandler, this);
        this.mArrow7.off("Tap", this.onClickHandler, this);
        // this.mArrow1.off("pointerup", this.onArrow1Handler, this);
        // this.mArrow3.off("pointerup", this.onArrow3Handler, this);
        // this.mArrow5.off("pointerup", this.onArrow5Handler, this);
        // this.mArrow7.off("pointerup", this.onArrow7Handler, this);
    };
    MoveMenu.prototype.onArrow1Handler = function (pointer) {
        this.emit("move", element_element["a" /* Direction */].north_west);
    };
    MoveMenu.prototype.onArrow3Handler = function () {
        this.emit("move", element_element["a" /* Direction */].west_south);
    };
    MoveMenu.prototype.onArrow5Handler = function () {
        this.emit("move", element_element["a" /* Direction */].south_east);
    };
    MoveMenu.prototype.onArrow7Handler = function () {
        this.emit("move", element_element["a" /* Direction */].east_north);
    };
    MoveMenu.prototype.onHoldHandler = function (gameobject) {
        this.emit("hold", gameobject.getData("dir"));
    };
    MoveMenu.prototype.onClickHandler = function (pointer, gameobject) {
        this.emit("move", gameobject.getData("dir"));
    };
    return MoveMenu;
}(Phaser.GameObjects.Container));

// CONCATENATED MODULE: ./src/ui/decorate/decorate.manager.ts
var decorate_manager_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var decorate_manager_DecorateManager = /** @class */ (function (_super) {
    decorate_manager_extends(DecorateManager, _super);
    function DecorateManager(scene, roomService) {
        var _this = _super.call(this) || this;
        _this.mPanel = new decorate_panel_DecoratePanel(scene, roomService);
        _this.mPanel.on("moveElement", _this.onMoveElementHandler, _this);
        _this.mPanel.on("addSprite", _this.onAddSpriteHandler, _this);
        _this.mPanel.on("addSingleSprite", _this.onAddSingleSprtieHandle, _this);
        _this.mRoomService = roomService;
        _this.mLayerManager = roomService.layerManager;
        return _this;
    }
    DecorateManager.prototype.setElement = function (ele) {
        this.mPanel.setElement(ele);
        this.mLayerManager.addToSceneToUI(this.mPanel);
        this.mPanel.show();
    };
    DecorateManager.prototype.canPut = function (val) {
        if (this.mPanel) {
            this.mPanel.canPUt(val);
        }
    };
    DecorateManager.prototype.remove = function () {
        // TODO panel只有destroy。需要封装个仅移除的方法
        if (this.mPanel.parentContainer) {
            this.mPanel.parentContainer.remove(this.mPanel);
        }
        this.mPanel.removeListen();
    };
    DecorateManager.prototype.updatePos = function (x, y) {
        if (!this.mPanel) {
            return;
        }
        this.mPanel.setPos(x, y);
    };
    DecorateManager.prototype.destroy = function () {
        if (this.mPanel) {
            this.mPanel.destroy();
        }
        _super.prototype.destroy.call(this);
    };
    DecorateManager.prototype.onMoveElementHandler = function (pos) {
        this.emit("moveElement", pos);
    };
    DecorateManager.prototype.onAddSpriteHandler = function (sprite, points) {
        this.sendAddSpriteByType(sprite, points);
    };
    DecorateManager.prototype.onAddSingleSprtieHandle = function (sprite, points) {
        this.sendAddSingleSprite(sprite, points);
    };
    DecorateManager.prototype.sendAddSpriteByType = function (sprite, points) {
        if (!sprite || !points || points.length < 1) {
            return;
        }
        var packet = new dist["PBpacket"](protocols["op_virtual_world"].OPCODE._OP_CLIENT_REQ_VIRTUAL_WORLD_EDIT_MODE_ADD_SPRITE_BY_TYPE);
        var content = packet.content;
        var pos = [];
        for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
            var point = points_1[_i];
            var p = protocols["op_def"].PBPoint3f.create();
            p.x = point.x;
            p.y = point.y;
            pos.push(p);
        }
        content.nodeType = protocols["op_def"].NodeType.ElementNodeType;
        content.sprite = sprite.toSprite();
        content.points = pos;
        this.mRoomService.connection.send(packet);
    };
    DecorateManager.prototype.sendAddSingleSprite = function (sprite, points) {
        if (!sprite || !points || points.length < 1) {
            return;
        }
        var packet = new dist["PBpacket"](protocols["op_virtual_world"].OPCODE._OP_CLIENT_REQ_VIRTUAL_WORLD_EDIT_MODE_ADD_SINGLE_SPRITE_BY_TYPE);
        var content = packet.content;
        var pos = [];
        for (var _i = 0, points_2 = points; _i < points_2.length; _i++) {
            var point = points_2[_i];
            var p = protocols["op_def"].PBPoint3f.create();
            p.x = point.x;
            p.y = point.y;
            pos.push(p);
        }
        content.nodeType = protocols["op_def"].NodeType.ElementNodeType;
        content.sprite = sprite.toSprite();
        content.points = pos;
        this.mRoomService.connection.send(packet);
    };
    return DecorateManager;
}(Phaser.Events.EventEmitter));


// CONCATENATED MODULE: ./src/rooms/decorate/selector.element.ts



var selector_element_SelectorElement = /** @class */ (function () {
    function SelectorElement(mElement) {
        this.mElement = mElement;
        this.mScene = this.mElement.scene;
        this.mRoomService = this.mElement.roomService;
        this.mDecorateManager = new decorate_manager_DecorateManager(this.mScene, this.mRoomService);
        this.mDecorateManager.setElement(mElement);
        var display = mElement.getDisplay();
        if (!display.collisionArea) {
            display.once("initialized", function () {
                display.showRefernceArea();
            });
        }
        else {
            display.showRefernceArea();
        }
        this.mSelecting = true;
        this.mDecorateManager.on("moveElement", this.onMoveElementHandler, this);
        this.mRoomService.world.emitter.emit(MessageType["a" /* MessageType */].EDIT_PACKAGE_COLLAPSE);
        this.mRoomService.world.emitter.emit(MessageType["a" /* MessageType */].SELECTED_DECORATE_ELEMENT);
    }
    SelectorElement.prototype.turnElement = function () {
        if (!this.mElement) {
            return;
        }
        this.mElement.turn();
        this.checkCanPut();
    };
    SelectorElement.prototype.setDisplayPos = function (pos) {
        if (!this.mElement) {
            return;
        }
        this.mElement.setPosition(pos);
        this.checkCanPut();
    };
    SelectorElement.prototype.update = function (time, delta) {
        if (this.mElement) {
            var pos = this.mElement.getPosition();
            this.mDecorateManager.updatePos(pos.x, pos.y);
            this.checkCanPut();
        }
    };
    SelectorElement.prototype.clone = function () {
        if (!this.mElement) {
            return;
        }
        var sprite = this.mElement.model;
        var pos = sprite.pos;
        this.mSourceData = {
            x: pos.x,
            y: pos.y,
            z: pos.z,
            direction: sprite.direction
        };
    };
    SelectorElement.prototype.recover = function () {
        if (!this.mElement) {
            return;
        }
        if (this.mSourceData) {
            this.mElement.setAlpha(1);
            this.mElement.setPosition(new utils_pos["a" /* Pos */](this.mSourceData.x, this.mSourceData.y));
            this.mElement.setDirection(this.mSourceData.direction);
        }
    };
    SelectorElement.prototype.destroy = function () {
        if (this.mDecorateManager) {
            this.mDecorateManager.destroy();
        }
        if (this.mElement) {
            var display = this.mElement.getDisplay();
            if (display) {
                display.hideRefernceArea();
            }
        }
        this.mSourceData = undefined;
        this.mRoomService.world.emitter.emit(MessageType["a" /* MessageType */].EDIT_PACKAGE_EXPANED);
        this.mRoomService.world.emitter.emit(MessageType["a" /* MessageType */].CANCEL_DECORATE_ELEMENT);
    };
    SelectorElement.prototype.checkCanPut = function () {
        if (!this.mRoomService || !this.mElement) {
            return;
        }
        var sprite = this.mElement.model;
        var canPut = this.mRoomService.canPut(this.mElement.getPosition(), sprite.currentCollisionArea, sprite.currentCollisionPoint);
        if (canPut) {
            this.element.setAlpha(1);
        }
        else {
            this.element.setAlpha(0.6);
        }
        if (this.mDecorateManager) {
            this.mDecorateManager.canPut(canPut);
        }
    };
    SelectorElement.prototype.onMoveElementHandler = function (pos) {
        if (!pos) {
            return;
        }
        this.setDisplayPos(pos);
    };
    Object.defineProperty(SelectorElement.prototype, "selecting", {
        get: function () {
            return this.mSelecting;
        },
        set: function (val) {
            this.mSelecting = val;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SelectorElement.prototype, "element", {
        get: function () {
            return this.mElement;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SelectorElement.prototype, "root", {
        get: function () {
            return this.mSourceData;
        },
        enumerable: false,
        configurable: true
    });
    return SelectorElement;
}());


// CONCATENATED MODULE: ./src/rooms/decorate.room.ts
var decorate_room_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


















var decorate_room_DecorateRoom = /** @class */ (function (_super) {
    decorate_room_extends(DecorateRoom, _super);
    function DecorateRoom(manager) {
        var _this = _super.call(this) || this;
        // TODO clock sync
        _this.clockSyncComplete = true;
        _this.world = manager.world;
        _this.mScaleRatio = _this.world.scaleRatio;
        if (_this.connection) {
            _this.connection.addPacketListener(_this);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_RES_CLIENT_EDIT_MODE_SELECTED_SPRITE, _this.onSelectSpriteHandler);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_RES_CLIENT_EDIT_MODE_GET_SPAWN_POINT, _this.onShowSpawnPointHandler);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_RES_CLIENT_EDIT_MODE_ADD_SPRITE_BY_TYPE, _this.onAddSpriteHandler);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_RES_CLIENT_EDIT_MODE_ADD_SINGLE_SPRITE_BY_TYPE, _this.onAddSingleSpriteHandler);
        }
        return _this;
    }
    DecorateRoom.prototype.enter = function (room) {
        var _this = this;
        // this.mID = room.id;
        this.mID = room.id;
        var rows = room.rows, cols = room.cols, tileWidth = room.tileWidth, tileHeight = room.tileHeight;
        this.mSize = {
            cols: room.cols,
            rows: room.rows,
            tileHeight: room.tileHeight,
            tileWidth: room.tileWidth,
            sceneWidth: (room.rows + room.cols) * (room.tileWidth / 2),
            sceneHeight: (room.rows + room.cols) * (room.tileHeight / 2)
        };
        rows *= 2;
        cols *= 2;
        tileWidth /= 2;
        tileHeight /= 2;
        this.mMiniSize = {
            cols: cols,
            rows: rows,
            tileHeight: tileHeight,
            tileWidth: tileWidth,
            sceneWidth: (rows + cols) * (tileWidth / 2),
            sceneHeight: (rows + cols) * (tileHeight / 2),
        };
        this.mMap = new Array(rows);
        for (var i = 0; i < rows; i++) {
            this.mMap[i] = new Array(cols).fill(0);
        }
        this.mCameraService = new cameras_manager["a" /* CamerasManager */](this);
        // if (!this.world.game.scene.getScene(LoadingScene.name))
        //     this.world.game.scene.add(LoadingScene.name, LoadingScene, false);
        // this.world.game.scene.start(LoadingScene.name, {
        //     world: this.world,
        //     room: this
        // });
        this.world.showLoading().then(function () {
            _this.completeLoad();
        });
    };
    DecorateRoom.prototype.addBlockObject = function (object) {
        if (this.mBlocks) {
            this.mBlocks.add(object);
        }
    };
    DecorateRoom.prototype.addMouseListen = function () {
    };
    DecorateRoom.prototype.addToGround = function (element) {
        this.mLayerManager.addToGround(element);
    };
    DecorateRoom.prototype.addToSceneUI = function (element) {
        this.mLayerManager.addToSceneToUI(element);
    };
    DecorateRoom.prototype.addToSurface = function (element) {
        this.mLayerManager.addToSurface(element);
    };
    DecorateRoom.prototype.addToUI = function (element) {
    };
    DecorateRoom.prototype.completeLoad = function () {
        this.world.game.scene.add(play["a" /* PlayScene */].name, play["a" /* PlayScene */], true, {
            room: this
        });
    };
    DecorateRoom.prototype.destroy = function () {
        if (this.mTerrainManager)
            this.mTerrainManager.destroy();
        if (this.mElementManager)
            this.mElementManager.destroy();
        if (this.mLayerManager)
            this.mLayerManager.destroy();
        if (this.mBlocks)
            this.mBlocks.destroy();
        this.removePointerMoveHandler();
        this.world.game.scene.remove(play["a" /* PlayScene */].name);
        this.world.emitter.off(MessageType["a" /* MessageType */].TURN_ELEMENT, this.onTurnElementHandler, this);
        this.world.emitter.off(MessageType["a" /* MessageType */].RECYCLE_ELEMENT, this.onRecycleHandler, this);
        this.world.emitter.off(MessageType["a" /* MessageType */].PUT_ELEMENT, this.onPutElement, this);
        this.world.emitter.off(MessageType["a" /* MessageType */].CANCEL_PUT, this.onCancelPutHandler, this);
        if (!this.mScene)
            return;
        this.mScene.input.off("pointerup", this.onPointerUpHandler, this);
        this.mScene.input.off("pointerdown", this.onPointerDownHandler, this);
        this.mScene.input.off("gameobjectdown", this.onGameobjectUpHandler, this);
    };
    DecorateRoom.prototype.now = function () {
        return 0;
    };
    DecorateRoom.prototype.pause = function () {
        if (this.mScene) {
            this.mScene.scene.pause();
        }
    };
    DecorateRoom.prototype.removeBlockObject = function (object) {
        if (this.mBlocks) {
            this.mBlocks.remove(object);
        }
    };
    DecorateRoom.prototype.requestActorMove = function (d, key) {
    };
    DecorateRoom.prototype.resume = function (name) {
        if (this.mScene) {
            this.mScene.scene.resume(name);
        }
    };
    DecorateRoom.prototype.startLoad = function () {
    };
    DecorateRoom.prototype.startPlay = function () {
        if (this.mLayerManager) {
            this.mLayerManager.destroy();
        }
        this.mScene = this.world.game.scene.getScene(play["a" /* PlayScene */].name);
        this.mLayerManager = new layer_manager["a" /* LayerManager */](this);
        this.mLayerManager.drawGrid(this);
        this.mTerrainManager = new decorate_terrain_manager_DecorateTerrainManager(this);
        this.mElementManager = new decorate_element_manager_DecorateElementManager(this);
        this.mBlocks = new viewblock_manager["a" /* ViewblockManager */](this.mCameraService);
        this.mBlocks.int(this.mSize);
        this.mScene.input.on("pointerup", this.onPointerUpHandler, this);
        this.mScene.input.on("pointerdown", this.onPointerDownHandler, this);
        this.mScene.input.on("gameobjectdown", this.onGameobjectUpHandler, this);
        // const mainCameras = this.mScene.cameras.main;
        var camera = this.scene.cameras.main;
        this.mCameraService.camera = camera;
        var zoom = Math.ceil(window.devicePixelRatio);
        this.mCameraService.setBounds(-camera.width >> 1, -camera.height >> 1, this.mSize.sceneWidth * zoom + camera.width, this.mSize.sceneHeight * zoom + camera.height);
        if (this.cameraPos) {
            this.mCameraService.scrollTargetPoint(this.cameraPos.x, this.cameraPos.y);
            this.mCameraService.syncCameraScroll();
        }
        this.world.changeRoom(this);
        var loadingScene = this.world.game.scene.getScene(loading["a" /* LoadingScene */].name);
        if (loadingScene)
            loadingScene.sleep();
        this.connection.send(new dist["PBpacket"](protocols["op_virtual_world"].OPCODE._OP_CLIENT_REQ_VIRTUAL_WORLD_SCENE_CREATED));
        // this.mCameraService.centerCameas();
        if (this.world.uiManager) {
            this.world.uiManager.showDecorateUI();
        }
        this.world.emitter.on(MessageType["a" /* MessageType */].TURN_ELEMENT, this.onTurnElementHandler, this);
        this.world.emitter.on(MessageType["a" /* MessageType */].RECYCLE_ELEMENT, this.onRecycleHandler, this);
        this.world.emitter.on(MessageType["a" /* MessageType */].PUT_ELEMENT, this.onPutElement, this);
        this.world.emitter.on(MessageType["a" /* MessageType */].CANCEL_PUT, this.onCancelPutHandler, this);
    };
    DecorateRoom.prototype.transformTo45 = function (p) {
        if (!this.mSize) {
            log["a" /* Logger */].getInstance().error("position object is undefined");
            return;
        }
        return position45["a" /* Position45 */].transformTo45(p, this.mSize);
    };
    DecorateRoom.prototype.transformTo90 = function (p) {
        if (!this.mSize) {
            log["a" /* Logger */].getInstance().error("position object is undefined");
            return;
        }
        return position45["a" /* Position45 */].transformTo90(p, this.mSize);
    };
    DecorateRoom.prototype.transformToMini90 = function (p) {
        if (!this.mMiniSize) {
            log["a" /* Logger */].getInstance().error("position object is undefined");
            return;
        }
        return position45["a" /* Position45 */].transformTo90(p, this.mMiniSize);
    };
    DecorateRoom.prototype.transformToMini45 = function (p) {
        if (!this.mMiniSize) {
            log["a" /* Logger */].getInstance().error("position object is undefined");
            return;
        }
        return position45["a" /* Position45 */].transformTo45(p, this.mMiniSize);
    };
    DecorateRoom.prototype.update = function (time, delta) {
        if (this.mLayerManager) {
            this.mLayerManager.update(time, delta);
        }
        if (this.mSelectorElement) {
            this.mSelectorElement.update(time, delta);
        }
        if (this.mBlocks) {
            this.mBlocks.update(time, delta);
        }
    };
    DecorateRoom.prototype.updateBlockObject = function () {
    };
    DecorateRoom.prototype.resize = function (width, height) {
        this.layerManager.resize(width, height);
        this.mCameraService.resize(width, height);
    };
    DecorateRoom.prototype.transitionGrid = function (x, y) {
        var source = new utils_pos["a" /* Pos */](x, y);
        var pos = this.transformToMini45(source);
        return this.checkBound(pos);
    };
    DecorateRoom.prototype.addElements = function (sprites, nodeType) {
        if (nodeType === protocols["op_def"].NodeType.ElementNodeType) {
            this.mElementManager.add(sprites);
        }
        else if (nodeType === protocols["op_def"].NodeType.TerrainNodeType) {
            this.mTerrainManager.add(sprites);
        }
    };
    DecorateRoom.prototype.setEnterPos = function (x, y) {
        this.cameraPos = new utils_pos["a" /* Pos */](x, y);
    };
    /**
     * 边界检查
     * @param pos 45度坐标，
     * @param source 没有超出边界并不贴边就返回原始坐标
     */
    DecorateRoom.prototype.checkBound = function (pos, source) {
        var bound = new utils_pos["a" /* Pos */](pos.x, pos.y);
        var size = this.mMiniSize;
        if (pos.x < 0) {
            bound.x = 0;
        }
        else if (pos.x > size.cols) {
            bound.x = size.cols;
        }
        if (pos.y < 0) {
            bound.y = 0;
        }
        else if (pos.y > size.rows) {
            bound.y = size.rows;
        }
        if (bound.equal(pos) && source) {
            return source;
        }
        return this.transformToMini90(bound);
    };
    DecorateRoom.prototype.canPut = function (pos, collisionArea, origin) {
        if (!collisionArea || !origin) {
            return;
        }
        var pos45 = this.transformToMini45(pos);
        if (pos45.x < 0 || pos45.y < 0 || pos45.x > this.miniSize.rows || pos45.y > this.miniSize.cols) {
            return false;
        }
        var row = 0;
        var col = 0;
        var map = this.mElementManager.map;
        for (var i = 0; i < collisionArea.length; i++) {
            row = i + pos45.y - origin.y;
            if (row >= map.length) {
                return false;
            }
            for (var j = 0; j < collisionArea[i].length; j++) {
                col = j + pos45.x - origin.x;
                if (col >= map[i].length || map[row][col] === 0) {
                    return false;
                }
            }
        }
        return true;
    };
    DecorateRoom.prototype.setMap = function (cols, rows, type) {
        if (rows < 0 || cols < 0 || this.mMap.length < rows || this.mMap[0].length < cols) {
            return;
        }
        this.mMap[cols][rows] = type;
    };
    DecorateRoom.prototype.addPointerMoveHandler = function () {
        if (!this.mScene)
            return;
        this.mScene.input.on("pointermove", this.onPointerMoveHandler, this);
        this.mScene.input.on("gameout", this.onGameOutHandler, this);
    };
    DecorateRoom.prototype.removePointerMoveHandler = function () {
        if (!this.mScene)
            return;
        this.mScene.input.off("pointermove", this.onPointerMoveHandler, this);
        this.mScene.input.off("gameout", this.onGameOutHandler, this);
    };
    DecorateRoom.prototype.onPointerUpHandler = function (pointer) {
        this.removePointerMoveHandler();
        if (this.mSelectorElement) {
            this.mSelectorElement.selecting = false;
        }
    };
    DecorateRoom.prototype.onPointerDownHandler = function () {
        this.addPointerMoveHandler();
    };
    DecorateRoom.prototype.onGameobjectUpHandler = function (pointer, gameobject) {
        // this.addPointerMoveHandler();
        var com = gameobject.parentContainer;
        if (!com) {
            return;
        }
        if (!(com instanceof display_object["a" /* DisplayObject */])) {
            return;
        }
        if (com instanceof terrain_display["a" /* TerrainDisplay */]) {
            return;
        }
        this.selectedElement(com.element);
    };
    DecorateRoom.prototype.onPointerMoveHandler = function (pointer) {
        if (!this.mSelectorElement || (this.mSelectorElement && this.mSelectorElement.selecting === false)) {
            this.moveCamera(pointer);
            return;
        }
        if (pointer.downX === pointer.x && pointer.downY === pointer.y) {
            return;
        }
        // if (pointer.downX !== pointer.upX && pointer.downY !== pointer.upY) {
        this.moveElement(pointer);
    };
    DecorateRoom.prototype.onGameOutHandler = function () {
        this.removePointerMoveHandler();
    };
    DecorateRoom.prototype.moveCamera = function (pointer) {
        this.cameraService.offsetScroll(pointer.prevPosition.x - pointer.position.x, pointer.prevPosition.y - pointer.position.y);
    };
    DecorateRoom.prototype.moveElement = function (pointer) {
        var pos = this.transitionGrid(pointer.worldX / this.mScaleRatio, pointer.worldY / this.mScaleRatio);
        if (this.mSelectorElement) {
            this.mSelectorElement.setDisplayPos(pos);
        }
        // this.mSelectedElement.setDisplayPos(pos.x, pos.y);
    };
    DecorateRoom.prototype.removeElement = function (id, nodeType) {
        if (nodeType === protocols["op_def"].NodeType.ElementNodeType || nodeType === protocols["op_def"].NodeType.SpawnPointType) {
            this.elementManager.remove(id);
        }
        else if (nodeType === protocols["op_def"].NodeType.TerrainNodeType) {
            this.elementManager.remove(id);
        }
    };
    DecorateRoom.prototype.addElement = function (sprite, addMap) {
        var nodeType = sprite.nodeType;
        if (nodeType === protocols["op_def"].NodeType.ElementNodeType || nodeType === protocols["op_def"].NodeType.SpawnPointType) {
            this.mElementManager.add([sprite], addMap);
        }
        else if (nodeType === protocols["op_def"].NodeType.TerrainNodeType) {
            this.mTerrainManager.add([sprite]);
        }
    };
    DecorateRoom.prototype.selectedElement = function (element, isClone) {
        if (isClone === void 0) { isClone = true; }
        if (!element) {
            return;
        }
        if (!this.mSelectorElement) {
            this.mSelectorElement = new selector_element_SelectorElement(element);
            if (isClone) {
                this.mSelectorElement.clone();
                this.elementManager.removeMap(element.model);
            }
            this.mSelectorElement.update();
        }
        else {
            if (this.mSelectorElement.element === element) {
                this.mSelectorElement.selecting = true;
            }
            else {
                this.onPutElement(null);
                // this.cancelSelector();
                this.selectedElement(element, isClone);
            }
        }
    };
    DecorateRoom.prototype.cancelSelector = function () {
        if (this.mSelectorElement) {
            var sprite = null;
            if (this.mSelectorElement.root) {
                sprite = this.mSelectorElement.element.model;
            }
            this.mSelectorElement.destroy();
            this.mSelectorElement = undefined;
            if (sprite) {
                this.mElementManager.addMap(sprite);
            }
        }
    };
    DecorateRoom.prototype.onTurnElementHandler = function (display) {
        if (!this.mSelectorElement) {
            return;
        }
        this.mSelectorElement.turnElement();
    };
    DecorateRoom.prototype.onRecycleHandler = function (display) {
        if (!this.mSelectorElement) {
            return;
        }
        var element = this.mSelectorElement.element;
        var sprite = element.model;
        if (!sprite) {
            return;
        }
        var packet = new dist["PBpacket"](protocols["op_virtual_world"].OPCODE._OP_CLIENT_REQ_VIRTUAL_WORLD_EDIT_MODE_RECYCLE_SPRITE);
        var content = packet.content;
        content.sprites = [sprite.toSprite()];
        content.nodeType = sprite.nodeType;
        this.world.connection.send(packet);
        this.mSelectorElement.destroy();
        this.mSelectorElement = undefined;
    };
    DecorateRoom.prototype.onPutElement = function (display) {
        this.removePointerMoveHandler();
        if (!this.mSelectorElement) {
            return;
        }
        var element = this.mSelectorElement.element;
        if (!element) {
            return;
        }
        var sprite = element.model;
        if (!sprite) {
            return;
        }
        if (this.canPut(sprite.pos, sprite.currentCollisionArea, sprite.currentCollisionPoint)) {
            if (this.mSelectorElement.root) {
                this.sendUpdateSprite(sprite);
            }
            else {
                if (sprite.nodeType === protocols["op_def"].NodeType.SpawnPointType) {
                    this.sendSpawnPoint(sprite.pos);
                    this.removeElement(sprite.id, sprite.nodeType);
                }
                else {
                    this.sendAddSprite(sprite);
                }
            }
            this.cancelSelector();
        }
        else {
            this.onCancelPutHandler(element);
        }
    };
    DecorateRoom.prototype.onCancelPutHandler = function (element) {
        this.removePointerMoveHandler();
        if (!this.mSelectorElement) {
            return;
        }
        if (!element) {
            element = this.mElementManager.get(this.mSelectorElement.element.id);
        }
        if (!element) {
            return;
        }
        var root = this.mSelectorElement.root;
        if (root) {
            this.mSelectorElement.recover();
        }
        else {
            this.removeElement(element.id, element.model.nodeType);
        }
        this.cancelSelector();
    };
    DecorateRoom.prototype.sendAddSprite = function (sprite) {
        var packet = new dist["PBpacket"](protocols["op_virtual_world"].OPCODE._OP_CLIENT_REQ_VIRTUAL_WORLD_EDIT_MODE_ADD_SPRITE);
        var content = packet.content;
        content.sprites = [sprite.toSprite()];
        content.nodeType = sprite.nodeType;
        this.connection.send(packet);
    };
    DecorateRoom.prototype.sendUpdateSprite = function (sprite) {
        var packet = new dist["PBpacket"](protocols["op_virtual_world"].OPCODE._OP_CLIENT_REQ_VIRTUAL_WORLD_EDIT_MODE_UPDATE_SPRITE);
        var content = packet.content;
        content.sprites = [sprite.toSprite()];
        content.nodeType = sprite.nodeType;
        this.connection.send(packet);
    };
    DecorateRoom.prototype.sendSpawnPoint = function (pos) {
        var packet = new dist["PBpacket"](protocols["op_virtual_world"].OPCODE._OP_CLIENT_REQ_VIRTUAL_WORLD_EDIT_MODE_SET_SPAWN_POINT);
        var content = packet.content;
        var pos3f = protocols["op_def"].PBPoint3f.create();
        pos3f.x = pos.x;
        pos3f.y = pos.y;
        content.spawnPoint = pos3f;
        this.connection.send(packet);
    };
    DecorateRoom.prototype.sendPosition = function (sprite) {
        var packet = new dist["PBpacket"](protocols["op_virtual_world"].OPCODE._OP_CLIENT_REQ_VIRTUAL_WORLD_EDIT_MODE_CHANGE_SPRITE_POSITION);
        var content = packet.content;
        content.sprites = [sprite.toSprite()];
        content.nodeType = sprite.nodeType;
        this.connection.send(packet);
    };
    DecorateRoom.prototype.onSelectSpriteHandler = function (packet) {
        var content = packet.content;
        var camera = this.cameraService.camera;
        var sprite = new element_sprite["a" /* Sprite */](content.sprite, content.nodeType);
        sprite.setPosition((camera.scrollX + camera.width / 2) / this.world.scaleRatio, (camera.scrollY + camera.height / 2) / this.world.scaleRatio);
        this.addElement(sprite, false);
        var element = this.mElementManager.get(content.sprite.id);
        if (element)
            this.selectedElement(element, false);
    };
    DecorateRoom.prototype.onShowSpawnPointHandler = function (packet) {
        var content = packet.content;
        var spawnPoint = new spawn_point_SpawnPoint();
        var pos = content.spawnPoint;
        spawnPoint.setPosition(pos.x, pos.y);
        this.addElement(spawnPoint, false);
        this.selectedElement(this.mElementManager.get(spawnPoint.id), false);
        // this.mSelectedElement.setSprite(spawnPoint);
        this.mCameraService.scrollTargetPoint(pos.x, pos.y);
    };
    DecorateRoom.prototype.onAddSpriteHandler = function (packet) {
        var content = packet.content;
        // if (this.mSelectedElement.root && content.id === this.mSelectedElement.root.id) {
        //     this.addElement(this.mSelectedElement.sprite);
        // }
        // this.mSelectedElement.remove();
        this.cancelSelector();
    };
    DecorateRoom.prototype.onAddSingleSpriteHandler = function (packet) {
        var content = packet.content;
        var addedSprites = content.addedSprites;
        if (addedSprites) {
            var sprites = [];
            for (var _i = 0, addedSprites_1 = addedSprites; _i < addedSprites_1.length; _i++) {
                var sprite = addedSprites_1[_i];
                sprites.push(new element_sprite["a" /* Sprite */](sprite, content.nodeType));
            }
            if (sprites.length > 0) {
                this.mElementManager.add(sprites);
                var ele = this.mElementManager.get(sprites[sprites.length - 1].id);
                if (ele) {
                    this.cancelSelector();
                    this.selectedElement(ele);
                    if (this.mSelectorElement)
                        this.mSelectorElement.selecting = false;
                }
            }
        }
    };
    Object.defineProperty(DecorateRoom.prototype, "id", {
        get: function () {
            return this.mID;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DecorateRoom.prototype, "roomSize", {
        get: function () {
            return this.mSize;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DecorateRoom.prototype, "terrainManager", {
        get: function () {
            return this.mTerrainManager;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DecorateRoom.prototype, "elementManager", {
        get: function () {
            return this.mElementManager;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DecorateRoom.prototype, "layerManager", {
        get: function () {
            return this.mLayerManager;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DecorateRoom.prototype, "cameraService", {
        get: function () {
            return this.mCameraService;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DecorateRoom.prototype, "scene", {
        get: function () {
            return this.mScene;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DecorateRoom.prototype, "connection", {
        get: function () {
            return this.world.connection;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DecorateRoom.prototype, "miniSize", {
        get: function () {
            return this.mMiniSize;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DecorateRoom.prototype, "selectedSprite", {
        get: function () {
            if (!this.mSelectorElement) {
                return;
            }
            return this.mSelectorElement.element;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DecorateRoom.prototype, "enableEdit", {
        get: function () {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DecorateRoom.prototype, "sceneType", {
        get: function () {
            return protocols["op_def"].SceneTypeEnum.EDIT_SCENE_TYPE;
        },
        enumerable: false,
        configurable: true
    });
    return DecorateRoom;
}(dist["PacketHandler"]));



/***/ }),
/* 97 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ dragonbones_display_DragonbonesDisplay; });

// UNUSED EXPORTS: AvatarSlotType, AvatarPartType

// EXTERNAL MODULE: ./src/utils/resUtil.ts + 1 modules
var resUtil = __webpack_require__(8);

// EXTERNAL MODULE: ./src/rooms/display/display.object.ts + 1 modules
var display_object = __webpack_require__(29);

// CONCATENATED MODULE: ./lib/rexui/lib/ui/interface/sound/ISoundConfig.ts
var SoundField;
(function (SoundField) {
    SoundField[SoundField["Background"] = 0] = "Background";
    SoundField[SoundField["Element"] = 1] = "Element";
    SoundField[SoundField["Effect"] = 2] = "Effect";
})(SoundField || (SoundField = {}));

// CONCATENATED MODULE: ./src/rooms/display/dragonbones.display.ts
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var AvatarSlotType;
(function (AvatarSlotType) {
    AvatarSlotType["BodyCostDres"] = "body_cost_$_dres";
    AvatarSlotType["BodyCost"] = "body_cost_$";
    AvatarSlotType["BodyTail"] = "body_tail_$";
    AvatarSlotType["BodyWing"] = "body_wing_$";
    AvatarSlotType["BodyBase"] = "body_base_$";
    AvatarSlotType["BodySpec"] = "body_spec_$";
    AvatarSlotType["FlegSpec"] = "fleg_spec_$";
    AvatarSlotType["FlegBase"] = "fleg_base_$";
    AvatarSlotType["FlegCost"] = "fleg_cost_$";
    AvatarSlotType["BarmSpec"] = "barm_spec_$";
    AvatarSlotType["BarmBase"] = "barm_base_$";
    AvatarSlotType["BarmCost"] = "barm_cost_$";
    AvatarSlotType["WeapBarm"] = "weap_barm_$";
    AvatarSlotType["ShldBarm"] = "shld_barm_$";
    AvatarSlotType["BlegSpec"] = "bleg_spec_$";
    AvatarSlotType["BlegBase"] = "bleg_base_$";
    AvatarSlotType["BlegCost"] = "bleg_cost_$";
    AvatarSlotType["FarmSpec"] = "farm_spec_$";
    AvatarSlotType["FarmBase"] = "farm_base_$";
    AvatarSlotType["FarmCost"] = "farm_cost_$";
    AvatarSlotType["ShldFarm"] = "shld_farm_$";
    AvatarSlotType["WeapFarm"] = "weap_farm_$";
    AvatarSlotType["HeadSpec"] = "head_spec_$";
    AvatarSlotType["HeadMask"] = "head_mask_$";
    AvatarSlotType["HeadEyes"] = "head_eyes_$";
    AvatarSlotType["HeadBase"] = "head_base_$";
    AvatarSlotType["HeadHairBack"] = "head_hair_$_back";
    AvatarSlotType["HeadMous"] = "head_mous_$";
    AvatarSlotType["HeadHair"] = "head_hair_$";
    AvatarSlotType["HeadHats"] = "head_hats_$";
})(AvatarSlotType || (AvatarSlotType = {}));
var AvatarPartType;
(function (AvatarPartType) {
    AvatarPartType["BarmBase"] = "barm_base_#_$";
    AvatarPartType["BarmCost"] = "barm_cost_#_$";
    AvatarPartType["BarmSpec"] = "barm_spec_#_$";
    AvatarPartType["BlegBase"] = "bleg_base_#_$";
    AvatarPartType["BlegCost"] = "bleg_cost_#_$";
    AvatarPartType["BlegSpec"] = "bleg_spec_#_$";
    AvatarPartType["BodyBase"] = "body_base_#_$";
    AvatarPartType["BodyCost"] = "body_cost_#_$";
    AvatarPartType["BodyCostDres"] = "body_cost_#_$_dres";
    AvatarPartType["BodySpec"] = "body_spec_#_$";
    AvatarPartType["BodyTail"] = "body_tail_#_$";
    AvatarPartType["BodyWing"] = "body_wing_#_$";
    AvatarPartType["FarmBase"] = "farm_base_#_$";
    AvatarPartType["FarmCost"] = "farm_cost_#_$";
    AvatarPartType["FarmSpec"] = "farm_spec_#_$";
    AvatarPartType["FlegBase"] = "fleg_base_#_$";
    AvatarPartType["FlegCost"] = "fleg_cost_#_$";
    AvatarPartType["FlegSpec"] = "fleg_spec_#_$";
    AvatarPartType["HeadBase"] = "head_base_#_$";
    AvatarPartType["HeadEyes"] = "head_eyes_#_$";
    AvatarPartType["HeadHair"] = "head_hair_#_$";
    AvatarPartType["HeadHairBack"] = "head_hair_#_$_back";
    AvatarPartType["HeadHats"] = "head_hats_#_$";
    AvatarPartType["HeadMask"] = "head_mask_#_$";
    AvatarPartType["HeadMous"] = "head_mous_#_$";
    AvatarPartType["HeadSpec"] = "head_spec_#_$";
    AvatarPartType["ShldFarm"] = "shld_farm_#_$";
    AvatarPartType["WeapFarm"] = "weap_farm_#_$";
    AvatarPartType["ShldBarm"] = "shld_barm_#_$";
    AvatarPartType["WeapBarm"] = "weap_barm_#_$";
})(AvatarPartType || (AvatarPartType = {}));
/**
 * 龙骨显示对象
 */
var dragonbones_display_DragonbonesDisplay = /** @class */ (function (_super) {
    __extends(DragonbonesDisplay, _super);
    function DragonbonesDisplay(scene, roomService, element, antial) {
        if (antial === void 0) { antial = false; }
        var _this = _super.call(this, scene, roomService, element, antial) || this;
        _this.mAnimationName = "Armature";
        _this.mDragonbonesName = "";
        _this.replaceArr = [];
        _this.mHasLoadMap = new Map();
        _this.mLoadMap = new Map();
        _this.mErrorLoadMap = new Map();
        return _this;
    }
    Object.defineProperty(DragonbonesDisplay.prototype, "spriteWidth", {
        get: function () {
            if (this.mArmatureDisplay) {
                return this.mArmatureDisplay.width;
            }
            return 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DragonbonesDisplay.prototype, "spriteHeight", {
        get: function () {
            if (this.mArmatureDisplay) {
                return this.mArmatureDisplay.height;
            }
            return 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DragonbonesDisplay.prototype, "GameObject", {
        get: function () {
            return this;
        },
        enumerable: false,
        configurable: true
    });
    DragonbonesDisplay.prototype.changeAlpha = function (val) {
        // this.alpha = val;
    };
    DragonbonesDisplay.prototype.load = function (display) {
        this.mDisplayInfo = display;
        this.mCollisionArea = [[1, 1], [1, 1]];
        this.mOriginPoint = new Phaser.Geom.Point(1, 1);
        if (!this.mDisplayInfo)
            return;
        this.dragonBonesName = "bones_human01"; // this.mDisplayInfo.avatar.id;
    };
    DragonbonesDisplay.prototype.getDisplay = function () {
        return this.mArmatureDisplay;
    };
    DragonbonesDisplay.prototype.play = function (val) {
        this.mActionName = val;
        if (this.mArmatureDisplay) {
            if (this.mArmatureDisplay.hasDBEventListener(dragonBones.EventObject.LOOP_COMPLETE)) {
                this.mArmatureDisplay.removeDBEventListener(dragonBones.EventObject.LOOP_COMPLETE, this.onArmatureLoopComplete, this);
            }
            if (val.playingQueue && val.playingQueue.complete) {
                this.mArmatureDisplay.addDBEventListener(dragonBones.EventObject.LOOP_COMPLETE, this.onArmatureLoopComplete, this);
            }
            this.mArmatureDisplay.animation.play(val.animationName);
            this.mArmatureDisplay.scaleX = val.flip ? -1 : 1;
        }
    };
    DragonbonesDisplay.prototype.fadeIn = function (callback) {
        this.clearFadeTween();
        this.alpha = 0;
        this.mFadeTween = this.scene.tweens.add({
            targets: this,
            alpha: 1,
            duration: 1200,
            onComplete: function () {
                if (callback)
                    callback();
            }
        });
    };
    DragonbonesDisplay.prototype.fadeOut = function (callback) {
        this.clearFadeTween();
        this.mFadeTween = this.scene.tweens.add({
            targets: this,
            alpha: 0,
            duration: 1200,
            onComplete: function () {
                if (callback)
                    callback();
            }
        });
    };
    DragonbonesDisplay.prototype.destroy = function () {
        this.mDisplayInfo = null;
        if (this.mArmatureDisplay) {
            this.mArmatureDisplay.dispose(true);
            this.mArmatureDisplay = null;
        }
        if (this.mClickCon) {
            this.mClickCon.destroy(true);
            this.mClickCon = null;
        }
        if (this.mFadeTween) {
            this.clearFadeTween();
            this.mFadeTween = null;
        }
        _super.prototype.destroy.call(this);
    };
    DragonbonesDisplay.prototype.buildDragbones = function () {
        if (this.scene.cache.custom.dragonbone.get(this.mDragonbonesName)) {
            this.onLoadCompleteHandler();
        }
        else {
            var res = "./resources/dragonbones";
            var pngUrl = res + "/" + this.mDragonbonesName + "_tex.png";
            var jsonUrl = res + "/" + this.mDragonbonesName + "_tex.json";
            var dbbinUrl = res + "/" + this.mDragonbonesName + "_ske.dbbin";
            this.loadDragonBones(res, pngUrl, jsonUrl, dbbinUrl);
        }
    };
    DragonbonesDisplay.prototype.onLoadCompleteHandler = function (loader, totalComplete, totalFailed) {
        if (!this.scene)
            return;
        if (this.mArmatureDisplay) {
            this.mArmatureDisplay.dbClear();
        }
        this.mArmatureDisplay = this.scene.add.armature(this.mAnimationName, this.dragonBonesName);
        this.mArmatureDisplay.addDBEventListener(dragonBones.EventObject.SOUND_EVENT, this.onSoundEventHandler, this);
        this.mArmatureDisplay.visible = false;
        this.add(this.mArmatureDisplay);
        // ==========只有在创建龙骨时才会调用全部清除，显示通过后续通信做处理
        this.clearArmatureSlot();
        // ==========替换相应格位的display，服务端通信后可调用
        this.getReplaceArr();
        this.showReplaceArmatrue();
        // this.play("idle");
        this.mArmatureDisplay.x = this.baseLoc.x;
        this.mArmatureDisplay.y = this.baseLoc.y;
        var rect = new Phaser.Geom.Rectangle(0, 0, 50, 70);
        if (!this.mClickCon) {
            this.mClickCon = this.scene.make.container(undefined, false);
            this.mClickCon.setInteractive(rect, Phaser.Geom.Rectangle.Contains);
            this.mClickCon.x = -rect.width >> 1;
            this.mClickCon.y = -rect.height;
        }
        this.setData("id", this.mDisplayInfo.id);
        this.add(this.mClickCon);
        this.emit("initialized");
    };
    DragonbonesDisplay.prototype.loadDragonBones = function (resUrl, pngUrl, jsonUrl, dbbinUrl) {
        this.scene.load.dragonbone(this.mDragonbonesName, pngUrl, jsonUrl, dbbinUrl, null, null, { responseType: "arraybuffer" });
        this.scene.load.once(Phaser.Loader.Events.COMPLETE, this.onLoadCompleteHandler, this);
        this.scene.load.start();
    };
    DragonbonesDisplay.prototype.clearArmatureSlot = function () {
        var slotList = this.mArmatureDisplay.armature.getSlots();
        slotList.forEach(function (slot) {
            if (slot)
                slot.display.visible = false;
        });
    };
    DragonbonesDisplay.prototype.clearReplaceArmature = function () {
        this.mArmatureDisplay.armature.animation.stop();
        if (!this.replaceArr || this.replaceArr.length === 0) {
            return;
        }
        var len = this.replaceArr.length;
        for (var i = 0; i < len; i++) {
            var part = this.replaceArr[i].slot.replace("$", this.replaceArr[i].dir.toString());
            var slot = this.mArmatureDisplay.armature.getSlot(part);
            slot.replaceDisplay(null);
        }
    };
    DragonbonesDisplay.prototype.showReplaceArmatrue = function () {
        for (var _i = 0, _a = this.replaceArr; _i < _a.length; _i++) {
            var obj = _a[_i];
            this.replacePartDisplay(obj.slot, obj.part, obj.dir, obj.skin);
        }
        if (this.mLoadMap && this.mLoadMap.size > 0) {
            this.startLoad();
        }
        else {
            this.refreshAvatar();
        }
    };
    DragonbonesDisplay.prototype.getReplaceArr = function () {
        this.replaceArr.length = 0;
        var avater = this.mDisplayInfo.avatar;
        if (avater.bodyBaseId) {
            this.replaceArr.push({
                slot: AvatarSlotType.BodyBase,
                part: AvatarPartType.BodyBase,
                dir: 3,
                skin: avater.bodyBaseId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.BodyBase,
                part: AvatarPartType.BodyBase,
                dir: 1,
                skin: avater.bodyBaseId,
            });
        }
        if (avater.bodySpecId) {
            this.replaceArr.push({
                slot: AvatarSlotType.BodySpec,
                part: AvatarPartType.BodySpec,
                dir: 3,
                skin: avater.bodySpecId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.BodySpec,
                part: AvatarPartType.BodySpec,
                dir: 1,
                skin: avater.bodySpecId,
            });
        }
        if (avater.bodyWingId) {
            this.replaceArr.push({
                slot: AvatarSlotType.BodyWing,
                part: AvatarPartType.BodyWing,
                dir: 3,
                skin: avater.bodyWingId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.BodyWing,
                part: AvatarPartType.BodyWing,
                dir: 1,
                skin: avater.bodyWingId,
            });
        }
        if (avater.bodyTailId) {
            this.replaceArr.push({
                slot: AvatarSlotType.BodyTail,
                part: AvatarPartType.BodyTail,
                dir: 3,
                skin: avater.bodyTailId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.BodyTail,
                part: AvatarPartType.BodyTail,
                dir: 1,
                skin: avater.bodyTailId,
            });
        }
        if (avater.bodyCostId) {
            this.replaceArr.push({
                slot: AvatarSlotType.BodyCost,
                part: AvatarPartType.BodyCost,
                dir: 3,
                skin: avater.bodyCostId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.BodyCost,
                part: AvatarPartType.BodyCost,
                dir: 1,
                skin: avater.bodyCostId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.BodyCostDres,
                part: AvatarPartType.BodyCostDres,
                dir: 3,
                skin: avater.bodyCostId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.BodyCostDres,
                part: AvatarPartType.BodyCostDres,
                dir: 1,
                skin: avater.bodyCostId,
            });
        }
        if (avater.farmBaseId) {
            this.replaceArr.push({
                slot: AvatarSlotType.FarmBase,
                part: AvatarPartType.FarmBase,
                dir: 3,
                skin: avater.farmBaseId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.FarmBase,
                part: AvatarPartType.FarmBase,
                dir: 1,
                skin: avater.farmBaseId,
            });
        }
        if (avater.farmSpecId) {
            this.replaceArr.push({
                slot: AvatarSlotType.FarmSpec,
                part: AvatarPartType.FarmSpec,
                dir: 3,
                skin: avater.farmSpecId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.FarmSpec,
                part: AvatarPartType.FarmSpec,
                dir: 1,
                skin: avater.farmSpecId,
            });
        }
        if (avater.farmCostId) {
            this.replaceArr.push({
                slot: AvatarSlotType.FarmCost,
                part: AvatarPartType.FarmCost,
                dir: 3,
                skin: avater.farmCostId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.FarmCost,
                part: AvatarPartType.FarmCost,
                dir: 1,
                skin: avater.farmCostId,
            });
        }
        if (avater.barmBaseId) {
            this.replaceArr.push({
                slot: AvatarSlotType.BarmBase,
                part: AvatarPartType.BarmBase,
                dir: 3,
                skin: avater.barmBaseId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.BarmBase,
                part: AvatarPartType.BarmBase,
                dir: 1,
                skin: avater.barmBaseId,
            });
        }
        if (avater.barmSpecId) {
            this.replaceArr.push({
                slot: AvatarSlotType.BarmSpec,
                part: AvatarPartType.BarmSpec,
                dir: 3,
                skin: avater.barmSpecId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.BarmSpec,
                part: AvatarPartType.BarmSpec,
                dir: 1,
                skin: avater.barmSpecId,
            });
        }
        if (avater.barmCostId) {
            this.replaceArr.push({
                slot: AvatarSlotType.BarmCost,
                part: AvatarPartType.BarmCost,
                dir: 3,
                skin: avater.barmCostId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.BarmCost,
                part: AvatarPartType.BarmCost,
                dir: 1,
                skin: avater.barmCostId,
            });
        }
        if (avater.blegBaseId) {
            this.replaceArr.push({
                slot: AvatarSlotType.BlegBase,
                part: AvatarPartType.BlegBase,
                dir: 3,
                skin: avater.blegBaseId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.BlegBase,
                part: AvatarPartType.BlegBase,
                dir: 1,
                skin: avater.blegBaseId,
            });
        }
        if (avater.blegSpecId) {
            this.replaceArr.push({
                slot: AvatarSlotType.BlegSpec,
                part: AvatarPartType.BlegSpec,
                dir: 3,
                skin: avater.blegSpecId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.BlegSpec,
                part: AvatarPartType.BlegSpec,
                dir: 1,
                skin: avater.blegSpecId,
            });
        }
        if (avater.blegCostId) {
            this.replaceArr.push({
                slot: AvatarSlotType.BlegCost,
                part: AvatarPartType.BlegCost,
                dir: 3,
                skin: avater.blegCostId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.BlegCost,
                part: AvatarPartType.BlegCost,
                dir: 1,
                skin: avater.blegCostId,
            });
        }
        if (avater.flegBaseId) {
            this.replaceArr.push({
                slot: AvatarSlotType.FlegBase,
                part: AvatarPartType.FlegBase,
                dir: 3,
                skin: avater.flegBaseId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.FlegBase,
                part: AvatarPartType.FlegBase,
                dir: 1,
                skin: avater.flegBaseId,
            });
        }
        if (avater.flegSpecId) {
            this.replaceArr.push({
                slot: AvatarSlotType.FlegSpec,
                part: AvatarPartType.FlegSpec,
                dir: 3,
                skin: avater.flegSpecId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.FlegSpec,
                part: AvatarPartType.FlegSpec,
                dir: 1,
                skin: avater.flegSpecId,
            });
        }
        if (avater.flegCostId) {
            this.replaceArr.push({
                slot: AvatarSlotType.FlegCost,
                part: AvatarPartType.FlegCost,
                dir: 3,
                skin: avater.flegCostId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.FlegCost,
                part: AvatarPartType.FlegCost,
                dir: 1,
                skin: avater.flegCostId,
            });
        }
        if (avater.headBaseId) {
            this.replaceArr.push({
                slot: AvatarSlotType.HeadBase,
                part: AvatarPartType.HeadBase,
                dir: 3,
                skin: avater.headBaseId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.HeadBase,
                part: AvatarPartType.HeadBase,
                dir: 1,
                skin: avater.headBaseId,
            });
        }
        if (avater.barmWeapId) {
            this.replaceArr.push({
                slot: AvatarSlotType.WeapBarm,
                part: AvatarPartType.WeapBarm,
                dir: 3,
                skin: avater.barmWeapId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.WeapBarm,
                part: AvatarPartType.WeapBarm,
                dir: 1,
                skin: avater.barmWeapId,
            });
        }
        if (avater.headHairId) {
            this.replaceArr.push({
                slot: AvatarSlotType.HeadHair,
                part: AvatarPartType.HeadHair,
                dir: 3,
                skin: avater.headHairId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.HeadHair,
                part: AvatarPartType.HeadHair,
                dir: 1,
                skin: avater.headHairId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.HeadHairBack,
                part: AvatarPartType.HeadHairBack,
                dir: 3,
                skin: avater.headHairId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.HeadHairBack,
                part: AvatarPartType.HeadHairBack,
                dir: 1,
                skin: avater.headHairId,
            });
        }
        if (avater.headHatsId) {
            this.replaceArr.push({
                slot: AvatarSlotType.HeadHats,
                part: AvatarPartType.HeadHats,
                dir: 3,
                skin: avater.headHatsId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.HeadHats,
                part: AvatarPartType.HeadHats,
                dir: 1,
                skin: avater.headHatsId,
            });
        }
        if (avater.headSpecId) {
            this.replaceArr.push({
                slot: AvatarSlotType.HeadSpec,
                part: AvatarPartType.HeadSpec,
                dir: 3,
                skin: avater.headSpecId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.HeadSpec,
                part: AvatarPartType.HeadSpec,
                dir: 1,
                skin: avater.headSpecId,
            });
        }
        if (avater.headEyesId) {
            this.replaceArr.push({
                slot: AvatarSlotType.HeadEyes,
                part: AvatarPartType.HeadEyes,
                dir: 3,
                skin: avater.headEyesId,
            });
        }
        if (avater.headMousId) {
            this.replaceArr.push({
                slot: AvatarSlotType.HeadMous,
                part: AvatarPartType.HeadMous,
                dir: 3,
                skin: avater.headMousId,
            });
        }
        if (avater.headMaskId) {
            this.replaceArr.push({
                slot: AvatarSlotType.HeadMask,
                part: AvatarPartType.HeadMask,
                dir: 3,
                skin: avater.headMaskId,
            });
        }
        if (avater.farmShldId) {
            this.replaceArr.push({
                slot: AvatarSlotType.ShldFarm,
                part: AvatarPartType.ShldFarm,
                dir: 3,
                skin: avater.farmShldId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.ShldFarm,
                part: AvatarPartType.ShldFarm,
                dir: 1,
                skin: avater.farmShldId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.ShldBarm,
                part: AvatarPartType.ShldBarm,
                dir: 3,
                skin: avater.farmShldId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.ShldBarm,
                part: AvatarPartType.ShldBarm,
                dir: 1,
                skin: avater.farmShldId,
            });
        }
        if (avater.farmWeapId) {
            this.replaceArr.push({
                slot: AvatarSlotType.WeapFarm,
                part: AvatarPartType.WeapFarm,
                dir: 3,
                skin: avater.farmWeapId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.WeapFarm,
                part: AvatarPartType.WeapFarm,
                dir: 1,
                skin: avater.farmWeapId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.WeapBarm,
                part: AvatarPartType.WeapBarm,
                dir: 3,
                skin: avater.farmWeapId,
            });
            this.replaceArr.push({
                slot: AvatarSlotType.WeapBarm,
                part: AvatarPartType.WeapBarm,
                dir: 1,
                skin: avater.farmWeapId,
            });
        }
    };
    DragonbonesDisplay.prototype.replacePartDisplay = function (soltName, soltPart, soltDir, skin) {
        var part = soltName.replace("$", soltDir.toString());
        var slot = this.mArmatureDisplay.armature.getSlot(part);
        var key = soltPart.replace("#", skin.toString()).replace("$", soltDir.toString());
        var dragonBonesTexture = this.scene.game.textures.get(this.mDragonbonesName);
        if (this.scene.cache.custom.dragonbone.get(this.dragonBonesName)) {
            var partName = resUtil["b" /* ResUtils */].getPartName(key);
            var frameName = "test resources/" + key;
            if (this.mErrorLoadMap.get(partName))
                return;
            if (!this.scene.textures.exists(partName)) {
                if (!dragonBonesTexture.frames[frameName]) {
                    // ==============新资源需从外部加载，之后要重新打图集
                    this.mLoadMap.set(slot.name, [slot.name, key]);
                }
                else {
                    this.mHasLoadMap.set(key, this.scene.textures.get(partName));
                }
            }
            else {
                //     // ==============贴图集上的资源 / 单个替换资源
                // this.mHasLoadMap.set(slot.name,this.scene.textures.exists(partName));
                // let img: dragonBones.phaser.display.SlotImage;
                // if (dragonBonesTexture.frames[frameName]) {// && this.scene.game.textures.exists(this.mDisplayInfo.id + "")) {
                //     if (!this.scene.textures.exists(partName)) {
                //         this.mLoadMap.set(slot.name, [slot.name, key]);
                //         return;
                //     }
                //     img = new dragonBones.phaser.display.SlotImage(this.scene, slot.display.x, slot.display.y, partName);
                // } else {
                //     img = new dragonBones.phaser.display.SlotImage(this.scene, slot.display.x, slot.display.y, partName);
                // }
                // if (this.mAntial) {
                //     // 用于设置边缘抗锯齿
                //     img.texture.setFilter(Phaser.Textures.FilterMode.NEAREST);
                // }
                // slot.replaceDisplay(img);
            }
        }
    };
    DragonbonesDisplay.prototype.startLoad = function () {
        var _this = this;
        var configList = [];
        // ============只有check到新资源时才会重新load，否则直接从当前龙骨的贴图资源上，获取对应贴图
        this.scene.load.once(Phaser.Loader.Events.COMPLETE, function (data, totalComplete, totalFailed) {
            if (!configList || !_this.scene)
                return;
            _this.refreshAvatar();
            _this.mLoadMap.clear();
        }, this);
        this.scene.load.once(Phaser.Loader.Events.FILE_LOAD_ERROR, function (e) {
            // ==============为了防止404资源重复请求加载，在加载失败后直接将其索引放置加载失败列表中，并从加载map中删除
            _this.mLoadMap.delete(e.key);
            _this.mErrorLoadMap.set(e.key, e);
        }, this);
        this.mLoadMap.forEach(function (data) {
            var nextLoad = data;
            var partUrl = resUtil["b" /* ResUtils */].getPartUrl(nextLoad[1]);
            var partName = resUtil["b" /* ResUtils */].getPartName(nextLoad[1]);
            configList.push({ key: partName, url: partUrl });
        });
        this.scene.load.image(configList);
        this.scene.load.start();
    };
    DragonbonesDisplay.prototype.refreshAvatar = function () {
        var _this = this;
        var dragonBonesTexture = this.scene.game.textures.get(this.mDragonbonesName);
        var frames = dragonBonesTexture.getFrameNames();
        // ==============重绘贴图方式
        // if (this.mLoadMap.size > 0) {
        // }
        var renderTextureKey = "bones_" + this.mDisplayInfo.id; // "bones_" + this.mDisplayInfo.id;// "bones_human01";
        var renderTexture = this.scene.textures.get(renderTextureKey);
        if (!this.mDragonBonesRenderTexture)
            this.mDragonBonesRenderTexture = this.scene.make.renderTexture({ x: 0, y: 0, width: dragonBonesTexture.source[0].width, height: dragonBonesTexture.source[0].height }, false);
        this.mDragonBonesRenderTexture.clear();
        // this.scene.add.existing(this.mDragonBonesRenderTexture);
        for (var i = 0, len = frames.length; i < len; i++) {
            // =============龙骨贴图资源frames里面的key "test resources/xxxxx"
            var name_1 = frames[i];
            // =============龙骨part资源key 带图片资源名及方向
            var key = name_1.split("/")[1].split("_");
            // =============front || back单独也有格位
            var slotKey = key[4] ? key[0] + "_" + key[1] + "_" + key[3] + "_" + key[4] : key[0] + "_" + key[1] + "_" + key[3];
            var slot = this.mArmatureDisplay.armature.getSlot(slotKey);
            var dat = dragonBonesTexture.get(name_1);
            var loadArr = this.mLoadMap.get(slotKey);
            // 原始资源
            if (!loadArr) {
                for (var _i = 0, _a = this.replaceArr; _i < _a.length; _i++) {
                    var obj = _a[_i];
                    var tmpKey = obj.part.replace("#", obj.skin.toString()).replace("$", obj.dir.toString());
                    var partName = resUtil["b" /* ResUtils */].getPartName(tmpKey);
                    var frameName = "test resources/" + tmpKey;
                    var part = obj.slot.replace("$", obj.dir.toString());
                    if (part === slotKey) {
                        var texture = this.scene.textures.get(partName);
                        if (this.mAntial) {
                            // 用于设置边缘抗锯齿
                            texture.setFilter(Phaser.Textures.FilterMode.NEAREST);
                        }
                        if (dragonBonesTexture.frames[frameName]) {
                            this.mDragonBonesRenderTexture.drawFrame(this.mDragonbonesName, name_1, dat.cutX, dat.cutY);
                            break;
                        }
                        else {
                            this.mDragonBonesRenderTexture.drawFrame(partName, texture.firstFrame, dat.cutX, dat.cutY);
                            break;
                        }
                    }
                }
                // this.mDragonBonesRenderTexture.drawFrame(this.mDragonbonesName, name, dat.cutX, dat.cutY);
            }
            else {
                var drawTextureKey = loadArr[1] + "_png";
                var drawTexture = this.scene.game.textures.get(drawTextureKey);
                if (this.mAntial) {
                    // 用于设置边缘抗锯齿
                    drawTexture.setFilter(Phaser.Textures.FilterMode.NEAREST);
                }
                this.mDragonBonesRenderTexture.drawFrame(drawTextureKey, drawTexture.firstFrame, dat.cutX, dat.cutY);
            }
        }
        this.mDragonBonesRenderTexture.snapshotArea(0, 0, dragonBonesTexture.source[0].width, dragonBonesTexture.source[0].height, function (snapshot) {
            if (snapshot instanceof HTMLImageElement) {
                if (_this.scene.game.textures.exists(renderTextureKey))
                    _this.scene.game.textures.removeKey(renderTextureKey);
                var changeTexture = _this.scene.game.textures.create(renderTextureKey, snapshot, dragonBonesTexture.source[0].width, dragonBonesTexture.source[0].height);
                _this.mArmatureDisplay.armature.replacedTexture = changeTexture;
            }
        });
        // }
        this.mArmatureDisplay.visible = true;
    };
    DragonbonesDisplay.prototype.clearFadeTween = function () {
        if (this.mFadeTween) {
            this.mFadeTween.stop();
            this.mFadeTween.remove();
        }
    };
    DragonbonesDisplay.prototype.onArmatureLoopComplete = function (event) {
        if (!this.mArmatureDisplay || !this.mActionName) {
            return;
        }
        var queue = this.mActionName.playingQueue;
        if (queue.playedTimes === undefined) {
            queue.playedTimes = 1;
        }
        else {
            queue.playedTimes++;
        }
        if (queue.playedTimes >= queue.playTimes) {
            this.mArmatureDisplay.removeDBEventListener(dragonBones.EventObject.LOOP_COMPLETE, this.onArmatureLoopComplete, this);
            // this.emit("animationComplete");
            if (queue.complete) {
                queue.complete.call(this);
                delete queue.complete;
            }
        }
    };
    DragonbonesDisplay.prototype.onSoundEventHandler = function (event) {
        // Logger.getInstance().log("sound event: ", event.name);
        if (event.name) {
            this.mRoomService.world.playSound({
                field: SoundField.Element,
                key: event.name,
            });
        }
    };
    Object.defineProperty(DragonbonesDisplay.prototype, "dragonBonesName", {
        get: function () {
            return this.mDragonbonesName;
        },
        set: function (val) {
            // if (this.mDragonbonesName !== val) {
            // TODO 暴露一个换装接口
            this.mDragonbonesName = val;
            this.buildDragbones();
            // }
        },
        enumerable: false,
        configurable: true
    });
    return DragonbonesDisplay;
}(display_object["a" /* DisplayObject */]));



/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ viewblock_manager_ViewblockManager; });

// CONCATENATED MODULE: ./src/rooms/cameras/viewblock.ts
/**
 * 显示区域
 */
var Viewblock = /** @class */ (function () {
    function Viewblock(mRect, index) {
        this.mRect = mRect;
        // private mElements: IElement[] = [];
        this.mElements = new Map();
        this.mIndex = index;
    }
    Viewblock.prototype.add = function (element, miniViewPort) {
        // this.mElements.push(element);
        this.mElements.set(element.id, element);
        if (!miniViewPort) {
            return;
        }
        var pos = element.getPosition45();
        element.setRenderable(miniViewPort.contains(pos.x, pos.y) && this.mInCamera);
    };
    Viewblock.prototype.remove = function (ele) {
        // const index = this.mElements.indexOf(ele);
        // if (index !== -1) {
        //     this.mElements.splice(index, 1);
        //     return true;
        // }
        return this.mElements.delete(ele.id);
    };
    // tick running... powered by manager.
    Viewblock.prototype.check = function (bound, miniViewPort) {
        if (!bound)
            return;
        var newStat = Phaser.Geom.Intersects.RectangleToRectangle(bound, this.rectangle);
        // if (this.mInCamera !== newStat) {
        //     for (const e of this.mElements) {
        //         根据情况看是否需要提前加载
        //         e.setRenderable(newStat);
        //     }
        // }
        if (!miniViewPort)
            return;
        if (this.mInCamera) {
            // for (const ele of this.mElements) {
            //     const pos = ele.getPosition45();
            //     ele.setRenderable(miniViewPort.contains(pos.x, pos.y), 1000);
            // }
            this.mElements.forEach(function (ele) {
                var pos = ele.getPosition45();
                ele.setRenderable(miniViewPort.contains(pos.x, pos.y), 0);
            });
        }
        this.mInCamera = newStat;
    };
    Viewblock.prototype.getElement = function (id) {
        return this.mElements.get(id);
    };
    Object.defineProperty(Viewblock.prototype, "rectangle", {
        get: function () {
            return this.mRect || undefined;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Viewblock.prototype, "inCamera", {
        get: function () {
            return this.mInCamera;
        },
        enumerable: false,
        configurable: true
    });
    return Viewblock;
}());


// CONCATENATED MODULE: ./src/rooms/cameras/viewblock.manager.ts

var viewblock_manager_ViewblockManager = /** @class */ (function () {
    function ViewblockManager(cameras) {
        this.mBlocks = [];
        this.mDelay = 0;
        this.mCameras = cameras;
    }
    ViewblockManager.prototype.add = function (e) {
        if (!this.mCameras)
            return false;
        var miniView = this.mCameras.getMiniViewPort();
        for (var _i = 0, _a = this.mBlocks; _i < _a.length; _i++) {
            var block = _a[_i];
            var rect = block.rectangle;
            var ePos = e.getPosition();
            if (!ePos)
                return;
            if (rect.contains(ePos.x, ePos.y)) {
                block.add(e, miniView);
                return;
            }
        }
    };
    ViewblockManager.prototype.remove = function (e) {
        if (!e)
            return;
        for (var _i = 0, _a = this.mBlocks; _i < _a.length; _i++) {
            var block = _a[_i];
            if (block.remove(e)) {
                return;
            }
        }
    };
    ViewblockManager.prototype.check = function (e) {
        if (!e)
            return;
        for (var _i = 0, _a = this.mBlocks; _i < _a.length; _i++) {
            var block = _a[_i];
            if (block.inCamera) {
                var rect = block.rectangle;
                var pos = e.getPosition();
                if (rect.contains(pos.x, pos.y)) {
                    if (!block.getElement(e.id)) {
                        this.remove(e);
                        block.add(e);
                    }
                    return;
                }
            }
        }
    };
    ViewblockManager.prototype.int = function (size) {
        if (!size) {
            return;
        }
        this.mBlocks = [];
        var colSize = 10;
        var viewW = (colSize + colSize) * (size.tileWidth / 2);
        var viewH = (colSize + colSize) * (size.tileHeight / 2);
        var blockW = size.sceneWidth / viewW;
        var blockH = size.sceneHeight / viewH;
        var index = 0;
        for (var i = 0; i < blockW; i++) {
            for (var j = 0; j < blockH; j++) {
                var block = new Viewblock(new Phaser.Geom.Rectangle(i * viewW, j * viewH, viewW, viewH), index++);
                this.mBlocks.push(block);
                // this.layerManager.addToAtmosphere(block.drawBoard(this.scene));
            }
        }
    };
    ViewblockManager.prototype.update = function (time, delta) {
        if (!this.mCameras)
            return;
        // if (time - this.mDelay < 3000) {
        //     return;
        // }
        this.mDelay = time;
        var bound = this.mCameras.getViewPort();
        var miniViewPort = this.mCameras.getMiniViewPort();
        for (var _i = 0, _a = this.mBlocks; _i < _a.length; _i++) {
            var block = _a[_i];
            block.check(bound, miniViewPort);
        }
    };
    ViewblockManager.prototype.destroy = function () {
        this.mDelay = 0;
    };
    return ViewblockManager;
}());



/***/ }),
/* 99 */,
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["dragonBones"] = __webpack_require__(101);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(22)))

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * @private
     */
    var DragonBones = /** @class */ (function () {
        function DragonBones(eventManager) {
            this._clock = new dragonBones.WorldClock();
            this._events = [];
            this._objects = [];
            this._eventManager = null;
            this._eventManager = eventManager;
            console.info("DragonBones: " + DragonBones.VERSION + "\nWebsite: http://dragonbones.com/\nSource and Demo: https://github.com/DragonBones/");
        }
        DragonBones.prototype.advanceTime = function (passedTime) {
            if (this._objects.length > 0) {
                for (var _i = 0, _a = this._objects; _i < _a.length; _i++) {
                    var object = _a[_i];
                    object.returnToPool();
                }
                this._objects.length = 0;
            }
            this._clock.advanceTime(passedTime);
            if (this._events.length > 0) {
                for (var i = 0; i < this._events.length; ++i) {
                    var eventObject = this._events[i];
                    var armature = eventObject.armature;
                    if (armature._armatureData !== null) { // May be armature disposed before advanceTime.
                        armature.eventDispatcher.dispatchDBEvent(eventObject.type, eventObject);
                        if (eventObject.type === dragonBones.EventObject.SOUND_EVENT) {
                            this._eventManager.dispatchDBEvent(eventObject.type, eventObject);
                        }
                    }
                    this.bufferObject(eventObject);
                }
                this._events.length = 0;
            }
        };
        DragonBones.prototype.bufferEvent = function (value) {
            if (this._events.indexOf(value) < 0) {
                this._events.push(value);
            }
        };
        DragonBones.prototype.bufferObject = function (object) {
            if (this._objects.indexOf(object) < 0) {
                this._objects.push(object);
            }
        };
        Object.defineProperty(DragonBones.prototype, "clock", {
            get: function () {
                return this._clock;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DragonBones.prototype, "eventManager", {
            get: function () {
                return this._eventManager;
            },
            enumerable: true,
            configurable: true
        });
        DragonBones.VERSION = "5.7.000";
        DragonBones.yDown = true;
        DragonBones.debug = false;
        DragonBones.debugDraw = false;
        return DragonBones;
    }());
    dragonBones.DragonBones = DragonBones;
})(dragonBones || (dragonBones = {}));
//
if (!console.warn) {
    console.warn = function () { };
}
if (!console.assert) {
    console.assert = function () { };
}
//
if (!Date.now) {
    Date.now = function now() {
        return new Date().getTime();
    };
}
// Weixin can not support typescript extends.
var __extends = function (t, e) {
    function r() {
        this.constructor = t;
    }
    for (var i in e) {
        if (e.hasOwnProperty(i)) {
            t[i] = e[i];
        }
    }
    r.prototype = e.prototype, t.prototype = new r();
};
//
if (typeof global === "undefined" && typeof window !== "undefined") {
    var global = window;
}
if (true) {
    module.exports = dragonBones;
}
else {}
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * - The BaseObject is the base class for all objects in the DragonBones framework.
     * All BaseObject instances are cached to the object pool to reduce the performance consumption of frequent requests for memory or memory recovery.
     * @version DragonBones 4.5
     * @language en_US
     */
    /**
     * - 基础对象，通常 DragonBones 的对象都继承自该类。
     * 所有基础对象的实例都会缓存到对象池，以减少频繁申请内存或内存回收的性能消耗。
     * @version DragonBones 4.5
     * @language zh_CN
     */
    var BaseObject = /** @class */ (function () {
        function BaseObject() {
            /**
             * - A unique identification number assigned to the object.
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 分配给此实例的唯一标识号。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            this.hashCode = BaseObject._hashCode++;
            this._isInPool = false;
        }
        BaseObject._returnObject = function (object) {
            var classType = String(object.constructor);
            var maxCount = classType in BaseObject._maxCountMap ? BaseObject._maxCountMap[classType] : BaseObject._defaultMaxCount;
            var pool = BaseObject._poolsMap[classType] = BaseObject._poolsMap[classType] || [];
            if (pool.length < maxCount) {
                if (!object._isInPool) {
                    object._isInPool = true;
                    pool.push(object);
                }
                else {
                    console.warn("The object is already in the pool.");
                }
            }
            else {
            }
        };
        BaseObject.toString = function () {
            throw new Error();
        };
        /**
         * - Set the maximum cache count of the specify object pool.
         * @param objectConstructor - The specify class. (Set all object pools max cache count if not set)
         * @param maxCount - Max count.
         * @version DragonBones 4.5
         * @language en_US
         */
        /**
         * - 设置特定对象池的最大缓存数量。
         * @param objectConstructor - 特定的类。 (不设置则设置所有对象池的最大缓存数量)
         * @param maxCount - 最大缓存数量。
         * @version DragonBones 4.5
         * @language zh_CN
         */
        BaseObject.setMaxCount = function (objectConstructor, maxCount) {
            if (maxCount < 0 || maxCount !== maxCount) { // isNaN
                maxCount = 0;
            }
            if (objectConstructor !== null) {
                var classType = String(objectConstructor);
                var pool = classType in BaseObject._poolsMap ? BaseObject._poolsMap[classType] : null;
                if (pool !== null && pool.length > maxCount) {
                    pool.length = maxCount;
                }
                BaseObject._maxCountMap[classType] = maxCount;
            }
            else {
                BaseObject._defaultMaxCount = maxCount;
                for (var classType in BaseObject._poolsMap) {
                    var pool = BaseObject._poolsMap[classType];
                    if (pool.length > maxCount) {
                        pool.length = maxCount;
                    }
                    if (classType in BaseObject._maxCountMap) {
                        BaseObject._maxCountMap[classType] = maxCount;
                    }
                }
            }
        };
        /**
         * - Clear the cached instances of a specify object pool.
         * @param objectConstructor - Specify class. (Clear all cached instances if not set)
         * @version DragonBones 4.5
         * @language en_US
         */
        /**
         * - 清除特定对象池的缓存实例。
         * @param objectConstructor - 特定的类。 (不设置则清除所有缓存的实例)
         * @version DragonBones 4.5
         * @language zh_CN
         */
        BaseObject.clearPool = function (objectConstructor) {
            if (objectConstructor === void 0) { objectConstructor = null; }
            if (objectConstructor !== null) {
                var classType = String(objectConstructor);
                var pool = classType in BaseObject._poolsMap ? BaseObject._poolsMap[classType] : null;
                if (pool !== null && pool.length > 0) {
                    pool.length = 0;
                }
            }
            else {
                for (var k in BaseObject._poolsMap) {
                    var pool = BaseObject._poolsMap[k];
                    pool.length = 0;
                }
            }
        };
        /**
         * - Get an instance of the specify class from object pool.
         * @param objectConstructor - The specify class.
         * @version DragonBones 4.5
         * @language en_US
         */
        /**
         * - 从对象池中获取特定类的实例。
         * @param objectConstructor - 特定的类。
         * @version DragonBones 4.5
         * @language zh_CN
         */
        BaseObject.borrowObject = function (objectConstructor) {
            var classType = String(objectConstructor);
            var pool = classType in BaseObject._poolsMap ? BaseObject._poolsMap[classType] : null;
            if (pool !== null && pool.length > 0) {
                var object_1 = pool.pop();
                object_1._isInPool = false;
                return object_1;
            }
            var object = new objectConstructor();
            object._onClear();
            return object;
        };
        /**
         * - Clear the object and return it back to object pool。
         * @version DragonBones 4.5
         * @language en_US
         */
        /**
         * - 清除该实例的所有数据并将其返还对象池。
         * @version DragonBones 4.5
         * @language zh_CN
         */
        BaseObject.prototype.returnToPool = function () {
            this._onClear();
            BaseObject._returnObject(this);
        };
        BaseObject._hashCode = 0;
        BaseObject._defaultMaxCount = 3000;
        BaseObject._maxCountMap = {};
        BaseObject._poolsMap = {};
        return BaseObject;
    }());
    dragonBones.BaseObject = BaseObject;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * - 2D Transform matrix.
     * @version DragonBones 3.0
     * @language en_US
     */
    /**
     * - 2D 转换矩阵。
     * @version DragonBones 3.0
     * @language zh_CN
     */
    var Matrix = /** @class */ (function () {
        /**
         * @private
         */
        function Matrix(a, b, c, d, tx, ty) {
            if (a === void 0) { a = 1.0; }
            if (b === void 0) { b = 0.0; }
            if (c === void 0) { c = 0.0; }
            if (d === void 0) { d = 1.0; }
            if (tx === void 0) { tx = 0.0; }
            if (ty === void 0) { ty = 0.0; }
            this.a = a;
            this.b = b;
            this.c = c;
            this.d = d;
            this.tx = tx;
            this.ty = ty;
        }
        Matrix.prototype.toString = function () {
            return "[object dragonBones.Matrix] a:" + this.a + " b:" + this.b + " c:" + this.c + " d:" + this.d + " tx:" + this.tx + " ty:" + this.ty;
        };
        /**
         * @private
         */
        Matrix.prototype.copyFrom = function (value) {
            this.a = value.a;
            this.b = value.b;
            this.c = value.c;
            this.d = value.d;
            this.tx = value.tx;
            this.ty = value.ty;
            return this;
        };
        /**
         * @private
         */
        Matrix.prototype.copyFromArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            this.a = value[offset];
            this.b = value[offset + 1];
            this.c = value[offset + 2];
            this.d = value[offset + 3];
            this.tx = value[offset + 4];
            this.ty = value[offset + 5];
            return this;
        };
        /**
         * - Convert to unit matrix.
         * The resulting matrix has the following properties: a=1, b=0, c=0, d=1, tx=0, ty=0.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 转换为单位矩阵。
         * 该矩阵具有以下属性：a=1、b=0、c=0、d=1、tx=0、ty=0。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        Matrix.prototype.identity = function () {
            this.a = this.d = 1.0;
            this.b = this.c = 0.0;
            this.tx = this.ty = 0.0;
            return this;
        };
        /**
         * - Multiplies the current matrix with another matrix.
         * @param value - The matrix that needs to be multiplied.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 将当前矩阵与另一个矩阵相乘。
         * @param value - 需要相乘的矩阵。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        Matrix.prototype.concat = function (value) {
            var aA = this.a * value.a;
            var bA = 0.0;
            var cA = 0.0;
            var dA = this.d * value.d;
            var txA = this.tx * value.a + value.tx;
            var tyA = this.ty * value.d + value.ty;
            if (this.b !== 0.0 || this.c !== 0.0) {
                aA += this.b * value.c;
                bA += this.b * value.d;
                cA += this.c * value.a;
                dA += this.c * value.b;
            }
            if (value.b !== 0.0 || value.c !== 0.0) {
                bA += this.a * value.b;
                cA += this.d * value.c;
                txA += this.ty * value.c;
                tyA += this.tx * value.b;
            }
            this.a = aA;
            this.b = bA;
            this.c = cA;
            this.d = dA;
            this.tx = txA;
            this.ty = tyA;
            return this;
        };
        /**
         * - Convert to inverse matrix.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 转换为逆矩阵。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        Matrix.prototype.invert = function () {
            var aA = this.a;
            var bA = this.b;
            var cA = this.c;
            var dA = this.d;
            var txA = this.tx;
            var tyA = this.ty;
            if (bA === 0.0 && cA === 0.0) {
                this.b = this.c = 0.0;
                if (aA === 0.0 || dA === 0.0) {
                    this.a = this.b = this.tx = this.ty = 0.0;
                }
                else {
                    aA = this.a = 1.0 / aA;
                    dA = this.d = 1.0 / dA;
                    this.tx = -aA * txA;
                    this.ty = -dA * tyA;
                }
                return this;
            }
            var determinant = aA * dA - bA * cA;
            if (determinant === 0.0) {
                this.a = this.d = 1.0;
                this.b = this.c = 0.0;
                this.tx = this.ty = 0.0;
                return this;
            }
            determinant = 1.0 / determinant;
            var k = this.a = dA * determinant;
            bA = this.b = -bA * determinant;
            cA = this.c = -cA * determinant;
            dA = this.d = aA * determinant;
            this.tx = -(k * txA + cA * tyA);
            this.ty = -(bA * txA + dA * tyA);
            return this;
        };
        /**
         * - Apply a matrix transformation to a specific point.
         * @param x - X coordinate.
         * @param y - Y coordinate.
         * @param result - The point after the transformation is applied.
         * @param delta - Whether to ignore tx, ty's conversion to point.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 将矩阵转换应用于特定点。
         * @param x - 横坐标。
         * @param y - 纵坐标。
         * @param result - 应用转换之后的点。
         * @param delta - 是否忽略 tx，ty 对点的转换。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        Matrix.prototype.transformPoint = function (x, y, result, delta) {
            if (delta === void 0) { delta = false; }
            result.x = this.a * x + this.c * y;
            result.y = this.b * x + this.d * y;
            if (!delta) {
                result.x += this.tx;
                result.y += this.ty;
            }
        };
        /**
         * @private
         */
        Matrix.prototype.transformRectangle = function (rectangle, delta) {
            if (delta === void 0) { delta = false; }
            var a = this.a;
            var b = this.b;
            var c = this.c;
            var d = this.d;
            var tx = delta ? 0.0 : this.tx;
            var ty = delta ? 0.0 : this.ty;
            var x = rectangle.x;
            var y = rectangle.y;
            var xMax = x + rectangle.width;
            var yMax = y + rectangle.height;
            var x0 = a * x + c * y + tx;
            var y0 = b * x + d * y + ty;
            var x1 = a * xMax + c * y + tx;
            var y1 = b * xMax + d * y + ty;
            var x2 = a * xMax + c * yMax + tx;
            var y2 = b * xMax + d * yMax + ty;
            var x3 = a * x + c * yMax + tx;
            var y3 = b * x + d * yMax + ty;
            var tmp = 0.0;
            if (x0 > x1) {
                tmp = x0;
                x0 = x1;
                x1 = tmp;
            }
            if (x2 > x3) {
                tmp = x2;
                x2 = x3;
                x3 = tmp;
            }
            rectangle.x = Math.floor(x0 < x2 ? x0 : x2);
            rectangle.width = Math.ceil((x1 > x3 ? x1 : x3) - rectangle.x);
            if (y0 > y1) {
                tmp = y0;
                y0 = y1;
                y1 = tmp;
            }
            if (y2 > y3) {
                tmp = y2;
                y2 = y3;
                y3 = tmp;
            }
            rectangle.y = Math.floor(y0 < y2 ? y0 : y2);
            rectangle.height = Math.ceil((y1 > y3 ? y1 : y3) - rectangle.y);
        };
        return Matrix;
    }());
    dragonBones.Matrix = Matrix;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * - 2D Transform.
     * @version DragonBones 3.0
     * @language en_US
     */
    /**
     * - 2D 变换。
     * @version DragonBones 3.0
     * @language zh_CN
     */
    var Transform = /** @class */ (function () {
        /**
         * @private
         */
        function Transform(x, y, skew, rotation, scaleX, scaleY) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (skew === void 0) { skew = 0.0; }
            if (rotation === void 0) { rotation = 0.0; }
            if (scaleX === void 0) { scaleX = 1.0; }
            if (scaleY === void 0) { scaleY = 1.0; }
            this.x = x;
            this.y = y;
            this.skew = skew;
            this.rotation = rotation;
            this.scaleX = scaleX;
            this.scaleY = scaleY;
        }
        /**
         * @private
         */
        Transform.normalizeRadian = function (value) {
            value = (value + Math.PI) % (Math.PI * 2.0);
            value += value > 0.0 ? -Math.PI : Math.PI;
            return value;
        };
        Transform.prototype.toString = function () {
            return "[object dragonBones.Transform] x:" + this.x + " y:" + this.y + " skewX:" + this.skew * 180.0 / Math.PI + " skewY:" + this.rotation * 180.0 / Math.PI + " scaleX:" + this.scaleX + " scaleY:" + this.scaleY;
        };
        /**
         * @private
         */
        Transform.prototype.copyFrom = function (value) {
            this.x = value.x;
            this.y = value.y;
            this.skew = value.skew;
            this.rotation = value.rotation;
            this.scaleX = value.scaleX;
            this.scaleY = value.scaleY;
            return this;
        };
        /**
         * @private
         */
        Transform.prototype.identity = function () {
            this.x = this.y = 0.0;
            this.skew = this.rotation = 0.0;
            this.scaleX = this.scaleY = 1.0;
            return this;
        };
        /**
         * @private
         */
        Transform.prototype.add = function (value) {
            this.x += value.x;
            this.y += value.y;
            this.skew += value.skew;
            this.rotation += value.rotation;
            this.scaleX *= value.scaleX;
            this.scaleY *= value.scaleY;
            return this;
        };
        /**
         * @private
         */
        Transform.prototype.minus = function (value) {
            this.x -= value.x;
            this.y -= value.y;
            this.skew -= value.skew;
            this.rotation -= value.rotation;
            this.scaleX /= value.scaleX;
            this.scaleY /= value.scaleY;
            return this;
        };
        /**
         * @private
         */
        Transform.prototype.fromMatrix = function (matrix) {
            var backupScaleX = this.scaleX, backupScaleY = this.scaleY;
            var PI_Q = Transform.PI_Q;
            this.x = matrix.tx;
            this.y = matrix.ty;
            this.rotation = Math.atan(matrix.b / matrix.a);
            var skewX = Math.atan(-matrix.c / matrix.d);
            this.scaleX = (this.rotation > -PI_Q && this.rotation < PI_Q) ? matrix.a / Math.cos(this.rotation) : matrix.b / Math.sin(this.rotation);
            this.scaleY = (skewX > -PI_Q && skewX < PI_Q) ? matrix.d / Math.cos(skewX) : -matrix.c / Math.sin(skewX);
            if (backupScaleX >= 0.0 && this.scaleX < 0.0) {
                this.scaleX = -this.scaleX;
                this.rotation = this.rotation - Math.PI;
            }
            if (backupScaleY >= 0.0 && this.scaleY < 0.0) {
                this.scaleY = -this.scaleY;
                skewX = skewX - Math.PI;
            }
            this.skew = skewX - this.rotation;
            return this;
        };
        /**
         * @private
         */
        Transform.prototype.toMatrix = function (matrix) {
            if (this.rotation === 0.0) {
                matrix.a = 1.0;
                matrix.b = 0.0;
            }
            else {
                matrix.a = Math.cos(this.rotation);
                matrix.b = Math.sin(this.rotation);
            }
            if (this.skew === 0.0) {
                matrix.c = -matrix.b;
                matrix.d = matrix.a;
            }
            else {
                matrix.c = -Math.sin(this.skew + this.rotation);
                matrix.d = Math.cos(this.skew + this.rotation);
            }
            if (this.scaleX !== 1.0) {
                matrix.a *= this.scaleX;
                matrix.b *= this.scaleX;
            }
            if (this.scaleY !== 1.0) {
                matrix.c *= this.scaleY;
                matrix.d *= this.scaleY;
            }
            matrix.tx = this.x;
            matrix.ty = this.y;
            return this;
        };
        /**
         * @private
         */
        Transform.PI = Math.PI;
        /**
         * @private
         */
        Transform.PI_D = Math.PI * 2.0;
        /**
         * @private
         */
        Transform.PI_H = Math.PI / 2.0;
        /**
         * @private
         */
        Transform.PI_Q = Math.PI / 4.0;
        /**
         * @private
         */
        Transform.RAD_DEG = 180.0 / Math.PI;
        /**
         * @private
         */
        Transform.DEG_RAD = Math.PI / 180.0;
        return Transform;
    }());
    dragonBones.Transform = Transform;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * @private
     */
    var ColorTransform = /** @class */ (function () {
        function ColorTransform(alphaMultiplier, redMultiplier, greenMultiplier, blueMultiplier, alphaOffset, redOffset, greenOffset, blueOffset) {
            if (alphaMultiplier === void 0) { alphaMultiplier = 1.0; }
            if (redMultiplier === void 0) { redMultiplier = 1.0; }
            if (greenMultiplier === void 0) { greenMultiplier = 1.0; }
            if (blueMultiplier === void 0) { blueMultiplier = 1.0; }
            if (alphaOffset === void 0) { alphaOffset = 0; }
            if (redOffset === void 0) { redOffset = 0; }
            if (greenOffset === void 0) { greenOffset = 0; }
            if (blueOffset === void 0) { blueOffset = 0; }
            this.alphaMultiplier = alphaMultiplier;
            this.redMultiplier = redMultiplier;
            this.greenMultiplier = greenMultiplier;
            this.blueMultiplier = blueMultiplier;
            this.alphaOffset = alphaOffset;
            this.redOffset = redOffset;
            this.greenOffset = greenOffset;
            this.blueOffset = blueOffset;
        }
        ColorTransform.prototype.copyFrom = function (value) {
            this.alphaMultiplier = value.alphaMultiplier;
            this.redMultiplier = value.redMultiplier;
            this.greenMultiplier = value.greenMultiplier;
            this.blueMultiplier = value.blueMultiplier;
            this.alphaOffset = value.alphaOffset;
            this.redOffset = value.redOffset;
            this.greenOffset = value.greenOffset;
            this.blueOffset = value.blueOffset;
        };
        ColorTransform.prototype.identity = function () {
            this.alphaMultiplier = this.redMultiplier = this.greenMultiplier = this.blueMultiplier = 1.0;
            this.alphaOffset = this.redOffset = this.greenOffset = this.blueOffset = 0;
        };
        return ColorTransform;
    }());
    dragonBones.ColorTransform = ColorTransform;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * - The Point object represents a location in a two-dimensional coordinate system.
     * @version DragonBones 3.0
     * @language en_US
     */
    /**
     * - Point 对象表示二维坐标系统中的某个位置。
     * @version DragonBones 3.0
     * @language zh_CN
     */
    var Point = /** @class */ (function () {
        /**
         * - Creates a new point. If you pass no parameters to this method, a point is created at (0,0).
         * @param x - The horizontal coordinate.
         * @param y - The vertical coordinate.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 创建一个 egret.Point 对象.若不传入任何参数，将会创建一个位于（0，0）位置的点。
         * @param x - 该对象的x属性值，默认为 0.0。
         * @param y - 该对象的y属性值，默认为 0.0。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        function Point(x, y) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            this.x = x;
            this.y = y;
        }
        /**
         * @private
         */
        Point.prototype.copyFrom = function (value) {
            this.x = value.x;
            this.y = value.y;
        };
        /**
         * @private
         */
        Point.prototype.clear = function () {
            this.x = this.y = 0.0;
        };
        return Point;
    }());
    dragonBones.Point = Point;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * - A Rectangle object is an area defined by its position, as indicated by its top-left corner point (x, y) and by its
     * width and its height.<br/>
     * The x, y, width, and height properties of the Rectangle class are independent of each other; changing the value of
     * one property has no effect on the others. However, the right and bottom properties are integrally related to those
     * four properties. For example, if you change the value of the right property, the value of the width property changes;
     * if you change the bottom property, the value of the height property changes.
     * @version DragonBones 3.0
     * @language en_US
     */
    /**
     * - Rectangle 对象是按其位置（由它左上角的点 (x, y) 确定）以及宽度和高度定义的区域。<br/>
     * Rectangle 类的 x、y、width 和 height 属性相互独立；更改一个属性的值不会影响其他属性。
     * 但是，right 和 bottom 属性与这四个属性是整体相关的。例如，如果更改 right 属性的值，则 width
     * 属性的值将发生变化；如果更改 bottom 属性，则 height 属性的值将发生变化。
     * @version DragonBones 3.0
     * @language zh_CN
     */
    var Rectangle = /** @class */ (function () {
        /**
         * @private
         */
        function Rectangle(x, y, width, height) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (width === void 0) { width = 0.0; }
            if (height === void 0) { height = 0.0; }
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }
        /**
         * @private
         */
        Rectangle.prototype.copyFrom = function (value) {
            this.x = value.x;
            this.y = value.y;
            this.width = value.width;
            this.height = value.height;
        };
        /**
         * @private
         */
        Rectangle.prototype.clear = function () {
            this.x = this.y = 0.0;
            this.width = this.height = 0.0;
        };
        return Rectangle;
    }());
    dragonBones.Rectangle = Rectangle;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * - The user custom data.
     * @version DragonBones 5.0
     * @language en_US
     */
    /**
     * - 用户自定义数据。
     * @version DragonBones 5.0
     * @language zh_CN
     */
    var UserData = /** @class */ (function (_super) {
        __extends(UserData, _super);
        function UserData() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * - The custom int numbers.
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 自定义整数。
             * @version DragonBones 5.0
             * @language zh_CN
             */
            _this.ints = [];
            /**
             * - The custom float numbers.
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 自定义浮点数。
             * @version DragonBones 5.0
             * @language zh_CN
             */
            _this.floats = [];
            /**
             * - The custom strings.
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 自定义字符串。
             * @version DragonBones 5.0
             * @language zh_CN
             */
            _this.strings = [];
            return _this;
        }
        UserData.toString = function () {
            return "[class dragonBones.UserData]";
        };
        UserData.prototype._onClear = function () {
            this.ints.length = 0;
            this.floats.length = 0;
            this.strings.length = 0;
        };
        /**
         * @internal
         */
        UserData.prototype.addInt = function (value) {
            this.ints.push(value);
        };
        /**
         * @internal
         */
        UserData.prototype.addFloat = function (value) {
            this.floats.push(value);
        };
        /**
         * @internal
         */
        UserData.prototype.addString = function (value) {
            this.strings.push(value);
        };
        /**
         * - Get the custom int number.
         * @version DragonBones 5.0
         * @language en_US
         */
        /**
         * - 获取自定义整数。
         * @version DragonBones 5.0
         * @language zh_CN
         */
        UserData.prototype.getInt = function (index) {
            if (index === void 0) { index = 0; }
            return index >= 0 && index < this.ints.length ? this.ints[index] : 0;
        };
        /**
         * - Get the custom float number.
         * @version DragonBones 5.0
         * @language en_US
         */
        /**
         * - 获取自定义浮点数。
         * @version DragonBones 5.0
         * @language zh_CN
         */
        UserData.prototype.getFloat = function (index) {
            if (index === void 0) { index = 0; }
            return index >= 0 && index < this.floats.length ? this.floats[index] : 0.0;
        };
        /**
         * - Get the custom string.
         * @version DragonBones 5.0
         * @language en_US
         */
        /**
         * - 获取自定义字符串。
         * @version DragonBones 5.0
         * @language zh_CN
         */
        UserData.prototype.getString = function (index) {
            if (index === void 0) { index = 0; }
            return index >= 0 && index < this.strings.length ? this.strings[index] : "";
        };
        return UserData;
    }(dragonBones.BaseObject));
    dragonBones.UserData = UserData;
    /**
     * @private
     */
    var ActionData = /** @class */ (function (_super) {
        __extends(ActionData, _super);
        function ActionData() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.data = null; //
            return _this;
        }
        ActionData.toString = function () {
            return "[class dragonBones.ActionData]";
        };
        ActionData.prototype._onClear = function () {
            if (this.data !== null) {
                this.data.returnToPool();
            }
            this.type = 0 /* Play */;
            this.name = "";
            this.bone = null;
            this.slot = null;
            this.data = null;
        };
        return ActionData;
    }(dragonBones.BaseObject));
    dragonBones.ActionData = ActionData;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * - The DragonBones data.
     * A DragonBones data contains multiple armature data.
     * @see dragonBones.ArmatureData
     * @version DragonBones 3.0
     * @language en_US
     */
    /**
     * - 龙骨数据。
     * 一个龙骨数据包含多个骨架数据。
     * @see dragonBones.ArmatureData
     * @version DragonBones 3.0
     * @language zh_CN
     */
    var DragonBonesData = /** @class */ (function (_super) {
        __extends(DragonBonesData, _super);
        function DragonBonesData() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @internal
             */
            _this.frameIndices = [];
            /**
             * @internal
             */
            _this.cachedFrames = [];
            /**
             * - All armature data names.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 所有的骨架数据名称。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            _this.armatureNames = [];
            /**
             * @private
             */
            _this.armatures = {};
            /**
             * @private
             */
            _this.userData = null; // Initial value.
            return _this;
        }
        DragonBonesData.toString = function () {
            return "[class dragonBones.DragonBonesData]";
        };
        DragonBonesData.prototype._onClear = function () {
            for (var k in this.armatures) {
                this.armatures[k].returnToPool();
                delete this.armatures[k];
            }
            if (this.userData !== null) {
                this.userData.returnToPool();
            }
            this.autoSearch = false;
            this.frameRate = 0;
            this.version = "";
            this.name = "";
            this.stage = null;
            this.frameIndices.length = 0;
            this.cachedFrames.length = 0;
            this.armatureNames.length = 0;
            //this.armatures.clear();
            this.binary = null; //
            this.intArray = null; //
            this.floatArray = null; //
            this.frameIntArray = null; //
            this.frameFloatArray = null; //
            this.frameArray = null; //
            this.timelineArray = null; //
            this.colorArray = null; //
            this.userData = null;
        };
        /**
         * @internal
         */
        DragonBonesData.prototype.addArmature = function (value) {
            if (value.name in this.armatures) {
                console.warn("Same armature: " + value.name);
                return;
            }
            value.parent = this;
            this.armatures[value.name] = value;
            this.armatureNames.push(value.name);
        };
        /**
         * - Get a specific armature data.
         * @param armatureName - The armature data name.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 获取特定的骨架数据。
         * @param armatureName - 骨架数据名称。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        DragonBonesData.prototype.getArmature = function (armatureName) {
            return armatureName in this.armatures ? this.armatures[armatureName] : null;
        };
        return DragonBonesData;
    }(dragonBones.BaseObject));
    dragonBones.DragonBonesData = DragonBonesData;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * - The armature data.
     * @version DragonBones 3.0
     * @language en_US
     */
    /**
     * - 骨架数据。
     * @version DragonBones 3.0
     * @language zh_CN
     */
    var ArmatureData = /** @class */ (function (_super) {
        __extends(ArmatureData, _super);
        function ArmatureData() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @private
             */
            _this.aabb = new dragonBones.Rectangle();
            /**
             * - The names of all the animation data.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 所有的动画数据名称。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            _this.animationNames = [];
            /**
             * @private
             */
            _this.sortedBones = [];
            /**
             * @private
             */
            _this.sortedSlots = [];
            /**
             * @private
             */
            _this.defaultActions = [];
            /**
             * @private
             */
            _this.actions = [];
            /**
             * @private
             */
            _this.bones = {};
            /**
             * @private
             */
            _this.slots = {};
            /**
             * @private
             */
            _this.constraints = {};
            /**
             * @private
             */
            _this.skins = {};
            /**
             * @private
             */
            _this.animations = {};
            /**
             * @private
             */
            _this.canvas = null; // Initial value.
            /**
             * @private
             */
            _this.userData = null; // Initial value.
            return _this;
        }
        ArmatureData.toString = function () {
            return "[class dragonBones.ArmatureData]";
        };
        ArmatureData.prototype._onClear = function () {
            for (var _i = 0, _a = this.defaultActions; _i < _a.length; _i++) {
                var action = _a[_i];
                action.returnToPool();
            }
            for (var _b = 0, _c = this.actions; _b < _c.length; _b++) {
                var action = _c[_b];
                action.returnToPool();
            }
            for (var k in this.bones) {
                this.bones[k].returnToPool();
                delete this.bones[k];
            }
            for (var k in this.slots) {
                this.slots[k].returnToPool();
                delete this.slots[k];
            }
            for (var k in this.constraints) {
                this.constraints[k].returnToPool();
                delete this.constraints[k];
            }
            for (var k in this.skins) {
                this.skins[k].returnToPool();
                delete this.skins[k];
            }
            for (var k in this.animations) {
                this.animations[k].returnToPool();
                delete this.animations[k];
            }
            if (this.canvas !== null) {
                this.canvas.returnToPool();
            }
            if (this.userData !== null) {
                this.userData.returnToPool();
            }
            this.type = 0 /* Armature */;
            this.frameRate = 0;
            this.cacheFrameRate = 0;
            this.scale = 1.0;
            this.name = "";
            this.aabb.clear();
            this.animationNames.length = 0;
            this.sortedBones.length = 0;
            this.sortedSlots.length = 0;
            this.defaultActions.length = 0;
            this.actions.length = 0;
            // this.bones.clear();
            // this.slots.clear();
            // this.constraints.clear();
            // this.skins.clear();
            // this.animations.clear();
            this.defaultSkin = null;
            this.defaultAnimation = null;
            this.canvas = null;
            this.userData = null;
            this.parent = null; //
        };
        /**
         * @internal
         */
        ArmatureData.prototype.sortBones = function () {
            var total = this.sortedBones.length;
            if (total <= 0) {
                return;
            }
            var sortHelper = this.sortedBones.concat();
            var index = 0;
            var count = 0;
            this.sortedBones.length = 0;
            while (count < total) {
                var bone = sortHelper[index++];
                if (index >= total) {
                    index = 0;
                }
                if (this.sortedBones.indexOf(bone) >= 0) {
                    continue;
                }
                var flag = false;
                for (var k in this.constraints) { // Wait constraint.
                    var constraint = this.constraints[k];
                    if (constraint.root === bone && this.sortedBones.indexOf(constraint.target) < 0) {
                        flag = true;
                        break;
                    }
                }
                if (flag) {
                    continue;
                }
                if (bone.parent !== null && this.sortedBones.indexOf(bone.parent) < 0) { // Wait parent.
                    continue;
                }
                this.sortedBones.push(bone);
                count++;
            }
        };
        /**
         * @internal
         */
        ArmatureData.prototype.cacheFrames = function (frameRate) {
            if (this.cacheFrameRate > 0) { // TODO clear cache.
                return;
            }
            this.cacheFrameRate = frameRate;
            for (var k in this.animations) {
                this.animations[k].cacheFrames(this.cacheFrameRate);
            }
        };
        /**
         * @internal
         */
        ArmatureData.prototype.setCacheFrame = function (globalTransformMatrix, transform) {
            var dataArray = this.parent.cachedFrames;
            var arrayOffset = dataArray.length;
            dataArray.length += 10;
            dataArray[arrayOffset] = globalTransformMatrix.a;
            dataArray[arrayOffset + 1] = globalTransformMatrix.b;
            dataArray[arrayOffset + 2] = globalTransformMatrix.c;
            dataArray[arrayOffset + 3] = globalTransformMatrix.d;
            dataArray[arrayOffset + 4] = globalTransformMatrix.tx;
            dataArray[arrayOffset + 5] = globalTransformMatrix.ty;
            dataArray[arrayOffset + 6] = transform.rotation;
            dataArray[arrayOffset + 7] = transform.skew;
            dataArray[arrayOffset + 8] = transform.scaleX;
            dataArray[arrayOffset + 9] = transform.scaleY;
            return arrayOffset;
        };
        /**
         * @internal
         */
        ArmatureData.prototype.getCacheFrame = function (globalTransformMatrix, transform, arrayOffset) {
            var dataArray = this.parent.cachedFrames;
            globalTransformMatrix.a = dataArray[arrayOffset];
            globalTransformMatrix.b = dataArray[arrayOffset + 1];
            globalTransformMatrix.c = dataArray[arrayOffset + 2];
            globalTransformMatrix.d = dataArray[arrayOffset + 3];
            globalTransformMatrix.tx = dataArray[arrayOffset + 4];
            globalTransformMatrix.ty = dataArray[arrayOffset + 5];
            transform.rotation = dataArray[arrayOffset + 6];
            transform.skew = dataArray[arrayOffset + 7];
            transform.scaleX = dataArray[arrayOffset + 8];
            transform.scaleY = dataArray[arrayOffset + 9];
            transform.x = globalTransformMatrix.tx;
            transform.y = globalTransformMatrix.ty;
        };
        /**
         * @internal
         */
        ArmatureData.prototype.addBone = function (value) {
            if (value.name in this.bones) {
                console.warn("Same bone: " + value.name);
                return;
            }
            this.bones[value.name] = value;
            this.sortedBones.push(value);
        };
        /**
         * @internal
         */
        ArmatureData.prototype.addSlot = function (value) {
            if (value.name in this.slots) {
                console.warn("Same slot: " + value.name);
                return;
            }
            this.slots[value.name] = value;
            this.sortedSlots.push(value);
        };
        /**
         * @internal
         */
        ArmatureData.prototype.addConstraint = function (value) {
            if (value.name in this.constraints) {
                console.warn("Same constraint: " + value.name);
                return;
            }
            this.constraints[value.name] = value;
        };
        /**
         * @internal
         */
        ArmatureData.prototype.addSkin = function (value) {
            if (value.name in this.skins) {
                console.warn("Same skin: " + value.name);
                return;
            }
            value.parent = this;
            this.skins[value.name] = value;
            if (this.defaultSkin === null) {
                this.defaultSkin = value;
            }
            if (value.name === "default") {
                this.defaultSkin = value;
            }
        };
        /**
         * @internal
         */
        ArmatureData.prototype.addAnimation = function (value) {
            if (value.name in this.animations) {
                console.warn("Same animation: " + value.name);
                return;
            }
            value.parent = this;
            this.animations[value.name] = value;
            this.animationNames.push(value.name);
            if (this.defaultAnimation === null) {
                this.defaultAnimation = value;
            }
        };
        /**
         * @internal
         */
        ArmatureData.prototype.addAction = function (value, isDefault) {
            if (isDefault) {
                this.defaultActions.push(value);
            }
            else {
                this.actions.push(value);
            }
        };
        /**
         * - Get a specific done data.
         * @param boneName - The bone name.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 获取特定的骨骼数据。
         * @param boneName - 骨骼名称。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        ArmatureData.prototype.getBone = function (boneName) {
            return boneName in this.bones ? this.bones[boneName] : null;
        };
        /**
         * - Get a specific slot data.
         * @param slotName - The slot name.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 获取特定的插槽数据。
         * @param slotName - 插槽名称。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        ArmatureData.prototype.getSlot = function (slotName) {
            return slotName in this.slots ? this.slots[slotName] : null;
        };
        /**
         * @private
         */
        ArmatureData.prototype.getConstraint = function (constraintName) {
            return constraintName in this.constraints ? this.constraints[constraintName] : null;
        };
        /**
         * - Get a specific skin data.
         * @param skinName - The skin name.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 获取特定皮肤数据。
         * @param skinName - 皮肤名称。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        ArmatureData.prototype.getSkin = function (skinName) {
            return skinName in this.skins ? this.skins[skinName] : null;
        };
        /**
         * @private
         */
        ArmatureData.prototype.getMesh = function (skinName, slotName, meshName) {
            var skin = this.getSkin(skinName);
            if (skin === null) {
                return null;
            }
            return skin.getDisplay(slotName, meshName);
        };
        /**
         * - Get a specific animation data.
         * @param animationName - The animation animationName.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 获取特定的动画数据。
         * @param animationName - 动画名称。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        ArmatureData.prototype.getAnimation = function (animationName) {
            return animationName in this.animations ? this.animations[animationName] : null;
        };
        return ArmatureData;
    }(dragonBones.BaseObject));
    dragonBones.ArmatureData = ArmatureData;
    /**
     * - The bone data.
     * @version DragonBones 3.0
     * @language en_US
     */
    /**
     * - 骨骼数据。
     * @version DragonBones 3.0
     * @language zh_CN
     */
    var BoneData = /** @class */ (function (_super) {
        __extends(BoneData, _super);
        function BoneData() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @private
             */
            _this.transform = new dragonBones.Transform();
            /**
             * @private
             */
            _this.userData = null; // Initial value.
            return _this;
        }
        BoneData.toString = function () {
            return "[class dragonBones.BoneData]";
        };
        BoneData.prototype._onClear = function () {
            if (this.userData !== null) {
                this.userData.returnToPool();
            }
            this.inheritTranslation = false;
            this.inheritRotation = false;
            this.inheritScale = false;
            this.inheritReflection = false;
            this.type = 0 /* Bone */;
            this.length = 0.0;
            this.alpha = 1.0;
            this.name = "";
            this.transform.identity();
            this.userData = null;
            this.parent = null;
        };
        return BoneData;
    }(dragonBones.BaseObject));
    dragonBones.BoneData = BoneData;
    /**
     * @internal
     */
    var SurfaceData = /** @class */ (function (_super) {
        __extends(SurfaceData, _super);
        function SurfaceData() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.geometry = new dragonBones.GeometryData();
            return _this;
        }
        SurfaceData.toString = function () {
            return "[class dragonBones.SurfaceData]";
        };
        SurfaceData.prototype._onClear = function () {
            _super.prototype._onClear.call(this);
            this.type = 1 /* Surface */;
            this.segmentX = 0;
            this.segmentY = 0;
            this.geometry.clear();
        };
        return SurfaceData;
    }(BoneData));
    dragonBones.SurfaceData = SurfaceData;
    /**
     * - The slot data.
     * @version DragonBones 3.0
     * @language en_US
     */
    /**
     * - 插槽数据。
     * @version DragonBones 3.0
     * @language zh_CN
     */
    var SlotData = /** @class */ (function (_super) {
        __extends(SlotData, _super);
        function SlotData() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @private
             */
            _this.color = null; // Initial value.
            /**
             * @private
             */
            _this.userData = null; // Initial value.
            return _this;
        }
        /**
         * @internal
         */
        SlotData.createColor = function () {
            return new dragonBones.ColorTransform();
        };
        SlotData.toString = function () {
            return "[class dragonBones.SlotData]";
        };
        SlotData.prototype._onClear = function () {
            if (this.userData !== null) {
                this.userData.returnToPool();
            }
            this.blendMode = 0 /* Normal */;
            this.displayIndex = 0;
            this.zOrder = 0;
            this.zIndex = 0;
            this.alpha = 1.0;
            this.name = "";
            this.color = null; //
            this.userData = null;
            this.parent = null; //
        };
        /**
         * @internal
         */
        SlotData.DEFAULT_COLOR = new dragonBones.ColorTransform();
        return SlotData;
    }(dragonBones.BaseObject));
    dragonBones.SlotData = SlotData;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * @private
     */
    var ConstraintData = /** @class */ (function (_super) {
        __extends(ConstraintData, _super);
        function ConstraintData() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ConstraintData.prototype._onClear = function () {
            this.order = 0;
            this.name = "";
            this.type = 0 /* IK */;
            this.target = null; //
            this.root = null; //
            this.bone = null;
        };
        return ConstraintData;
    }(dragonBones.BaseObject));
    dragonBones.ConstraintData = ConstraintData;
    /**
     * @internal
     */
    var IKConstraintData = /** @class */ (function (_super) {
        __extends(IKConstraintData, _super);
        function IKConstraintData() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IKConstraintData.toString = function () {
            return "[class dragonBones.IKConstraintData]";
        };
        IKConstraintData.prototype._onClear = function () {
            _super.prototype._onClear.call(this);
            this.scaleEnabled = false;
            this.bendPositive = false;
            this.weight = 1.0;
        };
        return IKConstraintData;
    }(ConstraintData));
    dragonBones.IKConstraintData = IKConstraintData;
    /**
     * @internal
     */
    var PathConstraintData = /** @class */ (function (_super) {
        __extends(PathConstraintData, _super);
        function PathConstraintData() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.bones = [];
            return _this;
        }
        PathConstraintData.toString = function () {
            return "[class dragonBones.PathConstraintData]";
        };
        PathConstraintData.prototype._onClear = function () {
            _super.prototype._onClear.call(this);
            this.pathSlot = null;
            this.pathDisplayData = null;
            this.bones.length = 0;
            this.positionMode = 0 /* Fixed */;
            this.spacingMode = 1 /* Fixed */;
            this.rotateMode = 1 /* Chain */;
            this.position = 0.0;
            this.spacing = 0.0;
            this.rotateOffset = 0.0;
            this.rotateMix = 0.0;
            this.translateMix = 0.0;
        };
        PathConstraintData.prototype.AddBone = function (value) {
            this.bones.push(value);
        };
        return PathConstraintData;
    }(ConstraintData));
    dragonBones.PathConstraintData = PathConstraintData;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * @private
     */
    var CanvasData = /** @class */ (function (_super) {
        __extends(CanvasData, _super);
        function CanvasData() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CanvasData.toString = function () {
            return "[class dragonBones.CanvasData]";
        };
        CanvasData.prototype._onClear = function () {
            this.hasBackground = false;
            this.color = 0x000000;
            this.x = 0;
            this.y = 0;
            this.width = 0;
            this.height = 0;
        };
        return CanvasData;
    }(dragonBones.BaseObject));
    dragonBones.CanvasData = CanvasData;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * - The skin data, typically a armature data instance contains at least one skinData.
     * @version DragonBones 3.0
     * @language en_US
     */
    /**
     * - 皮肤数据，通常一个骨架数据至少包含一个皮肤数据。
     * @version DragonBones 3.0
     * @language zh_CN
     */
    var SkinData = /** @class */ (function (_super) {
        __extends(SkinData, _super);
        function SkinData() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @private
             */
            _this.displays = {};
            return _this;
        }
        SkinData.toString = function () {
            return "[class dragonBones.SkinData]";
        };
        SkinData.prototype._onClear = function () {
            for (var k in this.displays) {
                var slotDisplays = this.displays[k];
                for (var _i = 0, slotDisplays_1 = slotDisplays; _i < slotDisplays_1.length; _i++) {
                    var display = slotDisplays_1[_i];
                    if (display !== null) {
                        display.returnToPool();
                    }
                }
                delete this.displays[k];
            }
            this.name = "";
            // this.displays.clear();
            this.parent = null; //
        };
        /**
         * @internal
         */
        SkinData.prototype.addDisplay = function (slotName, value) {
            if (!(slotName in this.displays)) {
                this.displays[slotName] = [];
            }
            if (value !== null) {
                value.parent = this;
            }
            var slotDisplays = this.displays[slotName]; // TODO clear prev
            slotDisplays.push(value);
        };
        /**
         * @private
         */
        SkinData.prototype.getDisplay = function (slotName, displayName) {
            var slotDisplays = this.getDisplays(slotName);
            if (slotDisplays !== null) {
                for (var _i = 0, slotDisplays_2 = slotDisplays; _i < slotDisplays_2.length; _i++) {
                    var display = slotDisplays_2[_i];
                    if (display !== null && display.name === displayName) {
                        return display;
                    }
                }
            }
            return null;
        };
        /**
         * @private
         */
        SkinData.prototype.getDisplays = function (slotName) {
            if (!(slotName in this.displays)) {
                return null;
            }
            return this.displays[slotName];
        };
        return SkinData;
    }(dragonBones.BaseObject));
    dragonBones.SkinData = SkinData;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * @private
     */
    var GeometryData = /** @class */ (function () {
        function GeometryData() {
            this.weight = null; // Initial value.
        }
        GeometryData.prototype.clear = function () {
            if (!this.isShared && this.weight !== null) {
                this.weight.returnToPool();
            }
            this.isShared = false;
            this.inheritDeform = false;
            this.offset = 0;
            this.data = null;
            this.weight = null;
        };
        GeometryData.prototype.shareFrom = function (value) {
            this.isShared = true;
            this.offset = value.offset;
            this.weight = value.weight;
        };
        Object.defineProperty(GeometryData.prototype, "vertexCount", {
            get: function () {
                var intArray = this.data.intArray;
                return intArray[this.offset + 0 /* GeometryVertexCount */];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeometryData.prototype, "triangleCount", {
            get: function () {
                var intArray = this.data.intArray;
                return intArray[this.offset + 1 /* GeometryTriangleCount */];
            },
            enumerable: true,
            configurable: true
        });
        return GeometryData;
    }());
    dragonBones.GeometryData = GeometryData;
    /**
     * @private
     */
    var DisplayData = /** @class */ (function (_super) {
        __extends(DisplayData, _super);
        function DisplayData() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.transform = new dragonBones.Transform();
            return _this;
        }
        DisplayData.prototype._onClear = function () {
            this.name = "";
            this.path = "";
            this.transform.identity();
            this.parent = null; //
        };
        return DisplayData;
    }(dragonBones.BaseObject));
    dragonBones.DisplayData = DisplayData;
    /**
     * @private
     */
    var ImageDisplayData = /** @class */ (function (_super) {
        __extends(ImageDisplayData, _super);
        function ImageDisplayData() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.pivot = new dragonBones.Point();
            return _this;
        }
        ImageDisplayData.toString = function () {
            return "[class dragonBones.ImageDisplayData]";
        };
        ImageDisplayData.prototype._onClear = function () {
            _super.prototype._onClear.call(this);
            this.type = 0 /* Image */;
            this.pivot.clear();
            this.texture = null;
        };
        return ImageDisplayData;
    }(DisplayData));
    dragonBones.ImageDisplayData = ImageDisplayData;
    /**
     * @private
     */
    var ArmatureDisplayData = /** @class */ (function (_super) {
        __extends(ArmatureDisplayData, _super);
        function ArmatureDisplayData() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.actions = [];
            return _this;
        }
        ArmatureDisplayData.toString = function () {
            return "[class dragonBones.ArmatureDisplayData]";
        };
        ArmatureDisplayData.prototype._onClear = function () {
            _super.prototype._onClear.call(this);
            for (var _i = 0, _a = this.actions; _i < _a.length; _i++) {
                var action = _a[_i];
                action.returnToPool();
            }
            this.type = 1 /* Armature */;
            this.inheritAnimation = false;
            this.actions.length = 0;
            this.armature = null;
        };
        /**
         * @private
         */
        ArmatureDisplayData.prototype.addAction = function (value) {
            this.actions.push(value);
        };
        return ArmatureDisplayData;
    }(DisplayData));
    dragonBones.ArmatureDisplayData = ArmatureDisplayData;
    /**
     * @private
     */
    var MeshDisplayData = /** @class */ (function (_super) {
        __extends(MeshDisplayData, _super);
        function MeshDisplayData() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.geometry = new GeometryData();
            return _this;
        }
        MeshDisplayData.toString = function () {
            return "[class dragonBones.MeshDisplayData]";
        };
        MeshDisplayData.prototype._onClear = function () {
            _super.prototype._onClear.call(this);
            this.type = 2 /* Mesh */;
            this.geometry.clear();
            this.texture = null;
        };
        return MeshDisplayData;
    }(DisplayData));
    dragonBones.MeshDisplayData = MeshDisplayData;
    /**
     * @private
     */
    var BoundingBoxDisplayData = /** @class */ (function (_super) {
        __extends(BoundingBoxDisplayData, _super);
        function BoundingBoxDisplayData() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.boundingBox = null; // Initial value.
            return _this;
        }
        BoundingBoxDisplayData.toString = function () {
            return "[class dragonBones.BoundingBoxDisplayData]";
        };
        BoundingBoxDisplayData.prototype._onClear = function () {
            _super.prototype._onClear.call(this);
            if (this.boundingBox !== null) {
                this.boundingBox.returnToPool();
            }
            this.type = 3 /* BoundingBox */;
            this.boundingBox = null;
        };
        return BoundingBoxDisplayData;
    }(DisplayData));
    dragonBones.BoundingBoxDisplayData = BoundingBoxDisplayData;
    /**
     * @private
     */
    var PathDisplayData = /** @class */ (function (_super) {
        __extends(PathDisplayData, _super);
        function PathDisplayData() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.geometry = new GeometryData();
            _this.curveLengths = [];
            return _this;
        }
        PathDisplayData.toString = function () {
            return "[class dragonBones.PathDisplayData]";
        };
        PathDisplayData.prototype._onClear = function () {
            _super.prototype._onClear.call(this);
            this.type = 4 /* Path */;
            this.closed = false;
            this.constantSpeed = false;
            this.geometry.clear();
            this.curveLengths.length = 0;
        };
        return PathDisplayData;
    }(DisplayData));
    dragonBones.PathDisplayData = PathDisplayData;
    /**
     * @private
     */
    var WeightData = /** @class */ (function (_super) {
        __extends(WeightData, _super);
        function WeightData() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.bones = [];
            return _this;
        }
        WeightData.toString = function () {
            return "[class dragonBones.WeightData]";
        };
        WeightData.prototype._onClear = function () {
            this.count = 0;
            this.offset = 0;
            this.bones.length = 0;
        };
        WeightData.prototype.addBone = function (value) {
            this.bones.push(value);
        };
        return WeightData;
    }(dragonBones.BaseObject));
    dragonBones.WeightData = WeightData;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * - The base class of bounding box data.
     * @see dragonBones.RectangleData
     * @see dragonBones.EllipseData
     * @see dragonBones.PolygonData
     * @version DragonBones 5.0
     * @language en_US
     */
    /**
     * - 边界框数据基类。
     * @see dragonBones.RectangleData
     * @see dragonBones.EllipseData
     * @see dragonBones.PolygonData
     * @version DragonBones 5.0
     * @language zh_CN
     */
    var BoundingBoxData = /** @class */ (function (_super) {
        __extends(BoundingBoxData, _super);
        function BoundingBoxData() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BoundingBoxData.prototype._onClear = function () {
            this.color = 0x000000;
            this.width = 0.0;
            this.height = 0.0;
        };
        return BoundingBoxData;
    }(dragonBones.BaseObject));
    dragonBones.BoundingBoxData = BoundingBoxData;
    /**
     * - The rectangle bounding box data.
     * @version DragonBones 5.1
     * @language en_US
     */
    /**
     * - 矩形边界框数据。
     * @version DragonBones 5.1
     * @language zh_CN
     */
    var RectangleBoundingBoxData = /** @class */ (function (_super) {
        __extends(RectangleBoundingBoxData, _super);
        function RectangleBoundingBoxData() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        RectangleBoundingBoxData.toString = function () {
            return "[class dragonBones.RectangleBoundingBoxData]";
        };
        /**
         * - Compute the bit code for a point (x, y) using the clip rectangle
         */
        RectangleBoundingBoxData._computeOutCode = function (x, y, xMin, yMin, xMax, yMax) {
            var code = 0 /* InSide */; // initialised as being inside of [[clip window]]
            if (x < xMin) { // to the left of clip window
                code |= 1 /* Left */;
            }
            else if (x > xMax) { // to the right of clip window
                code |= 2 /* Right */;
            }
            if (y < yMin) { // below the clip window
                code |= 4 /* Top */;
            }
            else if (y > yMax) { // above the clip window
                code |= 8 /* Bottom */;
            }
            return code;
        };
        /**
         * @private
         */
        RectangleBoundingBoxData.rectangleIntersectsSegment = function (xA, yA, xB, yB, xMin, yMin, xMax, yMax, intersectionPointA, intersectionPointB, normalRadians) {
            if (intersectionPointA === void 0) { intersectionPointA = null; }
            if (intersectionPointB === void 0) { intersectionPointB = null; }
            if (normalRadians === void 0) { normalRadians = null; }
            var inSideA = xA > xMin && xA < xMax && yA > yMin && yA < yMax;
            var inSideB = xB > xMin && xB < xMax && yB > yMin && yB < yMax;
            if (inSideA && inSideB) {
                return -1;
            }
            var intersectionCount = 0;
            var outcode0 = RectangleBoundingBoxData._computeOutCode(xA, yA, xMin, yMin, xMax, yMax);
            var outcode1 = RectangleBoundingBoxData._computeOutCode(xB, yB, xMin, yMin, xMax, yMax);
            while (true) {
                if ((outcode0 | outcode1) === 0) { // Bitwise OR is 0. Trivially accept and get out of loop
                    intersectionCount = 2;
                    break;
                }
                else if ((outcode0 & outcode1) !== 0) { // Bitwise AND is not 0. Trivially reject and get out of loop
                    break;
                }
                // failed both tests, so calculate the line segment to clip
                // from an outside point to an intersection with clip edge
                var x = 0.0;
                var y = 0.0;
                var normalRadian = 0.0;
                // At least one endpoint is outside the clip rectangle; pick it.
                var outcodeOut = outcode0 !== 0 ? outcode0 : outcode1;
                // Now find the intersection point;
                if ((outcodeOut & 4 /* Top */) !== 0) { // point is above the clip rectangle
                    x = xA + (xB - xA) * (yMin - yA) / (yB - yA);
                    y = yMin;
                    if (normalRadians !== null) {
                        normalRadian = -Math.PI * 0.5;
                    }
                }
                else if ((outcodeOut & 8 /* Bottom */) !== 0) { // point is below the clip rectangle
                    x = xA + (xB - xA) * (yMax - yA) / (yB - yA);
                    y = yMax;
                    if (normalRadians !== null) {
                        normalRadian = Math.PI * 0.5;
                    }
                }
                else if ((outcodeOut & 2 /* Right */) !== 0) { // point is to the right of clip rectangle
                    y = yA + (yB - yA) * (xMax - xA) / (xB - xA);
                    x = xMax;
                    if (normalRadians !== null) {
                        normalRadian = 0;
                    }
                }
                else if ((outcodeOut & 1 /* Left */) !== 0) { // point is to the left of clip rectangle
                    y = yA + (yB - yA) * (xMin - xA) / (xB - xA);
                    x = xMin;
                    if (normalRadians !== null) {
                        normalRadian = Math.PI;
                    }
                }
                // Now we move outside point to intersection point to clip
                // and get ready for next pass.
                if (outcodeOut === outcode0) {
                    xA = x;
                    yA = y;
                    outcode0 = RectangleBoundingBoxData._computeOutCode(xA, yA, xMin, yMin, xMax, yMax);
                    if (normalRadians !== null) {
                        normalRadians.x = normalRadian;
                    }
                }
                else {
                    xB = x;
                    yB = y;
                    outcode1 = RectangleBoundingBoxData._computeOutCode(xB, yB, xMin, yMin, xMax, yMax);
                    if (normalRadians !== null) {
                        normalRadians.y = normalRadian;
                    }
                }
            }
            if (intersectionCount) {
                if (inSideA) {
                    intersectionCount = 2; // 10
                    if (intersectionPointA !== null) {
                        intersectionPointA.x = xB;
                        intersectionPointA.y = yB;
                    }
                    if (intersectionPointB !== null) {
                        intersectionPointB.x = xB;
                        intersectionPointB.y = xB;
                    }
                    if (normalRadians !== null) {
                        normalRadians.x = normalRadians.y + Math.PI;
                    }
                }
                else if (inSideB) {
                    intersectionCount = 1; // 01
                    if (intersectionPointA !== null) {
                        intersectionPointA.x = xA;
                        intersectionPointA.y = yA;
                    }
                    if (intersectionPointB !== null) {
                        intersectionPointB.x = xA;
                        intersectionPointB.y = yA;
                    }
                    if (normalRadians !== null) {
                        normalRadians.y = normalRadians.x + Math.PI;
                    }
                }
                else {
                    intersectionCount = 3; // 11
                    if (intersectionPointA !== null) {
                        intersectionPointA.x = xA;
                        intersectionPointA.y = yA;
                    }
                    if (intersectionPointB !== null) {
                        intersectionPointB.x = xB;
                        intersectionPointB.y = yB;
                    }
                }
            }
            return intersectionCount;
        };
        RectangleBoundingBoxData.prototype._onClear = function () {
            _super.prototype._onClear.call(this);
            this.type = 0 /* Rectangle */;
        };
        /**
         * @inheritDoc
         */
        RectangleBoundingBoxData.prototype.containsPoint = function (pX, pY) {
            var widthH = this.width * 0.5;
            if (pX >= -widthH && pX <= widthH) {
                var heightH = this.height * 0.5;
                if (pY >= -heightH && pY <= heightH) {
                    return true;
                }
            }
            return false;
        };
        /**
         * @inheritDoc
         */
        RectangleBoundingBoxData.prototype.intersectsSegment = function (xA, yA, xB, yB, intersectionPointA, intersectionPointB, normalRadians) {
            if (intersectionPointA === void 0) { intersectionPointA = null; }
            if (intersectionPointB === void 0) { intersectionPointB = null; }
            if (normalRadians === void 0) { normalRadians = null; }
            var widthH = this.width * 0.5;
            var heightH = this.height * 0.5;
            var intersectionCount = RectangleBoundingBoxData.rectangleIntersectsSegment(xA, yA, xB, yB, -widthH, -heightH, widthH, heightH, intersectionPointA, intersectionPointB, normalRadians);
            return intersectionCount;
        };
        return RectangleBoundingBoxData;
    }(BoundingBoxData));
    dragonBones.RectangleBoundingBoxData = RectangleBoundingBoxData;
    /**
     * - The ellipse bounding box data.
     * @version DragonBones 5.1
     * @language en_US
     */
    /**
     * - 椭圆边界框数据。
     * @version DragonBones 5.1
     * @language zh_CN
     */
    var EllipseBoundingBoxData = /** @class */ (function (_super) {
        __extends(EllipseBoundingBoxData, _super);
        function EllipseBoundingBoxData() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EllipseBoundingBoxData.toString = function () {
            return "[class dragonBones.EllipseData]";
        };
        /**
         * @private
         */
        EllipseBoundingBoxData.ellipseIntersectsSegment = function (xA, yA, xB, yB, xC, yC, widthH, heightH, intersectionPointA, intersectionPointB, normalRadians) {
            if (intersectionPointA === void 0) { intersectionPointA = null; }
            if (intersectionPointB === void 0) { intersectionPointB = null; }
            if (normalRadians === void 0) { normalRadians = null; }
            var d = widthH / heightH;
            var dd = d * d;
            yA *= d;
            yB *= d;
            var dX = xB - xA;
            var dY = yB - yA;
            var lAB = Math.sqrt(dX * dX + dY * dY);
            var xD = dX / lAB;
            var yD = dY / lAB;
            var a = (xC - xA) * xD + (yC - yA) * yD;
            var aa = a * a;
            var ee = xA * xA + yA * yA;
            var rr = widthH * widthH;
            var dR = rr - ee + aa;
            var intersectionCount = 0;
            if (dR >= 0.0) {
                var dT = Math.sqrt(dR);
                var sA = a - dT;
                var sB = a + dT;
                var inSideA = sA < 0.0 ? -1 : (sA <= lAB ? 0 : 1);
                var inSideB = sB < 0.0 ? -1 : (sB <= lAB ? 0 : 1);
                var sideAB = inSideA * inSideB;
                if (sideAB < 0) {
                    return -1;
                }
                else if (sideAB === 0) {
                    if (inSideA === -1) {
                        intersectionCount = 2; // 10
                        xB = xA + sB * xD;
                        yB = (yA + sB * yD) / d;
                        if (intersectionPointA !== null) {
                            intersectionPointA.x = xB;
                            intersectionPointA.y = yB;
                        }
                        if (intersectionPointB !== null) {
                            intersectionPointB.x = xB;
                            intersectionPointB.y = yB;
                        }
                        if (normalRadians !== null) {
                            normalRadians.x = Math.atan2(yB / rr * dd, xB / rr);
                            normalRadians.y = normalRadians.x + Math.PI;
                        }
                    }
                    else if (inSideB === 1) {
                        intersectionCount = 1; // 01
                        xA = xA + sA * xD;
                        yA = (yA + sA * yD) / d;
                        if (intersectionPointA !== null) {
                            intersectionPointA.x = xA;
                            intersectionPointA.y = yA;
                        }
                        if (intersectionPointB !== null) {
                            intersectionPointB.x = xA;
                            intersectionPointB.y = yA;
                        }
                        if (normalRadians !== null) {
                            normalRadians.x = Math.atan2(yA / rr * dd, xA / rr);
                            normalRadians.y = normalRadians.x + Math.PI;
                        }
                    }
                    else {
                        intersectionCount = 3; // 11
                        if (intersectionPointA !== null) {
                            intersectionPointA.x = xA + sA * xD;
                            intersectionPointA.y = (yA + sA * yD) / d;
                            if (normalRadians !== null) {
                                normalRadians.x = Math.atan2(intersectionPointA.y / rr * dd, intersectionPointA.x / rr);
                            }
                        }
                        if (intersectionPointB !== null) {
                            intersectionPointB.x = xA + sB * xD;
                            intersectionPointB.y = (yA + sB * yD) / d;
                            if (normalRadians !== null) {
                                normalRadians.y = Math.atan2(intersectionPointB.y / rr * dd, intersectionPointB.x / rr);
                            }
                        }
                    }
                }
            }
            return intersectionCount;
        };
        EllipseBoundingBoxData.prototype._onClear = function () {
            _super.prototype._onClear.call(this);
            this.type = 1 /* Ellipse */;
        };
        /**
         * @inheritDoc
         */
        EllipseBoundingBoxData.prototype.containsPoint = function (pX, pY) {
            var widthH = this.width * 0.5;
            if (pX >= -widthH && pX <= widthH) {
                var heightH = this.height * 0.5;
                if (pY >= -heightH && pY <= heightH) {
                    pY *= widthH / heightH;
                    return Math.sqrt(pX * pX + pY * pY) <= widthH;
                }
            }
            return false;
        };
        /**
         * @inheritDoc
         */
        EllipseBoundingBoxData.prototype.intersectsSegment = function (xA, yA, xB, yB, intersectionPointA, intersectionPointB, normalRadians) {
            if (intersectionPointA === void 0) { intersectionPointA = null; }
            if (intersectionPointB === void 0) { intersectionPointB = null; }
            if (normalRadians === void 0) { normalRadians = null; }
            var intersectionCount = EllipseBoundingBoxData.ellipseIntersectsSegment(xA, yA, xB, yB, 0.0, 0.0, this.width * 0.5, this.height * 0.5, intersectionPointA, intersectionPointB, normalRadians);
            return intersectionCount;
        };
        return EllipseBoundingBoxData;
    }(BoundingBoxData));
    dragonBones.EllipseBoundingBoxData = EllipseBoundingBoxData;
    /**
     * - The polygon bounding box data.
     * @version DragonBones 5.1
     * @language en_US
     */
    /**
     * - 多边形边界框数据。
     * @version DragonBones 5.1
     * @language zh_CN
     */
    var PolygonBoundingBoxData = /** @class */ (function (_super) {
        __extends(PolygonBoundingBoxData, _super);
        function PolygonBoundingBoxData() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * - The polygon vertices.
             * @version DragonBones 5.1
             * @language en_US
             */
            /**
             * - 多边形顶点。
             * @version DragonBones 5.1
             * @language zh_CN
             */
            _this.vertices = [];
            return _this;
        }
        PolygonBoundingBoxData.toString = function () {
            return "[class dragonBones.PolygonBoundingBoxData]";
        };
        /**
         * @private
         */
        PolygonBoundingBoxData.polygonIntersectsSegment = function (xA, yA, xB, yB, vertices, intersectionPointA, intersectionPointB, normalRadians) {
            if (intersectionPointA === void 0) { intersectionPointA = null; }
            if (intersectionPointB === void 0) { intersectionPointB = null; }
            if (normalRadians === void 0) { normalRadians = null; }
            if (xA === xB) {
                xA = xB + 0.000001;
            }
            if (yA === yB) {
                yA = yB + 0.000001;
            }
            var count = vertices.length;
            var dXAB = xA - xB;
            var dYAB = yA - yB;
            var llAB = xA * yB - yA * xB;
            var intersectionCount = 0;
            var xC = vertices[count - 2];
            var yC = vertices[count - 1];
            var dMin = 0.0;
            var dMax = 0.0;
            var xMin = 0.0;
            var yMin = 0.0;
            var xMax = 0.0;
            var yMax = 0.0;
            for (var i = 0; i < count; i += 2) {
                var xD = vertices[i];
                var yD = vertices[i + 1];
                if (xC === xD) {
                    xC = xD + 0.0001;
                }
                if (yC === yD) {
                    yC = yD + 0.0001;
                }
                var dXCD = xC - xD;
                var dYCD = yC - yD;
                var llCD = xC * yD - yC * xD;
                var ll = dXAB * dYCD - dYAB * dXCD;
                var x = (llAB * dXCD - dXAB * llCD) / ll;
                if (((x >= xC && x <= xD) || (x >= xD && x <= xC)) && (dXAB === 0.0 || (x >= xA && x <= xB) || (x >= xB && x <= xA))) {
                    var y = (llAB * dYCD - dYAB * llCD) / ll;
                    if (((y >= yC && y <= yD) || (y >= yD && y <= yC)) && (dYAB === 0.0 || (y >= yA && y <= yB) || (y >= yB && y <= yA))) {
                        if (intersectionPointB !== null) {
                            var d = x - xA;
                            if (d < 0.0) {
                                d = -d;
                            }
                            if (intersectionCount === 0) {
                                dMin = d;
                                dMax = d;
                                xMin = x;
                                yMin = y;
                                xMax = x;
                                yMax = y;
                                if (normalRadians !== null) {
                                    normalRadians.x = Math.atan2(yD - yC, xD - xC) - Math.PI * 0.5;
                                    normalRadians.y = normalRadians.x;
                                }
                            }
                            else {
                                if (d < dMin) {
                                    dMin = d;
                                    xMin = x;
                                    yMin = y;
                                    if (normalRadians !== null) {
                                        normalRadians.x = Math.atan2(yD - yC, xD - xC) - Math.PI * 0.5;
                                    }
                                }
                                if (d > dMax) {
                                    dMax = d;
                                    xMax = x;
                                    yMax = y;
                                    if (normalRadians !== null) {
                                        normalRadians.y = Math.atan2(yD - yC, xD - xC) - Math.PI * 0.5;
                                    }
                                }
                            }
                            intersectionCount++;
                        }
                        else {
                            xMin = x;
                            yMin = y;
                            xMax = x;
                            yMax = y;
                            intersectionCount++;
                            if (normalRadians !== null) {
                                normalRadians.x = Math.atan2(yD - yC, xD - xC) - Math.PI * 0.5;
                                normalRadians.y = normalRadians.x;
                            }
                            break;
                        }
                    }
                }
                xC = xD;
                yC = yD;
            }
            if (intersectionCount === 1) {
                if (intersectionPointA !== null) {
                    intersectionPointA.x = xMin;
                    intersectionPointA.y = yMin;
                }
                if (intersectionPointB !== null) {
                    intersectionPointB.x = xMin;
                    intersectionPointB.y = yMin;
                }
                if (normalRadians !== null) {
                    normalRadians.y = normalRadians.x + Math.PI;
                }
            }
            else if (intersectionCount > 1) {
                intersectionCount++;
                if (intersectionPointA !== null) {
                    intersectionPointA.x = xMin;
                    intersectionPointA.y = yMin;
                }
                if (intersectionPointB !== null) {
                    intersectionPointB.x = xMax;
                    intersectionPointB.y = yMax;
                }
            }
            return intersectionCount;
        };
        PolygonBoundingBoxData.prototype._onClear = function () {
            _super.prototype._onClear.call(this);
            this.type = 2 /* Polygon */;
            this.x = 0.0;
            this.y = 0.0;
            this.vertices.length = 0;
        };
        /**
         * @inheritDoc
         */
        PolygonBoundingBoxData.prototype.containsPoint = function (pX, pY) {
            var isInSide = false;
            if (pX >= this.x && pX <= this.width && pY >= this.y && pY <= this.height) {
                for (var i = 0, l = this.vertices.length, iP = l - 2; i < l; i += 2) {
                    var yA = this.vertices[iP + 1];
                    var yB = this.vertices[i + 1];
                    if ((yB < pY && yA >= pY) || (yA < pY && yB >= pY)) {
                        var xA = this.vertices[iP];
                        var xB = this.vertices[i];
                        if ((pY - yB) * (xA - xB) / (yA - yB) + xB < pX) {
                            isInSide = !isInSide;
                        }
                    }
                    iP = i;
                }
            }
            return isInSide;
        };
        /**
         * @inheritDoc
         */
        PolygonBoundingBoxData.prototype.intersectsSegment = function (xA, yA, xB, yB, intersectionPointA, intersectionPointB, normalRadians) {
            if (intersectionPointA === void 0) { intersectionPointA = null; }
            if (intersectionPointB === void 0) { intersectionPointB = null; }
            if (normalRadians === void 0) { normalRadians = null; }
            var intersectionCount = 0;
            if (RectangleBoundingBoxData.rectangleIntersectsSegment(xA, yA, xB, yB, this.x, this.y, this.x + this.width, this.y + this.height, null, null, null) !== 0) {
                intersectionCount = PolygonBoundingBoxData.polygonIntersectsSegment(xA, yA, xB, yB, this.vertices, intersectionPointA, intersectionPointB, normalRadians);
            }
            return intersectionCount;
        };
        return PolygonBoundingBoxData;
    }(BoundingBoxData));
    dragonBones.PolygonBoundingBoxData = PolygonBoundingBoxData;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * - The animation data.
     * @version DragonBones 3.0
     * @language en_US
     */
    /**
     * - 动画数据。
     * @version DragonBones 3.0
     * @language zh_CN
     */
    var AnimationData = /** @class */ (function (_super) {
        __extends(AnimationData, _super);
        function AnimationData() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @private
             */
            _this.cachedFrames = [];
            /**
             * @private
             */
            _this.boneTimelines = {};
            /**
             * @private
             */
            _this.slotTimelines = {};
            /**
             * @private
             */
            _this.constraintTimelines = {};
            /**
             * @private
             */
            _this.animationTimelines = {};
            /**
             * @private
             */
            _this.boneCachedFrameIndices = {};
            /**
             * @private
             */
            _this.slotCachedFrameIndices = {};
            /**
             * @private
             */
            _this.actionTimeline = null; // Initial value.
            /**
             * @private
             */
            _this.zOrderTimeline = null; // Initial value.
            return _this;
        }
        AnimationData.toString = function () {
            return "[class dragonBones.AnimationData]";
        };
        AnimationData.prototype._onClear = function () {
            for (var k in this.boneTimelines) {
                for (var _i = 0, _a = this.boneTimelines[k]; _i < _a.length; _i++) {
                    var timeline = _a[_i];
                    timeline.returnToPool();
                }
                delete this.boneTimelines[k];
            }
            for (var k in this.slotTimelines) {
                for (var _b = 0, _c = this.slotTimelines[k]; _b < _c.length; _b++) {
                    var timeline = _c[_b];
                    timeline.returnToPool();
                }
                delete this.slotTimelines[k];
            }
            for (var k in this.constraintTimelines) {
                for (var _d = 0, _e = this.constraintTimelines[k]; _d < _e.length; _d++) {
                    var timeline = _e[_d];
                    timeline.returnToPool();
                }
                delete this.constraintTimelines[k];
            }
            for (var k in this.animationTimelines) {
                for (var _f = 0, _g = this.animationTimelines[k]; _f < _g.length; _f++) {
                    var timeline = _g[_f];
                    timeline.returnToPool();
                }
                delete this.animationTimelines[k];
            }
            for (var k in this.boneCachedFrameIndices) {
                delete this.boneCachedFrameIndices[k];
            }
            for (var k in this.slotCachedFrameIndices) {
                delete this.slotCachedFrameIndices[k];
            }
            if (this.actionTimeline !== null) {
                this.actionTimeline.returnToPool();
            }
            if (this.zOrderTimeline !== null) {
                this.zOrderTimeline.returnToPool();
            }
            this.frameIntOffset = 0;
            this.frameFloatOffset = 0;
            this.frameOffset = 0;
            this.blendType = 0 /* None */;
            this.frameCount = 0;
            this.playTimes = 0;
            this.duration = 0.0;
            this.scale = 1.0;
            this.fadeInTime = 0.0;
            this.cacheFrameRate = 0.0;
            this.name = "";
            this.cachedFrames.length = 0;
            // this.boneTimelines.clear();
            // this.slotTimelines.clear();
            // this.constraintTimelines.clear();
            // this.animationTimelines.clear();
            // this.boneCachedFrameIndices.clear();
            // this.slotCachedFrameIndices.clear();
            this.actionTimeline = null;
            this.zOrderTimeline = null;
            this.parent = null; //
        };
        /**
         * @internal
         */
        AnimationData.prototype.cacheFrames = function (frameRate) {
            if (this.cacheFrameRate > 0.0) { // TODO clear cache.
                return;
            }
            this.cacheFrameRate = Math.max(Math.ceil(frameRate * this.scale), 1.0);
            var cacheFrameCount = Math.ceil(this.cacheFrameRate * this.duration) + 1; // Cache one more frame.
            this.cachedFrames.length = cacheFrameCount;
            for (var i = 0, l = this.cacheFrames.length; i < l; ++i) {
                this.cachedFrames[i] = false;
            }
            for (var _i = 0, _a = this.parent.sortedBones; _i < _a.length; _i++) {
                var bone = _a[_i];
                var indices = new Array(cacheFrameCount);
                for (var i = 0, l = indices.length; i < l; ++i) {
                    indices[i] = -1;
                }
                this.boneCachedFrameIndices[bone.name] = indices;
            }
            for (var _b = 0, _c = this.parent.sortedSlots; _b < _c.length; _b++) {
                var slot = _c[_b];
                var indices = new Array(cacheFrameCount);
                for (var i = 0, l = indices.length; i < l; ++i) {
                    indices[i] = -1;
                }
                this.slotCachedFrameIndices[slot.name] = indices;
            }
        };
        /**
         * @private
         */
        AnimationData.prototype.addBoneTimeline = function (timelineName, timeline) {
            var timelines = timelineName in this.boneTimelines ? this.boneTimelines[timelineName] : (this.boneTimelines[timelineName] = []);
            if (timelines.indexOf(timeline) < 0) {
                timelines.push(timeline);
            }
        };
        /**
         * @private
         */
        AnimationData.prototype.addSlotTimeline = function (timelineName, timeline) {
            var timelines = timelineName in this.slotTimelines ? this.slotTimelines[timelineName] : (this.slotTimelines[timelineName] = []);
            if (timelines.indexOf(timeline) < 0) {
                timelines.push(timeline);
            }
        };
        /**
         * @private
         */
        AnimationData.prototype.addConstraintTimeline = function (timelineName, timeline) {
            var timelines = timelineName in this.constraintTimelines ? this.constraintTimelines[timelineName] : (this.constraintTimelines[timelineName] = []);
            if (timelines.indexOf(timeline) < 0) {
                timelines.push(timeline);
            }
        };
        /**
         * @private
         */
        AnimationData.prototype.addAnimationTimeline = function (timelineName, timeline) {
            var timelines = timelineName in this.animationTimelines ? this.animationTimelines[timelineName] : (this.animationTimelines[timelineName] = []);
            if (timelines.indexOf(timeline) < 0) {
                timelines.push(timeline);
            }
        };
        /**
         * @private
         */
        AnimationData.prototype.getBoneTimelines = function (timelineName) {
            return timelineName in this.boneTimelines ? this.boneTimelines[timelineName] : null;
        };
        /**
         * @private
         */
        AnimationData.prototype.getSlotTimelines = function (timelineName) {
            return timelineName in this.slotTimelines ? this.slotTimelines[timelineName] : null;
        };
        /**
         * @private
         */
        AnimationData.prototype.getConstraintTimelines = function (timelineName) {
            return timelineName in this.constraintTimelines ? this.constraintTimelines[timelineName] : null;
        };
        /**
         * @private
         */
        AnimationData.prototype.getAnimationTimelines = function (timelineName) {
            return timelineName in this.animationTimelines ? this.animationTimelines[timelineName] : null;
        };
        /**
         * @private
         */
        AnimationData.prototype.getBoneCachedFrameIndices = function (boneName) {
            return boneName in this.boneCachedFrameIndices ? this.boneCachedFrameIndices[boneName] : null;
        };
        /**
         * @private
         */
        AnimationData.prototype.getSlotCachedFrameIndices = function (slotName) {
            return slotName in this.slotCachedFrameIndices ? this.slotCachedFrameIndices[slotName] : null;
        };
        return AnimationData;
    }(dragonBones.BaseObject));
    dragonBones.AnimationData = AnimationData;
    /**
     * @private
     */
    var TimelineData = /** @class */ (function (_super) {
        __extends(TimelineData, _super);
        function TimelineData() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TimelineData.toString = function () {
            return "[class dragonBones.TimelineData]";
        };
        TimelineData.prototype._onClear = function () {
            this.type = 10 /* BoneAll */;
            this.offset = 0;
            this.frameIndicesOffset = -1;
        };
        return TimelineData;
    }(dragonBones.BaseObject));
    dragonBones.TimelineData = TimelineData;
    /**
     * @internal
     */
    var AnimationTimelineData = /** @class */ (function (_super) {
        __extends(AnimationTimelineData, _super);
        function AnimationTimelineData() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AnimationTimelineData.toString = function () {
            return "[class dragonBones.AnimationTimelineData]";
        };
        AnimationTimelineData.prototype._onClear = function () {
            _super.prototype._onClear.call(this);
            this.x = 0.0;
            this.y = 0.0;
        };
        return AnimationTimelineData;
    }(TimelineData));
    dragonBones.AnimationTimelineData = AnimationTimelineData;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * - The animation config is used to describe all the information needed to play an animation state.
     * The API is still in the experimental phase and may encounter bugs or stability or compatibility issues when used.
     * @see dragonBones.AnimationState
     * @beta
     * @version DragonBones 5.0
     * @language en_US
     */
    /**
     * - 动画配置用来描述播放一个动画状态所需要的全部信息。
     * 该 API 仍在实验阶段，使用时可能遭遇 bug 或稳定性或兼容性问题。
     * @see dragonBones.AnimationState
     * @beta
     * @version DragonBones 5.0
     * @language zh_CN
     */
    var AnimationConfig = /** @class */ (function (_super) {
        __extends(AnimationConfig, _super);
        function AnimationConfig() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @private
             */
            _this.boneMask = [];
            return _this;
        }
        AnimationConfig.toString = function () {
            return "[class dragonBones.AnimationConfig]";
        };
        AnimationConfig.prototype._onClear = function () {
            this.pauseFadeOut = true;
            this.fadeOutMode = 4 /* All */;
            this.fadeOutTweenType = 1 /* Line */;
            this.fadeOutTime = -1.0;
            this.actionEnabled = true;
            this.additive = false;
            this.displayControl = true;
            this.pauseFadeIn = true;
            this.resetToPose = true;
            this.fadeInTweenType = 1 /* Line */;
            this.playTimes = -1;
            this.layer = 0;
            this.position = 0.0;
            this.duration = -1.0;
            this.timeScale = -100.0;
            this.weight = 1.0;
            this.fadeInTime = -1.0;
            this.autoFadeOutTime = -1.0;
            this.name = "";
            this.animation = "";
            this.group = "";
            this.boneMask.length = 0;
        };
        /**
         * @private
         */
        AnimationConfig.prototype.clear = function () {
            this._onClear();
        };
        /**
         * @private
         */
        AnimationConfig.prototype.copyFrom = function (value) {
            this.pauseFadeOut = value.pauseFadeOut;
            this.fadeOutMode = value.fadeOutMode;
            this.autoFadeOutTime = value.autoFadeOutTime;
            this.fadeOutTweenType = value.fadeOutTweenType;
            this.actionEnabled = value.actionEnabled;
            this.additive = value.additive;
            this.displayControl = value.displayControl;
            this.pauseFadeIn = value.pauseFadeIn;
            this.resetToPose = value.resetToPose;
            this.playTimes = value.playTimes;
            this.layer = value.layer;
            this.position = value.position;
            this.duration = value.duration;
            this.timeScale = value.timeScale;
            this.fadeInTime = value.fadeInTime;
            this.fadeOutTime = value.fadeOutTime;
            this.fadeInTweenType = value.fadeInTweenType;
            this.weight = value.weight;
            this.name = value.name;
            this.animation = value.animation;
            this.group = value.group;
            this.boneMask.length = value.boneMask.length;
            for (var i = 0, l = this.boneMask.length; i < l; ++i) {
                this.boneMask[i] = value.boneMask[i];
            }
        };
        return AnimationConfig;
    }(dragonBones.BaseObject));
    dragonBones.AnimationConfig = AnimationConfig;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * - The texture atlas data.
     * @version DragonBones 3.0
     * @language en_US
     */
    /**
     * - 贴图集数据。
     * @version DragonBones 3.0
     * @language zh_CN
     */
    var TextureAtlasData = /** @class */ (function (_super) {
        __extends(TextureAtlasData, _super);
        function TextureAtlasData() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @private
             */
            _this.textures = {};
            return _this;
        }
        TextureAtlasData.prototype._onClear = function () {
            for (var k in this.textures) {
                this.textures[k].returnToPool();
                delete this.textures[k];
            }
            this.autoSearch = false;
            this.width = 0;
            this.height = 0;
            this.scale = 1.0;
            // this.textures.clear();
            this.name = "";
            this.imagePath = "";
        };
        /**
         * @private
         */
        TextureAtlasData.prototype.copyFrom = function (value) {
            this.autoSearch = value.autoSearch;
            this.scale = value.scale;
            this.width = value.width;
            this.height = value.height;
            this.name = value.name;
            this.imagePath = value.imagePath;
            for (var k in this.textures) {
                this.textures[k].returnToPool();
                delete this.textures[k];
            }
            // this.textures.clear();
            for (var k in value.textures) {
                var texture = this.createTexture();
                texture.copyFrom(value.textures[k]);
                this.textures[k] = texture;
            }
        };
        /**
         * @internal
         */
        TextureAtlasData.prototype.addTexture = function (value) {
            if (value.name in this.textures) {
                console.warn("Same texture: " + value.name);
                return;
            }
            value.parent = this;
            this.textures[value.name] = value;
        };
        /**
         * @private
         */
        TextureAtlasData.prototype.getTexture = function (textureName) {
            return textureName in this.textures ? this.textures[textureName] : null;
        };
        return TextureAtlasData;
    }(dragonBones.BaseObject));
    dragonBones.TextureAtlasData = TextureAtlasData;
    /**
     * @private
     */
    var TextureData = /** @class */ (function (_super) {
        __extends(TextureData, _super);
        function TextureData() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.region = new dragonBones.Rectangle();
            _this.frame = null; // Initial value.
            return _this;
        }
        TextureData.createRectangle = function () {
            return new dragonBones.Rectangle();
        };
        TextureData.prototype._onClear = function () {
            this.rotated = false;
            this.name = "";
            this.region.clear();
            this.parent = null; //
            this.frame = null;
        };
        TextureData.prototype.copyFrom = function (value) {
            this.rotated = value.rotated;
            this.name = value.name;
            this.region.copyFrom(value.region);
            this.parent = value.parent;
            if (this.frame === null && value.frame !== null) {
                this.frame = TextureData.createRectangle();
            }
            else if (this.frame !== null && value.frame === null) {
                this.frame = null;
            }
            if (this.frame !== null && value.frame !== null) {
                this.frame.copyFrom(value.frame);
            }
        };
        return TextureData;
    }(dragonBones.BaseObject));
    dragonBones.TextureData = TextureData;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones_1) {
    /**
     * - Armature is the core of the skeleton animation system.
     * @see dragonBones.ArmatureData
     * @see dragonBones.Bone
     * @see dragonBones.Slot
     * @see dragonBones.Animation
     * @version DragonBones 3.0
     * @language en_US
     */
    /**
     * - 骨架是骨骼动画系统的核心。
     * @see dragonBones.ArmatureData
     * @see dragonBones.Bone
     * @see dragonBones.Slot
     * @see dragonBones.Animation
     * @version DragonBones 3.0
     * @language zh_CN
     */
    var Armature = /** @class */ (function (_super) {
        __extends(Armature, _super);
        function Armature() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._bones = [];
            _this._slots = [];
            /**
             * @internal
             */
            _this._constraints = [];
            _this._actions = [];
            _this._animation = null; // Initial value.
            _this._proxy = null; // Initial value.
            /**
             * @internal
             */
            _this._replaceTextureAtlasData = null; // Initial value.
            _this._clock = null; // Initial value.
            return _this;
        }
        Armature.toString = function () {
            return "[class dragonBones.Armature]";
        };
        Armature._onSortSlots = function (a, b) {
            return a._zIndex * 1000 + a._zOrder > b._zIndex * 1000 + b._zOrder ? 1 : -1;
        };
        Armature.prototype._onClear = function () {
            if (this._clock !== null) { // Remove clock first.
                this._clock.remove(this);
            }
            for (var _i = 0, _a = this._bones; _i < _a.length; _i++) {
                var bone = _a[_i];
                bone.returnToPool();
            }
            for (var _b = 0, _c = this._slots; _b < _c.length; _b++) {
                var slot = _c[_b];
                slot.returnToPool();
            }
            for (var _d = 0, _e = this._constraints; _d < _e.length; _d++) {
                var constraint = _e[_d];
                constraint.returnToPool();
            }
            for (var _f = 0, _g = this._actions; _f < _g.length; _f++) {
                var action = _g[_f];
                action.returnToPool();
            }
            if (this._animation !== null) {
                this._animation.returnToPool();
            }
            if (this._proxy !== null) {
                this._proxy.dbClear();
            }
            if (this._replaceTextureAtlasData !== null) {
                this._replaceTextureAtlasData.returnToPool();
            }
            this.inheritAnimation = true;
            this.userData = null;
            this._lockUpdate = false;
            this._slotsDirty = true;
            this._zOrderDirty = false;
            this._zIndexDirty = false;
            this._alphaDirty = true;
            this._flipX = false;
            this._flipY = false;
            this._cacheFrameIndex = -1;
            this._alpha = 1.0;
            this._globalAlpha = 1.0;
            this._bones.length = 0;
            this._slots.length = 0;
            this._constraints.length = 0;
            this._actions.length = 0;
            this._armatureData = null; //
            this._animation = null; //
            this._proxy = null; //
            this._display = null;
            this._replaceTextureAtlasData = null;
            this._replacedTexture = null;
            this._dragonBones = null; //
            this._clock = null;
            this._parent = null;
        };
        /**
         * @internal
         */
        Armature.prototype._sortZOrder = function (slotIndices, offset) {
            var slotDatas = this._armatureData.sortedSlots;
            var isOriginal = slotIndices === null;
            if (this._zOrderDirty || !isOriginal) {
                for (var i = 0, l = slotDatas.length; i < l; ++i) {
                    var slotIndex = isOriginal ? i : slotIndices[offset + i];
                    if (slotIndex < 0 || slotIndex >= l) {
                        continue;
                    }
                    var slotData = slotDatas[slotIndex];
                    var slot = this.getSlot(slotData.name);
                    if (slot !== null) {
                        slot._setZOrder(i);
                    }
                }
                this._slotsDirty = true;
                this._zOrderDirty = !isOriginal;
            }
        };
        /**
         * @internal
         */
        Armature.prototype._addBone = function (value) {
            if (this._bones.indexOf(value) < 0) {
                this._bones.push(value);
            }
        };
        /**
         * @internal
         */
        Armature.prototype._addSlot = function (value) {
            if (this._slots.indexOf(value) < 0) {
                this._slots.push(value);
            }
        };
        /**
         * @internal
         */
        Armature.prototype._addConstraint = function (value) {
            if (this._constraints.indexOf(value) < 0) {
                this._constraints.push(value);
            }
        };
        /**
         * @internal
         */
        Armature.prototype._bufferAction = function (action, append) {
            if (this._actions.indexOf(action) < 0) {
                if (append) {
                    this._actions.push(action);
                }
                else {
                    this._actions.unshift(action);
                }
            }
        };
        /**
         * - Dispose the armature. (Return to the object pool)
         * @example
         * <pre>
         *     removeChild(armature.display);
         *     armature.dispose();
         * </pre>
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 释放骨架。 （回收到对象池）
         * @example
         * <pre>
         *     removeChild(armature.display);
         *     armature.dispose();
         * </pre>
         * @version DragonBones 3.0
         * @language zh_CN
         */
        Armature.prototype.dispose = function () {
            if (this._armatureData !== null) {
                this._lockUpdate = true;
                this._dragonBones.bufferObject(this);
            }
        };
        /**
         * @internal
         */
        Armature.prototype.init = function (armatureData, proxy, display, dragonBones) {
            if (this._armatureData !== null) {
                return;
            }
            this._armatureData = armatureData;
            this._animation = dragonBones_1.BaseObject.borrowObject(dragonBones_1.Animation);
            this._proxy = proxy;
            this._display = display;
            this._dragonBones = dragonBones;
            this._proxy.dbInit(this);
            this._animation.init(this);
            this._animation.animations = this._armatureData.animations;
        };
        /**
         * @inheritDoc
         */
        Armature.prototype.advanceTime = function (passedTime) {
            if (this._lockUpdate) {
                return;
            }
            this._lockUpdate = true;
            if (this._armatureData === null) {
                console.warn("The armature has been disposed.");
                return;
            }
            else if (this._armatureData.parent === null) {
                console.warn("The armature data has been disposed.\nPlease make sure dispose armature before call factory.clear().");
                return;
            }
            var prevCacheFrameIndex = this._cacheFrameIndex;
            // Update animation.
            this._animation.advanceTime(passedTime);
            // Sort slots.
            if (this._slotsDirty || this._zIndexDirty) {
                this._slots.sort(Armature._onSortSlots);
                if (this._zIndexDirty) {
                    for (var i = 0, l = this._slots.length; i < l; ++i) {
                        this._slots[i]._setZOrder(i); // 
                    }
                }
                this._slotsDirty = false;
                this._zIndexDirty = false;
            }
            // Update alpha.
            if (this._alphaDirty) {
                this._alphaDirty = false;
                this._globalAlpha = this._alpha * (this._parent !== null ? this._parent._globalAlpha : 1.0);
                for (var _i = 0, _a = this._bones; _i < _a.length; _i++) {
                    var bone = _a[_i];
                    bone._updateAlpha();
                }
                for (var _b = 0, _c = this._slots; _b < _c.length; _b++) {
                    var slot = _c[_b];
                    slot._updateAlpha();
                }
            }
            // Update bones and slots.
            if (this._cacheFrameIndex < 0 || this._cacheFrameIndex !== prevCacheFrameIndex) {
                var i = 0, l = 0;
                for (i = 0, l = this._bones.length; i < l; ++i) {
                    this._bones[i].update(this._cacheFrameIndex);
                }
                for (i = 0, l = this._slots.length; i < l; ++i) {
                    this._slots[i].update(this._cacheFrameIndex);
                }
            }
            // Do actions.
            if (this._actions.length > 0) {
                for (var _d = 0, _e = this._actions; _d < _e.length; _d++) {
                    var action = _e[_d];
                    var actionData = action.actionData;
                    if (actionData !== null) {
                        if (actionData.type === 0 /* Play */) {
                            if (action.slot !== null) {
                                var childArmature = action.slot.childArmature;
                                if (childArmature !== null) {
                                    childArmature.animation.fadeIn(actionData.name);
                                }
                            }
                            else if (action.bone !== null) {
                                for (var _f = 0, _g = this.getSlots(); _f < _g.length; _f++) {
                                    var slot = _g[_f];
                                    if (slot.parent === action.bone) {
                                        var childArmature = slot.childArmature;
                                        if (childArmature !== null) {
                                            childArmature.animation.fadeIn(actionData.name);
                                        }
                                    }
                                }
                            }
                            else {
                                this._animation.fadeIn(actionData.name);
                            }
                        }
                    }
                    action.returnToPool();
                }
                this._actions.length = 0;
            }
            this._lockUpdate = false;
            this._proxy.dbUpdate();
        };
        /**
         * - Forces a specific bone or its owning slot to update the transform or display property in the next frame.
         * @param boneName - The bone name. (If not set, all bones will be update)
         * @param updateSlot - Whether to update the bone's slots. (Default: false)
         * @see dragonBones.Bone#invalidUpdate()
         * @see dragonBones.Slot#invalidUpdate()
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 强制特定骨骼或其拥有的插槽在下一帧更新变换或显示属性。
         * @param boneName - 骨骼名称。 （如果未设置，将更新所有骨骼）
         * @param updateSlot - 是否更新骨骼的插槽。 （默认: false）
         * @see dragonBones.Bone#invalidUpdate()
         * @see dragonBones.Slot#invalidUpdate()
         * @version DragonBones 3.0
         * @language zh_CN
         */
        Armature.prototype.invalidUpdate = function (boneName, updateSlot) {
            if (boneName === void 0) { boneName = null; }
            if (updateSlot === void 0) { updateSlot = false; }
            if (boneName !== null && boneName.length > 0) {
                var bone = this.getBone(boneName);
                if (bone !== null) {
                    bone.invalidUpdate();
                    if (updateSlot) {
                        for (var _i = 0, _a = this._slots; _i < _a.length; _i++) {
                            var slot = _a[_i];
                            if (slot.parent === bone) {
                                slot.invalidUpdate();
                            }
                        }
                    }
                }
            }
            else {
                for (var _b = 0, _c = this._bones; _b < _c.length; _b++) {
                    var bone = _c[_b];
                    bone.invalidUpdate();
                }
                if (updateSlot) {
                    for (var _d = 0, _e = this._slots; _d < _e.length; _d++) {
                        var slot = _e[_d];
                        slot.invalidUpdate();
                    }
                }
            }
        };
        /**
         * - Check whether a specific point is inside a custom bounding box in a slot.
         * The coordinate system of the point is the inner coordinate system of the armature.
         * Custom bounding boxes need to be customized in Dragonbones Pro.
         * @param x - The horizontal coordinate of the point.
         * @param y - The vertical coordinate of the point.
         * @version DragonBones 5.0
         * @language en_US
         */
        /**
         * - 检查特定点是否在某个插槽的自定义边界框内。
         * 点的坐标系为骨架内坐标系。
         * 自定义边界框需要在 DragonBones Pro 中自定义。
         * @param x - 点的水平坐标。
         * @param y - 点的垂直坐标。
         * @version DragonBones 5.0
         * @language zh_CN
         */
        Armature.prototype.containsPoint = function (x, y) {
            for (var _i = 0, _a = this._slots; _i < _a.length; _i++) {
                var slot = _a[_i];
                if (slot.containsPoint(x, y)) {
                    return slot;
                }
            }
            return null;
        };
        /**
         * - Check whether a specific segment intersects a custom bounding box for a slot in the armature.
         * The coordinate system of the segment and intersection is the inner coordinate system of the armature.
         * Custom bounding boxes need to be customized in Dragonbones Pro.
         * @param xA - The horizontal coordinate of the beginning of the segment.
         * @param yA - The vertical coordinate of the beginning of the segment.
         * @param xB - The horizontal coordinate of the end point of the segment.
         * @param yB - The vertical coordinate of the end point of the segment.
         * @param intersectionPointA - The first intersection at which a line segment intersects the bounding box from the beginning to the end. (If not set, the intersection point will not calculated)
         * @param intersectionPointB - The first intersection at which a line segment intersects the bounding box from the end to the beginning. (If not set, the intersection point will not calculated)
         * @param normalRadians - The normal radians of the tangent of the intersection boundary box. [x: Normal radian of the first intersection tangent, y: Normal radian of the second intersection tangent] (If not set, the normal will not calculated)
         * @returns The slot of the first custom bounding box where the segment intersects from the start point to the end point.
         * @version DragonBones 5.0
         * @language en_US
         */
        /**
         * - 检查特定线段是否与骨架的某个插槽的自定义边界框相交。
         * 线段和交点的坐标系均为骨架内坐标系。
         * 自定义边界框需要在 DragonBones Pro 中自定义。
         * @param xA - 线段起点的水平坐标。
         * @param yA - 线段起点的垂直坐标。
         * @param xB - 线段终点的水平坐标。
         * @param yB - 线段终点的垂直坐标。
         * @param intersectionPointA - 线段从起点到终点与边界框相交的第一个交点。 （如果未设置，则不计算交点）
         * @param intersectionPointB - 线段从终点到起点与边界框相交的第一个交点。 （如果未设置，则不计算交点）
         * @param normalRadians - 交点边界框切线的法线弧度。 [x: 第一个交点切线的法线弧度, y: 第二个交点切线的法线弧度] （如果未设置，则不计算法线）
         * @returns 线段从起点到终点相交的第一个自定义边界框的插槽。
         * @version DragonBones 5.0
         * @language zh_CN
         */
        Armature.prototype.intersectsSegment = function (xA, yA, xB, yB, intersectionPointA, intersectionPointB, normalRadians) {
            if (intersectionPointA === void 0) { intersectionPointA = null; }
            if (intersectionPointB === void 0) { intersectionPointB = null; }
            if (normalRadians === void 0) { normalRadians = null; }
            var isV = xA === xB;
            var dMin = 0.0;
            var dMax = 0.0;
            var intXA = 0.0;
            var intYA = 0.0;
            var intXB = 0.0;
            var intYB = 0.0;
            var intAN = 0.0;
            var intBN = 0.0;
            var intSlotA = null;
            var intSlotB = null;
            for (var _i = 0, _a = this._slots; _i < _a.length; _i++) {
                var slot = _a[_i];
                var intersectionCount = slot.intersectsSegment(xA, yA, xB, yB, intersectionPointA, intersectionPointB, normalRadians);
                if (intersectionCount > 0) {
                    if (intersectionPointA !== null || intersectionPointB !== null) {
                        if (intersectionPointA !== null) {
                            var d = isV ? intersectionPointA.y - yA : intersectionPointA.x - xA;
                            if (d < 0.0) {
                                d = -d;
                            }
                            if (intSlotA === null || d < dMin) {
                                dMin = d;
                                intXA = intersectionPointA.x;
                                intYA = intersectionPointA.y;
                                intSlotA = slot;
                                if (normalRadians) {
                                    intAN = normalRadians.x;
                                }
                            }
                        }
                        if (intersectionPointB !== null) {
                            var d = intersectionPointB.x - xA;
                            if (d < 0.0) {
                                d = -d;
                            }
                            if (intSlotB === null || d > dMax) {
                                dMax = d;
                                intXB = intersectionPointB.x;
                                intYB = intersectionPointB.y;
                                intSlotB = slot;
                                if (normalRadians !== null) {
                                    intBN = normalRadians.y;
                                }
                            }
                        }
                    }
                    else {
                        intSlotA = slot;
                        break;
                    }
                }
            }
            if (intSlotA !== null && intersectionPointA !== null) {
                intersectionPointA.x = intXA;
                intersectionPointA.y = intYA;
                if (normalRadians !== null) {
                    normalRadians.x = intAN;
                }
            }
            if (intSlotB !== null && intersectionPointB !== null) {
                intersectionPointB.x = intXB;
                intersectionPointB.y = intYB;
                if (normalRadians !== null) {
                    normalRadians.y = intBN;
                }
            }
            return intSlotA;
        };
        /**
         * - Get a specific bone.
         * @param name - The bone name.
         * @see dragonBones.Bone
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 获取特定的骨骼。
         * @param name - 骨骼名称。
         * @see dragonBones.Bone
         * @version DragonBones 3.0
         * @language zh_CN
         */
        Armature.prototype.getBone = function (name) {
            for (var _i = 0, _a = this._bones; _i < _a.length; _i++) {
                var bone = _a[_i];
                if (bone.name === name) {
                    return bone;
                }
            }
            return null;
        };
        /**
         * - Get a specific bone by the display.
         * @param display - The display object.
         * @see dragonBones.Bone
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 通过显示对象获取特定的骨骼。
         * @param display - 显示对象。
         * @see dragonBones.Bone
         * @version DragonBones 3.0
         * @language zh_CN
         */
        Armature.prototype.getBoneByDisplay = function (display) {
            var slot = this.getSlotByDisplay(display);
            return slot !== null ? slot.parent : null;
        };
        /**
         * - Get a specific slot.
         * @param name - The slot name.
         * @see dragonBones.Slot
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 获取特定的插槽。
         * @param name - 插槽名称。
         * @see dragonBones.Slot
         * @version DragonBones 3.0
         * @language zh_CN
         */
        Armature.prototype.getSlot = function (name) {
            for (var _i = 0, _a = this._slots; _i < _a.length; _i++) {
                var slot = _a[_i];
                if (slot.name === name) {
                    return slot;
                }
            }
            return null;
        };
        /**
         * - Get a specific slot by the display.
         * @param display - The display object.
         * @see dragonBones.Slot
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 通过显示对象获取特定的插槽。
         * @param display - 显示对象。
         * @see dragonBones.Slot
         * @version DragonBones 3.0
         * @language zh_CN
         */
        Armature.prototype.getSlotByDisplay = function (display) {
            if (display !== null) {
                for (var _i = 0, _a = this._slots; _i < _a.length; _i++) {
                    var slot = _a[_i];
                    if (slot.display === display) {
                        return slot;
                    }
                }
            }
            return null;
        };
        /**
         * - Get all bones.
         * @see dragonBones.Bone
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 获取所有的骨骼。
         * @see dragonBones.Bone
         * @version DragonBones 3.0
         * @language zh_CN
         */
        Armature.prototype.getBones = function () {
            return this._bones;
        };
        /**
         * - Get all slots.
         * @see dragonBones.Slot
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 获取所有的插槽。
         * @see dragonBones.Slot
         * @version DragonBones 3.0
         * @language zh_CN
         */
        Armature.prototype.getSlots = function () {
            return this._slots;
        };
        Object.defineProperty(Armature.prototype, "flipX", {
            /**
             * - Whether to flip the armature horizontally.
             * @version DragonBones 5.5
             * @language en_US
             */
            /**
             * - 是否将骨架水平翻转。
             * @version DragonBones 5.5
             * @language zh_CN
             */
            get: function () {
                return this._flipX;
            },
            set: function (value) {
                if (this._flipX === value) {
                    return;
                }
                this._flipX = value;
                this.invalidUpdate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Armature.prototype, "flipY", {
            /**
             * - Whether to flip the armature vertically.
             * @version DragonBones 5.5
             * @language en_US
             */
            /**
             * - 是否将骨架垂直翻转。
             * @version DragonBones 5.5
             * @language zh_CN
             */
            get: function () {
                return this._flipY;
            },
            set: function (value) {
                if (this._flipY === value) {
                    return;
                }
                this._flipY = value;
                this.invalidUpdate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Armature.prototype, "cacheFrameRate", {
            /**
             * - The animation cache frame rate, which turns on the animation cache when the set value is greater than 0.
             * There is a certain amount of memory overhead to improve performance by caching animation data in memory.
             * The frame rate should not be set too high, usually with the frame rate of the animation is similar and lower than the program running frame rate.
             * When the animation cache is turned on, some features will fail, such as the offset property of bone.
             * @example
             * <pre>
             *     armature.cacheFrameRate = 24;
             * </pre>
             * @see dragonBones.DragonBonesData#frameRate
             * @see dragonBones.ArmatureData#frameRate
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 动画缓存帧率，当设置的值大于 0 的时，将会开启动画缓存。
             * 通过将动画数据缓存在内存中来提高运行性能，会有一定的内存开销。
             * 帧率不宜设置的过高，通常跟动画的帧率相当且低于程序运行的帧率。
             * 开启动画缓存后，某些功能将会失效，比如骨骼的 offset 属性等。
             * @example
             * <pre>
             *     armature.cacheFrameRate = 24;
             * </pre>
             * @see dragonBones.DragonBonesData#frameRate
             * @see dragonBones.ArmatureData#frameRate
             * @version DragonBones 4.5
             * @language zh_CN
             */
            get: function () {
                return this._armatureData.cacheFrameRate;
            },
            set: function (value) {
                if (this._armatureData.cacheFrameRate !== value) {
                    this._armatureData.cacheFrames(value);
                    // Set child armature frameRate.
                    for (var _i = 0, _a = this._slots; _i < _a.length; _i++) {
                        var slot = _a[_i];
                        var childArmature = slot.childArmature;
                        if (childArmature !== null) {
                            childArmature.cacheFrameRate = value;
                        }
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Armature.prototype, "name", {
            /**
             * - The armature name.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 骨架名称。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            get: function () {
                return this._armatureData.name;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Armature.prototype, "armatureData", {
            /**
             * - The armature data.
             * @see dragonBones.ArmatureData
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 骨架数据。
             * @see dragonBones.ArmatureData
             * @version DragonBones 4.5
             * @language zh_CN
             */
            get: function () {
                return this._armatureData;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Armature.prototype, "animation", {
            /**
             * - The animation player.
             * @see dragonBones.Animation
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 动画播放器。
             * @see dragonBones.Animation
             * @version DragonBones 3.0
             * @language zh_CN
             */
            get: function () {
                return this._animation;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Armature.prototype, "proxy", {
            /**
             * @pivate
             */
            get: function () {
                return this._proxy;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Armature.prototype, "eventDispatcher", {
            /**
             * - The EventDispatcher instance of the armature.
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 该骨架的 EventDispatcher 实例。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            get: function () {
                return this._proxy;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Armature.prototype, "display", {
            /**
             * - The display container.
             * The display of the slot is displayed as the parent.
             * Depending on the rendering engine, the type will be different, usually the DisplayObjectContainer type.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 显示容器实例。
             * 插槽的显示对象都会以此显示容器为父级。
             * 根据渲染引擎的不同，类型会不同，通常是 DisplayObjectContainer 类型。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            get: function () {
                return this._display;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Armature.prototype, "replacedTexture", {
            /**
             * @private
             */
            get: function () {
                return this._replacedTexture;
            },
            set: function (value) {
                if (this._replacedTexture === value) {
                    return;
                }
                if (this._replaceTextureAtlasData !== null) {
                    this._replaceTextureAtlasData.returnToPool();
                    this._replaceTextureAtlasData = null;
                }
                this._replacedTexture = value;
                for (var _i = 0, _a = this._slots; _i < _a.length; _i++) {
                    var slot = _a[_i];
                    slot.invalidUpdate();
                    slot.update(-1);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Armature.prototype, "clock", {
            /**
             * @inheritDoc
             */
            get: function () {
                return this._clock;
            },
            set: function (value) {
                if (this._clock === value) {
                    return;
                }
                if (this._clock !== null) {
                    this._clock.remove(this);
                }
                this._clock = value;
                if (this._clock) {
                    this._clock.add(this);
                }
                // Update childArmature clock.
                for (var _i = 0, _a = this._slots; _i < _a.length; _i++) {
                    var slot = _a[_i];
                    var childArmature = slot.childArmature;
                    if (childArmature !== null) {
                        childArmature.clock = this._clock;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Armature.prototype, "parent", {
            /**
             * - Get the parent slot which the armature belongs to.
             * @see dragonBones.Slot
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 该骨架所属的父插槽。
             * @see dragonBones.Slot
             * @version DragonBones 4.5
             * @language zh_CN
             */
            get: function () {
                return this._parent;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * - Deprecated, please refer to {@link #display}.
         * @deprecated
         * @language en_US
         */
        /**
         * - 已废弃，请参考 {@link #display}。
         * @deprecated
         * @language zh_CN
         */
        Armature.prototype.getDisplay = function () {
            return this._display;
        };
        return Armature;
    }(dragonBones_1.BaseObject));
    dragonBones_1.Armature = Armature;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * - The base class of the transform object.
     * @see dragonBones.Transform
     * @version DragonBones 4.5
     * @language en_US
     */
    /**
     * - 变换对象的基类。
     * @see dragonBones.Transform
     * @version DragonBones 4.5
     * @language zh_CN
     */
    var TransformObject = /** @class */ (function (_super) {
        __extends(TransformObject, _super);
        function TransformObject() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * - A matrix relative to the armature coordinate system.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 相对于骨架坐标系的矩阵。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            _this.globalTransformMatrix = new dragonBones.Matrix();
            /**
             * - A transform relative to the armature coordinate system.
             * @see #updateGlobalTransform()
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 相对于骨架坐标系的变换。
             * @see #updateGlobalTransform()
             * @version DragonBones 3.0
             * @language zh_CN
             */
            _this.global = new dragonBones.Transform();
            /**
             * - The offset transform relative to the armature or the parent bone coordinate system.
             * @see #dragonBones.Bone#invalidUpdate()
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 相对于骨架或父骨骼坐标系的偏移变换。
             * @see #dragonBones.Bone#invalidUpdate()
             * @version DragonBones 3.0
             * @language zh_CN
             */
            _this.offset = new dragonBones.Transform();
            return _this;
        }
        /**
         */
        TransformObject.prototype._onClear = function () {
            this.globalTransformMatrix.identity();
            this.global.identity();
            this.offset.identity();
            this.origin = null;
            this.userData = null;
            this._globalDirty = false;
            this._alpha = 1.0;
            this._globalAlpha = 1.0;
            this._armature = null; //
        };
        /**
         * - For performance considerations, rotation or scale in the {@link #global} attribute of the bone or slot is not always properly accessible,
         * some engines do not rely on these attributes to update rendering, such as Egret.
         * The use of this method ensures that the access to the {@link #global} property is correctly rotation or scale.
         * @example
         * <pre>
         *     bone.updateGlobalTransform();
         *     let rotation = bone.global.rotation;
         * </pre>
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 出于性能的考虑，骨骼或插槽的 {@link #global} 属性中的旋转或缩放并不总是正确可访问的，有些引擎并不依赖这些属性更新渲染，比如 Egret。
         * 使用此方法可以保证访问到 {@link #global} 属性中正确的旋转或缩放。
         * @example
         * <pre>
         *     bone.updateGlobalTransform();
         *     let rotation = bone.global.rotation;
         * </pre>
         * @version DragonBones 3.0
         * @language zh_CN
         */
        TransformObject.prototype.updateGlobalTransform = function () {
            if (this._globalDirty) {
                this._globalDirty = false;
                this.global.fromMatrix(this.globalTransformMatrix);
            }
        };
        Object.defineProperty(TransformObject.prototype, "armature", {
            /**
             * - The armature to which it belongs.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 所属的骨架。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            get: function () {
                return this._armature;
            },
            enumerable: true,
            configurable: true
        });
        TransformObject._helpMatrix = new dragonBones.Matrix();
        TransformObject._helpTransform = new dragonBones.Transform();
        TransformObject._helpPoint = new dragonBones.Point();
        return TransformObject;
    }(dragonBones.BaseObject));
    dragonBones.TransformObject = TransformObject;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * - Bone is one of the most important logical units in the armature animation system,
     * and is responsible for the realization of translate, rotation, scaling in the animations.
     * A armature can contain multiple bones.
     * @see dragonBones.BoneData
     * @see dragonBones.Armature
     * @see dragonBones.Slot
     * @version DragonBones 3.0
     * @language en_US
     */
    /**
     * - 骨骼在骨骼动画体系中是最重要的逻辑单元之一，负责动画中的平移、旋转、缩放的实现。
     * 一个骨架中可以包含多个骨骼。
     * @see dragonBones.BoneData
     * @see dragonBones.Armature
     * @see dragonBones.Slot
     * @version DragonBones 3.0
     * @language zh_CN
     */
    var Bone = /** @class */ (function (_super) {
        __extends(Bone, _super);
        function Bone() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @internal
             */
            _this.animationPose = new dragonBones.Transform();
            return _this;
        }
        Bone.toString = function () {
            return "[class dragonBones.Bone]";
        };
        Bone.prototype._onClear = function () {
            _super.prototype._onClear.call(this);
            this.offsetMode = 1 /* Additive */;
            this.animationPose.identity();
            this._transformDirty = false;
            this._childrenTransformDirty = false;
            this._localDirty = true;
            this._hasConstraint = false;
            this._visible = true;
            this._cachedFrameIndex = -1;
            this._boneData = null; //
            this._parent = null; //
            this._cachedFrameIndices = null;
        };
        Bone.prototype._updateGlobalTransformMatrix = function (isCache) {
            // For typescript.
            var boneData = this._boneData;
            var global = this.global;
            var globalTransformMatrix = this.globalTransformMatrix;
            var origin = this.origin;
            var offset = this.offset;
            var animationPose = this.animationPose;
            var parent = this._parent; //
            var flipX = this._armature.flipX;
            var flipY = this._armature.flipY === dragonBones.DragonBones.yDown;
            var inherit = parent !== null;
            var rotation = 0.0;
            if (this.offsetMode === 1 /* Additive */) {
                if (origin !== null) {
                    // global.copyFrom(this.origin).add(this.offset).add(this.animationPose);
                    global.x = origin.x + offset.x + animationPose.x;
                    global.scaleX = origin.scaleX * offset.scaleX * animationPose.scaleX;
                    global.scaleY = origin.scaleY * offset.scaleY * animationPose.scaleY;
                    if (dragonBones.DragonBones.yDown) {
                        global.y = origin.y + offset.y + animationPose.y;
                        global.skew = origin.skew + offset.skew + animationPose.skew;
                        global.rotation = origin.rotation + offset.rotation + animationPose.rotation;
                    }
                    else {
                        global.y = origin.y - offset.y + animationPose.y;
                        global.skew = origin.skew - offset.skew + animationPose.skew;
                        global.rotation = origin.rotation - offset.rotation + animationPose.rotation;
                    }
                }
                else {
                    global.copyFrom(offset);
                    if (!dragonBones.DragonBones.yDown) {
                        global.y = -global.y;
                        global.skew = -global.skew;
                        global.rotation = -global.rotation;
                    }
                    global.add(animationPose);
                }
            }
            else if (this.offsetMode === 0 /* None */) {
                if (origin !== null) {
                    global.copyFrom(origin).add(animationPose);
                }
                else {
                    global.copyFrom(animationPose);
                }
            }
            else {
                inherit = false;
                global.copyFrom(offset);
                if (!dragonBones.DragonBones.yDown) {
                    global.y = -global.y;
                    global.skew = -global.skew;
                    global.rotation = -global.rotation;
                }
            }
            if (inherit) {
                var isSurface = parent._boneData.type === 1 /* Surface */;
                var surfaceBone = isSurface ? parent._bone : null;
                var parentMatrix = isSurface ? parent._getGlobalTransformMatrix(global.x, global.y) : parent.globalTransformMatrix;
                if (boneData.inheritScale && (!isSurface || surfaceBone !== null)) {
                    if (isSurface) {
                        if (boneData.inheritRotation) {
                            global.rotation += parent.global.rotation;
                        }
                        surfaceBone.updateGlobalTransform();
                        global.scaleX *= surfaceBone.global.scaleX;
                        global.scaleY *= surfaceBone.global.scaleY;
                        parentMatrix.transformPoint(global.x, global.y, global);
                        global.toMatrix(globalTransformMatrix);
                        if (boneData.inheritTranslation) {
                            global.x = globalTransformMatrix.tx;
                            global.y = globalTransformMatrix.ty;
                        }
                        else {
                            globalTransformMatrix.tx = global.x;
                            globalTransformMatrix.ty = global.y;
                        }
                    }
                    else {
                        if (!boneData.inheritRotation) {
                            parent.updateGlobalTransform();
                            if (flipX && flipY) {
                                rotation = global.rotation - (parent.global.rotation + Math.PI);
                            }
                            else if (flipX) {
                                rotation = global.rotation + parent.global.rotation + Math.PI;
                            }
                            else if (flipY) {
                                rotation = global.rotation + parent.global.rotation;
                            }
                            else {
                                rotation = global.rotation - parent.global.rotation;
                            }
                            global.rotation = rotation;
                        }
                        global.toMatrix(globalTransformMatrix);
                        globalTransformMatrix.concat(parentMatrix);
                        if (boneData.inheritTranslation) {
                            global.x = globalTransformMatrix.tx;
                            global.y = globalTransformMatrix.ty;
                        }
                        else {
                            globalTransformMatrix.tx = global.x;
                            globalTransformMatrix.ty = global.y;
                        }
                        if (isCache) {
                            global.fromMatrix(globalTransformMatrix);
                        }
                        else {
                            this._globalDirty = true;
                        }
                    }
                }
                else {
                    if (boneData.inheritTranslation) {
                        var x = global.x;
                        var y = global.y;
                        global.x = parentMatrix.a * x + parentMatrix.c * y + parentMatrix.tx;
                        global.y = parentMatrix.b * x + parentMatrix.d * y + parentMatrix.ty;
                    }
                    else {
                        if (flipX) {
                            global.x = -global.x;
                        }
                        if (flipY) {
                            global.y = -global.y;
                        }
                    }
                    if (boneData.inheritRotation) {
                        parent.updateGlobalTransform();
                        if (parent.global.scaleX < 0.0) {
                            rotation = global.rotation + parent.global.rotation + Math.PI;
                        }
                        else {
                            rotation = global.rotation + parent.global.rotation;
                        }
                        if (parentMatrix.a * parentMatrix.d - parentMatrix.b * parentMatrix.c < 0.0) {
                            rotation -= global.rotation * 2.0;
                            if (flipX !== flipY || boneData.inheritReflection) {
                                global.skew += Math.PI;
                            }
                            if (!dragonBones.DragonBones.yDown) {
                                global.skew = -global.skew;
                            }
                        }
                        global.rotation = rotation;
                    }
                    else if (flipX || flipY) {
                        if (flipX && flipY) {
                            rotation = global.rotation + Math.PI;
                        }
                        else {
                            if (flipX) {
                                rotation = Math.PI - global.rotation;
                            }
                            else {
                                rotation = -global.rotation;
                            }
                            global.skew += Math.PI;
                        }
                        global.rotation = rotation;
                    }
                    global.toMatrix(globalTransformMatrix);
                }
            }
            else {
                if (flipX || flipY) {
                    if (flipX) {
                        global.x = -global.x;
                    }
                    if (flipY) {
                        global.y = -global.y;
                    }
                    if (flipX && flipY) {
                        rotation = global.rotation + Math.PI;
                    }
                    else {
                        if (flipX) {
                            rotation = Math.PI - global.rotation;
                        }
                        else {
                            rotation = -global.rotation;
                        }
                        global.skew += Math.PI;
                    }
                    global.rotation = rotation;
                }
                global.toMatrix(globalTransformMatrix);
            }
        };
        /**
         * @internal
         */
        Bone.prototype._updateAlpha = function () {
            if (this._parent !== null) {
                this._globalAlpha = this._alpha * this._parent._globalAlpha;
            }
            else {
                this._globalAlpha = this._alpha * this._armature._globalAlpha;
            }
        };
        /**
         * @internal
         */
        Bone.prototype.init = function (boneData, armatureValue) {
            if (this._boneData !== null) {
                return;
            }
            this._boneData = boneData;
            this._armature = armatureValue;
            this._alpha = this._boneData.alpha;
            if (this._boneData.parent !== null) {
                this._parent = this._armature.getBone(this._boneData.parent.name);
            }
            this._armature._addBone(this);
            //
            this.origin = this._boneData.transform;
        };
        /**
         * @internal
         */
        Bone.prototype.update = function (cacheFrameIndex) {
            if (cacheFrameIndex >= 0 && this._cachedFrameIndices !== null) {
                var cachedFrameIndex = this._cachedFrameIndices[cacheFrameIndex];
                if (cachedFrameIndex >= 0 && this._cachedFrameIndex === cachedFrameIndex) { // Same cache.
                    this._transformDirty = false;
                }
                else if (cachedFrameIndex >= 0) { // Has been Cached.
                    this._transformDirty = true;
                    this._cachedFrameIndex = cachedFrameIndex;
                }
                else {
                    if (this._hasConstraint) { // Update constraints.
                        for (var _i = 0, _a = this._armature._constraints; _i < _a.length; _i++) {
                            var constraint = _a[_i];
                            if (constraint._root === this) {
                                constraint.update();
                            }
                        }
                    }
                    if (this._transformDirty ||
                        (this._parent !== null && this._parent._childrenTransformDirty)) { // Dirty.
                        this._transformDirty = true;
                        this._cachedFrameIndex = -1;
                    }
                    else if (this._cachedFrameIndex >= 0) { // Same cache, but not set index yet.
                        this._transformDirty = false;
                        this._cachedFrameIndices[cacheFrameIndex] = this._cachedFrameIndex;
                    }
                    else { // Dirty.
                        this._transformDirty = true;
                        this._cachedFrameIndex = -1;
                    }
                }
            }
            else {
                if (this._hasConstraint) { // Update constraints.
                    for (var _b = 0, _c = this._armature._constraints; _b < _c.length; _b++) {
                        var constraint = _c[_b];
                        if (constraint._root === this) {
                            constraint.update();
                        }
                    }
                }
                if (this._transformDirty || (this._parent !== null && this._parent._childrenTransformDirty)) { // Dirty.
                    cacheFrameIndex = -1;
                    this._transformDirty = true;
                    this._cachedFrameIndex = -1;
                }
            }
            if (this._transformDirty) {
                this._transformDirty = false;
                this._childrenTransformDirty = true;
                //
                if (this._cachedFrameIndex < 0) {
                    var isCache = cacheFrameIndex >= 0;
                    if (this._localDirty) {
                        this._updateGlobalTransformMatrix(isCache);
                    }
                    if (isCache && this._cachedFrameIndices !== null) {
                        this._cachedFrameIndex = this._cachedFrameIndices[cacheFrameIndex] = this._armature._armatureData.setCacheFrame(this.globalTransformMatrix, this.global);
                    }
                }
                else {
                    this._armature._armatureData.getCacheFrame(this.globalTransformMatrix, this.global, this._cachedFrameIndex);
                }
                //
            }
            else if (this._childrenTransformDirty) {
                this._childrenTransformDirty = false;
            }
            this._localDirty = true;
        };
        /**
         * @internal
         */
        Bone.prototype.updateByConstraint = function () {
            if (this._localDirty) {
                this._localDirty = false;
                if (this._transformDirty || (this._parent !== null && this._parent._childrenTransformDirty)) {
                    this._updateGlobalTransformMatrix(true);
                }
                this._transformDirty = true;
            }
        };
        /**
         * - Forces the bone to update the transform in the next frame.
         * When the bone is not animated or its animation state is finished, the bone will not continue to update,
         * and when the skeleton must be updated for some reason, the method needs to be called explicitly.
         * @example
         * <pre>
         *     let bone = armature.getBone("arm");
         *     bone.offset.scaleX = 2.0;
         *     bone.invalidUpdate();
         * </pre>
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 强制骨骼在下一帧更新变换。
         * 当该骨骼没有动画状态或其动画状态播放完成时，骨骼将不在继续更新，而此时由于某些原因必须更新骨骼时，则需要显式调用该方法。
         * @example
         * <pre>
         *     let bone = armature.getBone("arm");
         *     bone.offset.scaleX = 2.0;
         *     bone.invalidUpdate();
         * </pre>
         * @version DragonBones 3.0
         * @language zh_CN
         */
        Bone.prototype.invalidUpdate = function () {
            this._transformDirty = true;
        };
        /**
         * - Check whether the bone contains a specific bone.
         * @see dragonBones.Bone
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 检查该骨骼是否包含特定的骨骼。
         * @see dragonBones.Bone
         * @version DragonBones 3.0
         * @language zh_CN
         */
        Bone.prototype.contains = function (value) {
            if (value === this) {
                return false;
            }
            var ancestor = value;
            while (ancestor !== this && ancestor !== null) {
                ancestor = ancestor.parent;
            }
            return ancestor === this;
        };
        Object.defineProperty(Bone.prototype, "boneData", {
            /**
             * - The bone data.
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 骨骼数据。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            get: function () {
                return this._boneData;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Bone.prototype, "visible", {
            /**
             * - The visible of all slots in the bone.
             * @default true
             * @see dragonBones.Slot#visible
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 此骨骼所有插槽的可见。
             * @default true
             * @see dragonBones.Slot#visible
             * @version DragonBones 3.0
             * @language zh_CN
             */
            get: function () {
                return this._visible;
            },
            set: function (value) {
                if (this._visible === value) {
                    return;
                }
                this._visible = value;
                for (var _i = 0, _a = this._armature.getSlots(); _i < _a.length; _i++) {
                    var slot = _a[_i];
                    if (slot.parent === this) {
                        slot._updateVisible();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Bone.prototype, "name", {
            /**
             * - The bone name.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 骨骼名称。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            get: function () {
                return this._boneData.name;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Bone.prototype, "parent", {
            /**
             * - The parent bone to which it belongs.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 所属的父骨骼。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            get: function () {
                return this._parent;
            },
            enumerable: true,
            configurable: true
        });
        return Bone;
    }(dragonBones.TransformObject));
    dragonBones.Bone = Bone;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * @internal
     */
    var Surface = /** @class */ (function (_super) {
        __extends(Surface, _super);
        function Surface() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._vertices = [];
            _this._deformVertices = [];
            /**
             * - x1, y1, x2, y2, x3, y3, x4, y4, d1X, d1Y, d2X, d2Y
             */
            _this._hullCache = [];
            /**
             * - Inside [flag, a, b, c, d, tx, ty], Outside [flag, a, b, c, d, tx, ty]
             */
            _this._matrixCahce = [];
            return _this;
        }
        Surface.toString = function () {
            return "[class dragonBones.Surface]";
        };
        Surface.prototype._onClear = function () {
            _super.prototype._onClear.call(this);
            this._dX = 0.0;
            this._dY = 0.0;
            this._k = 0.0;
            this._kX = 0.0;
            this._kY = 0.0;
            this._vertices.length = 0;
            this._deformVertices.length = 0;
            this._matrixCahce.length = 0;
            this._hullCache.length = 0;
            this._bone = null;
        };
        Surface.prototype._getAffineTransform = function (x, y, lX, lY, aX, aY, bX, bY, cX, cY, transform, matrix, isDown) {
            var dabX = bX - aX;
            var dabY = bY - aY;
            var dacX = cX - aX;
            var dacY = cY - aY;
            transform.rotation = Math.atan2(dabY, dabX);
            transform.skew = Math.atan2(dacY, dacX) - Math.PI * 0.5 - transform.rotation;
            if (isDown) {
                transform.rotation += Math.PI;
            }
            transform.scaleX = Math.sqrt(dabX * dabX + dabY * dabY) / lX;
            transform.scaleY = Math.sqrt(dacX * dacX + dacY * dacY) / lY;
            transform.toMatrix(matrix);
            transform.x = matrix.tx = aX - (matrix.a * x + matrix.c * y);
            transform.y = matrix.ty = aY - (matrix.b * x + matrix.d * y);
        };
        Surface.prototype._updateVertices = function () {
            var data = this._armature.armatureData.parent;
            var geometry = this._boneData.geometry;
            var intArray = data.intArray;
            var floatArray = data.floatArray;
            var vertexCount = intArray[geometry.offset + 0 /* GeometryVertexCount */];
            var verticesOffset = intArray[geometry.offset + 2 /* GeometryFloatOffset */];
            var vertices = this._vertices;
            var animationVertices = this._deformVertices;
            if (this._parent !== null) {
                if (this._parent._boneData.type === 1 /* Surface */) {
                    for (var i = 0, l = vertexCount; i < l; ++i) {
                        var iD = i * 2;
                        var x = floatArray[verticesOffset + iD] + animationVertices[iD];
                        var y = floatArray[verticesOffset + iD + 1] + animationVertices[iD + 1];
                        var matrix = this._parent._getGlobalTransformMatrix(x, y);
                        //
                        vertices[iD] = matrix.a * x + matrix.c * y + matrix.tx;
                        vertices[iD + 1] = matrix.b * x + matrix.d * y + matrix.ty;
                    }
                }
                else {
                    var parentMatrix = this._parent.globalTransformMatrix;
                    for (var i = 0, l = vertexCount; i < l; ++i) {
                        var iD = i * 2;
                        var x = floatArray[verticesOffset + iD] + animationVertices[iD];
                        var y = floatArray[verticesOffset + iD + 1] + animationVertices[iD + 1];
                        //
                        vertices[iD] = parentMatrix.a * x + parentMatrix.c * y + parentMatrix.tx;
                        vertices[iD + 1] = parentMatrix.b * x + parentMatrix.d * y + parentMatrix.ty;
                    }
                }
            }
            else {
                for (var i = 0, l = vertexCount; i < l; ++i) {
                    var iD = i * 2;
                    vertices[iD] = floatArray[verticesOffset + iD] + animationVertices[iD];
                    vertices[iD + 1] = floatArray[verticesOffset + iD + 1] + animationVertices[iD + 1];
                }
            }
        };
        Surface.prototype._updateGlobalTransformMatrix = function (isCache) {
            // tslint:disable-next-line:no-unused-expression
            isCache;
            var segmentXD = this._boneData.segmentX * 2;
            var lastIndex = this._vertices.length - 2;
            var lA = 200.0;
            //
            var raX = this._vertices[0];
            var raY = this._vertices[1];
            var rbX = this._vertices[segmentXD];
            var rbY = this._vertices[segmentXD + 1];
            var rcX = this._vertices[lastIndex];
            var rcY = this._vertices[lastIndex + 1];
            var rdX = this._vertices[lastIndex - segmentXD];
            var rdY = this._vertices[lastIndex - segmentXD + 1];
            //
            var dacX = raX + (rcX - raX) * 0.5;
            var dacY = raY + (rcY - raY) * 0.5;
            var dbdX = rbX + (rdX - rbX) * 0.5;
            var dbdY = rbY + (rdY - rbY) * 0.5;
            var aX = dacX + (dbdX - dacX) * 0.5;
            var aY = dacY + (dbdY - dacY) * 0.5;
            var bX = rbX + (rcX - rbX) * 0.5;
            var bY = rbY + (rcY - rbY) * 0.5;
            var cX = rdX + (rcX - rdX) * 0.5;
            var cY = rdY + (rcY - rdY) * 0.5;
            // TODO interpolation
            this._getAffineTransform(0.0, 0.0, lA, lA, aX, aY, bX, bY, cX, cY, this.global, this.globalTransformMatrix, false);
            this._globalDirty = false;
        };
        Surface.prototype._getGlobalTransformMatrix = function (x, y) {
            var lA = 200.0;
            var lB = 1000.0;
            if (x < -lB || lB < x || y < -lB || lB < y) {
                return this.globalTransformMatrix;
            }
            var isDown = false;
            var surfaceData = this._boneData;
            var segmentX = surfaceData.segmentX;
            var segmentY = surfaceData.segmentY;
            var segmentXD = surfaceData.segmentX * 2;
            var dX = this._dX;
            var dY = this._dY;
            var indexX = Math.floor((x + lA) / dX); // -1 ~ segmentX - 1
            var indexY = Math.floor((y + lA) / dY); // -1 ~ segmentY - 1
            var matrixIndex = 0;
            var pX = indexX * dX - lA;
            var pY = indexY * dY - lA;
            //
            var matrices = this._matrixCahce;
            var helpMatrix = Surface._helpMatrix;
            if (x < -lA) {
                if (y < -lA || y >= lA) { // Out.
                    return this.globalTransformMatrix;
                }
                // Left.
                isDown = y > this._kX * (x + lA) + pY;
                matrixIndex = ((segmentX * segmentY + segmentX + segmentY + segmentY + indexY) * 2 + (isDown ? 1 : 0)) * 7;
                if (matrices[matrixIndex] > 0.0) {
                    helpMatrix.copyFromArray(matrices, matrixIndex + 1);
                }
                else {
                    var vertexIndex = indexY * (segmentXD + 2);
                    var ddX = this._hullCache[4];
                    var ddY = this._hullCache[5];
                    var sX = this._hullCache[2] - (segmentY - indexY) * ddX;
                    var sY = this._hullCache[3] - (segmentY - indexY) * ddY;
                    var vertices = this._vertices;
                    if (isDown) {
                        this._getAffineTransform(-lA, pY + dY, lB - lA, dY, vertices[vertexIndex + segmentXD + 2], vertices[vertexIndex + segmentXD + 3], sX + ddX, sY + ddY, vertices[vertexIndex], vertices[vertexIndex + 1], Surface._helpTransform, helpMatrix, true);
                    }
                    else {
                        this._getAffineTransform(-lB, pY, lB - lA, dY, sX, sY, vertices[vertexIndex], vertices[vertexIndex + 1], sX + ddX, sY + ddY, Surface._helpTransform, helpMatrix, false);
                    }
                    matrices[matrixIndex] = 1.0;
                    matrices[matrixIndex + 1] = helpMatrix.a;
                    matrices[matrixIndex + 2] = helpMatrix.b;
                    matrices[matrixIndex + 3] = helpMatrix.c;
                    matrices[matrixIndex + 4] = helpMatrix.d;
                    matrices[matrixIndex + 5] = helpMatrix.tx;
                    matrices[matrixIndex + 6] = helpMatrix.ty;
                }
            }
            else if (x >= lA) {
                if (y < -lA || y >= lA) { // Out.
                    return this.globalTransformMatrix;
                }
                // Right.
                isDown = y > this._kX * (x - lB) + pY;
                matrixIndex = ((segmentX * segmentY + segmentX + indexY) * 2 + (isDown ? 1 : 0)) * 7;
                if (matrices[matrixIndex] > 0.0) {
                    helpMatrix.copyFromArray(matrices, matrixIndex + 1);
                }
                else {
                    var vertexIndex = (indexY + 1) * (segmentXD + 2) - 2;
                    var ddX = this._hullCache[4];
                    var ddY = this._hullCache[5];
                    var sX = this._hullCache[0] + indexY * ddX;
                    var sY = this._hullCache[1] + indexY * ddY;
                    var vertices = this._vertices;
                    if (isDown) {
                        this._getAffineTransform(lB, pY + dY, lB - lA, dY, sX + ddX, sY + ddY, vertices[vertexIndex + segmentXD + 2], vertices[vertexIndex + segmentXD + 3], sX, sY, Surface._helpTransform, helpMatrix, true);
                    }
                    else {
                        this._getAffineTransform(lA, pY, lB - lA, dY, vertices[vertexIndex], vertices[vertexIndex + 1], sX, sY, vertices[vertexIndex + segmentXD + 2], vertices[vertexIndex + segmentXD + 3], Surface._helpTransform, helpMatrix, false);
                    }
                    matrices[matrixIndex] = 1.0;
                    matrices[matrixIndex + 1] = helpMatrix.a;
                    matrices[matrixIndex + 2] = helpMatrix.b;
                    matrices[matrixIndex + 3] = helpMatrix.c;
                    matrices[matrixIndex + 4] = helpMatrix.d;
                    matrices[matrixIndex + 5] = helpMatrix.tx;
                    matrices[matrixIndex + 6] = helpMatrix.ty;
                }
            }
            else if (y < -lA) {
                if (x < -lA || x >= lA) { // Out.
                    return this.globalTransformMatrix;
                }
                // Up.
                isDown = y > this._kY * (x - pX - dX) - lB;
                matrixIndex = ((segmentX * segmentY + indexX) * 2 + (isDown ? 1 : 0)) * 7;
                if (matrices[matrixIndex] > 0.0) {
                    helpMatrix.copyFromArray(matrices, matrixIndex + 1);
                }
                else {
                    var vertexIndex = indexX * 2;
                    var ddX = this._hullCache[10];
                    var ddY = this._hullCache[11];
                    var sX = this._hullCache[8] + indexX * ddX;
                    var sY = this._hullCache[9] + indexX * ddY;
                    var vertices = this._vertices;
                    if (isDown) {
                        this._getAffineTransform(pX + dX, -lA, dX, lB - lA, vertices[vertexIndex + 2], vertices[vertexIndex + 3], vertices[vertexIndex], vertices[vertexIndex + 1], sX + ddX, sY + ddY, Surface._helpTransform, helpMatrix, true);
                    }
                    else {
                        this._getAffineTransform(pX, -lB, dX, lB - lA, sX, sY, sX + ddX, sY + ddY, vertices[vertexIndex], vertices[vertexIndex + 1], Surface._helpTransform, helpMatrix, false);
                    }
                    matrices[matrixIndex] = 1.0;
                    matrices[matrixIndex + 1] = helpMatrix.a;
                    matrices[matrixIndex + 2] = helpMatrix.b;
                    matrices[matrixIndex + 3] = helpMatrix.c;
                    matrices[matrixIndex + 4] = helpMatrix.d;
                    matrices[matrixIndex + 5] = helpMatrix.tx;
                    matrices[matrixIndex + 6] = helpMatrix.ty;
                }
            }
            else if (y >= lA) {
                if (x < -lA || x >= lA) { //  Out.
                    return this.globalTransformMatrix;
                }
                // Down
                isDown = y > this._kY * (x - pX - dX) + lA;
                matrixIndex = ((segmentX * segmentY + segmentX + segmentY + indexX) * 2 + (isDown ? 1 : 0)) * 7;
                if (matrices[matrixIndex] > 0.0) {
                    helpMatrix.copyFromArray(matrices, matrixIndex + 1);
                }
                else {
                    var vertexIndex = segmentY * (segmentXD + 2) + indexX * 2;
                    var ddX = this._hullCache[10];
                    var ddY = this._hullCache[11];
                    var sX = this._hullCache[6] - (segmentX - indexX) * ddX;
                    var sY = this._hullCache[7] - (segmentX - indexX) * ddY;
                    var vertices = this._vertices;
                    if (isDown) {
                        this._getAffineTransform(pX + dX, lB, dX, lB - lA, sX + ddX, sY + ddY, sX, sY, vertices[vertexIndex + 2], vertices[vertexIndex + 3], Surface._helpTransform, helpMatrix, true);
                    }
                    else {
                        this._getAffineTransform(pX, lA, dX, lB - lA, vertices[vertexIndex], vertices[vertexIndex + 1], vertices[vertexIndex + 2], vertices[vertexIndex + 3], sX, sY, Surface._helpTransform, helpMatrix, false);
                    }
                    matrices[matrixIndex] = 1.0;
                    matrices[matrixIndex + 1] = helpMatrix.a;
                    matrices[matrixIndex + 2] = helpMatrix.b;
                    matrices[matrixIndex + 3] = helpMatrix.c;
                    matrices[matrixIndex + 4] = helpMatrix.d;
                    matrices[matrixIndex + 5] = helpMatrix.tx;
                    matrices[matrixIndex + 6] = helpMatrix.ty;
                }
            }
            else { // Center.
                isDown = y > this._k * (x - pX - dX) + pY;
                matrixIndex = ((segmentX * indexY + indexX) * 2 + (isDown ? 1 : 0)) * 7;
                if (matrices[matrixIndex] > 0.0) {
                    helpMatrix.copyFromArray(matrices, matrixIndex + 1);
                }
                else {
                    var vertexIndex = indexX * 2 + indexY * (segmentXD + 2);
                    var vertices = this._vertices;
                    if (isDown) {
                        this._getAffineTransform(pX + dX, pY + dY, dX, dY, vertices[vertexIndex + segmentXD + 4], vertices[vertexIndex + segmentXD + 5], vertices[vertexIndex + segmentXD + 2], vertices[vertexIndex + segmentXD + 3], vertices[vertexIndex + 2], vertices[vertexIndex + 3], Surface._helpTransform, helpMatrix, true);
                    }
                    else {
                        this._getAffineTransform(pX, pY, dX, dY, vertices[vertexIndex], vertices[vertexIndex + 1], vertices[vertexIndex + 2], vertices[vertexIndex + 3], vertices[vertexIndex + segmentXD + 2], vertices[vertexIndex + segmentXD + 3], Surface._helpTransform, helpMatrix, false);
                    }
                    matrices[matrixIndex] = 1.0;
                    matrices[matrixIndex + 1] = helpMatrix.a;
                    matrices[matrixIndex + 2] = helpMatrix.b;
                    matrices[matrixIndex + 3] = helpMatrix.c;
                    matrices[matrixIndex + 4] = helpMatrix.d;
                    matrices[matrixIndex + 5] = helpMatrix.tx;
                    matrices[matrixIndex + 6] = helpMatrix.ty;
                }
            }
            return helpMatrix;
        };
        /**
         * @internal
         * @private
         */
        Surface.prototype.init = function (surfaceData, armatureValue) {
            if (this._boneData !== null) {
                return;
            }
            _super.prototype.init.call(this, surfaceData, armatureValue);
            var segmentX = surfaceData.segmentX;
            var segmentY = surfaceData.segmentY;
            var vertexCount = this._armature.armatureData.parent.intArray[surfaceData.geometry.offset + 0 /* GeometryVertexCount */];
            var lB = 1000.0;
            var lA = 200.0;
            //
            this._dX = lA * 2.0 / segmentX;
            this._dY = lA * 2.0 / segmentY;
            this._k = -this._dY / this._dX;
            this._kX = -this._dY / (lB - lA);
            this._kY = -(lB - lA) / this._dX;
            this._vertices.length = vertexCount * 2;
            this._deformVertices.length = vertexCount * 2;
            this._matrixCahce.length = (segmentX * segmentY + segmentX * 2 + segmentY * 2) * 2 * 7;
            this._hullCache.length = 10;
            for (var i = 0; i < vertexCount * 2; ++i) {
                this._deformVertices[i] = 0.0;
            }
            if (this._parent !== null) {
                if (this._parent.boneData.type === 0 /* Bone */) {
                    this._bone = this._parent;
                }
                else {
                    this._bone = this._parent._bone;
                }
            }
        };
        /**
         * @internal
         */
        Surface.prototype.update = function (cacheFrameIndex) {
            if (cacheFrameIndex >= 0 && this._cachedFrameIndices !== null) {
                var cachedFrameIndex = this._cachedFrameIndices[cacheFrameIndex];
                if (cachedFrameIndex >= 0 && this._cachedFrameIndex === cachedFrameIndex) { // Same cache.
                    this._transformDirty = false;
                }
                else if (cachedFrameIndex >= 0) { // Has been Cached.
                    this._transformDirty = true;
                    this._cachedFrameIndex = cachedFrameIndex;
                }
                else {
                    if (this._hasConstraint) { // Update constraints.
                        for (var _i = 0, _a = this._armature._constraints; _i < _a.length; _i++) {
                            var constraint = _a[_i];
                            if (constraint._root === this) {
                                constraint.update();
                            }
                        }
                    }
                    if (this._transformDirty ||
                        (this._parent !== null && this._parent._childrenTransformDirty)) { // Dirty.
                        this._transformDirty = true;
                        this._cachedFrameIndex = -1;
                    }
                    else if (this._cachedFrameIndex >= 0) { // Same cache, but not set index yet.
                        this._transformDirty = false;
                        this._cachedFrameIndices[cacheFrameIndex] = this._cachedFrameIndex;
                    }
                    else { // Dirty.
                        this._transformDirty = true;
                        this._cachedFrameIndex = -1;
                    }
                }
            }
            else {
                if (this._hasConstraint) { // Update constraints.
                    for (var _b = 0, _c = this._armature._constraints; _b < _c.length; _b++) {
                        var constraint = _c[_b];
                        if (constraint._root === this) {
                            constraint.update();
                        }
                    }
                }
                if (this._transformDirty || (this._parent !== null && this._parent._childrenTransformDirty)) { // Dirty.
                    cacheFrameIndex = -1;
                    this._transformDirty = true;
                    this._cachedFrameIndex = -1;
                }
            }
            if (this._transformDirty) {
                this._transformDirty = false;
                this._childrenTransformDirty = true;
                //
                for (var i = 0, l = this._matrixCahce.length; i < l; i += 7) {
                    this._matrixCahce[i] = -1.0;
                }
                //
                this._updateVertices();
                //
                if (this._cachedFrameIndex < 0) {
                    var isCache = cacheFrameIndex >= 0;
                    if (this._localDirty) {
                        this._updateGlobalTransformMatrix(isCache);
                    }
                    if (isCache && this._cachedFrameIndices !== null) {
                        this._cachedFrameIndex = this._cachedFrameIndices[cacheFrameIndex] = this._armature._armatureData.setCacheFrame(this.globalTransformMatrix, this.global);
                    }
                }
                else {
                    this._armature._armatureData.getCacheFrame(this.globalTransformMatrix, this.global, this._cachedFrameIndex);
                }
                // Update hull vertices.
                var lB = 1000.0;
                var lA = 200.0;
                var ddX = 2 * this.global.x;
                var ddY = 2 * this.global.y;
                //
                var helpPoint = Surface._helpPoint;
                this.globalTransformMatrix.transformPoint(lB, -lA, helpPoint);
                this._hullCache[0] = helpPoint.x;
                this._hullCache[1] = helpPoint.y;
                this._hullCache[2] = ddX - helpPoint.x;
                this._hullCache[3] = ddY - helpPoint.y;
                this.globalTransformMatrix.transformPoint(0.0, this._dY, helpPoint, true);
                this._hullCache[4] = helpPoint.x;
                this._hullCache[5] = helpPoint.y;
                //
                this.globalTransformMatrix.transformPoint(lA, lB, helpPoint);
                this._hullCache[6] = helpPoint.x;
                this._hullCache[7] = helpPoint.y;
                this._hullCache[8] = ddX - helpPoint.x;
                this._hullCache[9] = ddY - helpPoint.y;
                this.globalTransformMatrix.transformPoint(this._dX, 0.0, helpPoint, true);
                this._hullCache[10] = helpPoint.x;
                this._hullCache[11] = helpPoint.y;
            }
            else if (this._childrenTransformDirty) {
                this._childrenTransformDirty = false;
            }
            this._localDirty = true;
        };
        return Surface;
    }(dragonBones.Bone));
    dragonBones.Surface = Surface;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * @private
     */
    var DisplayFrame = /** @class */ (function (_super) {
        __extends(DisplayFrame, _super);
        function DisplayFrame() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.deformVertices = [];
            return _this;
        }
        DisplayFrame.toString = function () {
            return "[class dragonBones.DisplayFrame]";
        };
        DisplayFrame.prototype._onClear = function () {
            this.rawDisplayData = null;
            this.displayData = null;
            this.textureData = null;
            this.display = null;
            this.deformVertices.length = 0;
        };
        DisplayFrame.prototype.updateDeformVertices = function () {
            if (this.rawDisplayData === null || this.deformVertices.length !== 0) {
                return;
            }
            var rawGeometryData;
            if (this.rawDisplayData.type === 2 /* Mesh */) {
                rawGeometryData = this.rawDisplayData.geometry;
            }
            else if (this.rawDisplayData.type === 4 /* Path */) {
                rawGeometryData = this.rawDisplayData.geometry;
            }
            else {
                return;
            }
            var vertexCount = 0;
            if (rawGeometryData.weight !== null) {
                vertexCount = rawGeometryData.weight.count * 2;
            }
            else {
                vertexCount = rawGeometryData.data.intArray[rawGeometryData.offset + 0 /* GeometryVertexCount */] * 2;
            }
            this.deformVertices.length = vertexCount;
            for (var i = 0, l = this.deformVertices.length; i < l; ++i) {
                this.deformVertices[i] = 0.0;
            }
        };
        DisplayFrame.prototype.getGeometryData = function () {
            if (this.displayData !== null) {
                if (this.displayData.type === 2 /* Mesh */) {
                    return this.displayData.geometry;
                }
                if (this.displayData.type === 4 /* Path */) {
                    return this.displayData.geometry;
                }
            }
            if (this.rawDisplayData !== null) {
                if (this.rawDisplayData.type === 2 /* Mesh */) {
                    return this.rawDisplayData.geometry;
                }
                if (this.rawDisplayData.type === 4 /* Path */) {
                    return this.rawDisplayData.geometry;
                }
            }
            return null;
        };
        DisplayFrame.prototype.getBoundingBox = function () {
            if (this.displayData !== null && this.displayData.type === 3 /* BoundingBox */) {
                return this.displayData.boundingBox;
            }
            if (this.rawDisplayData !== null && this.rawDisplayData.type === 3 /* BoundingBox */) {
                return this.rawDisplayData.boundingBox;
            }
            return null;
        };
        DisplayFrame.prototype.getTextureData = function () {
            if (this.displayData !== null) {
                if (this.displayData.type === 0 /* Image */) {
                    return this.displayData.texture;
                }
                if (this.displayData.type === 2 /* Mesh */) {
                    return this.displayData.texture;
                }
            }
            if (this.textureData !== null) {
                return this.textureData;
            }
            if (this.rawDisplayData !== null) {
                if (this.rawDisplayData.type === 0 /* Image */) {
                    return this.rawDisplayData.texture;
                }
                if (this.rawDisplayData.type === 2 /* Mesh */) {
                    return this.rawDisplayData.texture;
                }
            }
            return null;
        };
        return DisplayFrame;
    }(dragonBones.BaseObject));
    dragonBones.DisplayFrame = DisplayFrame;
    /**
     * - The slot attached to the armature, controls the display status and properties of the display object.
     * A bone can contain multiple slots.
     * A slot can contain multiple display objects, displaying only one of the display objects at a time,
     * but you can toggle the display object into frame animation while the animation is playing.
     * The display object can be a normal texture, or it can be a display of a child armature, a grid display object,
     * and a custom other display object.
     * @see dragonBones.Armature
     * @see dragonBones.Bone
     * @see dragonBones.SlotData
     * @version DragonBones 3.0
     * @language en_US
     */
    /**
     * - 插槽附着在骨骼上，控制显示对象的显示状态和属性。
     * 一个骨骼上可以包含多个插槽。
     * 一个插槽中可以包含多个显示对象，同一时间只能显示其中的一个显示对象，但可以在动画播放的过程中切换显示对象实现帧动画。
     * 显示对象可以是普通的图片纹理，也可以是子骨架的显示容器，网格显示对象，还可以是自定义的其他显示对象。
     * @see dragonBones.Armature
     * @see dragonBones.Bone
     * @see dragonBones.SlotData
     * @version DragonBones 3.0
     * @language zh_CN
     */
    var Slot = /** @class */ (function (_super) {
        __extends(Slot, _super);
        function Slot() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._localMatrix = new dragonBones.Matrix();
            /**
             * @internal
             */
            _this._colorTransform = new dragonBones.ColorTransform();
            /**
             * @internal
             */
            _this._displayFrames = [];
            /**
             * @internal
             */
            _this._geometryBones = [];
            _this._rawDisplay = null; // Initial value.
            _this._meshDisplay = null; // Initial value.
            _this._display = null;
            return _this;
        }
        Slot.prototype._onClear = function () {
            _super.prototype._onClear.call(this);
            var disposeDisplayList = [];
            for (var _i = 0, _a = this._displayFrames; _i < _a.length; _i++) {
                var dispayFrame = _a[_i];
                var display = dispayFrame.display;
                if (display !== this._rawDisplay && display !== this._meshDisplay &&
                    disposeDisplayList.indexOf(display) < 0) {
                    disposeDisplayList.push(display);
                }
                dispayFrame.returnToPool();
            }
            for (var _b = 0, disposeDisplayList_1 = disposeDisplayList; _b < disposeDisplayList_1.length; _b++) {
                var eachDisplay = disposeDisplayList_1[_b];
                if (eachDisplay instanceof dragonBones.Armature) {
                    eachDisplay.dispose();
                }
                else {
                    this._disposeDisplay(eachDisplay, true);
                }
            }
            if (this._meshDisplay !== null && this._meshDisplay !== this._rawDisplay) { // May be _meshDisplay and _rawDisplay is the same one.
                this._disposeDisplay(this._meshDisplay, false);
            }
            if (this._rawDisplay !== null) {
                this._disposeDisplay(this._rawDisplay, false);
            }
            this.displayController = null;
            this._displayDataDirty = false;
            this._displayDirty = false;
            this._geometryDirty = false;
            this._textureDirty = false;
            this._visibleDirty = false;
            this._blendModeDirty = false;
            this._zOrderDirty = false;
            this._colorDirty = false;
            this._verticesDirty = false;
            this._transformDirty = false;
            this._visible = true;
            this._blendMode = 0 /* Normal */;
            this._displayIndex = -1;
            this._animationDisplayIndex = -1;
            this._zOrder = 0;
            this._zIndex = 0;
            this._cachedFrameIndex = -1;
            this._pivotX = 0.0;
            this._pivotY = 0.0;
            this._localMatrix.identity();
            this._colorTransform.identity();
            this._displayFrames.length = 0;
            this._geometryBones.length = 0;
            this._slotData = null; //
            this._displayFrame = null;
            this._geometryData = null;
            this._boundingBoxData = null;
            this._textureData = null;
            this._rawDisplay = null;
            this._meshDisplay = null;
            this._display = null;
            this._childArmature = null;
            this._parent = null; //
            this._cachedFrameIndices = null;
        };
        Slot.prototype._hasDisplay = function (display) {
            for (var _i = 0, _a = this._displayFrames; _i < _a.length; _i++) {
                var displayFrame = _a[_i];
                if (displayFrame.display === display) {
                    return true;
                }
            }
            return false;
        };
        /**
         * @internal
         */
        Slot.prototype._isBonesUpdate = function () {
            for (var _i = 0, _a = this._geometryBones; _i < _a.length; _i++) {
                var bone = _a[_i];
                if (bone !== null && bone._childrenTransformDirty) {
                    return true;
                }
            }
            return false;
        };
        /**
         * @internal
         */
        Slot.prototype._updateAlpha = function () {
            var globalAlpha = this._alpha * this._parent._globalAlpha;
            if (this._globalAlpha !== globalAlpha) {
                this._globalAlpha = globalAlpha;
                this._colorDirty = true;
            }
        };
        Slot.prototype._updateDisplayData = function () {
            var prevDisplayFrame = this._displayFrame;
            var prevGeometryData = this._geometryData;
            var prevTextureData = this._textureData;
            var rawDisplayData = null;
            var displayData = null;
            this._displayFrame = null;
            this._geometryData = null;
            this._boundingBoxData = null;
            this._textureData = null;
            if (this._displayIndex >= 0 && this._displayIndex < this._displayFrames.length) {
                this._displayFrame = this._displayFrames[this._displayIndex];
                rawDisplayData = this._displayFrame.rawDisplayData;
                displayData = this._displayFrame.displayData;
                this._geometryData = this._displayFrame.getGeometryData();
                this._boundingBoxData = this._displayFrame.getBoundingBox();
                this._textureData = this._displayFrame.getTextureData();
            }
            if (this._displayFrame !== prevDisplayFrame ||
                this._geometryData !== prevGeometryData || this._textureData !== prevTextureData) {
                // Update pivot offset.
                if (this._geometryData === null && this._textureData !== null) {
                    var imageDisplayData = ((displayData !== null && displayData.type === 0 /* Image */) ? displayData : rawDisplayData); //
                    var scale = this._textureData.parent.scale * this._armature._armatureData.scale;
                    var frame = this._textureData.frame;
                    this._pivotX = imageDisplayData.pivot.x;
                    this._pivotY = imageDisplayData.pivot.y;
                    var rect = frame !== null ? frame : this._textureData.region;
                    var width = rect.width;
                    var height = rect.height;
                    if (this._textureData.rotated && frame === null) {
                        width = rect.height;
                        height = rect.width;
                    }
                    this._pivotX *= width * scale;
                    this._pivotY *= height * scale;
                    if (frame !== null) {
                        this._pivotX += frame.x * scale;
                        this._pivotY += frame.y * scale;
                    }
                    // Update replace pivot. TODO
                    if (rawDisplayData !== null && imageDisplayData !== rawDisplayData) {
                        rawDisplayData.transform.toMatrix(Slot._helpMatrix);
                        Slot._helpMatrix.invert();
                        Slot._helpMatrix.transformPoint(0.0, 0.0, Slot._helpPoint);
                        this._pivotX -= Slot._helpPoint.x;
                        this._pivotY -= Slot._helpPoint.y;
                        imageDisplayData.transform.toMatrix(Slot._helpMatrix);
                        Slot._helpMatrix.invert();
                        Slot._helpMatrix.transformPoint(0.0, 0.0, Slot._helpPoint);
                        this._pivotX += Slot._helpPoint.x;
                        this._pivotY += Slot._helpPoint.y;
                    }
                    if (!dragonBones.DragonBones.yDown) {
                        this._pivotY = (this._textureData.rotated ? this._textureData.region.width : this._textureData.region.height) * scale - this._pivotY;
                    }
                }
                else {
                    this._pivotX = 0.0;
                    this._pivotY = 0.0;
                }
                // Update original transform.
                if (rawDisplayData !== null) { // Compatible.
                    this.origin = rawDisplayData.transform;
                }
                else if (displayData !== null) { // Compatible.
                    this.origin = displayData.transform;
                }
                else {
                    this.origin = null;
                }
                // TODO remove slot offset.
                if (this.origin !== null) {
                    this.global.copyFrom(this.origin).add(this.offset).toMatrix(this._localMatrix);
                }
                else {
                    this.global.copyFrom(this.offset).toMatrix(this._localMatrix);
                }
                // Update geometry.
                if (this._geometryData !== prevGeometryData) {
                    this._geometryDirty = true;
                    this._verticesDirty = true;
                    if (this._geometryData !== null) {
                        this._geometryBones.length = 0;
                        if (this._geometryData.weight !== null) {
                            for (var i = 0, l = this._geometryData.weight.bones.length; i < l; ++i) {
                                var bone = this._armature.getBone(this._geometryData.weight.bones[i].name);
                                this._geometryBones.push(bone);
                            }
                        }
                    }
                    else {
                        this._geometryBones.length = 0;
                        this._geometryData = null;
                    }
                }
                this._textureDirty = this._textureData !== prevTextureData;
                this._transformDirty = true;
            }
        };
        Slot.prototype._updateDisplay = function () {
            var prevDisplay = this._display !== null ? this._display : this._rawDisplay;
            var prevChildArmature = this._childArmature;
            // Update display and child armature.
            if (this._displayFrame !== null) {
                this._display = this._displayFrame.display;
                if (this._display !== null && this._display instanceof dragonBones.Armature) {
                    this._childArmature = this._display;
                    this._display = this._childArmature.display;
                }
                else {
                    this._childArmature = null;
                }
            }
            else {
                this._display = null;
                this._childArmature = null;
            }
            // Update display.
            var currentDisplay = this._display !== null ? this._display : this._rawDisplay;
            if (currentDisplay !== prevDisplay) {
                this._textureDirty = true;
                this._visibleDirty = true;
                this._blendModeDirty = true;
                // this._zOrderDirty = true;
                this._colorDirty = true;
                this._transformDirty = true;
                this._onUpdateDisplay();
                this._replaceDisplay(prevDisplay);
            }
            // Update child armature.
            if (this._childArmature !== prevChildArmature) {
                if (prevChildArmature !== null) {
                    prevChildArmature._parent = null; // Update child armature parent.
                    prevChildArmature.clock = null;
                    if (prevChildArmature.inheritAnimation) {
                        prevChildArmature.animation.reset();
                    }
                }
                if (this._childArmature !== null) {
                    this._childArmature._parent = this; // Update child armature parent.
                    this._childArmature.clock = this._armature.clock;
                    if (this._childArmature.inheritAnimation) { // Set child armature cache frameRate.
                        if (this._childArmature.cacheFrameRate === 0) {
                            var cacheFrameRate = this._armature.cacheFrameRate;
                            if (cacheFrameRate !== 0) {
                                this._childArmature.cacheFrameRate = cacheFrameRate;
                            }
                        }
                        // Child armature action.
                        if (this._displayFrame !== null) {
                            var actions = null;
                            var displayData = this._displayFrame.displayData !== null ? this._displayFrame.displayData : this._displayFrame.rawDisplayData;
                            if (displayData !== null && displayData.type === 1 /* Armature */) {
                                actions = displayData.actions;
                            }
                            if (actions !== null && actions.length > 0) {
                                for (var _i = 0, actions_1 = actions; _i < actions_1.length; _i++) {
                                    var action = actions_1[_i];
                                    var eventObject = dragonBones.BaseObject.borrowObject(dragonBones.EventObject);
                                    dragonBones.EventObject.actionDataToInstance(action, eventObject, this._armature);
                                    eventObject.slot = this;
                                    this._armature._bufferAction(eventObject, false);
                                }
                            }
                            else {
                                this._childArmature.animation.play();
                            }
                        }
                    }
                }
            }
        };
        Slot.prototype._updateGlobalTransformMatrix = function (isCache) {
            var parentMatrix = this._parent._boneData.type === 0 /* Bone */ ? this._parent.globalTransformMatrix : this._parent._getGlobalTransformMatrix(this.global.x, this.global.y);
            this.globalTransformMatrix.copyFrom(this._localMatrix);
            this.globalTransformMatrix.concat(parentMatrix);
            if (isCache) {
                this.global.fromMatrix(this.globalTransformMatrix);
            }
            else {
                this._globalDirty = true;
            }
        };
        /**
         * @internal
         */
        Slot.prototype._setDisplayIndex = function (value, isAnimation) {
            if (isAnimation === void 0) { isAnimation = false; }
            if (isAnimation) {
                if (this._animationDisplayIndex === value) {
                    return;
                }
                this._animationDisplayIndex = value;
            }
            if (this._displayIndex === value) {
                return;
            }
            this._displayIndex = value < this._displayFrames.length ? value : this._displayFrames.length - 1;
            this._displayDataDirty = true;
            this._displayDirty = this._displayIndex < 0 || this._display !== this._displayFrames[this._displayIndex].display;
        };
        /**
         * @internal
         */
        Slot.prototype._setZOrder = function (value) {
            if (this._zOrder === value) {
                // return false;
            }
            this._zOrder = value;
            this._zOrderDirty = true;
            return this._zOrderDirty;
        };
        /**
         * @internal
         */
        Slot.prototype._setColor = function (value) {
            this._colorTransform.copyFrom(value);
            return this._colorDirty = true;
        };
        /**
         * @internal
         */
        Slot.prototype.init = function (slotData, armatureValue, rawDisplay, meshDisplay) {
            if (this._slotData !== null) {
                return;
            }
            this._slotData = slotData;
            this._colorDirty = true; //
            this._blendModeDirty = true; //
            this._blendMode = this._slotData.blendMode;
            this._zOrder = this._slotData.zOrder;
            this._zIndex = this._slotData.zIndex;
            this._alpha = this._slotData.alpha;
            this._colorTransform.copyFrom(this._slotData.color);
            this._rawDisplay = rawDisplay;
            this._meshDisplay = meshDisplay;
            //
            this._armature = armatureValue;
            var slotParent = this._armature.getBone(this._slotData.parent.name);
            if (slotParent !== null) {
                this._parent = slotParent;
            }
            else {
                // Never;
            }
            this._armature._addSlot(this);
            //
            this._initDisplay(this._rawDisplay, false);
            if (this._rawDisplay !== this._meshDisplay) {
                this._initDisplay(this._meshDisplay, false);
            }
            this._onUpdateDisplay();
            this._addDisplay();
        };
        /**
         * @internal
         */
        Slot.prototype.update = function (cacheFrameIndex) {
            if (this._displayDataDirty) {
                this._updateDisplayData();
                this._displayDataDirty = false;
            }
            if (this._displayDirty) {
                this._updateDisplay();
                this._displayDirty = false;
            }
            if (this._geometryDirty || this._textureDirty) {
                if (this._display === null || this._display === this._rawDisplay || this._display === this._meshDisplay) {
                    this._updateFrame();
                }
                this._geometryDirty = false;
                this._textureDirty = false;
            }
            if (this._display === null) {
                return;
            }
            if (this._visibleDirty) {
                this._updateVisible();
                this._visibleDirty = false;
            }
            if (this._blendModeDirty) {
                this._updateBlendMode();
                this._blendModeDirty = false;
            }
            if (this._colorDirty) {
                this._updateColor();
                this._colorDirty = false;
            }
            if (this._zOrderDirty) {
                this._updateZOrder();
                this._zOrderDirty = false;
            }
            if (this._geometryData !== null && this._display === this._meshDisplay) {
                var isSkinned = this._geometryData.weight !== null;
                var isSurface = this._parent._boneData.type !== 0 /* Bone */;
                if (this._verticesDirty ||
                    (isSkinned && this._isBonesUpdate()) ||
                    (isSurface && this._parent._childrenTransformDirty)) {
                    this._verticesDirty = false; // Allow update mesh to reset the dirty value.
                    this._updateMesh();
                }
                if (isSkinned || isSurface) { // Compatible.
                    return;
                }
            }
            if (cacheFrameIndex >= 0 && this._cachedFrameIndices !== null) {
                var cachedFrameIndex = this._cachedFrameIndices[cacheFrameIndex];
                if (cachedFrameIndex >= 0 && this._cachedFrameIndex === cachedFrameIndex) { // Same cache.
                    this._transformDirty = false;
                }
                else if (cachedFrameIndex >= 0) { // Has been Cached.
                    this._transformDirty = true;
                    this._cachedFrameIndex = cachedFrameIndex;
                }
                else if (this._transformDirty || this._parent._childrenTransformDirty) { // Dirty.
                    this._transformDirty = true;
                    this._cachedFrameIndex = -1;
                }
                else if (this._cachedFrameIndex >= 0) { // Same cache, but not set index yet.
                    this._transformDirty = false;
                    this._cachedFrameIndices[cacheFrameIndex] = this._cachedFrameIndex;
                }
                else { // Dirty.
                    this._transformDirty = true;
                    this._cachedFrameIndex = -1;
                }
            }
            else if (this._transformDirty || this._parent._childrenTransformDirty) { // Dirty.
                cacheFrameIndex = -1;
                this._transformDirty = true;
                this._cachedFrameIndex = -1;
            }
            if (this._transformDirty) {
                if (this._cachedFrameIndex < 0) {
                    var isCache = cacheFrameIndex >= 0;
                    this._updateGlobalTransformMatrix(isCache);
                    if (isCache && this._cachedFrameIndices !== null) {
                        this._cachedFrameIndex = this._cachedFrameIndices[cacheFrameIndex] = this._armature._armatureData.setCacheFrame(this.globalTransformMatrix, this.global);
                    }
                }
                else {
                    this._armature._armatureData.getCacheFrame(this.globalTransformMatrix, this.global, this._cachedFrameIndex);
                }
                this._updateTransform();
                this._transformDirty = false;
            }
        };
        /**
         * - Forces the slot to update the state of the display object in the next frame.
         * @version DragonBones 4.5
         * @language en_US
         */
        /**
         * - 强制插槽在下一帧更新显示对象的状态。
         * @version DragonBones 4.5
         * @language zh_CN
         */
        Slot.prototype.invalidUpdate = function () {
            this._displayDataDirty = true;
            this._displayDirty = true;
            //
            this._transformDirty = true;
            // this._textureDirty = true;
        };
        /**
         * @private
         */
        Slot.prototype.updateTransformAndMatrix = function () {
            if (this._transformDirty) {
                this._updateGlobalTransformMatrix(false);
                this._transformDirty = false;
            }
        };
        /**
         * @private
         */
        Slot.prototype.replaceRawDisplayData = function (displayData, index) {
            if (index === void 0) { index = -1; }
            if (index < 0) {
                index = this._displayIndex < 0 ? 0 : this._displayIndex;
            }
            else if (index >= this._displayFrames.length) {
                return;
            }
            var displayFrame = this._displayFrames[index];
            if (displayFrame.rawDisplayData !== displayData) {
                displayFrame.deformVertices.length = 0;
                displayFrame.rawDisplayData = displayData;
                if (displayFrame.rawDisplayData === null) {
                    var defaultSkin = this._armature._armatureData.defaultSkin;
                    if (defaultSkin !== null) {
                        var defaultRawDisplayDatas = defaultSkin.getDisplays(this._slotData.name);
                        if (defaultRawDisplayDatas !== null && index < defaultRawDisplayDatas.length) {
                            displayFrame.rawDisplayData = defaultRawDisplayDatas[index];
                        }
                    }
                }
                if (index === this._displayIndex) {
                    this._displayDataDirty = true;
                }
            }
        };
        /**
         * @private
         */
        Slot.prototype.replaceDisplayData = function (displayData, index) {
            if (index === void 0) { index = -1; }
            if (index < 0) {
                index = this._displayIndex < 0 ? 0 : this._displayIndex;
            }
            else if (index >= this._displayFrames.length) {
                return;
            }
            var displayFrame = this._displayFrames[index];
            if (displayFrame.displayData !== displayData && displayFrame.rawDisplayData !== displayData) {
                displayFrame.displayData = displayData;
                if (index === this._displayIndex) {
                    this._displayDataDirty = true;
                }
            }
        };
        /**
         * @private
         */
        Slot.prototype.replaceTextureData = function (textureData, index) {
            if (index === void 0) { index = -1; }
            if (index < 0) {
                index = this._displayIndex < 0 ? 0 : this._displayIndex;
            }
            else if (index >= this._displayFrames.length) {
                return;
            }
            var displayFrame = this._displayFrames[index];
            if (displayFrame.textureData !== textureData) {
                displayFrame.textureData = textureData;
                if (index === this._displayIndex) {
                    this._displayDataDirty = true;
                }
            }
        };
        /**
         * @private
         */
        Slot.prototype.replaceDisplay = function (value, index) {
            if (index === void 0) { index = -1; }
            if (index < 0) {
                index = this._displayIndex < 0 ? 0 : this._displayIndex;
            }
            else if (index >= this._displayFrames.length) {
                return;
            }
            var displayFrame = this._displayFrames[index];
            if (displayFrame.display !== value) {
                var prevDisplay = displayFrame.display;
                displayFrame.display = value;
                if (prevDisplay !== null &&
                    prevDisplay !== this._rawDisplay && prevDisplay !== this._meshDisplay &&
                    !this._hasDisplay(prevDisplay)) {
                    if (prevDisplay instanceof dragonBones.Armature) {
                        // (eachDisplay as Armature).dispose();
                    }
                    else {
                        this._disposeDisplay(prevDisplay, true);
                    }
                }
                if (value !== null &&
                    value !== this._rawDisplay && value !== this._meshDisplay &&
                    !this._hasDisplay(prevDisplay) &&
                    !(value instanceof dragonBones.Armature)) {
                    this._initDisplay(value, true);
                }
                if (index === this._displayIndex) {
                    this._displayDirty = true;
                }
            }
        };
        /**
         * - Check whether a specific point is inside a custom bounding box in the slot.
         * The coordinate system of the point is the inner coordinate system of the armature.
         * Custom bounding boxes need to be customized in Dragonbones Pro.
         * @param x - The horizontal coordinate of the point.
         * @param y - The vertical coordinate of the point.
         * @version DragonBones 5.0
         * @language en_US
         */
        /**
         * - 检查特定点是否在插槽的自定义边界框内。
         * 点的坐标系为骨架内坐标系。
         * 自定义边界框需要在 DragonBones Pro 中自定义。
         * @param x - 点的水平坐标。
         * @param y - 点的垂直坐标。
         * @version DragonBones 5.0
         * @language zh_CN
         */
        Slot.prototype.containsPoint = function (x, y) {
            if (this._boundingBoxData === null) {
                return false;
            }
            this.updateTransformAndMatrix();
            Slot._helpMatrix.copyFrom(this.globalTransformMatrix);
            Slot._helpMatrix.invert();
            Slot._helpMatrix.transformPoint(x, y, Slot._helpPoint);
            return this._boundingBoxData.containsPoint(Slot._helpPoint.x, Slot._helpPoint.y);
        };
        /**
         * - Check whether a specific segment intersects a custom bounding box for the slot.
         * The coordinate system of the segment and intersection is the inner coordinate system of the armature.
         * Custom bounding boxes need to be customized in Dragonbones Pro.
         * @param xA - The horizontal coordinate of the beginning of the segment.
         * @param yA - The vertical coordinate of the beginning of the segment.
         * @param xB - The horizontal coordinate of the end point of the segment.
         * @param yB - The vertical coordinate of the end point of the segment.
         * @param intersectionPointA - The first intersection at which a line segment intersects the bounding box from the beginning to the end. (If not set, the intersection point will not calculated)
         * @param intersectionPointB - The first intersection at which a line segment intersects the bounding box from the end to the beginning. (If not set, the intersection point will not calculated)
         * @param normalRadians - The normal radians of the tangent of the intersection boundary box. [x: Normal radian of the first intersection tangent, y: Normal radian of the second intersection tangent] (If not set, the normal will not calculated)
         * @returns Intersection situation. [1: Disjoint and segments within the bounding box, 0: Disjoint, 1: Intersecting and having a nodal point and ending in the bounding box, 2: Intersecting and having a nodal point and starting at the bounding box, 3: Intersecting and having two intersections, N: Intersecting and having N intersections]
         * @version DragonBones 5.0
         * @language en_US
         */
        /**
         * - 检查特定线段是否与插槽的自定义边界框相交。
         * 线段和交点的坐标系均为骨架内坐标系。
         * 自定义边界框需要在 DragonBones Pro 中自定义。
         * @param xA - 线段起点的水平坐标。
         * @param yA - 线段起点的垂直坐标。
         * @param xB - 线段终点的水平坐标。
         * @param yB - 线段终点的垂直坐标。
         * @param intersectionPointA - 线段从起点到终点与边界框相交的第一个交点。 （如果未设置，则不计算交点）
         * @param intersectionPointB - 线段从终点到起点与边界框相交的第一个交点。 （如果未设置，则不计算交点）
         * @param normalRadians - 交点边界框切线的法线弧度。 [x: 第一个交点切线的法线弧度, y: 第二个交点切线的法线弧度] （如果未设置，则不计算法线）
         * @returns 相交的情况。 [-1: 不相交且线段在包围盒内, 0: 不相交, 1: 相交且有一个交点且终点在包围盒内, 2: 相交且有一个交点且起点在包围盒内, 3: 相交且有两个交点, N: 相交且有 N 个交点]
         * @version DragonBones 5.0
         * @language zh_CN
         */
        Slot.prototype.intersectsSegment = function (xA, yA, xB, yB, intersectionPointA, intersectionPointB, normalRadians) {
            if (intersectionPointA === void 0) { intersectionPointA = null; }
            if (intersectionPointB === void 0) { intersectionPointB = null; }
            if (normalRadians === void 0) { normalRadians = null; }
            if (this._boundingBoxData === null) {
                return 0;
            }
            this.updateTransformAndMatrix();
            Slot._helpMatrix.copyFrom(this.globalTransformMatrix);
            Slot._helpMatrix.invert();
            Slot._helpMatrix.transformPoint(xA, yA, Slot._helpPoint);
            xA = Slot._helpPoint.x;
            yA = Slot._helpPoint.y;
            Slot._helpMatrix.transformPoint(xB, yB, Slot._helpPoint);
            xB = Slot._helpPoint.x;
            yB = Slot._helpPoint.y;
            var intersectionCount = this._boundingBoxData.intersectsSegment(xA, yA, xB, yB, intersectionPointA, intersectionPointB, normalRadians);
            if (intersectionCount > 0) {
                if (intersectionCount === 1 || intersectionCount === 2) {
                    if (intersectionPointA !== null) {
                        this.globalTransformMatrix.transformPoint(intersectionPointA.x, intersectionPointA.y, intersectionPointA);
                        if (intersectionPointB !== null) {
                            intersectionPointB.x = intersectionPointA.x;
                            intersectionPointB.y = intersectionPointA.y;
                        }
                    }
                    else if (intersectionPointB !== null) {
                        this.globalTransformMatrix.transformPoint(intersectionPointB.x, intersectionPointB.y, intersectionPointB);
                    }
                }
                else {
                    if (intersectionPointA !== null) {
                        this.globalTransformMatrix.transformPoint(intersectionPointA.x, intersectionPointA.y, intersectionPointA);
                    }
                    if (intersectionPointB !== null) {
                        this.globalTransformMatrix.transformPoint(intersectionPointB.x, intersectionPointB.y, intersectionPointB);
                    }
                }
                if (normalRadians !== null) {
                    this.globalTransformMatrix.transformPoint(Math.cos(normalRadians.x), Math.sin(normalRadians.x), Slot._helpPoint, true);
                    normalRadians.x = Math.atan2(Slot._helpPoint.y, Slot._helpPoint.x);
                    this.globalTransformMatrix.transformPoint(Math.cos(normalRadians.y), Math.sin(normalRadians.y), Slot._helpPoint, true);
                    normalRadians.y = Math.atan2(Slot._helpPoint.y, Slot._helpPoint.x);
                }
            }
            return intersectionCount;
        };
        /**
         * @private
         */
        Slot.prototype.getDisplayFrameAt = function (index) {
            return this._displayFrames[index];
        };
        Object.defineProperty(Slot.prototype, "visible", {
            /**
             * - The visible of slot's display object.
             * @default true
             * @version DragonBones 5.6
             * @language en_US
             */
            /**
             * - 插槽的显示对象的可见。
             * @default true
             * @version DragonBones 5.6
             * @language zh_CN
             */
            get: function () {
                return this._visible;
            },
            set: function (value) {
                if (this._visible === value) {
                    return;
                }
                this._visible = value;
                this._updateVisible();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Slot.prototype, "displayFrameCount", {
            /**
             * @private
             */
            get: function () {
                return this._displayFrames.length;
            },
            set: function (value) {
                var prevCount = this._displayFrames.length;
                if (prevCount < value) {
                    this._displayFrames.length = value;
                    for (var i = prevCount; i < value; ++i) {
                        this._displayFrames[i] = dragonBones.BaseObject.borrowObject(DisplayFrame);
                    }
                }
                else if (prevCount > value) {
                    for (var i = prevCount - 1; i < value; --i) {
                        this.replaceDisplay(null, i);
                        this._displayFrames[i].returnToPool();
                    }
                    this._displayFrames.length = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Slot.prototype, "displayIndex", {
            /**
             * - The index of the display object displayed in the display list.
             * @example
             * <pre>
             *     let slot = armature.getSlot("weapon");
             *     slot.displayIndex = 3;
             *     slot.displayController = "none";
             * </pre>
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 此时显示的显示对象在显示列表中的索引。
             * @example
             * <pre>
             *     let slot = armature.getSlot("weapon");
             *     slot.displayIndex = 3;
             *     slot.displayController = "none";
             * </pre>
             * @version DragonBones 4.5
             * @language zh_CN
             */
            get: function () {
                return this._displayIndex;
            },
            set: function (value) {
                this._setDisplayIndex(value);
                this.update(-1);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Slot.prototype, "name", {
            /**
             * - The slot name.
             * @see dragonBones.SlotData#name
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 插槽名称。
             * @see dragonBones.SlotData#name
             * @version DragonBones 3.0
             * @language zh_CN
             */
            get: function () {
                return this._slotData.name;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Slot.prototype, "displayList", {
            /**
             * - Contains a display list of display objects or child armatures.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 包含显示对象或子骨架的显示列表。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            get: function () {
                var displays = new Array();
                for (var _i = 0, _a = this._displayFrames; _i < _a.length; _i++) {
                    var displayFrame = _a[_i];
                    displays.push(displayFrame.display);
                }
                return displays;
            },
            set: function (value) {
                this.displayFrameCount = value.length;
                var index = 0;
                for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
                    var eachDisplay = value_1[_i];
                    this.replaceDisplay(eachDisplay, index++);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Slot.prototype, "slotData", {
            /**
             * - The slot data.
             * @see dragonBones.SlotData
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 插槽数据。
             * @see dragonBones.SlotData
             * @version DragonBones 4.5
             * @language zh_CN
             */
            get: function () {
                return this._slotData;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Slot.prototype, "boundingBoxData", {
            /**
             * - The custom bounding box data for the slot at current time.
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 插槽此时的自定义包围盒数据。
             * @version DragonBones 5.0
             * @language zh_CN
             */
            get: function () {
                return this._boundingBoxData;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Slot.prototype, "rawDisplay", {
            /**
             * @private
             */
            get: function () {
                return this._rawDisplay;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Slot.prototype, "meshDisplay", {
            /**
             * @private
             */
            get: function () {
                return this._meshDisplay;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Slot.prototype, "display", {
            /**
             * - The display object that the slot displays at this time.
             * @example
             * <pre>
             *     let slot = armature.getSlot("text");
             *     slot.display = new yourEngine.TextField();
             * </pre>
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 插槽此时显示的显示对象。
             * @example
             * <pre>
             *     let slot = armature.getSlot("text");
             *     slot.display = new yourEngine.TextField();
             * </pre>
             * @version DragonBones 3.0
             * @language zh_CN
             */
            get: function () {
                return this._display;
            },
            set: function (value) {
                if (this._display === value) {
                    return;
                }
                if (this._displayFrames.length === 0) {
                    this.displayFrameCount = 1;
                    this._displayIndex = 0;
                }
                this.replaceDisplay(value, this._displayIndex);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Slot.prototype, "childArmature", {
            /**
             * - The child armature that the slot displayed at current time.
             * @example
             * <pre>
             *     let slot = armature.getSlot("weapon");
             *     let prevChildArmature = slot.childArmature;
             *     if (prevChildArmature) {
             *         prevChildArmature.dispose();
             *     }
             *     slot.childArmature = factory.buildArmature("weapon_blabla", "weapon_blabla_project");
             * </pre>
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 插槽此时显示的子骨架。
             * 注意，被替换的对象或子骨架并不会被回收，根据语言和引擎的不同，需要额外处理。
             * @example
             * <pre>
             *     let slot = armature.getSlot("weapon");
             *     let prevChildArmature = slot.childArmature;
             *     if (prevChildArmature) {
             *         prevChildArmature.dispose();
             *     }
             *     slot.childArmature = factory.buildArmature("weapon_blabla", "weapon_blabla_project");
             * </pre>
             * @version DragonBones 3.0
             * @language zh_CN
             */
            get: function () {
                return this._childArmature;
            },
            set: function (value) {
                if (this._childArmature === value) {
                    return;
                }
                this.display = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Slot.prototype, "parent", {
            /**
             * - The parent bone to which it belongs.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 所属的父骨骼。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            get: function () {
                return this._parent;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * - Deprecated, please refer to {@link #display}.
         * @deprecated
         * @language en_US
         */
        /**
         * - 已废弃，请参考 {@link #display}。
         * @deprecated
         * @language zh_CN
         */
        Slot.prototype.getDisplay = function () {
            return this._display;
        };
        /**
         * - Deprecated, please refer to {@link #display}.
         * @deprecated
         * @language en_US
         */
        /**
         * - 已废弃，请参考 {@link #display}。
         * @deprecated
         * @language zh_CN
         */
        Slot.prototype.setDisplay = function (value) {
            this.display = value;
        };
        return Slot;
    }(dragonBones.TransformObject));
    dragonBones.Slot = Slot;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * @internal
     */
    var Constraint = /** @class */ (function (_super) {
        __extends(Constraint, _super);
        function Constraint() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Constraint.prototype._onClear = function () {
            this._armature = null; //
            this._target = null; //
            this._root = null; //
            this._bone = null;
        };
        Object.defineProperty(Constraint.prototype, "name", {
            get: function () {
                return this._constraintData.name;
            },
            enumerable: true,
            configurable: true
        });
        Constraint._helpMatrix = new dragonBones.Matrix();
        Constraint._helpTransform = new dragonBones.Transform();
        Constraint._helpPoint = new dragonBones.Point();
        return Constraint;
    }(dragonBones.BaseObject));
    dragonBones.Constraint = Constraint;
    /**
     * @internal
     */
    var IKConstraint = /** @class */ (function (_super) {
        __extends(IKConstraint, _super);
        function IKConstraint() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IKConstraint.toString = function () {
            return "[class dragonBones.IKConstraint]";
        };
        IKConstraint.prototype._onClear = function () {
            _super.prototype._onClear.call(this);
            // this._scaleEnabled = false;
            this._bendPositive = false;
            this._weight = 1.0;
            this._constraintData = null;
        };
        IKConstraint.prototype._computeA = function () {
            var ikGlobal = this._target.global;
            var global = this._root.global;
            var globalTransformMatrix = this._root.globalTransformMatrix;
            var radian = Math.atan2(ikGlobal.y - global.y, ikGlobal.x - global.x);
            if (global.scaleX < 0.0) {
                radian += Math.PI;
            }
            global.rotation += dragonBones.Transform.normalizeRadian(radian - global.rotation) * this._weight;
            global.toMatrix(globalTransformMatrix);
        };
        IKConstraint.prototype._computeB = function () {
            var boneLength = this._bone._boneData.length;
            var parent = this._root;
            var ikGlobal = this._target.global;
            var parentGlobal = parent.global;
            var global = this._bone.global;
            var globalTransformMatrix = this._bone.globalTransformMatrix;
            var x = globalTransformMatrix.a * boneLength;
            var y = globalTransformMatrix.b * boneLength;
            var lLL = x * x + y * y;
            var lL = Math.sqrt(lLL);
            var dX = global.x - parentGlobal.x;
            var dY = global.y - parentGlobal.y;
            var lPP = dX * dX + dY * dY;
            var lP = Math.sqrt(lPP);
            var rawRadian = global.rotation;
            var rawParentRadian = parentGlobal.rotation;
            var rawRadianA = Math.atan2(dY, dX);
            dX = ikGlobal.x - parentGlobal.x;
            dY = ikGlobal.y - parentGlobal.y;
            var lTT = dX * dX + dY * dY;
            var lT = Math.sqrt(lTT);
            var radianA = 0.0;
            if (lL + lP <= lT || lT + lL <= lP || lT + lP <= lL) {
                radianA = Math.atan2(ikGlobal.y - parentGlobal.y, ikGlobal.x - parentGlobal.x);
                if (lL + lP <= lT) {
                }
                else if (lP < lL) {
                    radianA += Math.PI;
                }
            }
            else {
                var h = (lPP - lLL + lTT) / (2.0 * lTT);
                var r = Math.sqrt(lPP - h * h * lTT) / lT;
                var hX = parentGlobal.x + (dX * h);
                var hY = parentGlobal.y + (dY * h);
                var rX = -dY * r;
                var rY = dX * r;
                var isPPR = false;
                var parentParent = parent.parent;
                if (parentParent !== null) {
                    var parentParentMatrix = parentParent.globalTransformMatrix;
                    isPPR = parentParentMatrix.a * parentParentMatrix.d - parentParentMatrix.b * parentParentMatrix.c < 0.0;
                }
                if (isPPR !== this._bendPositive) {
                    global.x = hX - rX;
                    global.y = hY - rY;
                }
                else {
                    global.x = hX + rX;
                    global.y = hY + rY;
                }
                radianA = Math.atan2(global.y - parentGlobal.y, global.x - parentGlobal.x);
            }
            var dR = dragonBones.Transform.normalizeRadian(radianA - rawRadianA);
            parentGlobal.rotation = rawParentRadian + dR * this._weight;
            parentGlobal.toMatrix(parent.globalTransformMatrix);
            //
            var currentRadianA = rawRadianA + dR * this._weight;
            global.x = parentGlobal.x + Math.cos(currentRadianA) * lP;
            global.y = parentGlobal.y + Math.sin(currentRadianA) * lP;
            //
            var radianB = Math.atan2(ikGlobal.y - global.y, ikGlobal.x - global.x);
            if (global.scaleX < 0.0) {
                radianB += Math.PI;
            }
            global.rotation = parentGlobal.rotation + rawRadian - rawParentRadian + dragonBones.Transform.normalizeRadian(radianB - dR - rawRadian) * this._weight;
            global.toMatrix(globalTransformMatrix);
        };
        IKConstraint.prototype.init = function (constraintData, armature) {
            if (this._constraintData !== null) {
                return;
            }
            this._constraintData = constraintData;
            this._armature = armature;
            this._target = this._armature.getBone(this._constraintData.target.name);
            this._root = this._armature.getBone(this._constraintData.root.name);
            this._bone = this._constraintData.bone !== null ? this._armature.getBone(this._constraintData.bone.name) : null;
            {
                var ikConstraintData = this._constraintData;
                // this._scaleEnabled = ikConstraintData.scaleEnabled;
                this._bendPositive = ikConstraintData.bendPositive;
                this._weight = ikConstraintData.weight;
            }
            this._root._hasConstraint = true;
        };
        IKConstraint.prototype.update = function () {
            this._root.updateByConstraint();
            if (this._bone !== null) {
                this._bone.updateByConstraint();
                this._computeB();
            }
            else {
                this._computeA();
            }
        };
        IKConstraint.prototype.invalidUpdate = function () {
            this._root.invalidUpdate();
            if (this._bone !== null) {
                this._bone.invalidUpdate();
            }
        };
        return IKConstraint;
    }(Constraint));
    dragonBones.IKConstraint = IKConstraint;
    /**
     * @internal
     */
    var PathConstraint = /** @class */ (function (_super) {
        __extends(PathConstraint, _super);
        function PathConstraint() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._bones = [];
            _this._spaces = [];
            _this._positions = [];
            _this._curves = [];
            _this._boneLengths = [];
            _this._pathGlobalVertices = [];
            _this._segments = [10];
            return _this;
        }
        PathConstraint.toString = function () {
            return "[class dragonBones.PathConstraint]";
        };
        PathConstraint.prototype._onClear = function () {
            _super.prototype._onClear.call(this);
            this.dirty = false;
            this.pathOffset = 0;
            this.position = 0.0;
            this.spacing = 0.0;
            this.rotateOffset = 0.0;
            this.rotateMix = 1.0;
            this.translateMix = 1.0;
            this._pathSlot = null;
            this._bones.length = 0;
            this._spaces.length = 0;
            this._positions.length = 0;
            this._curves.length = 0;
            this._boneLengths.length = 0;
            this._pathGlobalVertices.length = 0;
        };
        PathConstraint.prototype._updatePathVertices = function (verticesData) {
            //计算曲线的节点数据
            var armature = this._armature;
            var dragonBonesData = armature.armatureData.parent;
            var scale = armature.armatureData.scale;
            var intArray = dragonBonesData.intArray;
            var floatArray = dragonBonesData.floatArray;
            var pathOffset = verticesData.offset;
            var pathVertexCount = intArray[pathOffset + 0 /* GeometryVertexCount */];
            var pathVertexOffset = intArray[pathOffset + 2 /* GeometryFloatOffset */];
            this._pathGlobalVertices.length = pathVertexCount * 2;
            var weightData = verticesData.weight;
            //没有骨骼约束我,那节点只受自己的Bone控制
            if (weightData === null) {
                var parentBone = this._pathSlot.parent;
                parentBone.updateByConstraint();
                var matrix = parentBone.globalTransformMatrix;
                for (var i = 0, iV_1 = pathVertexOffset; i < pathVertexCount; i += 2) {
                    var vx = floatArray[iV_1++] * scale;
                    var vy = floatArray[iV_1++] * scale;
                    var x = matrix.a * vx + matrix.c * vy + matrix.tx;
                    var y = matrix.b * vx + matrix.d * vy + matrix.ty;
                    //
                    this._pathGlobalVertices[i] = x;
                    this._pathGlobalVertices[i + 1] = y;
                }
                return;
            }
            //有骨骼约束我,那我的节点受骨骼权重控制
            var bones = this._pathSlot._geometryBones;
            var weightBoneCount = weightData.bones.length;
            var weightOffset = weightData.offset;
            var floatOffset = intArray[weightOffset + 1 /* WeigthFloatOffset */];
            var iV = floatOffset;
            var iB = weightOffset + 2 /* WeigthBoneIndices */ + weightBoneCount;
            for (var i = 0, iW = 0; i < pathVertexCount; i++) {
                var vertexBoneCount = intArray[iB++]; //
                var xG = 0.0, yG = 0.0;
                for (var ii = 0, ll = vertexBoneCount; ii < ll; ii++) {
                    var boneIndex = intArray[iB++];
                    var bone = bones[boneIndex];
                    if (bone === null) {
                        continue;
                    }
                    bone.updateByConstraint();
                    var matrix = bone.globalTransformMatrix;
                    var weight = floatArray[iV++];
                    var vx = floatArray[iV++] * scale;
                    var vy = floatArray[iV++] * scale;
                    xG += (matrix.a * vx + matrix.c * vy + matrix.tx) * weight;
                    yG += (matrix.b * vx + matrix.d * vy + matrix.ty) * weight;
                }
                this._pathGlobalVertices[iW++] = xG;
                this._pathGlobalVertices[iW++] = yG;
            }
        };
        PathConstraint.prototype._computeVertices = function (start, count, offset, out) {
            //TODO优化
            for (var i = offset, iW = start; i < count; i += 2) {
                out[i] = this._pathGlobalVertices[iW++];
                out[i + 1] = this._pathGlobalVertices[iW++];
            }
        };
        PathConstraint.prototype._computeBezierCurve = function (pathDisplayDta, spaceCount, tangents, percentPosition, percentSpacing) {
            //计算当前的骨骼在曲线上的位置
            var armature = this._armature;
            var intArray = armature.armatureData.parent.intArray;
            var vertexCount = intArray[pathDisplayDta.geometry.offset + 0 /* GeometryVertexCount */];
            var positions = this._positions;
            var spaces = this._spaces;
            var isClosed = pathDisplayDta.closed;
            var curveVertices = Array();
            var verticesLength = vertexCount * 2;
            var curveCount = verticesLength / 6;
            var preCurve = -1;
            var position = this.position;
            positions.length = spaceCount * 3 + 2;
            var pathLength = 0.0;
            //不需要匀速运动，效率高些
            if (!pathDisplayDta.constantSpeed) {
                var lenghts = pathDisplayDta.curveLengths;
                curveCount -= isClosed ? 1 : 2;
                pathLength = lenghts[curveCount];
                if (percentPosition) {
                    position *= pathLength;
                }
                if (percentSpacing) {
                    for (var i = 0; i < spaceCount; i++) {
                        spaces[i] *= pathLength;
                    }
                }
                curveVertices.length = 8;
                for (var i = 0, o = 0, curve = 0; i < spaceCount; i++, o += 3) {
                    var space = spaces[i];
                    position += space;
                    if (isClosed) {
                        position %= pathLength;
                        if (position < 0) {
                            position += pathLength;
                        }
                        curve = 0;
                    }
                    else if (position < 0) {
                        //TODO
                        continue;
                    }
                    else if (position > pathLength) {
                        //TODO
                        continue;
                    }
                    var percent = 0.0;
                    for (;; curve++) {
                        var len = lenghts[curve];
                        if (position > len) {
                            continue;
                        }
                        if (curve === 0) {
                            percent = position / len;
                        }
                        else {
                            var preLen = lenghts[curve - 1];
                            percent = (position - preLen) / (len - preLen);
                        }
                        break;
                    }
                    if (curve !== preCurve) {
                        preCurve = curve;
                        if (isClosed && curve === curveCount) {
                            //计算曲线
                            this._computeVertices(verticesLength - 4, 4, 0, curveVertices);
                            this._computeVertices(0, 4, 4, curveVertices);
                        }
                        else {
                            this._computeVertices(curve * 6 + 2, 8, 0, curveVertices);
                        }
                    }
                    //
                    this.addCurvePosition(percent, curveVertices[0], curveVertices[1], curveVertices[2], curveVertices[3], curveVertices[4], curveVertices[5], curveVertices[6], curveVertices[7], positions, o, tangents);
                }
                return;
            }
            //匀速的
            if (isClosed) {
                verticesLength += 2;
                curveVertices.length = vertexCount;
                this._computeVertices(2, verticesLength - 4, 0, curveVertices);
                this._computeVertices(0, 2, verticesLength - 4, curveVertices);
                curveVertices[verticesLength - 2] = curveVertices[0];
                curveVertices[verticesLength - 1] = curveVertices[1];
            }
            else {
                curveCount--;
                verticesLength -= 4;
                curveVertices.length = verticesLength;
                this._computeVertices(2, verticesLength, 0, curveVertices);
            }
            //
            var curves = new Array(curveCount);
            pathLength = 0;
            var x1 = curveVertices[0], y1 = curveVertices[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;
            var tmpx, tmpy, dddfx, dddfy, ddfx, ddfy, dfx, dfy;
            for (var i = 0, w = 2; i < curveCount; i++, w += 6) {
                cx1 = curveVertices[w];
                cy1 = curveVertices[w + 1];
                cx2 = curveVertices[w + 2];
                cy2 = curveVertices[w + 3];
                x2 = curveVertices[w + 4];
                y2 = curveVertices[w + 5];
                tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;
                tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;
                dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;
                dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;
                ddfx = tmpx * 2 + dddfx;
                ddfy = tmpy * 2 + dddfy;
                dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;
                dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;
                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                dfx += ddfx;
                dfy += ddfy;
                ddfx += dddfx;
                ddfy += dddfy;
                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                dfx += ddfx;
                dfy += ddfy;
                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                dfx += ddfx + dddfx;
                dfy += ddfy + dddfy;
                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                curves[i] = pathLength;
                x1 = x2;
                y1 = y2;
            }
            if (percentPosition) {
                position *= pathLength;
            }
            if (percentSpacing) {
                for (var i = 0; i < spaceCount; i++) {
                    spaces[i] *= pathLength;
                }
            }
            var segments = this._segments;
            var curveLength = 0;
            for (var i = 0, o = 0, curve = 0, segment = 0; i < spaceCount; i++, o += 3) {
                var space = spaces[i];
                position += space;
                var p = position;
                if (isClosed) {
                    p %= pathLength;
                    if (p < 0)
                        p += pathLength;
                    curve = 0;
                }
                else if (p < 0) {
                    continue;
                }
                else if (p > pathLength) {
                    continue;
                }
                // Determine curve containing position.
                for (;; curve++) {
                    var length_1 = curves[curve];
                    if (p > length_1)
                        continue;
                    if (curve === 0)
                        p /= length_1;
                    else {
                        var prev = curves[curve - 1];
                        p = (p - prev) / (length_1 - prev);
                    }
                    break;
                }
                if (curve !== preCurve) {
                    preCurve = curve;
                    var ii = curve * 6;
                    x1 = curveVertices[ii];
                    y1 = curveVertices[ii + 1];
                    cx1 = curveVertices[ii + 2];
                    cy1 = curveVertices[ii + 3];
                    cx2 = curveVertices[ii + 4];
                    cy2 = curveVertices[ii + 5];
                    x2 = curveVertices[ii + 6];
                    y2 = curveVertices[ii + 7];
                    tmpx = (x1 - cx1 * 2 + cx2) * 0.03;
                    tmpy = (y1 - cy1 * 2 + cy2) * 0.03;
                    dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;
                    dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;
                    ddfx = tmpx * 2 + dddfx;
                    ddfy = tmpy * 2 + dddfy;
                    dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;
                    dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;
                    curveLength = Math.sqrt(dfx * dfx + dfy * dfy);
                    segments[0] = curveLength;
                    for (ii = 1; ii < 8; ii++) {
                        dfx += ddfx;
                        dfy += ddfy;
                        ddfx += dddfx;
                        ddfy += dddfy;
                        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
                        segments[ii] = curveLength;
                    }
                    dfx += ddfx;
                    dfy += ddfy;
                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    segments[8] = curveLength;
                    dfx += ddfx + dddfx;
                    dfy += ddfy + dddfy;
                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
                    segments[9] = curveLength;
                    segment = 0;
                }
                // Weight by segment length.
                p *= curveLength;
                for (;; segment++) {
                    var length_2 = segments[segment];
                    if (p > length_2)
                        continue;
                    if (segment === 0)
                        p /= length_2;
                    else {
                        var prev = segments[segment - 1];
                        p = segment + (p - prev) / (length_2 - prev);
                    }
                    break;
                }
                this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, positions, o, tangents);
            }
        };
        //Calculates a point on the curve, for a given t value between 0 and 1.
        PathConstraint.prototype.addCurvePosition = function (t, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, offset, tangents) {
            if (t === 0) {
                out[offset] = x1;
                out[offset + 1] = y1;
                out[offset + 2] = 0;
                return;
            }
            if (t === 1) {
                out[offset] = x2;
                out[offset + 1] = y2;
                out[offset + 2] = 0;
                return;
            }
            var mt = 1 - t;
            var mt2 = mt * mt;
            var t2 = t * t;
            var a = mt2 * mt;
            var b = mt2 * t * 3;
            var c = mt * t2 * 3;
            var d = t * t2;
            var x = a * x1 + b * cx1 + c * cx2 + d * x2;
            var y = a * y1 + b * cy1 + c * cy2 + d * y2;
            out[offset] = x;
            out[offset + 1] = y;
            if (tangents) {
                //Calculates the curve tangent at the specified t value
                out[offset + 2] = Math.atan2(y - (a * y1 + b * cy1 + c * cy2), x - (a * x1 + b * cx1 + c * cx2));
            }
            else {
                out[offset + 2] = 0;
            }
        };
        PathConstraint.prototype.init = function (constraintData, armature) {
            this._constraintData = constraintData;
            this._armature = armature;
            var data = constraintData;
            this.pathOffset = data.pathDisplayData.geometry.offset;
            //
            this.position = data.position;
            this.spacing = data.spacing;
            this.rotateOffset = data.rotateOffset;
            this.rotateMix = data.rotateMix;
            this.translateMix = data.translateMix;
            //
            this._root = this._armature.getBone(data.root.name);
            this._target = this._armature.getBone(data.target.name);
            this._pathSlot = this._armature.getSlot(data.pathSlot.name);
            for (var i = 0, l = data.bones.length; i < l; i++) {
                var bone = this._armature.getBone(data.bones[i].name);
                if (bone !== null) {
                    this._bones.push(bone);
                }
            }
            if (data.rotateMode === 2 /* ChainScale */) {
                this._boneLengths.length = this._bones.length;
            }
            this._root._hasConstraint = true;
        };
        PathConstraint.prototype.update = function () {
            var pathSlot = this._pathSlot;
            if (pathSlot._geometryData === null ||
                pathSlot._geometryData.offset !== this.pathOffset) {
                return;
            }
            var constraintData = this._constraintData;
            //
            //曲线节点数据改变:父亲bone改变，权重bones改变，变形顶点改变
            var isPathVerticeDirty = false;
            if (this._root._childrenTransformDirty) {
                this._updatePathVertices(pathSlot._geometryData);
                isPathVerticeDirty = true;
            }
            else if (pathSlot._verticesDirty || pathSlot._isBonesUpdate()) {
                this._updatePathVertices(pathSlot._geometryData);
                pathSlot._verticesDirty = false;
                isPathVerticeDirty = true;
            }
            if (!isPathVerticeDirty && !this.dirty) {
                return;
            }
            //
            var positionMode = constraintData.positionMode;
            var spacingMode = constraintData.spacingMode;
            var rotateMode = constraintData.rotateMode;
            var bones = this._bones;
            var isLengthMode = spacingMode === 0 /* Length */;
            var isChainScaleMode = rotateMode === 2 /* ChainScale */;
            var isTangentMode = rotateMode === 0 /* Tangent */;
            var boneCount = bones.length;
            var spacesCount = isTangentMode ? boneCount : boneCount + 1;
            var spacing = this.spacing;
            var spaces = this._spaces;
            spaces.length = spacesCount;
            //计曲线间隔和长度
            if (isChainScaleMode || isLengthMode) {
                //Bone改变和spacing改变触发
                spaces[0] = 0;
                for (var i = 0, l = spacesCount - 1; i < l; i++) {
                    var bone = bones[i];
                    bone.updateByConstraint();
                    var boneLength = bone._boneData.length;
                    var matrix = bone.globalTransformMatrix;
                    var x = boneLength * matrix.a;
                    var y = boneLength * matrix.b;
                    var len = Math.sqrt(x * x + y * y);
                    if (isChainScaleMode) {
                        this._boneLengths[i] = len;
                    }
                    spaces[i + 1] = (boneLength + spacing) * len / boneLength;
                }
            }
            else {
                for (var i = 0; i < spacesCount; i++) {
                    spaces[i] = spacing;
                }
            }
            //
            this._computeBezierCurve(pathSlot._displayFrame.rawDisplayData, spacesCount, isTangentMode, positionMode === 1 /* Percent */, spacingMode === 2 /* Percent */);
            //根据新的节点数据重新采样
            var positions = this._positions;
            var rotateOffset = this.rotateOffset;
            var boneX = positions[0], boneY = positions[1];
            var tip;
            if (rotateOffset === 0) {
                tip = rotateMode === 1 /* Chain */;
            }
            else {
                tip = false;
                var bone = pathSlot.parent;
                if (bone !== null) {
                    var matrix = bone.globalTransformMatrix;
                    rotateOffset *= matrix.a * matrix.d - matrix.b * matrix.c > 0 ? dragonBones.Transform.DEG_RAD : -dragonBones.Transform.DEG_RAD;
                }
            }
            //
            var rotateMix = this.rotateMix;
            var translateMix = this.translateMix;
            for (var i = 0, p = 3; i < boneCount; i++, p += 3) {
                var bone = bones[i];
                bone.updateByConstraint();
                var matrix = bone.globalTransformMatrix;
                matrix.tx += (boneX - matrix.tx) * translateMix;
                matrix.ty += (boneY - matrix.ty) * translateMix;
                var x = positions[p], y = positions[p + 1];
                var dx = x - boneX, dy = y - boneY;
                if (isChainScaleMode) {
                    var lenght = this._boneLengths[i];
                    var s = (Math.sqrt(dx * dx + dy * dy) / lenght - 1) * rotateMix + 1;
                    matrix.a *= s;
                    matrix.b *= s;
                }
                boneX = x;
                boneY = y;
                if (rotateMix > 0) {
                    var a = matrix.a, b = matrix.b, c = matrix.c, d = matrix.d, r = void 0, cos = void 0, sin = void 0;
                    if (isTangentMode) {
                        r = positions[p - 1];
                    }
                    else {
                        r = Math.atan2(dy, dx);
                    }
                    r -= Math.atan2(b, a);
                    if (tip) {
                        cos = Math.cos(r);
                        sin = Math.sin(r);
                        var length_3 = bone._boneData.length;
                        boneX += (length_3 * (cos * a - sin * b) - dx) * rotateMix;
                        boneY += (length_3 * (sin * a + cos * b) - dy) * rotateMix;
                    }
                    else {
                        r += rotateOffset;
                    }
                    if (r > dragonBones.Transform.PI) {
                        r -= dragonBones.Transform.PI_D;
                    }
                    else if (r < -dragonBones.Transform.PI) {
                        r += dragonBones.Transform.PI_D;
                    }
                    r *= rotateMix;
                    cos = Math.cos(r);
                    sin = Math.sin(r);
                    matrix.a = cos * a - sin * b;
                    matrix.b = sin * a + cos * b;
                    matrix.c = cos * c - sin * d;
                    matrix.d = sin * c + cos * d;
                }
                bone.global.fromMatrix(matrix);
            }
            this.dirty = false;
        };
        PathConstraint.prototype.invalidUpdate = function () {
        };
        return PathConstraint;
    }(Constraint));
    dragonBones.PathConstraint = PathConstraint;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * - Worldclock provides clock support for animations, advance time for each IAnimatable object added to the instance.
     * @see dragonBones.IAnimateble
     * @see dragonBones.Armature
     * @version DragonBones 3.0
     * @language en_US
     */
    /**
     * - WorldClock 对动画提供时钟支持，为每个加入到该实例的 IAnimatable 对象更新时间。
     * @see dragonBones.IAnimateble
     * @see dragonBones.Armature
     * @version DragonBones 3.0
     * @language zh_CN
     */
    var WorldClock = /** @class */ (function () {
        /**
         * - Creating a Worldclock instance. Typically, you do not need to create Worldclock instance.
         * When multiple Worldclock instances are running at different speeds, can achieving some specific animation effects, such as bullet time.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 创建一个 WorldClock 实例。通常并不需要创建 WorldClock 实例。
         * 当多个 WorldClock 实例使用不同的速度运行时，可以实现一些特殊的动画效果，比如子弹时间等。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        function WorldClock(time) {
            if (time === void 0) { time = 0.0; }
            /**
             * - Current time. (In seconds)
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 当前的时间。 (以秒为单位)
             * @version DragonBones 3.0
             * @language zh_CN
             */
            this.time = 0.0;
            /**
             * - The play speed, used to control animation speed-shift play.
             * [0: Stop play, (0~1): Slow play, 1: Normal play, (1~N): Fast play]
             * @default 1.0
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 播放速度，用于控制动画变速播放。
             * [0: 停止播放, (0~1): 慢速播放, 1: 正常播放, (1~N): 快速播放]
             * @default 1.0
             * @version DragonBones 3.0
             * @language zh_CN
             */
            this.timeScale = 1.0;
            this._systemTime = 0.0;
            this._animatebles = [];
            this._clock = null;
            this.time = time;
            this._systemTime = new Date().getTime() * 0.001;
        }
        /**
         * - Advance time for all IAnimatable instances.
         * @param passedTime - Passed time. [-1: Automatically calculates the time difference between the current frame and the previous frame, [0~N): Passed time] (In seconds)
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 为所有的 IAnimatable 实例更新时间。
         * @param passedTime - 前进的时间。 [-1: 自动计算当前帧与上一帧的时间差, [0~N): 前进的时间] (以秒为单位)
         * @version DragonBones 3.0
         * @language zh_CN
         */
        WorldClock.prototype.advanceTime = function (passedTime) {
            if (passedTime !== passedTime) {
                passedTime = 0.0;
            }
            var currentTime = Date.now() * 0.001;
            if (passedTime < 0.0) {
                passedTime = currentTime - this._systemTime;
            }
            this._systemTime = currentTime;
            if (this.timeScale !== 1.0) {
                passedTime *= this.timeScale;
            }
            if (passedTime === 0.0) {
                return;
            }
            if (passedTime < 0.0) {
                this.time -= passedTime;
            }
            else {
                this.time += passedTime;
            }
            var i = 0, r = 0, l = this._animatebles.length;
            for (; i < l; ++i) {
                var animatable = this._animatebles[i];
                if (animatable !== null) {
                    if (r > 0) {
                        this._animatebles[i - r] = animatable;
                        this._animatebles[i] = null;
                    }
                    animatable.advanceTime(passedTime);
                }
                else {
                    r++;
                }
            }
            if (r > 0) {
                l = this._animatebles.length;
                for (; i < l; ++i) {
                    var animateble = this._animatebles[i];
                    if (animateble !== null) {
                        this._animatebles[i - r] = animateble;
                    }
                    else {
                        r++;
                    }
                }
                this._animatebles.length -= r;
            }
        };
        /**
         * - Check whether contains a specific instance of IAnimatable.
         * @param value - The IAnimatable instance.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 检查是否包含特定的 IAnimatable 实例。
         * @param value - IAnimatable 实例。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        WorldClock.prototype.contains = function (value) {
            if (value === this) {
                return false;
            }
            var ancestor = value;
            while (ancestor !== this && ancestor !== null) {
                ancestor = ancestor.clock;
            }
            return ancestor === this;
        };
        /**
         * - Add IAnimatable instance.
         * @param value - The IAnimatable instance.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 添加 IAnimatable 实例。
         * @param value - IAnimatable 实例。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        WorldClock.prototype.add = function (value) {
            if (this._animatebles.indexOf(value) < 0) {
                this._animatebles.push(value);
                value.clock = this;
            }
        };
        /**
         * - Removes a specified IAnimatable instance.
         * @param value - The IAnimatable instance.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 移除特定的 IAnimatable 实例。
         * @param value - IAnimatable 实例。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        WorldClock.prototype.remove = function (value) {
            var index = this._animatebles.indexOf(value);
            if (index >= 0) {
                this._animatebles[index] = null;
                value.clock = null;
            }
        };
        /**
         * - Clear all IAnimatable instances.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 清除所有的 IAnimatable 实例。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        WorldClock.prototype.clear = function () {
            for (var _i = 0, _a = this._animatebles; _i < _a.length; _i++) {
                var animatable = _a[_i];
                if (animatable !== null) {
                    animatable.clock = null;
                }
            }
        };
        Object.defineProperty(WorldClock.prototype, "clock", {
            /**
             * @inheritDoc
             */
            get: function () {
                return this._clock;
            },
            set: function (value) {
                if (this._clock === value) {
                    return;
                }
                if (this._clock !== null) {
                    this._clock.remove(this);
                }
                this._clock = value;
                if (this._clock !== null) {
                    this._clock.add(this);
                }
            },
            enumerable: true,
            configurable: true
        });
        return WorldClock;
    }());
    dragonBones.WorldClock = WorldClock;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * - The animation player is used to play the animation data and manage the animation states.
     * @see dragonBones.AnimationData
     * @see dragonBones.AnimationState
     * @version DragonBones 3.0
     * @language en_US
     */
    /**
     * - 动画播放器用来播放动画数据和管理动画状态。
     * @see dragonBones.AnimationData
     * @see dragonBones.AnimationState
     * @version DragonBones 3.0
     * @language zh_CN
     */
    var Animation = /** @class */ (function (_super) {
        __extends(Animation, _super);
        function Animation() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._animationNames = [];
            _this._animationStates = [];
            _this._animations = {};
            _this._blendStates = {};
            _this._animationConfig = null; // Initial value.
            return _this;
        }
        Animation.toString = function () {
            return "[class dragonBones.Animation]";
        };
        Animation.prototype._onClear = function () {
            for (var _i = 0, _a = this._animationStates; _i < _a.length; _i++) {
                var animationState = _a[_i];
                animationState.returnToPool();
            }
            for (var k in this._animations) {
                delete this._animations[k];
            }
            for (var k in this._blendStates) {
                var blendStates = this._blendStates[k];
                for (var kB in blendStates) {
                    blendStates[kB].returnToPool();
                }
                delete this._blendStates[k];
            }
            if (this._animationConfig !== null) {
                this._animationConfig.returnToPool();
            }
            this.timeScale = 1.0;
            this._animationDirty = false;
            this._inheritTimeScale = 1.0;
            this._animationNames.length = 0;
            this._animationStates.length = 0;
            //this._animations.clear();
            this._armature = null; //
            this._animationConfig = null; //
            this._lastAnimationState = null;
        };
        Animation.prototype._fadeOut = function (animationConfig) {
            switch (animationConfig.fadeOutMode) {
                case 1 /* SameLayer */:
                    for (var _i = 0, _a = this._animationStates; _i < _a.length; _i++) {
                        var animationState = _a[_i];
                        if (animationState._parent !== null) {
                            continue;
                        }
                        if (animationState.layer === animationConfig.layer) {
                            animationState.fadeOut(animationConfig.fadeOutTime, animationConfig.pauseFadeOut);
                        }
                    }
                    break;
                case 2 /* SameGroup */:
                    for (var _b = 0, _c = this._animationStates; _b < _c.length; _b++) {
                        var animationState = _c[_b];
                        if (animationState._parent !== null) {
                            continue;
                        }
                        if (animationState.group === animationConfig.group) {
                            animationState.fadeOut(animationConfig.fadeOutTime, animationConfig.pauseFadeOut);
                        }
                    }
                    break;
                case 3 /* SameLayerAndGroup */:
                    for (var _d = 0, _e = this._animationStates; _d < _e.length; _d++) {
                        var animationState = _e[_d];
                        if (animationState._parent !== null) {
                            continue;
                        }
                        if (animationState.layer === animationConfig.layer &&
                            animationState.group === animationConfig.group) {
                            animationState.fadeOut(animationConfig.fadeOutTime, animationConfig.pauseFadeOut);
                        }
                    }
                    break;
                case 4 /* All */:
                    for (var _f = 0, _g = this._animationStates; _f < _g.length; _f++) {
                        var animationState = _g[_f];
                        if (animationState._parent !== null) {
                            continue;
                        }
                        animationState.fadeOut(animationConfig.fadeOutTime, animationConfig.pauseFadeOut);
                    }
                    break;
                case 5 /* Single */: // TODO
                default:
                    break;
            }
        };
        /**
         * @internal
         */
        Animation.prototype.init = function (armature) {
            if (this._armature !== null) {
                return;
            }
            this._armature = armature;
            this._animationConfig = dragonBones.BaseObject.borrowObject(dragonBones.AnimationConfig);
        };
        /**
         * @internal
         */
        Animation.prototype.advanceTime = function (passedTime) {
            if (passedTime < 0.0) { // Only animationState can reverse play.
                passedTime = -passedTime;
            }
            if (this._armature.inheritAnimation && this._armature._parent !== null) { // Inherit parent animation timeScale.
                this._inheritTimeScale = this._armature._parent._armature.animation._inheritTimeScale * this.timeScale;
            }
            else {
                this._inheritTimeScale = this.timeScale;
            }
            if (this._inheritTimeScale !== 1.0) {
                passedTime *= this._inheritTimeScale;
            }
            for (var k in this._blendStates) {
                var blendStates = this._blendStates[k];
                for (var kB in blendStates) {
                    blendStates[kB].reset();
                }
            }
            var animationStateCount = this._animationStates.length;
            if (animationStateCount === 1) {
                var animationState = this._animationStates[0];
                if (animationState._fadeState > 0 && animationState._subFadeState > 0) {
                    this._armature._dragonBones.bufferObject(animationState);
                    this._animationStates.length = 0;
                    this._lastAnimationState = null;
                }
                else {
                    var animationData = animationState.animationData;
                    var cacheFrameRate = animationData.cacheFrameRate;
                    if (this._animationDirty && cacheFrameRate > 0.0) { // Update cachedFrameIndices.
                        this._animationDirty = false;
                        for (var _i = 0, _a = this._armature.getBones(); _i < _a.length; _i++) {
                            var bone = _a[_i];
                            bone._cachedFrameIndices = animationData.getBoneCachedFrameIndices(bone.name);
                        }
                        for (var _b = 0, _c = this._armature.getSlots(); _b < _c.length; _b++) {
                            var slot = _c[_b];
                            if (slot.displayFrameCount > 0) {
                                var rawDisplayData = slot.getDisplayFrameAt(0).rawDisplayData;
                                if (rawDisplayData !== null &&
                                    rawDisplayData.parent === this._armature.armatureData.defaultSkin) {
                                    slot._cachedFrameIndices = animationData.getSlotCachedFrameIndices(slot.name);
                                    continue;
                                }
                            }
                            slot._cachedFrameIndices = null;
                        }
                    }
                    animationState.advanceTime(passedTime, cacheFrameRate);
                }
            }
            else if (animationStateCount > 1) {
                for (var i = 0, r = 0; i < animationStateCount; ++i) {
                    var animationState = this._animationStates[i];
                    if (animationState._fadeState > 0 && animationState._subFadeState > 0) {
                        r++;
                        this._armature._dragonBones.bufferObject(animationState);
                        this._animationDirty = true;
                        if (this._lastAnimationState === animationState) { // Update last animation state.
                            this._lastAnimationState = null;
                        }
                    }
                    else {
                        if (r > 0) {
                            this._animationStates[i - r] = animationState;
                        }
                        animationState.advanceTime(passedTime, 0.0);
                    }
                    if (i === animationStateCount - 1 && r > 0) { // Modify animation states size.
                        this._animationStates.length -= r;
                        if (this._lastAnimationState === null && this._animationStates.length > 0) {
                            this._lastAnimationState = this._animationStates[this._animationStates.length - 1];
                        }
                    }
                }
                this._armature._cacheFrameIndex = -1;
            }
            else {
                this._armature._cacheFrameIndex = -1;
            }
        };
        /**
         * - Clear all animations states.
         * @see dragonBones.AnimationState
         * @version DragonBones 4.5
         * @language en_US
         */
        /**
         * - 清除所有的动画状态。
         * @see dragonBones.AnimationState
         * @version DragonBones 4.5
         * @language zh_CN
         */
        Animation.prototype.reset = function () {
            for (var _i = 0, _a = this._animationStates; _i < _a.length; _i++) {
                var animationState = _a[_i];
                animationState.returnToPool();
            }
            this._animationDirty = false;
            this._animationConfig.clear();
            this._animationStates.length = 0;
            this._lastAnimationState = null;
        };
        /**
         * - Pause a specific animation state.
         * @param animationName - The name of animation state. (If not set, it will pause all animations)
         * @see dragonBones.AnimationState
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 暂停指定动画状态的播放。
         * @param animationName - 动画状态名称。 （如果未设置，则暂停所有动画）
         * @see dragonBones.AnimationState
         * @version DragonBones 3.0
         * @language zh_CN
         */
        Animation.prototype.stop = function (animationName) {
            if (animationName === void 0) { animationName = null; }
            if (animationName !== null) {
                var animationState = this.getState(animationName);
                if (animationState !== null) {
                    animationState.stop();
                }
            }
            else {
                for (var _i = 0, _a = this._animationStates; _i < _a.length; _i++) {
                    var animationState = _a[_i];
                    animationState.stop();
                }
            }
        };
        /**
         * - Play animation with a specific animation config.
         * The API is still in the experimental phase and may encounter bugs or stability or compatibility issues when used.
         * @param animationConfig - The animation config.
         * @returns The playing animation state.
         * @see dragonBones.AnimationConfig
         * @beta
         * @version DragonBones 5.0
         * @language en_US
         */
        /**
         * - 通过指定的动画配置来播放动画。
         * 该 API 仍在实验阶段，使用时可能遭遇 bug 或稳定性或兼容性问题。
         * @param animationConfig - 动画配置。
         * @returns 播放的动画状态。
         * @see dragonBones.AnimationConfig
         * @beta
         * @version DragonBones 5.0
         * @language zh_CN
         */
        Animation.prototype.playConfig = function (animationConfig) {
            var animationName = animationConfig.animation;
            if (!(animationName in this._animations)) {
                console.warn("Non-existent animation.\n", "DragonBones name: " + this._armature.armatureData.parent.name, "Armature name: " + this._armature.name, "Animation name: " + animationName);
                return null;
            }
            var animationData = this._animations[animationName];
            if (animationConfig.fadeOutMode === 5 /* Single */) {
                for (var _i = 0, _a = this._animationStates; _i < _a.length; _i++) {
                    var animationState_1 = _a[_i];
                    if (animationState_1._fadeState < 1 &&
                        animationState_1.layer === animationConfig.layer &&
                        animationState_1.animationData === animationData) {
                        return animationState_1;
                    }
                }
            }
            if (this._animationStates.length === 0) {
                animationConfig.fadeInTime = 0.0;
            }
            else if (animationConfig.fadeInTime < 0.0) {
                animationConfig.fadeInTime = animationData.fadeInTime;
            }
            if (animationConfig.fadeOutTime < 0.0) {
                animationConfig.fadeOutTime = animationConfig.fadeInTime;
            }
            if (animationConfig.timeScale <= -100.0) {
                animationConfig.timeScale = 1.0 / animationData.scale;
            }
            if (animationData.frameCount > 0) {
                if (animationConfig.position < 0.0) {
                    animationConfig.position %= animationData.duration;
                    animationConfig.position = animationData.duration - animationConfig.position;
                }
                else if (animationConfig.position === animationData.duration) {
                    animationConfig.position -= 0.000001; // Play a little time before end.
                }
                else if (animationConfig.position > animationData.duration) {
                    animationConfig.position %= animationData.duration;
                }
                if (animationConfig.duration > 0.0 && animationConfig.position + animationConfig.duration > animationData.duration) {
                    animationConfig.duration = animationData.duration - animationConfig.position;
                }
                if (animationConfig.playTimes < 0) {
                    animationConfig.playTimes = animationData.playTimes;
                }
            }
            else {
                animationConfig.playTimes = 1;
                animationConfig.position = 0.0;
                if (animationConfig.duration > 0.0) {
                    animationConfig.duration = 0.0;
                }
            }
            if (animationConfig.duration === 0.0) {
                animationConfig.duration = -1.0;
            }
            this._fadeOut(animationConfig);
            //
            var animationState = dragonBones.BaseObject.borrowObject(dragonBones.AnimationState);
            animationState.init(this._armature, animationData, animationConfig);
            this._animationDirty = true;
            this._armature._cacheFrameIndex = -1;
            if (this._animationStates.length > 0) { // Sort animation state.
                var added = false;
                for (var i = 0, l = this._animationStates.length; i < l; ++i) {
                    if (animationState.layer > this._animationStates[i].layer) {
                        added = true;
                        this._animationStates.splice(i, 0, animationState);
                        break;
                    }
                    else if (i !== l - 1 && animationState.layer > this._animationStates[i + 1].layer) {
                        added = true;
                        this._animationStates.splice(i + 1, 0, animationState);
                        break;
                    }
                }
                if (!added) {
                    this._animationStates.push(animationState);
                }
            }
            else {
                this._animationStates.push(animationState);
            }
            for (var _b = 0, _c = this._armature.getSlots(); _b < _c.length; _b++) { // Child armature play same name animation.
                var slot = _c[_b];
                var childArmature = slot.childArmature;
                if (childArmature !== null && childArmature.inheritAnimation &&
                    childArmature.animation.hasAnimation(animationName) &&
                    childArmature.animation.getState(animationName) === null) {
                    childArmature.animation.fadeIn(animationName); //
                }
            }
            for (var k in animationData.animationTimelines) { // Blend animation node.
                var childAnimationState = this.fadeIn(k, 0.0, 1, animationState.layer, "", 5 /* Single */);
                if (childAnimationState === null) {
                    continue;
                }
                var timelines = animationData.animationTimelines[k];
                childAnimationState.actionEnabled = false;
                childAnimationState.resetToPose = false;
                childAnimationState.stop();
                animationState.addState(childAnimationState, timelines);
                //
                var index = this._animationStates.indexOf(animationState);
                var childIndex = this._animationStates.indexOf(childAnimationState);
                if (childIndex < index) {
                    this._animationStates.splice(index, 1);
                    this._animationStates.splice(childIndex, 0, animationState);
                }
            }
            // if (!this._armature._lockUpdate && animationConfig.fadeInTime <= 0.0) { // Blend animation state, update armature.
            //     this._armature.advanceTime(0.0);
            // }
            this._lastAnimationState = animationState;
            return animationState;
        };
        /**
         * - Play a specific animation.
         * @param animationName - The name of animation data. (If not set, The default animation will be played, or resume the animation playing from pause status, or replay the last playing animation)
         * @param playTimes - Playing repeat times. [-1: Use default value of the animation data, 0: No end loop playing, [1~N]: Repeat N times] (default: -1)
         * @returns The playing animation state.
         * @example
         * <pre>
         *     armature.animation.play("walk");
         * </pre>
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 播放指定动画。
         * @param animationName - 动画数据名称。 （如果未设置，则播放默认动画，或将暂停状态切换为播放状态，或重新播放之前播放的动画）
         * @param playTimes - 循环播放次数。 [-1: 使用动画数据默认值, 0: 无限循环播放, [1~N]: 循环播放 N 次] （默认: -1）
         * @returns 播放的动画状态。
         * @example
         * <pre>
         *     armature.animation.play("walk");
         * </pre>
         * @version DragonBones 3.0
         * @language zh_CN
         */
        Animation.prototype.play = function (animationName, playTimes) {
            if (animationName === void 0) { animationName = null; }
            if (playTimes === void 0) { playTimes = -1; }
            this._animationConfig.clear();
            this._animationConfig.resetToPose = true;
            this._animationConfig.playTimes = playTimes;
            this._animationConfig.fadeInTime = 0.0;
            this._animationConfig.animation = animationName !== null ? animationName : "";
            if (animationName !== null && animationName.length > 0) {
                this.playConfig(this._animationConfig);
            }
            else if (this._lastAnimationState === null) {
                var defaultAnimation = this._armature.armatureData.defaultAnimation;
                if (defaultAnimation !== null) {
                    this._animationConfig.animation = defaultAnimation.name;
                    this.playConfig(this._animationConfig);
                }
            }
            else if (!this._lastAnimationState.isPlaying && !this._lastAnimationState.isCompleted) {
                this._lastAnimationState.play();
            }
            else {
                this._animationConfig.animation = this._lastAnimationState.name;
                this.playConfig(this._animationConfig);
            }
            return this._lastAnimationState;
        };
        /**
         * - Fade in a specific animation.
         * @param animationName - The name of animation data.
         * @param fadeInTime - The fade in time. [-1: Use the default value of animation data, [0~N]: The fade in time (In seconds)] (Default: -1)
         * @param playTimes - playing repeat times. [-1: Use the default value of animation data, 0: No end loop playing, [1~N]: Repeat N times] (Default: -1)
         * @param layer - The blending layer, the animation states in high level layer will get the blending weights with high priority, when the total blending weights are more than 1.0, there will be no more weights can be allocated to the other animation states. (Default: 0)
         * @param group - The blending group name, it is typically used to specify the substitution of multiple animation states blending. (Default: null)
         * @param fadeOutMode - The fade out mode, which is typically used to specify alternate mode of multiple animation states blending. (Default: AnimationFadeOutMode.SameLayerAndGroup)
         * @returns The playing animation state.
         * @example
         * <pre>
         *     armature.animation.fadeIn("walk", 0.3, 0, 0, "normalGroup").resetToPose = false;
         *     armature.animation.fadeIn("attack", 0.3, 1, 0, "attackGroup").resetToPose = false;
         * </pre>
         * @version DragonBones 4.5
         * @language en_US
         */
        /**
         * - 淡入播放指定的动画。
         * @param animationName - 动画数据名称。
         * @param fadeInTime - 淡入时间。 [-1: 使用动画数据默认值, [0~N]: 淡入时间 (以秒为单位)] （默认: -1）
         * @param playTimes - 播放次数。 [-1: 使用动画数据默认值, 0: 无限循环播放, [1~N]: 循环播放 N 次] （默认: -1）
         * @param layer - 混合图层，图层高的动画状态会优先获取混合权重，当混合权重分配总和超过 1.0 时，剩余的动画状态将不能再获得权重分配。 （默认: 0）
         * @param group - 混合组名称，该属性通常用来指定多个动画状态混合时的相互替换关系。 （默认: null）
         * @param fadeOutMode - 淡出模式，该属性通常用来指定多个动画状态混合时的相互替换模式。 （默认: AnimationFadeOutMode.SameLayerAndGroup）
         * @returns 播放的动画状态。
         * @example
         * <pre>
         *     armature.animation.fadeIn("walk", 0.3, 0, 0, "normalGroup").resetToPose = false;
         *     armature.animation.fadeIn("attack", 0.3, 1, 0, "attackGroup").resetToPose = false;
         * </pre>
         * @version DragonBones 4.5
         * @language zh_CN
         */
        Animation.prototype.fadeIn = function (animationName, fadeInTime, playTimes, layer, group, fadeOutMode) {
            if (fadeInTime === void 0) { fadeInTime = -1.0; }
            if (playTimes === void 0) { playTimes = -1; }
            if (layer === void 0) { layer = 0; }
            if (group === void 0) { group = null; }
            if (fadeOutMode === void 0) { fadeOutMode = 3 /* SameLayerAndGroup */; }
            this._animationConfig.clear();
            this._animationConfig.fadeOutMode = fadeOutMode;
            this._animationConfig.playTimes = playTimes;
            this._animationConfig.layer = layer;
            this._animationConfig.fadeInTime = fadeInTime;
            this._animationConfig.animation = animationName;
            this._animationConfig.group = group !== null ? group : "";
            return this.playConfig(this._animationConfig);
        };
        /**
         * - Play a specific animation from the specific time.
         * @param animationName - The name of animation data.
         * @param time - The start time point of playing. (In seconds)
         * @param playTimes - Playing repeat times. [-1: Use the default value of animation data, 0: No end loop playing, [1~N]: Repeat N times] (Default: -1)
         * @returns The played animation state.
         * @version DragonBones 4.5
         * @language en_US
         */
        /**
         * - 从指定时间开始播放指定的动画。
         * @param animationName - 动画数据名称。
         * @param time - 播放开始的时间。 (以秒为单位)
         * @param playTimes - 循环播放次数。 [-1: 使用动画数据默认值, 0: 无限循环播放, [1~N]: 循环播放 N 次] （默认: -1）
         * @returns 播放的动画状态。
         * @version DragonBones 4.5
         * @language zh_CN
         */
        Animation.prototype.gotoAndPlayByTime = function (animationName, time, playTimes) {
            if (time === void 0) { time = 0.0; }
            if (playTimes === void 0) { playTimes = -1; }
            this._animationConfig.clear();
            this._animationConfig.resetToPose = true;
            this._animationConfig.playTimes = playTimes;
            this._animationConfig.position = time;
            this._animationConfig.fadeInTime = 0.0;
            this._animationConfig.animation = animationName;
            return this.playConfig(this._animationConfig);
        };
        /**
         * - Play a specific animation from the specific frame.
         * @param animationName - The name of animation data.
         * @param frame - The start frame of playing.
         * @param playTimes - Playing repeat times. [-1: Use the default value of animation data, 0: No end loop playing, [1~N]: Repeat N times] (Default: -1)
         * @returns The played animation state.
         * @version DragonBones 4.5
         * @language en_US
         */
        /**
         * - 从指定帧开始播放指定的动画。
         * @param animationName - 动画数据名称。
         * @param frame - 播放开始的帧数。
         * @param playTimes - 播放次数。 [-1: 使用动画数据默认值, 0: 无限循环播放, [1~N]: 循环播放 N 次] （默认: -1）
         * @returns 播放的动画状态。
         * @version DragonBones 4.5
         * @language zh_CN
         */
        Animation.prototype.gotoAndPlayByFrame = function (animationName, frame, playTimes) {
            if (frame === void 0) { frame = 0; }
            if (playTimes === void 0) { playTimes = -1; }
            this._animationConfig.clear();
            this._animationConfig.resetToPose = true;
            this._animationConfig.playTimes = playTimes;
            this._animationConfig.fadeInTime = 0.0;
            this._animationConfig.animation = animationName;
            var animationData = animationName in this._animations ? this._animations[animationName] : null;
            if (animationData !== null) {
                this._animationConfig.position = animationData.frameCount > 0 ? animationData.duration * frame / animationData.frameCount : 0.0;
            }
            return this.playConfig(this._animationConfig);
        };
        /**
         * - Play a specific animation from the specific progress.
         * @param animationName - The name of animation data.
         * @param progress - The start progress value of playing.
         * @param playTimes - Playing repeat times. [-1: Use the default value of animation data, 0: No end loop playing, [1~N]: Repeat N times] (Default: -1)
         * @returns The played animation state.
         * @version DragonBones 4.5
         * @language en_US
         */
        /**
         * - 从指定进度开始播放指定的动画。
         * @param animationName - 动画数据名称。
         * @param progress - 开始播放的进度。
         * @param playTimes - 播放次数。 [-1: 使用动画数据默认值, 0: 无限循环播放, [1~N]: 循环播放 N 次] （默认: -1）
         * @returns 播放的动画状态。
         * @version DragonBones 4.5
         * @language zh_CN
         */
        Animation.prototype.gotoAndPlayByProgress = function (animationName, progress, playTimes) {
            if (progress === void 0) { progress = 0.0; }
            if (playTimes === void 0) { playTimes = -1; }
            this._animationConfig.clear();
            this._animationConfig.resetToPose = true;
            this._animationConfig.playTimes = playTimes;
            this._animationConfig.fadeInTime = 0.0;
            this._animationConfig.animation = animationName;
            var animationData = animationName in this._animations ? this._animations[animationName] : null;
            if (animationData !== null) {
                this._animationConfig.position = animationData.duration * (progress > 0.0 ? progress : 0.0);
            }
            return this.playConfig(this._animationConfig);
        };
        /**
         * - Stop a specific animation at the specific time.
         * @param animationName - The name of animation data.
         * @param time - The stop time. (In seconds)
         * @returns The played animation state.
         * @version DragonBones 4.5
         * @language en_US
         */
        /**
         * - 在指定时间停止指定动画播放
         * @param animationName - 动画数据名称。
         * @param time - 停止的时间。 (以秒为单位)
         * @returns 播放的动画状态。
         * @version DragonBones 4.5
         * @language zh_CN
         */
        Animation.prototype.gotoAndStopByTime = function (animationName, time) {
            if (time === void 0) { time = 0.0; }
            var animationState = this.gotoAndPlayByTime(animationName, time, 1);
            if (animationState !== null) {
                animationState.stop();
            }
            return animationState;
        };
        /**
         * - Stop a specific animation at the specific frame.
         * @param animationName - The name of animation data.
         * @param frame - The stop frame.
         * @returns The played animation state.
         * @version DragonBones 4.5
         * @language en_US
         */
        /**
         * - 在指定帧停止指定动画的播放
         * @param animationName - 动画数据名称。
         * @param frame - 停止的帧数。
         * @returns 播放的动画状态。
         * @version DragonBones 4.5
         * @language zh_CN
         */
        Animation.prototype.gotoAndStopByFrame = function (animationName, frame) {
            if (frame === void 0) { frame = 0; }
            var animationState = this.gotoAndPlayByFrame(animationName, frame, 1);
            if (animationState !== null) {
                animationState.stop();
            }
            return animationState;
        };
        /**
         * - Stop a specific animation at the specific progress.
         * @param animationName - The name of animation data.
         * @param progress - The stop progress value.
         * @returns The played animation state.
         * @version DragonBones 4.5
         * @language en_US
         */
        /**
         * - 在指定的进度停止指定的动画播放。
         * @param animationName - 动画数据名称。
         * @param progress - 停止进度。
         * @returns 播放的动画状态。
         * @version DragonBones 4.5
         * @language zh_CN
         */
        Animation.prototype.gotoAndStopByProgress = function (animationName, progress) {
            if (progress === void 0) { progress = 0.0; }
            var animationState = this.gotoAndPlayByProgress(animationName, progress, 1);
            if (animationState !== null) {
                animationState.stop();
            }
            return animationState;
        };
        /**
         * @internal
         */
        Animation.prototype.getBlendState = function (type, name, target) {
            if (!(type in this._blendStates)) {
                this._blendStates[type] = {};
            }
            var blendStates = this._blendStates[type];
            if (!(name in blendStates)) {
                var blendState = blendStates[name] = dragonBones.BaseObject.borrowObject(dragonBones.BlendState);
                blendState.target = target;
            }
            return blendStates[name];
        };
        /**
         * - Get a specific animation state.
         * @param animationName - The name of animation state.
         * @param layer - The layer of find animation states. [-1: Find all layers, [0~N]: Specified layer] (default: -1)
         * @example
         * <pre>
         *     armature.animation.play("walk");
         *     let walkState = armature.animation.getState("walk");
         *     walkState.timeScale = 0.5;
         * </pre>
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 获取指定的动画状态。
         * @param animationName - 动画状态名称。
         * @param layer - 查找动画状态的层级。 [-1: 查找所有层级, [0~N]: 指定层级] （默认: -1）
         * @example
         * <pre>
         *     armature.animation.play("walk");
         *     let walkState = armature.animation.getState("walk");
         *     walkState.timeScale = 0.5;
         * </pre>
         * @version DragonBones 3.0
         * @language zh_CN
         */
        Animation.prototype.getState = function (animationName, layer) {
            if (layer === void 0) { layer = -1; }
            var i = this._animationStates.length;
            while (i--) {
                var animationState = this._animationStates[i];
                if (animationState.name === animationName && (layer < 0 || animationState.layer === layer)) {
                    return animationState;
                }
            }
            return null;
        };
        /**
         * - Check whether a specific animation data is included.
         * @param animationName - The name of animation data.
         * @see dragonBones.AnimationData
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 检查是否包含指定的动画数据
         * @param animationName - 动画数据名称。
         * @see dragonBones.AnimationData
         * @version DragonBones 3.0
         * @language zh_CN
         */
        Animation.prototype.hasAnimation = function (animationName) {
            return animationName in this._animations;
        };
        /**
         * - Get all the animation states.
         * @version DragonBones 5.1
         * @language en_US
         */
        /**
         * - 获取所有的动画状态
         * @version DragonBones 5.1
         * @language zh_CN
         */
        Animation.prototype.getStates = function () {
            return this._animationStates;
        };
        Object.defineProperty(Animation.prototype, "isPlaying", {
            /**
             * - Check whether there is an animation state is playing
             * @see dragonBones.AnimationState
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 检查是否有动画状态正在播放
             * @see dragonBones.AnimationState
             * @version DragonBones 3.0
             * @language zh_CN
             */
            get: function () {
                for (var _i = 0, _a = this._animationStates; _i < _a.length; _i++) {
                    var animationState = _a[_i];
                    if (animationState.isPlaying) {
                        return true;
                    }
                }
                return false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Animation.prototype, "isCompleted", {
            /**
             * - Check whether all the animation states' playing were finished.
             * @see dragonBones.AnimationState
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 检查是否所有的动画状态均已播放完毕。
             * @see dragonBones.AnimationState
             * @version DragonBones 3.0
             * @language zh_CN
             */
            get: function () {
                for (var _i = 0, _a = this._animationStates; _i < _a.length; _i++) {
                    var animationState = _a[_i];
                    if (!animationState.isCompleted) {
                        return false;
                    }
                }
                return this._animationStates.length > 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Animation.prototype, "lastAnimationName", {
            /**
             * - The name of the last playing animation state.
             * @see #lastAnimationState
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 上一个播放的动画状态名称
             * @see #lastAnimationState
             * @version DragonBones 3.0
             * @language zh_CN
             */
            get: function () {
                return this._lastAnimationState !== null ? this._lastAnimationState.name : "";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Animation.prototype, "animationNames", {
            /**
             * - The name of all animation data
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 所有动画数据的名称
             * @version DragonBones 4.5
             * @language zh_CN
             */
            get: function () {
                return this._animationNames;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Animation.prototype, "animations", {
            /**
             * - All animation data.
             * @version DragonBones 4.5
             * @language en_US
             */
            /**
             * - 所有的动画数据。
             * @version DragonBones 4.5
             * @language zh_CN
             */
            get: function () {
                return this._animations;
            },
            set: function (value) {
                if (this._animations === value) {
                    return;
                }
                this._animationNames.length = 0;
                for (var k in this._animations) {
                    delete this._animations[k];
                }
                for (var k in value) {
                    this._animationNames.push(k);
                    this._animations[k] = value[k];
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Animation.prototype, "animationConfig", {
            /**
             * - An AnimationConfig instance that can be used quickly.
             * @see dragonBones.AnimationConfig
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 一个可以快速使用的动画配置实例。
             * @see dragonBones.AnimationConfig
             * @version DragonBones 5.0
             * @language zh_CN
             */
            get: function () {
                this._animationConfig.clear();
                return this._animationConfig;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Animation.prototype, "lastAnimationState", {
            /**
             * - The last playing animation state
             * @see dragonBones.AnimationState
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 上一个播放的动画状态
             * @see dragonBones.AnimationState
             * @version DragonBones 3.0
             * @language zh_CN
             */
            get: function () {
                return this._lastAnimationState;
            },
            enumerable: true,
            configurable: true
        });
        return Animation;
    }(dragonBones.BaseObject));
    dragonBones.Animation = Animation;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * - The animation state is generated when the animation data is played.
     * @see dragonBones.Animation
     * @see dragonBones.AnimationData
     * @version DragonBones 3.0
     * @language en_US
     */
    /**
     * - 动画状态由播放动画数据时产生。
     * @see dragonBones.Animation
     * @see dragonBones.AnimationData
     * @version DragonBones 3.0
     * @language zh_CN
     */
    var AnimationState = /** @class */ (function (_super) {
        __extends(AnimationState, _super);
        function AnimationState() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._boneMask = [];
            _this._boneTimelines = [];
            _this._boneBlendTimelines = [];
            _this._slotTimelines = [];
            _this._slotBlendTimelines = [];
            _this._constraintTimelines = [];
            _this._animationTimelines = [];
            _this._poseTimelines = [];
            /**
             * @internal
             */
            _this._actionTimeline = null; // Initial value.
            _this._zOrderTimeline = null; // Initial value.
            return _this;
        }
        AnimationState.toString = function () {
            return "[class dragonBones.AnimationState]";
        };
        AnimationState.prototype._onClear = function () {
            for (var _i = 0, _a = this._boneTimelines; _i < _a.length; _i++) {
                var timeline = _a[_i];
                timeline.returnToPool();
            }
            for (var _b = 0, _c = this._boneBlendTimelines; _b < _c.length; _b++) {
                var timeline = _c[_b];
                timeline.returnToPool();
            }
            for (var _d = 0, _e = this._slotTimelines; _d < _e.length; _d++) {
                var timeline = _e[_d];
                timeline.returnToPool();
            }
            for (var _f = 0, _g = this._slotBlendTimelines; _f < _g.length; _f++) {
                var timeline = _g[_f];
                timeline.returnToPool();
            }
            for (var _h = 0, _j = this._constraintTimelines; _h < _j.length; _h++) {
                var timeline = _j[_h];
                timeline.returnToPool();
            }
            for (var _k = 0, _l = this._animationTimelines; _k < _l.length; _k++) {
                var timeline = _l[_k];
                var animationState = timeline.target;
                if (animationState._parent === this) {
                    animationState._fadeState = 1;
                    animationState._subFadeState = 1;
                    animationState._parent = null;
                }
                timeline.returnToPool();
            }
            if (this._actionTimeline !== null) {
                this._actionTimeline.returnToPool();
            }
            if (this._zOrderTimeline !== null) {
                this._zOrderTimeline.returnToPool();
            }
            this.actionEnabled = false;
            this.additive = false;
            this.displayControl = false;
            this.resetToPose = false;
            this.blendType = 0 /* None */;
            this.playTimes = 1;
            this.layer = 0;
            this.timeScale = 1.0;
            this._weight = 1.0;
            this.parameterX = 0.0;
            this.parameterY = 0.0;
            this.positionX = 0.0;
            this.positionY = 0.0;
            this.autoFadeOutTime = 0.0;
            this.fadeTotalTime = 0.0;
            this.name = "";
            this.group = "";
            this._timelineDirty = 2;
            this._playheadState = 0;
            this._fadeState = -1;
            this._subFadeState = -1;
            this._position = 0.0;
            this._duration = 0.0;
            this._fadeTime = 0.0;
            this._time = 0.0;
            this._fadeProgress = 0.0;
            this._weightResult = 0.0;
            this._boneMask.length = 0;
            this._boneTimelines.length = 0;
            this._boneBlendTimelines.length = 0;
            this._slotTimelines.length = 0;
            this._slotBlendTimelines.length = 0;
            this._constraintTimelines.length = 0;
            this._animationTimelines.length = 0;
            this._poseTimelines.length = 0;
            // this._bonePoses.clear();
            this._animationData = null; //
            this._armature = null; //
            this._actionTimeline = null; //
            this._zOrderTimeline = null;
            this._activeChildA = null;
            this._activeChildB = null;
            this._parent = null;
        };
        AnimationState.prototype._updateTimelines = function () {
            { // Update constraint timelines.
                for (var _i = 0, _a = this._armature._constraints; _i < _a.length; _i++) {
                    var constraint = _a[_i];
                    var timelineDatas = this._animationData.getConstraintTimelines(constraint.name);
                    if (timelineDatas !== null) {
                        for (var _b = 0, timelineDatas_1 = timelineDatas; _b < timelineDatas_1.length; _b++) {
                            var timelineData = timelineDatas_1[_b];
                            switch (timelineData.type) {
                                case 30 /* IKConstraint */: {
                                    var timeline = dragonBones.BaseObject.borrowObject(dragonBones.IKConstraintTimelineState);
                                    timeline.target = constraint;
                                    timeline.init(this._armature, this, timelineData);
                                    this._constraintTimelines.push(timeline);
                                    break;
                                }
                                default:
                                    break;
                            }
                        }
                    }
                    else if (this.resetToPose) { // Pose timeline.
                        var timeline = dragonBones.BaseObject.borrowObject(dragonBones.IKConstraintTimelineState);
                        timeline.target = constraint;
                        timeline.init(this._armature, this, null);
                        this._constraintTimelines.push(timeline);
                        this._poseTimelines.push(timeline);
                    }
                }
            }
        };
        AnimationState.prototype._updateBoneAndSlotTimelines = function () {
            { // Update bone and surface timelines.
                var boneTimelines = {};
                // Create bone timelines map.
                for (var _i = 0, _a = this._boneTimelines; _i < _a.length; _i++) {
                    var timeline = _a[_i];
                    var timelineName = timeline.target.target.name;
                    if (!(timelineName in boneTimelines)) {
                        boneTimelines[timelineName] = [];
                    }
                    boneTimelines[timelineName].push(timeline);
                }
                for (var _b = 0, _c = this._boneBlendTimelines; _b < _c.length; _b++) {
                    var timeline = _c[_b];
                    var timelineName = timeline.target.target.name;
                    if (!(timelineName in boneTimelines)) {
                        boneTimelines[timelineName] = [];
                    }
                    boneTimelines[timelineName].push(timeline);
                }
                //
                for (var _d = 0, _e = this._armature.getBones(); _d < _e.length; _d++) {
                    var bone = _e[_d];
                    var timelineName = bone.name;
                    if (!this.containsBoneMask(timelineName)) {
                        continue;
                    }
                    if (timelineName in boneTimelines) { // Remove bone timeline from map.
                        delete boneTimelines[timelineName];
                    }
                    else { // Create new bone timeline.
                        var timelineDatas = this._animationData.getBoneTimelines(timelineName);
                        var blendState = this._armature.animation.getBlendState(BlendState.BONE_TRANSFORM, bone.name, bone);
                        if (timelineDatas !== null) {
                            for (var _f = 0, timelineDatas_2 = timelineDatas; _f < timelineDatas_2.length; _f++) {
                                var timelineData = timelineDatas_2[_f];
                                switch (timelineData.type) {
                                    case 10 /* BoneAll */: {
                                        var timeline = dragonBones.BaseObject.borrowObject(dragonBones.BoneAllTimelineState);
                                        timeline.target = blendState;
                                        timeline.init(this._armature, this, timelineData);
                                        this._boneTimelines.push(timeline);
                                        break;
                                    }
                                    case 11 /* BoneTranslate */: {
                                        var timeline = dragonBones.BaseObject.borrowObject(dragonBones.BoneTranslateTimelineState);
                                        timeline.target = blendState;
                                        timeline.init(this._armature, this, timelineData);
                                        this._boneTimelines.push(timeline);
                                        break;
                                    }
                                    case 12 /* BoneRotate */: {
                                        var timeline = dragonBones.BaseObject.borrowObject(dragonBones.BoneRotateTimelineState);
                                        timeline.target = blendState;
                                        timeline.init(this._armature, this, timelineData);
                                        this._boneTimelines.push(timeline);
                                        break;
                                    }
                                    case 13 /* BoneScale */: {
                                        var timeline = dragonBones.BaseObject.borrowObject(dragonBones.BoneScaleTimelineState);
                                        timeline.target = blendState;
                                        timeline.init(this._armature, this, timelineData);
                                        this._boneTimelines.push(timeline);
                                        break;
                                    }
                                    case 60 /* BoneAlpha */: {
                                        var timeline = dragonBones.BaseObject.borrowObject(dragonBones.AlphaTimelineState);
                                        timeline.target = this._armature.animation.getBlendState(BlendState.BONE_ALPHA, bone.name, bone);
                                        timeline.init(this._armature, this, timelineData);
                                        this._boneBlendTimelines.push(timeline);
                                        break;
                                    }
                                    case 50 /* Surface */: {
                                        var timeline = dragonBones.BaseObject.borrowObject(dragonBones.SurfaceTimelineState);
                                        timeline.target = this._armature.animation.getBlendState(BlendState.SURFACE, bone.name, bone);
                                        timeline.init(this._armature, this, timelineData);
                                        this._boneBlendTimelines.push(timeline);
                                        break;
                                    }
                                    default:
                                        break;
                                }
                            }
                        }
                        else if (this.resetToPose) { // Pose timeline.
                            if (bone._boneData.type === 0 /* Bone */) {
                                var timeline = dragonBones.BaseObject.borrowObject(dragonBones.BoneAllTimelineState);
                                timeline.target = blendState;
                                timeline.init(this._armature, this, null);
                                this._boneTimelines.push(timeline);
                                this._poseTimelines.push(timeline);
                            }
                            else {
                                var timeline = dragonBones.BaseObject.borrowObject(dragonBones.SurfaceTimelineState);
                                timeline.target = this._armature.animation.getBlendState(BlendState.SURFACE, bone.name, bone);
                                timeline.init(this._armature, this, null);
                                this._boneBlendTimelines.push(timeline);
                                this._poseTimelines.push(timeline);
                            }
                        }
                    }
                }
                for (var k in boneTimelines) { // Remove bone timelines.
                    for (var _g = 0, _h = boneTimelines[k]; _g < _h.length; _g++) {
                        var timeline = _h[_g];
                        var index = this._boneTimelines.indexOf(timeline);
                        if (index >= 0) {
                            this._boneTimelines.splice(index, 1);
                            timeline.returnToPool();
                        }
                        index = this._boneBlendTimelines.indexOf(timeline);
                        if (index >= 0) {
                            this._boneBlendTimelines.splice(index, 1);
                            timeline.returnToPool();
                        }
                    }
                }
            }
            { // Update slot timelines.
                var slotTimelines = {};
                var ffdFlags = [];
                // Create slot timelines map.
                for (var _j = 0, _k = this._slotTimelines; _j < _k.length; _j++) {
                    var timeline = _k[_j];
                    var timelineName = timeline.target.name;
                    if (!(timelineName in slotTimelines)) {
                        slotTimelines[timelineName] = [];
                    }
                    slotTimelines[timelineName].push(timeline);
                }
                for (var _l = 0, _m = this._slotBlendTimelines; _l < _m.length; _l++) {
                    var timeline = _m[_l];
                    var timelineName = timeline.target.target.name;
                    if (!(timelineName in slotTimelines)) {
                        slotTimelines[timelineName] = [];
                    }
                    slotTimelines[timelineName].push(timeline);
                }
                //
                for (var _o = 0, _p = this._armature.getSlots(); _o < _p.length; _o++) {
                    var slot = _p[_o];
                    var boneName = slot.parent.name;
                    if (!this.containsBoneMask(boneName)) {
                        continue;
                    }
                    var timelineName = slot.name;
                    if (timelineName in slotTimelines) { // Remove slot timeline from map.
                        delete slotTimelines[timelineName];
                    }
                    else { // Create new slot timeline.
                        var displayIndexFlag = false;
                        var colorFlag = false;
                        ffdFlags.length = 0;
                        var timelineDatas = this._animationData.getSlotTimelines(timelineName);
                        if (timelineDatas !== null) {
                            for (var _q = 0, timelineDatas_3 = timelineDatas; _q < timelineDatas_3.length; _q++) {
                                var timelineData = timelineDatas_3[_q];
                                switch (timelineData.type) {
                                    case 20 /* SlotDisplay */: {
                                        var timeline = dragonBones.BaseObject.borrowObject(dragonBones.SlotDisplayTimelineState);
                                        timeline.target = slot;
                                        timeline.init(this._armature, this, timelineData);
                                        this._slotTimelines.push(timeline);
                                        displayIndexFlag = true;
                                        break;
                                    }
                                    case 23 /* SlotZIndex */: {
                                        var timeline = dragonBones.BaseObject.borrowObject(dragonBones.SlotZIndexTimelineState);
                                        timeline.target = this._armature.animation.getBlendState(BlendState.SLOT_Z_INDEX, slot.name, slot);
                                        timeline.init(this._armature, this, timelineData);
                                        this._slotBlendTimelines.push(timeline);
                                        break;
                                    }
                                    case 21 /* SlotColor */: {
                                        var timeline = dragonBones.BaseObject.borrowObject(dragonBones.SlotColorTimelineState);
                                        timeline.target = slot;
                                        timeline.init(this._armature, this, timelineData);
                                        this._slotTimelines.push(timeline);
                                        colorFlag = true;
                                        break;
                                    }
                                    case 22 /* SlotDeform */: {
                                        var dragonBonesData = this._animationData.parent.parent;
                                        var timelineArray = dragonBonesData.timelineArray;
                                        var frameIntOffset = this._animationData.frameIntOffset + timelineArray[timelineData.offset + 3 /* TimelineFrameValueCount */];
                                        var frameIntArray = dragonBonesData.frameIntArray;
                                        var geometryOffset = frameIntArray[frameIntOffset + 0 /* DeformVertexOffset */];
                                        if (geometryOffset < 0) {
                                            geometryOffset += 65536; // Fixed out of bounds bug. 
                                        }
                                        for (var i = 0, l = slot.displayFrameCount; i < l; ++i) {
                                            var displayFrame = slot.getDisplayFrameAt(i);
                                            var geometryData = displayFrame.getGeometryData();
                                            if (geometryData === null) {
                                                continue;
                                            }
                                            if (geometryData.offset === geometryOffset) {
                                                var timeline = dragonBones.BaseObject.borrowObject(dragonBones.DeformTimelineState);
                                                timeline.target = this._armature.animation.getBlendState(BlendState.SLOT_DEFORM, displayFrame.rawDisplayData.name, slot);
                                                timeline.displayFrame = displayFrame;
                                                timeline.init(this._armature, this, timelineData);
                                                this._slotBlendTimelines.push(timeline);
                                                displayFrame.updateDeformVertices();
                                                ffdFlags.push(geometryOffset);
                                                break;
                                            }
                                        }
                                        break;
                                    }
                                    case 24 /* SlotAlpha */: {
                                        var timeline = dragonBones.BaseObject.borrowObject(dragonBones.AlphaTimelineState);
                                        timeline.target = this._armature.animation.getBlendState(BlendState.SLOT_ALPHA, slot.name, slot);
                                        timeline.init(this._armature, this, timelineData);
                                        this._slotBlendTimelines.push(timeline);
                                        break;
                                    }
                                    default:
                                        break;
                                }
                            }
                        }
                        if (this.resetToPose) { // Pose timeline.
                            if (!displayIndexFlag) {
                                var timeline = dragonBones.BaseObject.borrowObject(dragonBones.SlotDisplayTimelineState);
                                timeline.target = slot;
                                timeline.init(this._armature, this, null);
                                this._slotTimelines.push(timeline);
                                this._poseTimelines.push(timeline);
                            }
                            if (!colorFlag) {
                                var timeline = dragonBones.BaseObject.borrowObject(dragonBones.SlotColorTimelineState);
                                timeline.target = slot;
                                timeline.init(this._armature, this, null);
                                this._slotTimelines.push(timeline);
                                this._poseTimelines.push(timeline);
                            }
                            for (var i = 0, l = slot.displayFrameCount; i < l; ++i) {
                                var displayFrame = slot.getDisplayFrameAt(i);
                                if (displayFrame.deformVertices.length === 0) {
                                    continue;
                                }
                                var geometryData = displayFrame.getGeometryData();
                                if (geometryData !== null && ffdFlags.indexOf(geometryData.offset) < 0) {
                                    var timeline = dragonBones.BaseObject.borrowObject(dragonBones.DeformTimelineState);
                                    timeline.displayFrame = displayFrame; //
                                    timeline.target = this._armature.animation.getBlendState(BlendState.SLOT_DEFORM, slot.name, slot);
                                    timeline.init(this._armature, this, null);
                                    this._slotBlendTimelines.push(timeline);
                                    this._poseTimelines.push(timeline);
                                }
                            }
                        }
                    }
                }
                for (var k in slotTimelines) { // Remove slot timelines.
                    for (var _r = 0, _s = slotTimelines[k]; _r < _s.length; _r++) {
                        var timeline = _s[_r];
                        var index = this._slotTimelines.indexOf(timeline);
                        if (index >= 0) {
                            this._slotTimelines.splice(index, 1);
                            timeline.returnToPool();
                        }
                        index = this._slotBlendTimelines.indexOf(timeline);
                        if (index >= 0) {
                            this._slotBlendTimelines.splice(index, 1);
                            timeline.returnToPool();
                        }
                    }
                }
            }
        };
        AnimationState.prototype._advanceFadeTime = function (passedTime) {
            var isFadeOut = this._fadeState > 0;
            if (this._subFadeState < 0) { // Fade start event.
                this._subFadeState = 0;
                var eventActive = this._parent === null && this.actionEnabled;
                if (eventActive) {
                    var eventType = isFadeOut ? dragonBones.EventObject.FADE_OUT : dragonBones.EventObject.FADE_IN;
                    if (this._armature.eventDispatcher.hasDBEventListener(eventType)) {
                        var eventObject = dragonBones.BaseObject.borrowObject(dragonBones.EventObject);
                        eventObject.type = eventType;
                        eventObject.armature = this._armature;
                        eventObject.animationState = this;
                        this._armature._dragonBones.bufferEvent(eventObject);
                    }
                }
            }
            if (passedTime < 0.0) {
                passedTime = -passedTime;
            }
            this._fadeTime += passedTime;
            if (this._fadeTime >= this.fadeTotalTime) { // Fade complete.
                this._subFadeState = 1;
                this._fadeProgress = isFadeOut ? 0.0 : 1.0;
            }
            else if (this._fadeTime > 0.0) { // Fading.
                this._fadeProgress = isFadeOut ? (1.0 - this._fadeTime / this.fadeTotalTime) : (this._fadeTime / this.fadeTotalTime);
            }
            else { // Before fade.
                this._fadeProgress = isFadeOut ? 1.0 : 0.0;
            }
            if (this._subFadeState > 0) { // Fade complete event.
                if (!isFadeOut) {
                    this._playheadState |= 1; // x1
                    this._fadeState = 0;
                }
                var eventActive = this._parent === null && this.actionEnabled;
                if (eventActive) {
                    var eventType = isFadeOut ? dragonBones.EventObject.FADE_OUT_COMPLETE : dragonBones.EventObject.FADE_IN_COMPLETE;
                    if (this._armature.eventDispatcher.hasDBEventListener(eventType)) {
                        var eventObject = dragonBones.BaseObject.borrowObject(dragonBones.EventObject);
                        eventObject.type = eventType;
                        eventObject.armature = this._armature;
                        eventObject.animationState = this;
                        this._armature._dragonBones.bufferEvent(eventObject);
                    }
                }
            }
        };
        /**
         * @internal
         */
        AnimationState.prototype.init = function (armature, animationData, animationConfig) {
            if (this._armature !== null) {
                return;
            }
            this._armature = armature;
            this._animationData = animationData;
            //
            this.resetToPose = animationConfig.resetToPose;
            this.additive = animationConfig.additive;
            this.displayControl = animationConfig.displayControl;
            this.actionEnabled = animationConfig.actionEnabled;
            this.blendType = animationData.blendType;
            this.layer = animationConfig.layer;
            this.playTimes = animationConfig.playTimes;
            this.timeScale = animationConfig.timeScale;
            this.fadeTotalTime = animationConfig.fadeInTime;
            this.autoFadeOutTime = animationConfig.autoFadeOutTime;
            this.name = animationConfig.name.length > 0 ? animationConfig.name : animationConfig.animation;
            this.group = animationConfig.group;
            //
            this._weight = animationConfig.weight;
            if (animationConfig.pauseFadeIn) {
                this._playheadState = 2; // 10
            }
            else {
                this._playheadState = 3; // 11
            }
            if (animationConfig.duration < 0.0) {
                this._position = 0.0;
                this._duration = this._animationData.duration;
                if (animationConfig.position !== 0.0) {
                    if (this.timeScale >= 0.0) {
                        this._time = animationConfig.position;
                    }
                    else {
                        this._time = animationConfig.position - this._duration;
                    }
                }
                else {
                    this._time = 0.0;
                }
            }
            else {
                this._position = animationConfig.position;
                this._duration = animationConfig.duration;
                this._time = 0.0;
            }
            if (this.timeScale < 0.0 && this._time === 0.0) {
                this._time = -0.000001; // Turn to end.
            }
            if (this.fadeTotalTime <= 0.0) {
                this._fadeProgress = 0.999999; // Make different.
            }
            if (animationConfig.boneMask.length > 0) {
                this._boneMask.length = animationConfig.boneMask.length;
                for (var i = 0, l = this._boneMask.length; i < l; ++i) {
                    this._boneMask[i] = animationConfig.boneMask[i];
                }
            }
            this._actionTimeline = dragonBones.BaseObject.borrowObject(dragonBones.ActionTimelineState);
            this._actionTimeline.init(this._armature, this, this._animationData.actionTimeline);
            this._actionTimeline.currentTime = this._time;
            if (this._actionTimeline.currentTime < 0.0) {
                this._actionTimeline.currentTime = this._duration - this._actionTimeline.currentTime;
            }
            if (this._animationData.zOrderTimeline !== null) {
                this._zOrderTimeline = dragonBones.BaseObject.borrowObject(dragonBones.ZOrderTimelineState);
                this._zOrderTimeline.init(this._armature, this, this._animationData.zOrderTimeline);
            }
        };
        /**
         * @internal
         */
        AnimationState.prototype.advanceTime = function (passedTime, cacheFrameRate) {
            // Update fade time.
            if (this._fadeState !== 0 || this._subFadeState !== 0) {
                this._advanceFadeTime(passedTime);
            }
            // Update time.
            if (this._playheadState === 3) { // 11
                if (this.timeScale !== 1.0) {
                    passedTime *= this.timeScale;
                }
                this._time += passedTime;
            }
            // Update timeline.
            if (this._timelineDirty !== 0) {
                if (this._timelineDirty === 2) {
                    this._updateTimelines();
                }
                this._timelineDirty = 0;
                this._updateBoneAndSlotTimelines();
            }
            var isBlendDirty = this._fadeState !== 0 || this._subFadeState === 0;
            var isCacheEnabled = this._fadeState === 0 && cacheFrameRate > 0.0;
            var isUpdateTimeline = true;
            var isUpdateBoneTimeline = true;
            var time = this._time;
            this._weightResult = this._weight * this._fadeProgress;
            if (this._parent !== null) {
                this._weightResult *= this._parent._weightResult;
            }
            if (this._actionTimeline.playState <= 0) { // Update main timeline.
                this._actionTimeline.update(time);
            }
            if (this._weight === 0.0) {
                return;
            }
            if (isCacheEnabled) { // Cache time internval.
                var internval = cacheFrameRate * 2.0;
                this._actionTimeline.currentTime = Math.floor(this._actionTimeline.currentTime * internval) / internval;
            }
            if (this._zOrderTimeline !== null && this._zOrderTimeline.playState <= 0) { // Update zOrder timeline.
                this._zOrderTimeline.update(time);
            }
            if (isCacheEnabled) { // Update cache.
                var cacheFrameIndex = Math.floor(this._actionTimeline.currentTime * cacheFrameRate); // uint
                if (this._armature._cacheFrameIndex === cacheFrameIndex) { // Same cache.
                    isUpdateTimeline = false;
                    isUpdateBoneTimeline = false;
                }
                else {
                    this._armature._cacheFrameIndex = cacheFrameIndex;
                    if (this._animationData.cachedFrames[cacheFrameIndex]) { // Cached.
                        isUpdateBoneTimeline = false;
                    }
                    else { // Cache.
                        this._animationData.cachedFrames[cacheFrameIndex] = true;
                    }
                }
            }
            if (isUpdateTimeline) {
                var isBlend = false;
                var prevTarget = null; //
                if (isUpdateBoneTimeline) {
                    for (var i = 0, l = this._boneTimelines.length; i < l; ++i) {
                        var timeline = this._boneTimelines[i];
                        if (timeline.playState <= 0) {
                            timeline.update(time);
                        }
                        if (timeline.target !== prevTarget) {
                            var blendState = timeline.target;
                            isBlend = blendState.update(this);
                            prevTarget = blendState;
                            if (blendState.dirty === 1) {
                                var pose = blendState.target.animationPose;
                                pose.x = 0.0;
                                pose.y = 0.0;
                                pose.rotation = 0.0;
                                pose.skew = 0.0;
                                pose.scaleX = 1.0;
                                pose.scaleY = 1.0;
                            }
                        }
                        if (isBlend) {
                            timeline.blend(isBlendDirty);
                        }
                    }
                }
                for (var i = 0, l = this._boneBlendTimelines.length; i < l; ++i) {
                    var timeline = this._boneBlendTimelines[i];
                    if (timeline.playState <= 0) {
                        timeline.update(time);
                    }
                    if (timeline.target.update(this)) {
                        timeline.blend(isBlendDirty);
                    }
                }
                if (this.displayControl) {
                    for (var i = 0, l = this._slotTimelines.length; i < l; ++i) {
                        var timeline = this._slotTimelines[i];
                        if (timeline.playState <= 0) {
                            var slot = timeline.target;
                            var displayController = slot.displayController;
                            if (displayController === null ||
                                displayController === this.name ||
                                displayController === this.group) {
                                timeline.update(time);
                            }
                        }
                    }
                }
                for (var i = 0, l = this._slotBlendTimelines.length; i < l; ++i) {
                    var timeline = this._slotBlendTimelines[i];
                    if (timeline.playState <= 0) {
                        var blendState = timeline.target;
                        timeline.update(time);
                        if (blendState.update(this)) {
                            timeline.blend(isBlendDirty);
                        }
                    }
                }
                for (var i = 0, l = this._constraintTimelines.length; i < l; ++i) {
                    var timeline = this._constraintTimelines[i];
                    if (timeline.playState <= 0) {
                        timeline.update(time);
                    }
                }
                if (this._animationTimelines.length > 0) {
                    var dL = 100.0;
                    var dR = 100.0;
                    var leftState = null;
                    var rightState = null;
                    for (var i = 0, l = this._animationTimelines.length; i < l; ++i) {
                        var timeline = this._animationTimelines[i];
                        if (timeline.playState <= 0) {
                            timeline.update(time);
                        }
                        if (this.blendType === 1 /* E1D */) { // TODO
                            var animationState = timeline.target;
                            var d = this.parameterX - animationState.positionX;
                            if (d >= 0.0) {
                                if (d < dL) {
                                    dL = d;
                                    leftState = animationState;
                                }
                            }
                            else {
                                if (-d < dR) {
                                    dR = -d;
                                    rightState = animationState;
                                }
                            }
                        }
                    }
                    if (leftState !== null) {
                        if (this._activeChildA !== leftState) {
                            if (this._activeChildA !== null) {
                                this._activeChildA.weight = 0.0;
                            }
                            this._activeChildA = leftState;
                            this._activeChildA.activeTimeline();
                        }
                        if (this._activeChildB !== rightState) {
                            if (this._activeChildB !== null) {
                                this._activeChildB.weight = 0.0;
                            }
                            this._activeChildB = rightState;
                        }
                        leftState.weight = dR / (dL + dR);
                        if (rightState) {
                            rightState.weight = 1.0 - leftState.weight;
                        }
                    }
                }
            }
            if (this._fadeState === 0) {
                if (this._subFadeState > 0) {
                    this._subFadeState = 0;
                    if (this._poseTimelines.length > 0) { // Remove pose timelines.
                        for (var _i = 0, _a = this._poseTimelines; _i < _a.length; _i++) {
                            var timeline = _a[_i];
                            var index = this._boneTimelines.indexOf(timeline);
                            if (index >= 0) {
                                this._boneTimelines.splice(index, 1);
                                timeline.returnToPool();
                                continue;
                            }
                            index = this._boneBlendTimelines.indexOf(timeline);
                            if (index >= 0) {
                                this._boneBlendTimelines.splice(index, 1);
                                timeline.returnToPool();
                                continue;
                            }
                            index = this._slotTimelines.indexOf(timeline);
                            if (index >= 0) {
                                this._slotTimelines.splice(index, 1);
                                timeline.returnToPool();
                                continue;
                            }
                            index = this._slotBlendTimelines.indexOf(timeline);
                            if (index >= 0) {
                                this._slotBlendTimelines.splice(index, 1);
                                timeline.returnToPool();
                                continue;
                            }
                            index = this._constraintTimelines.indexOf(timeline);
                            if (index >= 0) {
                                this._constraintTimelines.splice(index, 1);
                                timeline.returnToPool();
                                continue;
                            }
                        }
                        this._poseTimelines.length = 0;
                    }
                }
                if (this._actionTimeline.playState > 0) {
                    if (this.autoFadeOutTime >= 0.0) { // Auto fade out.
                        this.fadeOut(this.autoFadeOutTime);
                    }
                }
            }
        };
        /**
         * - Continue play.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 继续播放。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        AnimationState.prototype.play = function () {
            this._playheadState = 3; // 11
        };
        /**
         * - Stop play.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 暂停播放。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        AnimationState.prototype.stop = function () {
            this._playheadState &= 1; // 0x
        };
        /**
         * - Fade out the animation state.
         * @param fadeOutTime - The fade out time. (In seconds)
         * @param pausePlayhead - Whether to pause the animation playing when fade out.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 淡出动画状态。
         * @param fadeOutTime - 淡出时间。 （以秒为单位）
         * @param pausePlayhead - 淡出时是否暂停播放。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        AnimationState.prototype.fadeOut = function (fadeOutTime, pausePlayhead) {
            if (pausePlayhead === void 0) { pausePlayhead = true; }
            if (fadeOutTime < 0.0) {
                fadeOutTime = 0.0;
            }
            if (pausePlayhead) {
                this._playheadState &= 2; // x0
            }
            if (this._fadeState > 0) {
                if (fadeOutTime > this.fadeTotalTime - this._fadeTime) { // If the animation is already in fade out, the new fade out will be ignored.
                    return;
                }
            }
            else {
                this._fadeState = 1;
                this._subFadeState = -1;
                if (fadeOutTime <= 0.0 || this._fadeProgress <= 0.0) {
                    this._fadeProgress = 0.000001; // Modify fade progress to different value.
                }
                for (var _i = 0, _a = this._boneTimelines; _i < _a.length; _i++) {
                    var timeline = _a[_i];
                    timeline.fadeOut();
                }
                for (var _b = 0, _c = this._boneBlendTimelines; _b < _c.length; _b++) {
                    var timeline = _c[_b];
                    timeline.fadeOut();
                }
                for (var _d = 0, _e = this._slotTimelines; _d < _e.length; _d++) {
                    var timeline = _e[_d];
                    timeline.fadeOut();
                }
                for (var _f = 0, _g = this._slotBlendTimelines; _f < _g.length; _f++) {
                    var timeline = _g[_f];
                    timeline.fadeOut();
                }
                for (var _h = 0, _j = this._constraintTimelines; _h < _j.length; _h++) {
                    var timeline = _j[_h];
                    timeline.fadeOut();
                }
                for (var _k = 0, _l = this._animationTimelines; _k < _l.length; _k++) {
                    var timeline = _l[_k];
                    timeline.fadeOut();
                    //
                    var animaitonState = timeline.target;
                    animaitonState.fadeOut(999999.0, true);
                }
            }
            this.displayControl = false; //
            this.fadeTotalTime = this._fadeProgress > 0.000001 ? fadeOutTime / this._fadeProgress : 0.0;
            this._fadeTime = this.fadeTotalTime * (1.0 - this._fadeProgress);
        };
        /**
         * - Check if a specific bone mask is included.
         * @param boneName - The bone name.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 检查是否包含特定骨骼遮罩。
         * @param boneName - 骨骼名称。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        AnimationState.prototype.containsBoneMask = function (boneName) {
            return this._boneMask.length === 0 || this._boneMask.indexOf(boneName) >= 0;
        };
        /**
         * - Add a specific bone mask.
         * @param boneName - The bone name.
         * @param recursive - Whether or not to add a mask to the bone's sub-bone.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 添加特定的骨骼遮罩。
         * @param boneName - 骨骼名称。
         * @param recursive - 是否为该骨骼的子骨骼添加遮罩。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        AnimationState.prototype.addBoneMask = function (boneName, recursive) {
            if (recursive === void 0) { recursive = true; }
            var currentBone = this._armature.getBone(boneName);
            if (currentBone === null) {
                return;
            }
            if (this._boneMask.indexOf(boneName) < 0) { // Add mixing
                this._boneMask.push(boneName);
            }
            if (recursive) { // Add recursive mixing.
                for (var _i = 0, _a = this._armature.getBones(); _i < _a.length; _i++) {
                    var bone = _a[_i];
                    if (this._boneMask.indexOf(bone.name) < 0 && currentBone.contains(bone)) {
                        this._boneMask.push(bone.name);
                    }
                }
            }
            this._timelineDirty = 1;
        };
        /**
         * - Remove the mask of a specific bone.
         * @param boneName - The bone name.
         * @param recursive - Whether to remove the bone's sub-bone mask.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 删除特定骨骼的遮罩。
         * @param boneName - 骨骼名称。
         * @param recursive - 是否删除该骨骼的子骨骼遮罩。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        AnimationState.prototype.removeBoneMask = function (boneName, recursive) {
            if (recursive === void 0) { recursive = true; }
            var index = this._boneMask.indexOf(boneName);
            if (index >= 0) { // Remove mixing.
                this._boneMask.splice(index, 1);
            }
            if (recursive) {
                var currentBone = this._armature.getBone(boneName);
                if (currentBone !== null) {
                    var bones = this._armature.getBones();
                    if (this._boneMask.length > 0) { // Remove recursive mixing.
                        for (var _i = 0, bones_1 = bones; _i < bones_1.length; _i++) {
                            var bone = bones_1[_i];
                            var index_1 = this._boneMask.indexOf(bone.name);
                            if (index_1 >= 0 && currentBone.contains(bone)) {
                                this._boneMask.splice(index_1, 1);
                            }
                        }
                    }
                    else { // Add unrecursive mixing.
                        for (var _a = 0, bones_2 = bones; _a < bones_2.length; _a++) {
                            var bone = bones_2[_a];
                            if (bone === currentBone) {
                                continue;
                            }
                            if (!currentBone.contains(bone)) {
                                this._boneMask.push(bone.name);
                            }
                        }
                    }
                }
            }
            this._timelineDirty = 1;
        };
        /**
         * - Remove all bone masks.
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 删除所有骨骼遮罩。
         * @version DragonBones 3.0
         * @language zh_CN
         */
        AnimationState.prototype.removeAllBoneMask = function () {
            this._boneMask.length = 0;
            this._timelineDirty = 1;
        };
        /**
         * @private
         */
        AnimationState.prototype.addState = function (animationState, timelineDatas) {
            if (timelineDatas === void 0) { timelineDatas = null; }
            if (timelineDatas !== null) {
                for (var _i = 0, timelineDatas_4 = timelineDatas; _i < timelineDatas_4.length; _i++) {
                    var timelineData = timelineDatas_4[_i];
                    switch (timelineData.type) {
                        case 40 /* AnimationProgress */: {
                            var timeline = dragonBones.BaseObject.borrowObject(dragonBones.AnimationProgressTimelineState);
                            timeline.target = animationState;
                            timeline.init(this._armature, this, timelineData);
                            this._animationTimelines.push(timeline);
                            if (this.blendType !== 0 /* None */) {
                                var animaitonTimelineData = timelineData;
                                animationState.positionX = animaitonTimelineData.x;
                                animationState.positionY = animaitonTimelineData.y;
                                animationState.weight = 0.0;
                            }
                            animationState._parent = this;
                            this.resetToPose = false;
                            break;
                        }
                        case 41 /* AnimationWeight */: {
                            var timeline = dragonBones.BaseObject.borrowObject(dragonBones.AnimationWeightTimelineState);
                            timeline.target = animationState;
                            timeline.init(this._armature, this, timelineData);
                            this._animationTimelines.push(timeline);
                            break;
                        }
                        case 42 /* AnimationParameter */: {
                            var timeline = dragonBones.BaseObject.borrowObject(dragonBones.AnimationParametersTimelineState);
                            timeline.target = animationState;
                            timeline.init(this._armature, this, timelineData);
                            this._animationTimelines.push(timeline);
                            break;
                        }
                        default:
                            break;
                    }
                }
            }
            if (animationState._parent === null) {
                animationState._parent = this;
            }
        };
        /**
         * @internal
         */
        AnimationState.prototype.activeTimeline = function () {
            for (var _i = 0, _a = this._slotTimelines; _i < _a.length; _i++) {
                var timeline = _a[_i];
                timeline.dirty = true;
                timeline.currentTime = -1.0;
            }
        };
        Object.defineProperty(AnimationState.prototype, "isFadeIn", {
            /**
             * - Whether the animation state is fading in.
             * @version DragonBones 5.1
             * @language en_US
             */
            /**
             * - 是否正在淡入。
             * @version DragonBones 5.1
             * @language zh_CN
             */
            get: function () {
                return this._fadeState < 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "isFadeOut", {
            /**
             * - Whether the animation state is fading out.
             * @version DragonBones 5.1
             * @language en_US
             */
            /**
             * - 是否正在淡出。
             * @version DragonBones 5.1
             * @language zh_CN
             */
            get: function () {
                return this._fadeState > 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "isFadeComplete", {
            /**
             * - Whether the animation state is fade completed.
             * @version DragonBones 5.1
             * @language en_US
             */
            /**
             * - 是否淡入或淡出完毕。
             * @version DragonBones 5.1
             * @language zh_CN
             */
            get: function () {
                return this._fadeState === 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "isPlaying", {
            /**
             * - Whether the animation state is playing.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 是否正在播放。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            get: function () {
                return (this._playheadState & 2) !== 0 && this._actionTimeline.playState <= 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "isCompleted", {
            /**
             * - Whether the animation state is play completed.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 是否播放完毕。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            get: function () {
                return this._actionTimeline.playState > 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "currentPlayTimes", {
            /**
             * - The times has been played.
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 已经循环播放的次数。
             * @version DragonBones 3.0
             * @language zh_CN
             */
            get: function () {
                return this._actionTimeline.currentPlayTimes;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "totalTime", {
            /**
             * - The total time. (In seconds)
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 总播放时间。 （以秒为单位）
             * @version DragonBones 3.0
             * @language zh_CN
             */
            get: function () {
                return this._duration;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "currentTime", {
            /**
             * - The time is currently playing. (In seconds)
             * @version DragonBones 3.0
             * @language en_US
             */
            /**
             * - 当前播放的时间。 （以秒为单位）
             * @version DragonBones 3.0
             * @language zh_CN
             */
            get: function () {
                return this._actionTimeline.currentTime;
            },
            set: function (value) {
                var currentPlayTimes = this._actionTimeline.currentPlayTimes - (this._actionTimeline.playState > 0 ? 1 : 0);
                if (value < 0 || this._duration < value) {
                    value = (value % this._duration) + currentPlayTimes * this._duration;
                    if (value < 0) {
                        value += this._duration;
                    }
                }
                if (this.playTimes > 0 && currentPlayTimes === this.playTimes - 1 &&
                    value === this._duration && this._parent === null) {
                    value = this._duration - 0.000001; // 
                }
                if (this._time === value) {
                    return;
                }
                this._time = value;
                this._actionTimeline.setCurrentTime(this._time);
                if (this._zOrderTimeline !== null) {
                    this._zOrderTimeline.playState = -1;
                }
                for (var _i = 0, _a = this._boneTimelines; _i < _a.length; _i++) {
                    var timeline = _a[_i];
                    timeline.playState = -1;
                }
                for (var _b = 0, _c = this._slotTimelines; _b < _c.length; _b++) {
                    var timeline = _c[_b];
                    timeline.playState = -1;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "weight", {
            /**
             * - The blend weight.
             * @default 1.0
             * @version DragonBones 5.0
             * @language en_US
             */
            /**
             * - 混合权重。
             * @default 1.0
             * @version DragonBones 5.0
             * @language zh_CN
             */
            /**
             * - The animation data.
             * @see dragonBones.AnimationData
             * @version DragonBones 3.0
             * @language en_US
             */
            get: function () {
                return this._weight;
            },
            set: function (value) {
                if (this._weight === value) {
                    return;
                }
                this._weight = value;
                for (var _i = 0, _a = this._boneTimelines; _i < _a.length; _i++) {
                    var timeline = _a[_i];
                    timeline.dirty = true;
                }
                for (var _b = 0, _c = this._boneBlendTimelines; _b < _c.length; _b++) {
                    var timeline = _c[_b];
                    timeline.dirty = true;
                }
                for (var _d = 0, _e = this._slotBlendTimelines; _d < _e.length; _d++) {
                    var timeline = _e[_d];
                    timeline.dirty = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "animationData", {
            /**
             * - 动画数据。
             * @see dragonBones.AnimationData
             * @version DragonBones 3.0
             * @language zh_CN
             */
            get: function () {
                return this._animationData;
            },
            enumerable: true,
            configurable: true
        });
        return AnimationState;
    }(dragonBones.BaseObject));
    dragonBones.AnimationState = AnimationState;
    /**
     * @internal
     */
    var BlendState = /** @class */ (function (_super) {
        __extends(BlendState, _super);
        function BlendState() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BlendState.toString = function () {
            return "[class dragonBones.BlendState]";
        };
        BlendState.prototype._onClear = function () {
            this.reset();
            this.target = null;
        };
        BlendState.prototype.update = function (animationState) {
            var animationLayer = animationState.layer;
            var animationWeight = animationState._weightResult;
            if (this.dirty > 0) {
                if (this.leftWeight > 0.0) {
                    if (this.layer !== animationLayer) {
                        if (this.layerWeight >= this.leftWeight) {
                            this.dirty++;
                            this.layer = animationLayer;
                            this.leftWeight = 0.0;
                            this.blendWeight = 0.0;
                            return false;
                        }
                        this.layer = animationLayer;
                        this.leftWeight -= this.layerWeight;
                        this.layerWeight = 0.0;
                    }
                    animationWeight *= this.leftWeight;
                    this.dirty++;
                    this.blendWeight = animationWeight;
                    this.layerWeight += this.blendWeight;
                    return true;
                }
                return false;
            }
            this.dirty++;
            this.layer = animationLayer;
            this.leftWeight = 1.0;
            this.blendWeight = animationWeight;
            this.layerWeight = animationWeight;
            return true;
        };
        BlendState.prototype.reset = function () {
            this.dirty = 0;
            this.layer = 0;
            this.leftWeight = 0.0;
            this.layerWeight = 0.0;
            this.blendWeight = 0.0;
        };
        BlendState.BONE_TRANSFORM = "boneTransform";
        BlendState.BONE_ALPHA = "boneAlpha";
        BlendState.SURFACE = "surface";
        BlendState.SLOT_DEFORM = "slotDeform";
        BlendState.SLOT_ALPHA = "slotAlpha";
        BlendState.SLOT_Z_INDEX = "slotZIndex";
        return BlendState;
    }(dragonBones.BaseObject));
    dragonBones.BlendState = BlendState;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * @internal
     */
    var TimelineState = /** @class */ (function (_super) {
        __extends(TimelineState, _super);
        function TimelineState() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TimelineState.prototype._onClear = function () {
            this.dirty = false;
            this.playState = -1;
            this.currentPlayTimes = 0;
            this.currentTime = -1.0;
            this.target = null;
            this._isTween = false;
            this._valueOffset = 0;
            this._frameValueOffset = 0;
            this._frameOffset = 0;
            this._frameRate = 0;
            this._frameCount = 0;
            this._frameIndex = -1;
            this._frameRateR = 0.0;
            this._position = 0.0;
            this._duration = 0.0;
            this._timeScale = 1.0;
            this._timeOffset = 0.0;
            this._animationData = null; //
            this._timelineData = null; //
            this._armature = null; //
            this._animationState = null; //
            this._actionTimeline = null; //
            this._frameArray = null; //
            this._valueArray = null; //
            this._timelineArray = null; //
            this._frameIndices = null; //
        };
        TimelineState.prototype._setCurrentTime = function (passedTime) {
            var prevState = this.playState;
            var prevPlayTimes = this.currentPlayTimes;
            var prevTime = this.currentTime;
            if (this._actionTimeline !== null && this._frameCount <= 1) { // No frame or only one frame.
                this.playState = this._actionTimeline.playState >= 0 ? 1 : -1;
                this.currentPlayTimes = 1;
                this.currentTime = this._actionTimeline.currentTime;
            }
            else if (this._actionTimeline === null || this._timeScale !== 1.0 || this._timeOffset !== 0.0) { // Action timeline or has scale and offset.
                var playTimes = this._animationState.playTimes;
                var totalTime = playTimes * this._duration;
                passedTime *= this._timeScale;
                if (this._timeOffset !== 0.0) {
                    passedTime += this._timeOffset * this._animationData.duration;
                }
                if (playTimes > 0 && (passedTime >= totalTime || passedTime <= -totalTime)) {
                    if (this.playState <= 0 && this._animationState._playheadState === 3) {
                        this.playState = 1;
                    }
                    this.currentPlayTimes = playTimes;
                    if (passedTime < 0.0) {
                        this.currentTime = 0.0;
                    }
                    else {
                        this.currentTime = this.playState === 1 ? this._duration + 0.000001 : this._duration; // Precision problem
                    }
                }
                else {
                    if (this.playState !== 0 && this._animationState._playheadState === 3) {
                        this.playState = 0;
                    }
                    if (passedTime < 0.0) {
                        passedTime = -passedTime;
                        this.currentPlayTimes = Math.floor(passedTime / this._duration);
                        this.currentTime = this._duration - (passedTime % this._duration);
                    }
                    else {
                        this.currentPlayTimes = Math.floor(passedTime / this._duration);
                        this.currentTime = passedTime % this._duration;
                    }
                }
                this.currentTime += this._position;
            }
            else { // Multi frames.
                this.playState = this._actionTimeline.playState;
                this.currentPlayTimes = this._actionTimeline.currentPlayTimes;
                this.currentTime = this._actionTimeline.currentTime;
            }
            if (this.currentPlayTimes === prevPlayTimes && this.currentTime === prevTime) {
                return false;
            }
            // Clear frame flag when timeline start or loopComplete.
            if ((prevState < 0 && this.playState !== prevState) ||
                (this.playState <= 0 && this.currentPlayTimes !== prevPlayTimes)) {
                this._frameIndex = -1;
            }
            return true;
        };
        TimelineState.prototype.init = function (armature, animationState, timelineData) {
            this._armature = armature;
            this._animationState = animationState;
            this._timelineData = timelineData;
            this._actionTimeline = this._animationState._actionTimeline;
            if (this === this._actionTimeline) {
                this._actionTimeline = null; //
            }
            this._animationData = this._animationState.animationData;
            //
            this._frameRate = this._animationData.parent.frameRate;
            this._frameRateR = 1.0 / this._frameRate;
            this._position = this._animationState._position;
            this._duration = this._animationState._duration;
            if (this._timelineData !== null) {
                var dragonBonesData = this._animationData.parent.parent; // May by the animation data is not belone to this armature data.
                this._frameArray = dragonBonesData.frameArray;
                this._timelineArray = dragonBonesData.timelineArray;
                this._frameIndices = dragonBonesData.frameIndices;
                //
                this._frameCount = this._timelineArray[this._timelineData.offset + 2 /* TimelineKeyFrameCount */];
                this._frameValueOffset = this._timelineArray[this._timelineData.offset + 4 /* TimelineFrameValueOffset */];
                this._timeScale = 100.0 / this._timelineArray[this._timelineData.offset + 0 /* TimelineScale */];
                this._timeOffset = this._timelineArray[this._timelineData.offset + 1 /* TimelineOffset */] * 0.01;
            }
        };
        TimelineState.prototype.fadeOut = function () {
            this.dirty = false;
        };
        TimelineState.prototype.update = function (passedTime) {
            if (this._setCurrentTime(passedTime)) {
                if (this._frameCount > 1) {
                    var timelineFrameIndex = Math.floor(this.currentTime * this._frameRate); // uint
                    var frameIndex = this._frameIndices[this._timelineData.frameIndicesOffset + timelineFrameIndex];
                    if (this._frameIndex !== frameIndex) {
                        this._frameIndex = frameIndex;
                        this._frameOffset = this._animationData.frameOffset + this._timelineArray[this._timelineData.offset + 5 /* TimelineFrameOffset */ + this._frameIndex];
                        this._onArriveAtFrame();
                    }
                }
                else if (this._frameIndex < 0) {
                    this._frameIndex = 0;
                    if (this._timelineData !== null) { // May be pose timeline.
                        this._frameOffset = this._animationData.frameOffset + this._timelineArray[this._timelineData.offset + 5 /* TimelineFrameOffset */];
                    }
                    this._onArriveAtFrame();
                }
                if (this._isTween || this.dirty) {
                    this._onUpdateFrame();
                }
            }
        };
        TimelineState.prototype.blend = function (_isDirty) {
        };
        return TimelineState;
    }(dragonBones.BaseObject));
    dragonBones.TimelineState = TimelineState;
    /**
     * @internal
     */
    var TweenTimelineState = /** @class */ (function (_super) {
        __extends(TweenTimelineState, _super);
        function TweenTimelineState() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TweenTimelineState._getEasingValue = function (tweenType, progress, easing) {
            var value = progress;
            switch (tweenType) {
                case 3 /* QuadIn */:
                    value = Math.pow(progress, 2.0);
                    break;
                case 4 /* QuadOut */:
                    value = 1.0 - Math.pow(1.0 - progress, 2.0);
                    break;
                case 5 /* QuadInOut */:
                    value = 0.5 * (1.0 - Math.cos(progress * Math.PI));
                    break;
            }
            return (value - progress) * easing + progress;
        };
        TweenTimelineState._getEasingCurveValue = function (progress, samples, count, offset) {
            if (progress <= 0.0) {
                return 0.0;
            }
            else if (progress >= 1.0) {
                return 1.0;
            }
            var isOmited = count > 0;
            var segmentCount = count + 1; // + 2 - 1
            var valueIndex = Math.floor(progress * segmentCount);
            var fromValue = 0.0;
            var toValue = 0.0;
            if (isOmited) {
                fromValue = valueIndex === 0 ? 0.0 : samples[offset + valueIndex - 1];
                toValue = (valueIndex === segmentCount - 1) ? 10000.0 : samples[offset + valueIndex];
            }
            else {
                fromValue = samples[offset + valueIndex - 1];
                toValue = samples[offset + valueIndex];
            }
            return (fromValue + (toValue - fromValue) * (progress * segmentCount - valueIndex)) * 0.0001;
        };
        TweenTimelineState.prototype._onClear = function () {
            _super.prototype._onClear.call(this);
            this._tweenType = 0 /* None */;
            this._curveCount = 0;
            this._framePosition = 0.0;
            this._frameDurationR = 0.0;
            this._tweenEasing = 0.0;
            this._tweenProgress = 0.0;
            this._valueScale = 1.0;
        };
        TweenTimelineState.prototype._onArriveAtFrame = function () {
            if (this._frameCount > 1 &&
                (this._frameIndex !== this._frameCount - 1 ||
                    this._animationState.playTimes === 0 ||
                    this._animationState.currentPlayTimes < this._animationState.playTimes - 1)) {
                this._tweenType = this._frameArray[this._frameOffset + 1 /* FrameTweenType */];
                this._isTween = this._tweenType !== 0 /* None */;
                if (this._isTween) {
                    if (this._tweenType === 2 /* Curve */) {
                        this._curveCount = this._frameArray[this._frameOffset + 2 /* FrameTweenEasingOrCurveSampleCount */];
                    }
                    else if (this._tweenType !== 0 /* None */ && this._tweenType !== 1 /* Line */) {
                        this._tweenEasing = this._frameArray[this._frameOffset + 2 /* FrameTweenEasingOrCurveSampleCount */] * 0.01;
                    }
                }
                else {
                    this.dirty = true;
                }
                this._framePosition = this._frameArray[this._frameOffset] * this._frameRateR;
                if (this._frameIndex === this._frameCount - 1) {
                    this._frameDurationR = 1.0 / (this._animationData.duration - this._framePosition);
                }
                else {
                    var nextFrameOffset = this._animationData.frameOffset + this._timelineArray[this._timelineData.offset + 5 /* TimelineFrameOffset */ + this._frameIndex + 1];
                    var frameDuration = this._frameArray[nextFrameOffset] * this._frameRateR - this._framePosition;
                    if (frameDuration > 0) {
                        this._frameDurationR = 1.0 / frameDuration;
                    }
                    else {
                        this._frameDurationR = 0.0;
                    }
                }
            }
            else {
                this.dirty = true;
                this._isTween = false;
            }
        };
        TweenTimelineState.prototype._onUpdateFrame = function () {
            if (this._isTween) {
                this.dirty = true;
                this._tweenProgress = (this.currentTime - this._framePosition) * this._frameDurationR;
                if (this._tweenType === 2 /* Curve */) {
                    this._tweenProgress = TweenTimelineState._getEasingCurveValue(this._tweenProgress, this._frameArray, this._curveCount, this._frameOffset + 3 /* FrameCurveSamples */);
                }
                else if (this._tweenType !== 1 /* Line */) {
                    this._tweenProgress = TweenTimelineState._getEasingValue(this._tweenType, this._tweenProgress, this._tweenEasing);
                }
            }
        };
        return TweenTimelineState;
    }(TimelineState));
    dragonBones.TweenTimelineState = TweenTimelineState;
    /**
     * @internal
     */
    var SingleValueTimelineState = /** @class */ (function (_super) {
        __extends(SingleValueTimelineState, _super);
        function SingleValueTimelineState() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SingleValueTimelineState.prototype._onClear = function () {
            _super.prototype._onClear.call(this);
            this._current = 0.0;
            this._difference = 0.0;
            this._result = 0.0;
        };
        SingleValueTimelineState.prototype._onArriveAtFrame = function () {
            _super.prototype._onArriveAtFrame.call(this);
            if (this._timelineData !== null) {
                var valueScale = this._valueScale;
                var valueArray = this._valueArray;
                //
                var valueOffset = this._valueOffset + this._frameValueOffset + this._frameIndex;
                if (this._isTween) {
                    var nextValueOffset = this._frameIndex === this._frameCount - 1 ?
                        this._valueOffset + this._frameValueOffset :
                        valueOffset + 1;
                    if (valueScale === 1.0) {
                        this._current = valueArray[valueOffset];
                        this._difference = valueArray[nextValueOffset] - this._current;
                    }
                    else {
                        this._current = valueArray[valueOffset] * valueScale;
                        this._difference = valueArray[nextValueOffset] * valueScale - this._current;
                    }
                }
                else {
                    this._result = valueArray[valueOffset] * valueScale;
                }
            }
            else {
                this._result = 0.0;
            }
        };
        SingleValueTimelineState.prototype._onUpdateFrame = function () {
            _super.prototype._onUpdateFrame.call(this);
            if (this._isTween) {
                this._result = this._current + this._difference * this._tweenProgress;
            }
        };
        return SingleValueTimelineState;
    }(TweenTimelineState));
    dragonBones.SingleValueTimelineState = SingleValueTimelineState;
    /**
     * @internal
     */
    var DoubleValueTimelineState = /** @class */ (function (_super) {
        __extends(DoubleValueTimelineState, _super);
        function DoubleValueTimelineState() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DoubleValueTimelineState.prototype._onClear = function () {
            _super.prototype._onClear.call(this);
            this._currentA = 0.0;
            this._currentB = 0.0;
            this._differenceA = 0.0;
            this._differenceB = 0.0;
            this._resultA = 0.0;
            this._resultB = 0.0;
        };
        DoubleValueTimelineState.prototype._onArriveAtFrame = function () {
            _super.prototype._onArriveAtFrame.call(this);
            if (this._timelineData !== null) {
                var valueScale = this._valueScale;
                var valueArray = this._valueArray;
                //
                var valueOffset = this._valueOffset + this._frameValueOffset + this._frameIndex * 2;
                if (this._isTween) {
                    var nextValueOffset = this._frameIndex === this._frameCount - 1 ?
                        this._valueOffset + this._frameValueOffset :
                        valueOffset + 2;
                    if (valueScale === 1.0) {
                        this._currentA = valueArray[valueOffset];
                        this._currentB = valueArray[valueOffset + 1];
                        this._differenceA = valueArray[nextValueOffset] - this._currentA;
                        this._differenceB = valueArray[nextValueOffset + 1] - this._currentB;
                    }
                    else {
                        this._currentA = valueArray[valueOffset] * valueScale;
                        this._currentB = valueArray[valueOffset + 1] * valueScale;
                        this._differenceA = valueArray[nextValueOffset] * valueScale - this._currentA;
                        this._differenceB = valueArray[nextValueOffset + 1] * valueScale - this._currentB;
                    }
                }
                else {
                    this._resultA = valueArray[valueOffset] * valueScale;
                    this._resultB = valueArray[valueOffset + 1] * valueScale;
                }
            }
            else {
                this._resultA = 0.0;
                this._resultB = 0.0;
            }
        };
        DoubleValueTimelineState.prototype._onUpdateFrame = function () {
            _super.prototype._onUpdateFrame.call(this);
            if (this._isTween) {
                this._resultA = this._currentA + this._differenceA * this._tweenProgress;
                this._resultB = this._currentB + this._differenceB * this._tweenProgress;
            }
        };
        return DoubleValueTimelineState;
    }(TweenTimelineState));
    dragonBones.DoubleValueTimelineState = DoubleValueTimelineState;
    /**
     * @internal
     */
    var MutilpleValueTimelineState = /** @class */ (function (_super) {
        __extends(MutilpleValueTimelineState, _super);
        function MutilpleValueTimelineState() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._rd = [];
            return _this;
        }
        MutilpleValueTimelineState.prototype._onClear = function () {
            _super.prototype._onClear.call(this);
            this._valueCount = 0;
            this._rd.length = 0;
        };
        MutilpleValueTimelineState.prototype._onArriveAtFrame = function () {
            _super.prototype._onArriveAtFrame.call(this);
            var valueCount = this._valueCount;
            var rd = this._rd;
            if (this._timelineData !== null) {
                var valueScale = this._valueScale;
                var valueArray = this._valueArray;
                //
                var valueOffset = this._valueOffset + this._frameValueOffset + this._frameIndex * valueCount;
                if (this._isTween) {
                    var nextValueOffset = this._frameIndex === this._frameCount - 1 ?
                        this._valueOffset + this._frameValueOffset :
                        valueOffset + valueCount;
                    if (valueScale === 1.0) {
                        for (var i = 0; i < valueCount; ++i) {
                            rd[valueCount + i] = valueArray[nextValueOffset + i] - valueArray[valueOffset + i];
                        }
                    }
                    else {
                        for (var i = 0; i < valueCount; ++i) {
                            rd[valueCount + i] = (valueArray[nextValueOffset + i] - valueArray[valueOffset + i]) * valueScale;
                        }
                    }
                }
                else if (valueScale === 1.0) {
                    for (var i = 0; i < valueCount; ++i) {
                        rd[i] = valueArray[valueOffset + i];
                    }
                }
                else {
                    for (var i = 0; i < valueCount; ++i) {
                        rd[i] = valueArray[valueOffset + i] * valueScale;
                    }
                }
            }
            else {
                for (var i = 0; i < valueCount; ++i) {
                    rd[i] = 0.0;
                }
            }
        };
        MutilpleValueTimelineState.prototype._onUpdateFrame = function () {
            _super.prototype._onUpdateFrame.call(this);
            if (this._isTween) {
                var valueCount = this._valueCount;
                var valueScale = this._valueScale;
                var tweenProgress = this._tweenProgress;
                var valueArray = this._valueArray;
                var rd = this._rd;
                //
                var valueOffset = this._valueOffset + this._frameValueOffset + this._frameIndex * valueCount;
                if (valueScale === 1.0) {
                    for (var i = 0; i < valueCount; ++i) {
                        rd[i] = valueArray[valueOffset + i] + rd[valueCount + i] * tweenProgress;
                    }
                }
                else {
                    for (var i = 0; i < valueCount; ++i) {
                        rd[i] = valueArray[valueOffset + i] * valueScale + rd[valueCount + i] * tweenProgress;
                    }
                }
            }
        };
        return MutilpleValueTimelineState;
    }(TweenTimelineState));
    dragonBones.MutilpleValueTimelineState = MutilpleValueTimelineState;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * @internal
     */
    var ActionTimelineState = /** @class */ (function (_super) {
        __extends(ActionTimelineState, _super);
        function ActionTimelineState() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ActionTimelineState.toString = function () {
            return "[class dragonBones.ActionTimelineState]";
        };
        ActionTimelineState.prototype._onCrossFrame = function (frameIndex) {
            var eventDispatcher = this._armature.eventDispatcher;
            if (this._animationState.actionEnabled) {
                var frameOffset = this._animationData.frameOffset + this._timelineArray[this._timelineData.offset + 5 /* TimelineFrameOffset */ + frameIndex];
                var actionCount = this._frameArray[frameOffset + 1];
                var actions = this._animationData.parent.actions; // May be the animaton data not belong to this armature data.
                for (var i = 0; i < actionCount; ++i) {
                    var actionIndex = this._frameArray[frameOffset + 2 + i];
                    var action = actions[actionIndex];
                    if (action.type === 0 /* Play */) {
                        var eventObject = dragonBones.BaseObject.borrowObject(dragonBones.EventObject);
                        // eventObject.time = this._frameArray[frameOffset] * this._frameRateR; // Precision problem
                        eventObject.time = this._frameArray[frameOffset] / this._frameRate;
                        eventObject.animationState = this._animationState;
                        dragonBones.EventObject.actionDataToInstance(action, eventObject, this._armature);
                        this._armature._bufferAction(eventObject, true);
                    }
                    else {
                        var eventType = action.type === 10 /* Frame */ ? dragonBones.EventObject.FRAME_EVENT : dragonBones.EventObject.SOUND_EVENT;
                        if (action.type === 11 /* Sound */ || eventDispatcher.hasDBEventListener(eventType)) {
                            var eventObject = dragonBones.BaseObject.borrowObject(dragonBones.EventObject);
                            // eventObject.time = this._frameArray[frameOffset] * this._frameRateR; // Precision problem
                            eventObject.time = this._frameArray[frameOffset] / this._frameRate;
                            eventObject.animationState = this._animationState;
                            dragonBones.EventObject.actionDataToInstance(action, eventObject, this._armature);
                            this._armature._dragonBones.bufferEvent(eventObject);
                        }
                    }
                }
            }
        };
        ActionTimelineState.prototype._onArriveAtFrame = function () { };
        ActionTimelineState.prototype._onUpdateFrame = function () { };
        ActionTimelineState.prototype.update = function (passedTime) {
            var prevState = this.playState;
            var prevPlayTimes = this.currentPlayTimes;
            var prevTime = this.currentTime;
            if (this._setCurrentTime(passedTime)) {
                var eventActive = this._animationState._parent === null && this._animationState.actionEnabled;
                var eventDispatcher = this._armature.eventDispatcher;
                if (prevState < 0) {
                    if (this.playState !== prevState) {
                        if (this._animationState.displayControl && this._animationState.resetToPose) { // Reset zorder to pose.
                            this._armature._sortZOrder(null, 0);
                        }
                        // prevPlayTimes = this.currentPlayTimes; // TODO
                        if (eventActive && eventDispatcher.hasDBEventListener(dragonBones.EventObject.START)) {
                            var eventObject = dragonBones.BaseObject.borrowObject(dragonBones.EventObject);
                            eventObject.type = dragonBones.EventObject.START;
                            eventObject.armature = this._armature;
                            eventObject.animationState = this._animationState;
                            this._armature._dragonBones.bufferEvent(eventObject);
                        }
                    }
                    else {
                        return;
                    }
                }
                var isReverse = this._animationState.timeScale < 0.0;
                var loopCompleteEvent = null;
                var completeEvent = null;
                if (eventActive && this.currentPlayTimes !== prevPlayTimes) {
                    if (eventDispatcher.hasDBEventListener(dragonBones.EventObject.LOOP_COMPLETE)) {
                        loopCompleteEvent = dragonBones.BaseObject.borrowObject(dragonBones.EventObject);
                        loopCompleteEvent.type = dragonBones.EventObject.LOOP_COMPLETE;
                        loopCompleteEvent.armature = this._armature;
                        loopCompleteEvent.animationState = this._animationState;
                    }
                    if (this.playState > 0) {
                        if (eventDispatcher.hasDBEventListener(dragonBones.EventObject.COMPLETE)) {
                            completeEvent = dragonBones.BaseObject.borrowObject(dragonBones.EventObject);
                            completeEvent.type = dragonBones.EventObject.COMPLETE;
                            completeEvent.armature = this._armature;
                            completeEvent.animationState = this._animationState;
                        }
                    }
                }
                if (this._frameCount > 1) {
                    var timelineData = this._timelineData;
                    var timelineFrameIndex = Math.floor(this.currentTime * this._frameRate); // uint
                    var frameIndex = this._frameIndices[timelineData.frameIndicesOffset + timelineFrameIndex];
                    if (this._frameIndex !== frameIndex) { // Arrive at frame.                   
                        var crossedFrameIndex = this._frameIndex;
                        this._frameIndex = frameIndex;
                        if (this._timelineArray !== null) {
                            this._frameOffset = this._animationData.frameOffset + this._timelineArray[timelineData.offset + 5 /* TimelineFrameOffset */ + this._frameIndex];
                            if (isReverse) {
                                if (crossedFrameIndex < 0) {
                                    var prevFrameIndex = Math.floor(prevTime * this._frameRate);
                                    crossedFrameIndex = this._frameIndices[timelineData.frameIndicesOffset + prevFrameIndex];
                                    if (this.currentPlayTimes === prevPlayTimes) { // Start.
                                        if (crossedFrameIndex === frameIndex) { // Uncrossed.
                                            crossedFrameIndex = -1;
                                        }
                                    }
                                }
                                while (crossedFrameIndex >= 0) {
                                    var frameOffset = this._animationData.frameOffset + this._timelineArray[timelineData.offset + 5 /* TimelineFrameOffset */ + crossedFrameIndex];
                                    // const framePosition = this._frameArray[frameOffset] * this._frameRateR; // Precision problem
                                    var framePosition = this._frameArray[frameOffset] / this._frameRate;
                                    if (this._position <= framePosition &&
                                        framePosition <= this._position + this._duration) { // Support interval play.
                                        this._onCrossFrame(crossedFrameIndex);
                                    }
                                    if (loopCompleteEvent !== null && crossedFrameIndex === 0) { // Add loop complete event after first frame.
                                        this._armature._dragonBones.bufferEvent(loopCompleteEvent);
                                        loopCompleteEvent = null;
                                    }
                                    if (crossedFrameIndex > 0) {
                                        crossedFrameIndex--;
                                    }
                                    else {
                                        crossedFrameIndex = this._frameCount - 1;
                                    }
                                    if (crossedFrameIndex === frameIndex) {
                                        break;
                                    }
                                }
                            }
                            else {
                                if (crossedFrameIndex < 0) {
                                    var prevFrameIndex = Math.floor(prevTime * this._frameRate);
                                    crossedFrameIndex = this._frameIndices[timelineData.frameIndicesOffset + prevFrameIndex];
                                    var frameOffset = this._animationData.frameOffset + this._timelineArray[timelineData.offset + 5 /* TimelineFrameOffset */ + crossedFrameIndex];
                                    // const framePosition = this._frameArray[frameOffset] * this._frameRateR; // Precision problem
                                    var framePosition = this._frameArray[frameOffset] / this._frameRate;
                                    if (this.currentPlayTimes === prevPlayTimes) { // Start.
                                        if (prevTime <= framePosition) { // Crossed.
                                            if (crossedFrameIndex > 0) {
                                                crossedFrameIndex--;
                                            }
                                            else {
                                                crossedFrameIndex = this._frameCount - 1;
                                            }
                                        }
                                        else if (crossedFrameIndex === frameIndex) { // Uncrossed.
                                            crossedFrameIndex = -1;
                                        }
                                    }
                                }
                                while (crossedFrameIndex >= 0) {
                                    if (crossedFrameIndex < this._frameCount - 1) {
                                        crossedFrameIndex++;
                                    }
                                    else {
                                        crossedFrameIndex = 0;
                                    }
                                    var frameOffset = this._animationData.frameOffset + this._timelineArray[timelineData.offset + 5 /* TimelineFrameOffset */ + crossedFrameIndex];
                                    // const framePosition = this._frameArray[frameOffset] * this._frameRateR; // Precision problem
                                    var framePosition = this._frameArray[frameOffset] / this._frameRate;
                                    if (this._position <= framePosition &&
                                        framePosition <= this._position + this._duration //
                                    ) { // Support interval play.
                                        this._onCrossFrame(crossedFrameIndex);
                                    }
                                    if (loopCompleteEvent !== null && crossedFrameIndex === 0) { // Add loop complete event before first frame.
                                        this._armature._dragonBones.bufferEvent(loopCompleteEvent);
                                        loopCompleteEvent = null;
                                    }
                                    if (crossedFrameIndex === frameIndex) {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
                else if (this._frameIndex < 0) {
                    this._frameIndex = 0;
                    if (this._timelineData !== null) {
                        this._frameOffset = this._animationData.frameOffset + this._timelineArray[this._timelineData.offset + 5 /* TimelineFrameOffset */];
                        // Arrive at frame.
                        var framePosition = this._frameArray[this._frameOffset] / this._frameRate;
                        if (this.currentPlayTimes === prevPlayTimes) { // Start.
                            if (prevTime <= framePosition) {
                                this._onCrossFrame(this._frameIndex);
                            }
                        }
                        else if (this._position <= framePosition) { // Loop complete.
                            if (!isReverse && loopCompleteEvent !== null) { // Add loop complete event before first frame.
                                this._armature._dragonBones.bufferEvent(loopCompleteEvent);
                                loopCompleteEvent = null;
                            }
                            this._onCrossFrame(this._frameIndex);
                        }
                    }
                }
                if (loopCompleteEvent !== null) {
                    this._armature._dragonBones.bufferEvent(loopCompleteEvent);
                }
                if (completeEvent !== null) {
                    this._armature._dragonBones.bufferEvent(completeEvent);
                }
            }
        };
        ActionTimelineState.prototype.setCurrentTime = function (value) {
            this._setCurrentTime(value);
            this._frameIndex = -1;
        };
        return ActionTimelineState;
    }(dragonBones.TimelineState));
    dragonBones.ActionTimelineState = ActionTimelineState;
    /**
     * @internal
     */
    var ZOrderTimelineState = /** @class */ (function (_super) {
        __extends(ZOrderTimelineState, _super);
        function ZOrderTimelineState() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ZOrderTimelineState.toString = function () {
            return "[class dragonBones.ZOrderTimelineState]";
        };
        ZOrderTimelineState.prototype._onArriveAtFrame = function () {
            if (this.playState >= 0) {
                var count = this._frameArray[this._frameOffset + 1];
                if (count > 0) {
                    this._armature._sortZOrder(this._frameArray, this._frameOffset + 2);
                }
                else {
                    this._armature._sortZOrder(null, 0);
                }
            }
        };
        ZOrderTimelineState.prototype._onUpdateFrame = function () { };
        return ZOrderTimelineState;
    }(dragonBones.TimelineState));
    dragonBones.ZOrderTimelineState = ZOrderTimelineState;
    /**
     * @internal
     */
    var BoneAllTimelineState = /** @class */ (function (_super) {
        __extends(BoneAllTimelineState, _super);
        function BoneAllTimelineState() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BoneAllTimelineState.toString = function () {
            return "[class dragonBones.BoneAllTimelineState]";
        };
        BoneAllTimelineState.prototype._onArriveAtFrame = function () {
            _super.prototype._onArriveAtFrame.call(this);
            if (this._isTween && this._frameIndex === this._frameCount - 1) {
                this._rd[2] = dragonBones.Transform.normalizeRadian(this._rd[2]);
                this._rd[3] = dragonBones.Transform.normalizeRadian(this._rd[3]);
            }
            if (this._timelineData === null) { // Pose.
                this._rd[4] = 1.0;
                this._rd[5] = 1.0;
            }
        };
        BoneAllTimelineState.prototype.init = function (armature, animationState, timelineData) {
            _super.prototype.init.call(this, armature, animationState, timelineData);
            this._valueOffset = this._animationData.frameFloatOffset;
            this._valueCount = 6;
            this._valueArray = this._animationData.parent.parent.frameFloatArray;
        };
        BoneAllTimelineState.prototype.fadeOut = function () {
            this.dirty = false;
            this._rd[2] = dragonBones.Transform.normalizeRadian(this._rd[2]);
            this._rd[3] = dragonBones.Transform.normalizeRadian(this._rd[3]);
        };
        BoneAllTimelineState.prototype.blend = function (isDirty) {
            var valueScale = this._armature.armatureData.scale;
            var rd = this._rd;
            //
            var blendState = this.target;
            var bone = blendState.target;
            var blendWeight = blendState.blendWeight;
            var result = bone.animationPose;
            if (blendState.dirty > 1) {
                result.x += rd[0] * blendWeight * valueScale;
                result.y += rd[1] * blendWeight * valueScale;
                result.rotation += rd[2] * blendWeight;
                result.skew += rd[3] * blendWeight;
                result.scaleX += (rd[4] - 1.0) * blendWeight;
                result.scaleY += (rd[5] - 1.0) * blendWeight;
            }
            else {
                result.x = rd[0] * blendWeight * valueScale;
                result.y = rd[1] * blendWeight * valueScale;
                result.rotation = rd[2] * blendWeight;
                result.skew = rd[3] * blendWeight;
                result.scaleX = (rd[4] - 1.0) * blendWeight + 1.0; // 
                result.scaleY = (rd[5] - 1.0) * blendWeight + 1.0; //
            }
            if (isDirty || this.dirty) {
                this.dirty = false;
                bone._transformDirty = true;
            }
        };
        return BoneAllTimelineState;
    }(dragonBones.MutilpleValueTimelineState));
    dragonBones.BoneAllTimelineState = BoneAllTimelineState;
    /**
     * @internal
     */
    var BoneTranslateTimelineState = /** @class */ (function (_super) {
        __extends(BoneTranslateTimelineState, _super);
        function BoneTranslateTimelineState() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BoneTranslateTimelineState.toString = function () {
            return "[class dragonBones.BoneTranslateTimelineState]";
        };
        BoneTranslateTimelineState.prototype.init = function (armature, animationState, timelineData) {
            _super.prototype.init.call(this, armature, animationState, timelineData);
            this._valueOffset = this._animationData.frameFloatOffset;
            this._valueScale = this._armature.armatureData.scale;
            this._valueArray = this._animationData.parent.parent.frameFloatArray;
        };
        BoneTranslateTimelineState.prototype.blend = function (isDirty) {
            var blendState = this.target;
            var bone = blendState.target;
            var blendWeight = blendState.blendWeight;
            var result = bone.animationPose;
            if (blendState.dirty > 1) {
                result.x += this._resultA * blendWeight;
                result.y += this._resultB * blendWeight;
            }
            else if (blendWeight !== 1.0) {
                result.x = this._resultA * blendWeight;
                result.y = this._resultB * blendWeight;
            }
            else {
                result.x = this._resultA;
                result.y = this._resultB;
            }
            if (isDirty || this.dirty) {
                this.dirty = false;
                bone._transformDirty = true;
            }
        };
        return BoneTranslateTimelineState;
    }(dragonBones.DoubleValueTimelineState));
    dragonBones.BoneTranslateTimelineState = BoneTranslateTimelineState;
    /**
     * @internal
     */
    var BoneRotateTimelineState = /** @class */ (function (_super) {
        __extends(BoneRotateTimelineState, _super);
        function BoneRotateTimelineState() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BoneRotateTimelineState.toString = function () {
            return "[class dragonBones.BoneRotateTimelineState]";
        };
        BoneRotateTimelineState.prototype._onArriveAtFrame = function () {
            _super.prototype._onArriveAtFrame.call(this);
            if (this._isTween && this._frameIndex === this._frameCount - 1) {
                this._differenceA = dragonBones.Transform.normalizeRadian(this._differenceA);
                this._differenceB = dragonBones.Transform.normalizeRadian(this._differenceB);
            }
        };
        BoneRotateTimelineState.prototype.init = function (armature, animationState, timelineData) {
            _super.prototype.init.call(this, armature, animationState, timelineData);
            this._valueOffset = this._animationData.frameFloatOffset;
            this._valueArray = this._animationData.parent.parent.frameFloatArray;
        };
        BoneRotateTimelineState.prototype.fadeOut = function () {
            this.dirty = false;
            this._resultA = dragonBones.Transform.normalizeRadian(this._resultA);
            this._resultB = dragonBones.Transform.normalizeRadian(this._resultB);
        };
        BoneRotateTimelineState.prototype.blend = function (isDirty) {
            var blendState = this.target;
            var bone = blendState.target;
            var blendWeight = blendState.blendWeight;
            var result = bone.animationPose;
            if (blendState.dirty > 1) {
                result.rotation += this._resultA * blendWeight;
                result.skew += this._resultB * blendWeight;
            }
            else if (blendWeight !== 1.0) {
                result.rotation = this._resultA * blendWeight;
                result.skew = this._resultB * blendWeight;
            }
            else {
                result.rotation = this._resultA;
                result.skew = this._resultB;
            }
            if (isDirty || this.dirty) {
                this.dirty = false;
                bone._transformDirty = true;
            }
        };
        return BoneRotateTimelineState;
    }(dragonBones.DoubleValueTimelineState));
    dragonBones.BoneRotateTimelineState = BoneRotateTimelineState;
    /**
     * @internal
     */
    var BoneScaleTimelineState = /** @class */ (function (_super) {
        __extends(BoneScaleTimelineState, _super);
        function BoneScaleTimelineState() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BoneScaleTimelineState.toString = function () {
            return "[class dragonBones.BoneScaleTimelineState]";
        };
        BoneScaleTimelineState.prototype._onArriveAtFrame = function () {
            _super.prototype._onArriveAtFrame.call(this);
            if (this._timelineData === null) { // Pose.
                this._resultA = 1.0;
                this._resultB = 1.0;
            }
        };
        BoneScaleTimelineState.prototype.init = function (armature, animationState, timelineData) {
            _super.prototype.init.call(this, armature, animationState, timelineData);
            this._valueOffset = this._animationData.frameFloatOffset;
            this._valueArray = this._animationData.parent.parent.frameFloatArray;
        };
        BoneScaleTimelineState.prototype.blend = function (isDirty) {
            var blendState = this.target;
            var bone = blendState.target;
            var blendWeight = blendState.blendWeight;
            var result = bone.animationPose;
            if (blendState.dirty > 1) {
                result.scaleX += (this._resultA - 1.0) * blendWeight;
                result.scaleY += (this._resultB - 1.0) * blendWeight;
            }
            else if (blendWeight !== 1.0) {
                result.scaleX = (this._resultA - 1.0) * blendWeight + 1.0;
                result.scaleY = (this._resultB - 1.0) * blendWeight + 1.0;
            }
            else {
                result.scaleX = this._resultA;
                result.scaleY = this._resultB;
            }
            if (isDirty || this.dirty) {
                this.dirty = false;
                bone._transformDirty = true;
            }
        };
        return BoneScaleTimelineState;
    }(dragonBones.DoubleValueTimelineState));
    dragonBones.BoneScaleTimelineState = BoneScaleTimelineState;
    /**
     * @internal
     */
    var SurfaceTimelineState = /** @class */ (function (_super) {
        __extends(SurfaceTimelineState, _super);
        function SurfaceTimelineState() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SurfaceTimelineState.toString = function () {
            return "[class dragonBones.SurfaceTimelineState]";
        };
        SurfaceTimelineState.prototype._onClear = function () {
            _super.prototype._onClear.call(this);
            this._deformCount = 0;
            this._deformOffset = 0;
            this._sameValueOffset = 0;
        };
        SurfaceTimelineState.prototype.init = function (armature, animationState, timelineData) {
            _super.prototype.init.call(this, armature, animationState, timelineData);
            if (this._timelineData !== null) {
                var dragonBonesData = this._animationData.parent.parent;
                var frameIntArray = dragonBonesData.frameIntArray;
                var frameIntOffset = this._animationData.frameIntOffset + this._timelineArray[this._timelineData.offset + 3 /* TimelineFrameValueCount */];
                this._valueOffset = this._animationData.frameFloatOffset;
                this._valueCount = frameIntArray[frameIntOffset + 2 /* DeformValueCount */];
                this._deformCount = frameIntArray[frameIntOffset + 1 /* DeformCount */];
                this._deformOffset = frameIntArray[frameIntOffset + 3 /* DeformValueOffset */];
                this._sameValueOffset = frameIntArray[frameIntOffset + 4 /* DeformFloatOffset */] + this._animationData.frameFloatOffset;
                this._valueScale = this._armature.armatureData.scale;
                this._valueArray = dragonBonesData.frameFloatArray;
                this._rd.length = this._valueCount * 2;
            }
            else {
                this._deformCount = this.target.target._deformVertices.length;
            }
        };
        SurfaceTimelineState.prototype.blend = function (isDirty) {
            var blendState = this.target;
            var surface = blendState.target;
            var blendWeight = blendState.blendWeight;
            var result = surface._deformVertices;
            var valueArray = this._valueArray;
            if (valueArray !== null) {
                var valueCount = this._valueCount;
                var deformOffset = this._deformOffset;
                var sameValueOffset = this._sameValueOffset;
                var rd = this._rd;
                for (var i = 0; i < this._deformCount; ++i) {
                    var value = 0.0;
                    if (i < deformOffset) {
                        value = valueArray[sameValueOffset + i];
                    }
                    else if (i < deformOffset + valueCount) {
                        value = rd[i - deformOffset];
                    }
                    else {
                        value = valueArray[sameValueOffset + i - valueCount];
                    }
                    if (blendState.dirty > 1) {
                        result[i] += value * blendWeight;
                    }
                    else {
                        result[i] = value * blendWeight;
                    }
                }
            }
            else if (blendState.dirty === 1) {
                for (var i = 0; i < this._deformCount; ++i) {
                    result[i] = 0.0;
                }
            }
            if (isDirty || this.dirty) {
                this.dirty = false;
                surface._transformDirty = true;
            }
        };
        return SurfaceTimelineState;
    }(dragonBones.MutilpleValueTimelineState));
    dragonBones.SurfaceTimelineState = SurfaceTimelineState;
    /**
     * @internal
     */
    var AlphaTimelineState = /** @class */ (function (_super) {
        __extends(AlphaTimelineState, _super);
        function AlphaTimelineState() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AlphaTimelineState.toString = function () {
            return "[class dragonBones.AlphaTimelineState]";
        };
        AlphaTimelineState.prototype._onArriveAtFrame = function () {
            _super.prototype._onArriveAtFrame.call(this);
            if (this._timelineData === null) { // Pose.
                this._result = 1.0;
            }
        };
        AlphaTimelineState.prototype.init = function (armature, animationState, timelineData) {
            _super.prototype.init.call(this, armature, animationState, timelineData);
            this._valueOffset = this._animationData.frameIntOffset;
            this._valueScale = 0.01;
            this._valueArray = this._animationData.parent.parent.frameIntArray;
        };
        AlphaTimelineState.prototype.blend = function (isDirty) {
            var blendState = this.target;
            var alphaTarget = blendState.target;
            var blendWeight = blendState.blendWeight;
            if (blendState.dirty > 1) {
                alphaTarget._alpha += this._result * blendWeight;
                if (alphaTarget._alpha > 1.0) {
                    alphaTarget._alpha = 1.0;
                }
            }
            else {
                alphaTarget._alpha = this._result * blendWeight;
            }
            if (isDirty || this.dirty) {
                this.dirty = false;
                this._armature._alphaDirty = true;
            }
        };
        return AlphaTimelineState;
    }(dragonBones.SingleValueTimelineState));
    dragonBones.AlphaTimelineState = AlphaTimelineState;
    /**
     * @internal
     */
    var SlotDisplayTimelineState = /** @class */ (function (_super) {
        __extends(SlotDisplayTimelineState, _super);
        function SlotDisplayTimelineState() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SlotDisplayTimelineState.toString = function () {
            return "[class dragonBones.SlotDisplayTimelineState]";
        };
        SlotDisplayTimelineState.prototype._onArriveAtFrame = function () {
            if (this.playState >= 0) {
                var slot = this.target;
                var displayIndex = this._timelineData !== null ? this._frameArray[this._frameOffset + 1] : slot._slotData.displayIndex;
                if (slot.displayIndex !== displayIndex) {
                    slot._setDisplayIndex(displayIndex, true);
                }
            }
        };
        SlotDisplayTimelineState.prototype._onUpdateFrame = function () {
        };
        return SlotDisplayTimelineState;
    }(dragonBones.TimelineState));
    dragonBones.SlotDisplayTimelineState = SlotDisplayTimelineState;
    /**
     * @internal
     */
    var SlotColorTimelineState = /** @class */ (function (_super) {
        __extends(SlotColorTimelineState, _super);
        function SlotColorTimelineState() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._current = [0, 0, 0, 0, 0, 0, 0, 0];
            _this._difference = [0, 0, 0, 0, 0, 0, 0, 0];
            _this._result = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
            return _this;
        }
        SlotColorTimelineState.toString = function () {
            return "[class dragonBones.SlotColorTimelineState]";
        };
        SlotColorTimelineState.prototype._onArriveAtFrame = function () {
            _super.prototype._onArriveAtFrame.call(this);
            if (this._timelineData !== null) {
                var dragonBonesData = this._animationData.parent.parent;
                var colorArray = dragonBonesData.colorArray;
                var frameIntArray = dragonBonesData.frameIntArray;
                var valueOffset = this._animationData.frameIntOffset + this._frameValueOffset + this._frameIndex;
                var colorOffset = frameIntArray[valueOffset];
                if (colorOffset < 0) {
                    colorOffset += 65536; // Fixed out of bounds bug. 
                }
                if (this._isTween) {
                    this._current[0] = colorArray[colorOffset++];
                    this._current[1] = colorArray[colorOffset++];
                    this._current[2] = colorArray[colorOffset++];
                    this._current[3] = colorArray[colorOffset++];
                    this._current[4] = colorArray[colorOffset++];
                    this._current[5] = colorArray[colorOffset++];
                    this._current[6] = colorArray[colorOffset++];
                    this._current[7] = colorArray[colorOffset++];
                    if (this._frameIndex === this._frameCount - 1) {
                        colorOffset = frameIntArray[this._animationData.frameIntOffset + this._frameValueOffset];
                    }
                    else {
                        colorOffset = frameIntArray[valueOffset + 1];
                    }
                    if (colorOffset < 0) {
                        colorOffset += 65536; // Fixed out of bounds bug. 
                    }
                    this._difference[0] = colorArray[colorOffset++] - this._current[0];
                    this._difference[1] = colorArray[colorOffset++] - this._current[1];
                    this._difference[2] = colorArray[colorOffset++] - this._current[2];
                    this._difference[3] = colorArray[colorOffset++] - this._current[3];
                    this._difference[4] = colorArray[colorOffset++] - this._current[4];
                    this._difference[5] = colorArray[colorOffset++] - this._current[5];
                    this._difference[6] = colorArray[colorOffset++] - this._current[6];
                    this._difference[7] = colorArray[colorOffset++] - this._current[7];
                }
                else {
                    this._result[0] = colorArray[colorOffset++] * 0.01;
                    this._result[1] = colorArray[colorOffset++] * 0.01;
                    this._result[2] = colorArray[colorOffset++] * 0.01;
                    this._result[3] = colorArray[colorOffset++] * 0.01;
                    this._result[4] = colorArray[colorOffset++];
                    this._result[5] = colorArray[colorOffset++];
                    this._result[6] = colorArray[colorOffset++];
                    this._result[7] = colorArray[colorOffset++];
                }
            }
            else { // Pose.
                var slot = this.target;
                var color = slot.slotData.color;
                this._result[0] = color.alphaMultiplier;
                this._result[1] = color.redMultiplier;
                this._result[2] = color.greenMultiplier;
                this._result[3] = color.blueMultiplier;
                this._result[4] = color.alphaOffset;
                this._result[5] = color.redOffset;
                this._result[6] = color.greenOffset;
                this._result[7] = color.blueOffset;
            }
        };
        SlotColorTimelineState.prototype._onUpdateFrame = function () {
            _super.prototype._onUpdateFrame.call(this);
            if (this._isTween) {
                this._result[0] = (this._current[0] + this._difference[0] * this._tweenProgress) * 0.01;
                this._result[1] = (this._current[1] + this._difference[1] * this._tweenProgress) * 0.01;
                this._result[2] = (this._current[2] + this._difference[2] * this._tweenProgress) * 0.01;
                this._result[3] = (this._current[3] + this._difference[3] * this._tweenProgress) * 0.01;
                this._result[4] = this._current[4] + this._difference[4] * this._tweenProgress;
                this._result[5] = this._current[5] + this._difference[5] * this._tweenProgress;
                this._result[6] = this._current[6] + this._difference[6] * this._tweenProgress;
                this._result[7] = this._current[7] + this._difference[7] * this._tweenProgress;
            }
        };
        SlotColorTimelineState.prototype.fadeOut = function () {
            this._isTween = false;
        };
        SlotColorTimelineState.prototype.update = function (passedTime) {
            _super.prototype.update.call(this, passedTime);
            // Fade animation.
            if (this._isTween || this.dirty) {
                var slot = this.target;
                var result = slot._colorTransform;
                if (this._animationState._fadeState !== 0 || this._animationState._subFadeState !== 0) {
                    if (result.alphaMultiplier !== this._result[0] ||
                        result.redMultiplier !== this._result[1] ||
                        result.greenMultiplier !== this._result[2] ||
                        result.blueMultiplier !== this._result[3] ||
                        result.alphaOffset !== this._result[4] ||
                        result.redOffset !== this._result[5] ||
                        result.greenOffset !== this._result[6] ||
                        result.blueOffset !== this._result[7]) {
                        var fadeProgress = Math.pow(this._animationState._fadeProgress, 4);
                        result.alphaMultiplier += (this._result[0] - result.alphaMultiplier) * fadeProgress;
                        result.redMultiplier += (this._result[1] - result.redMultiplier) * fadeProgress;
                        result.greenMultiplier += (this._result[2] - result.greenMultiplier) * fadeProgress;
                        result.blueMultiplier += (this._result[3] - result.blueMultiplier) * fadeProgress;
                        result.alphaOffset += (this._result[4] - result.alphaOffset) * fadeProgress;
                        result.redOffset += (this._result[5] - result.redOffset) * fadeProgress;
                        result.greenOffset += (this._result[6] - result.greenOffset) * fadeProgress;
                        result.blueOffset += (this._result[7] - result.blueOffset) * fadeProgress;
                        slot._colorDirty = true;
                    }
                }
                else if (this.dirty) {
                    this.dirty = false;
                    if (result.alphaMultiplier !== this._result[0] ||
                        result.redMultiplier !== this._result[1] ||
                        result.greenMultiplier !== this._result[2] ||
                        result.blueMultiplier !== this._result[3] ||
                        result.alphaOffset !== this._result[4] ||
                        result.redOffset !== this._result[5] ||
                        result.greenOffset !== this._result[6] ||
                        result.blueOffset !== this._result[7]) {
                        result.alphaMultiplier = this._result[0];
                        result.redMultiplier = this._result[1];
                        result.greenMultiplier = this._result[2];
                        result.blueMultiplier = this._result[3];
                        result.alphaOffset = this._result[4];
                        result.redOffset = this._result[5];
                        result.greenOffset = this._result[6];
                        result.blueOffset = this._result[7];
                        slot._colorDirty = true;
                    }
                }
            }
        };
        return SlotColorTimelineState;
    }(dragonBones.TweenTimelineState));
    dragonBones.SlotColorTimelineState = SlotColorTimelineState;
    /**
     * @internal
     */
    var SlotZIndexTimelineState = /** @class */ (function (_super) {
        __extends(SlotZIndexTimelineState, _super);
        function SlotZIndexTimelineState() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SlotZIndexTimelineState.toString = function () {
            return "[class dragonBones.SlotZIndexTimelineState]";
        };
        SlotZIndexTimelineState.prototype._onArriveAtFrame = function () {
            _super.prototype._onArriveAtFrame.call(this);
            if (this._timelineData === null) { // Pose.
                var blendState = this.target;
                var slot = blendState.target;
                this._result = slot.slotData.zIndex;
            }
        };
        SlotZIndexTimelineState.prototype.init = function (armature, animationState, timelineData) {
            _super.prototype.init.call(this, armature, animationState, timelineData);
            this._valueOffset = this._animationData.frameIntOffset;
            this._valueArray = this._animationData.parent.parent.frameIntArray;
        };
        SlotZIndexTimelineState.prototype.blend = function (isDirty) {
            var blendState = this.target;
            var slot = blendState.target;
            var blendWeight = blendState.blendWeight;
            if (blendState.dirty > 1) {
                slot._zIndex += this._result * blendWeight;
            }
            else {
                slot._zIndex = this._result * blendWeight;
            }
            if (isDirty || this.dirty) {
                this.dirty = false;
                this._armature._zIndexDirty = true;
            }
        };
        return SlotZIndexTimelineState;
    }(dragonBones.SingleValueTimelineState));
    dragonBones.SlotZIndexTimelineState = SlotZIndexTimelineState;
    /**
     * @internal
     */
    var DeformTimelineState = /** @class */ (function (_super) {
        __extends(DeformTimelineState, _super);
        function DeformTimelineState() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DeformTimelineState.toString = function () {
            return "[class dragonBones.DeformTimelineState]";
        };
        DeformTimelineState.prototype._onClear = function () {
            _super.prototype._onClear.call(this);
            this.displayFrame = null;
            this._deformCount = 0;
            this._deformOffset = 0;
            this._sameValueOffset = 0;
        };
        DeformTimelineState.prototype.init = function (armature, animationState, timelineData) {
            _super.prototype.init.call(this, armature, animationState, timelineData);
            if (this._timelineData !== null) {
                var frameIntOffset = this._animationData.frameIntOffset + this._timelineArray[this._timelineData.offset + 3 /* TimelineFrameValueCount */];
                var dragonBonesData = this._animationData.parent.parent;
                var frameIntArray = dragonBonesData.frameIntArray;
                this._valueOffset = this._animationData.frameFloatOffset;
                this._valueCount = frameIntArray[frameIntOffset + 2 /* DeformValueCount */];
                this._deformCount = frameIntArray[frameIntOffset + 1 /* DeformCount */];
                this._deformOffset = frameIntArray[frameIntOffset + 3 /* DeformValueOffset */];
                this._sameValueOffset = frameIntArray[frameIntOffset + 4 /* DeformFloatOffset */];
                if (this._sameValueOffset < 0) {
                    this._sameValueOffset += 65536; // Fixed out of bounds bug. 
                }
                this._sameValueOffset += this._animationData.frameFloatOffset;
                this._valueScale = this._armature.armatureData.scale;
                this._valueArray = dragonBonesData.frameFloatArray;
                this._rd.length = this._valueCount * 2;
            }
            else {
                this._deformCount = this.displayFrame.deformVertices.length;
            }
        };
        DeformTimelineState.prototype.blend = function (isDirty) {
            var blendState = this.target;
            var slot = blendState.target;
            var blendWeight = blendState.blendWeight;
            var result = this.displayFrame.deformVertices;
            var valueArray = this._valueArray;
            if (valueArray !== null) {
                var valueCount = this._valueCount;
                var deformOffset = this._deformOffset;
                var sameValueOffset = this._sameValueOffset;
                var rd = this._rd;
                for (var i = 0; i < this._deformCount; ++i) {
                    var value = 0.0;
                    if (i < deformOffset) {
                        value = valueArray[sameValueOffset + i];
                    }
                    else if (i < deformOffset + valueCount) {
                        value = rd[i - deformOffset];
                    }
                    else {
                        value = valueArray[sameValueOffset + i - valueCount];
                    }
                    if (blendState.dirty > 1) {
                        result[i] += value * blendWeight;
                    }
                    else {
                        result[i] = value * blendWeight;
                    }
                }
            }
            else if (blendState.dirty === 1) {
                for (var i = 0; i < this._deformCount; ++i) {
                    result[i] = 0.0;
                }
            }
            if (isDirty || this.dirty) {
                this.dirty = false;
                if (slot._geometryData === this.displayFrame.getGeometryData()) {
                    slot._verticesDirty = true;
                }
            }
        };
        return DeformTimelineState;
    }(dragonBones.MutilpleValueTimelineState));
    dragonBones.DeformTimelineState = DeformTimelineState;
    /**
     * @internal
     */
    var IKConstraintTimelineState = /** @class */ (function (_super) {
        __extends(IKConstraintTimelineState, _super);
        function IKConstraintTimelineState() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IKConstraintTimelineState.toString = function () {
            return "[class dragonBones.IKConstraintTimelineState]";
        };
        IKConstraintTimelineState.prototype._onUpdateFrame = function () {
            _super.prototype._onUpdateFrame.call(this);
            var ikConstraint = this.target;
            if (this._timelineData !== null) {
                ikConstraint._bendPositive = this._currentA > 0.0;
                ikConstraint._weight = this._currentB;
            }
            else {
                var ikConstraintData = ikConstraint._constraintData;
                ikConstraint._bendPositive = ikConstraintData.bendPositive;
                ikConstraint._weight = ikConstraintData.weight;
            }
            ikConstraint.invalidUpdate();
            this.dirty = false;
        };
        IKConstraintTimelineState.prototype.init = function (armature, animationState, timelineData) {
            _super.prototype.init.call(this, armature, animationState, timelineData);
            this._valueOffset = this._animationData.frameIntOffset;
            this._valueScale = 0.01;
            this._valueArray = this._animationData.parent.parent.frameIntArray;
        };
        return IKConstraintTimelineState;
    }(dragonBones.DoubleValueTimelineState));
    dragonBones.IKConstraintTimelineState = IKConstraintTimelineState;
    /**
     * @internal
     */
    var AnimationProgressTimelineState = /** @class */ (function (_super) {
        __extends(AnimationProgressTimelineState, _super);
        function AnimationProgressTimelineState() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AnimationProgressTimelineState.toString = function () {
            return "[class dragonBones.AnimationProgressTimelineState]";
        };
        AnimationProgressTimelineState.prototype._onUpdateFrame = function () {
            _super.prototype._onUpdateFrame.call(this);
            var animationState = this.target;
            if (animationState._parent !== null) {
                animationState.currentTime = this._result * animationState.totalTime;
            }
            this.dirty = false;
        };
        AnimationProgressTimelineState.prototype.init = function (armature, animationState, timelineData) {
            _super.prototype.init.call(this, armature, animationState, timelineData);
            this._valueOffset = this._animationData.frameIntOffset;
            this._valueScale = 0.0001;
            this._valueArray = this._animationData.parent.parent.frameIntArray;
        };
        return AnimationProgressTimelineState;
    }(dragonBones.SingleValueTimelineState));
    dragonBones.AnimationProgressTimelineState = AnimationProgressTimelineState;
    /**
     * @internal
     */
    var AnimationWeightTimelineState = /** @class */ (function (_super) {
        __extends(AnimationWeightTimelineState, _super);
        function AnimationWeightTimelineState() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AnimationWeightTimelineState.toString = function () {
            return "[class dragonBones.AnimationWeightTimelineState]";
        };
        AnimationWeightTimelineState.prototype._onUpdateFrame = function () {
            _super.prototype._onUpdateFrame.call(this);
            var animationState = this.target;
            if (animationState._parent !== null) {
                animationState.weight = this._result;
            }
            this.dirty = false;
        };
        AnimationWeightTimelineState.prototype.init = function (armature, animationState, timelineData) {
            _super.prototype.init.call(this, armature, animationState, timelineData);
            this._valueOffset = this._animationData.frameIntOffset;
            this._valueScale = 0.0001;
            this._valueArray = this._animationData.parent.parent.frameIntArray;
        };
        return AnimationWeightTimelineState;
    }(dragonBones.SingleValueTimelineState));
    dragonBones.AnimationWeightTimelineState = AnimationWeightTimelineState;
    /**
     * @internal
     */
    var AnimationParametersTimelineState = /** @class */ (function (_super) {
        __extends(AnimationParametersTimelineState, _super);
        function AnimationParametersTimelineState() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AnimationParametersTimelineState.toString = function () {
            return "[class dragonBones.AnimationParametersTimelineState]";
        };
        AnimationParametersTimelineState.prototype._onUpdateFrame = function () {
            _super.prototype._onUpdateFrame.call(this);
            var animationState = this.target;
            if (animationState._parent !== null) {
                animationState.parameterX = this._resultA;
                animationState.parameterY = this._resultB;
            }
            this.dirty = false;
        };
        AnimationParametersTimelineState.prototype.init = function (armature, animationState, timelineData) {
            _super.prototype.init.call(this, armature, animationState, timelineData);
            this._valueOffset = this._animationData.frameIntOffset;
            this._valueScale = 0.0001;
            this._valueArray = this._animationData.parent.parent.frameIntArray;
        };
        return AnimationParametersTimelineState;
    }(dragonBones.DoubleValueTimelineState));
    dragonBones.AnimationParametersTimelineState = AnimationParametersTimelineState;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * - The properties of the object carry basic information about an event,
     * which are passed as parameter or parameter's parameter to event listeners when an event occurs.
     * @version DragonBones 4.5
     * @language en_US
     */
    /**
     * - 事件对象，包含有关事件的基本信息，当发生事件时，该实例将作为参数或参数的参数传递给事件侦听器。
     * @version DragonBones 4.5
     * @language zh_CN
     */
    var EventObject = /** @class */ (function (_super) {
        __extends(EventObject, _super);
        function EventObject() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @internal
         * @private
         */
        EventObject.actionDataToInstance = function (data, instance, armature) {
            if (data.type === 0 /* Play */) {
                instance.type = EventObject.FRAME_EVENT;
            }
            else {
                instance.type = data.type === 10 /* Frame */ ? EventObject.FRAME_EVENT : EventObject.SOUND_EVENT;
            }
            instance.name = data.name;
            instance.armature = armature;
            instance.actionData = data;
            instance.data = data.data;
            if (data.bone !== null) {
                instance.bone = armature.getBone(data.bone.name);
            }
            if (data.slot !== null) {
                instance.slot = armature.getSlot(data.slot.name);
            }
        };
        EventObject.toString = function () {
            return "[class dragonBones.EventObject]";
        };
        EventObject.prototype._onClear = function () {
            this.time = 0.0;
            this.type = "";
            this.name = "";
            this.armature = null;
            this.bone = null;
            this.slot = null;
            this.animationState = null;
            this.actionData = null;
            this.data = null;
        };
        /**
         * - Animation start play.
         * @version DragonBones 4.5
         * @language en_US
         */
        /**
         * - 动画开始播放。
         * @version DragonBones 4.5
         * @language zh_CN
         */
        EventObject.START = "start";
        /**
         * - Animation loop play complete once.
         * @version DragonBones 4.5
         * @language en_US
         */
        /**
         * - 动画循环播放完成一次。
         * @version DragonBones 4.5
         * @language zh_CN
         */
        EventObject.LOOP_COMPLETE = "loopComplete";
        /**
         * - Animation play complete.
         * @version DragonBones 4.5
         * @language en_US
         */
        /**
         * - 动画播放完成。
         * @version DragonBones 4.5
         * @language zh_CN
         */
        EventObject.COMPLETE = "complete";
        /**
         * - Animation fade in start.
         * @version DragonBones 4.5
         * @language en_US
         */
        /**
         * - 动画淡入开始。
         * @version DragonBones 4.5
         * @language zh_CN
         */
        EventObject.FADE_IN = "fadeIn";
        /**
         * - Animation fade in complete.
         * @version DragonBones 4.5
         * @language en_US
         */
        /**
         * - 动画淡入完成。
         * @version DragonBones 4.5
         * @language zh_CN
         */
        EventObject.FADE_IN_COMPLETE = "fadeInComplete";
        /**
         * - Animation fade out start.
         * @version DragonBones 4.5
         * @language en_US
         */
        /**
         * - 动画淡出开始。
         * @version DragonBones 4.5
         * @language zh_CN
         */
        EventObject.FADE_OUT = "fadeOut";
        /**
         * - Animation fade out complete.
         * @version DragonBones 4.5
         * @language en_US
         */
        /**
         * - 动画淡出完成。
         * @version DragonBones 4.5
         * @language zh_CN
         */
        EventObject.FADE_OUT_COMPLETE = "fadeOutComplete";
        /**
         * - Animation frame event.
         * @version DragonBones 4.5
         * @language en_US
         */
        /**
         * - 动画帧事件。
         * @version DragonBones 4.5
         * @language zh_CN
         */
        EventObject.FRAME_EVENT = "frameEvent";
        /**
         * - Animation frame sound event.
         * @version DragonBones 4.5
         * @language en_US
         */
        /**
         * - 动画帧声音事件。
         * @version DragonBones 4.5
         * @language zh_CN
         */
        EventObject.SOUND_EVENT = "soundEvent";
        return EventObject;
    }(dragonBones.BaseObject));
    dragonBones.EventObject = EventObject;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * @private
     */
    var DataParser = /** @class */ (function () {
        function DataParser() {
        }
        DataParser._getArmatureType = function (value) {
            switch (value.toLowerCase()) {
                case "stage":
                    return 2 /* Stage */;
                case "armature":
                    return 0 /* Armature */;
                case "movieclip":
                    return 1 /* MovieClip */;
                default:
                    return 0 /* Armature */;
            }
        };
        DataParser._getBoneType = function (value) {
            switch (value.toLowerCase()) {
                case "bone":
                    return 0 /* Bone */;
                case "surface":
                    return 1 /* Surface */;
                default:
                    return 0 /* Bone */;
            }
        };
        DataParser._getPositionMode = function (value) {
            switch (value.toLocaleLowerCase()) {
                case "percent":
                    return 1 /* Percent */;
                case "fixed":
                    return 0 /* Fixed */;
                default:
                    return 1 /* Percent */;
            }
        };
        DataParser._getSpacingMode = function (value) {
            switch (value.toLocaleLowerCase()) {
                case "length":
                    return 0 /* Length */;
                case "percent":
                    return 2 /* Percent */;
                case "fixed":
                    return 1 /* Fixed */;
                default:
                    return 0 /* Length */;
            }
        };
        DataParser._getRotateMode = function (value) {
            switch (value.toLocaleLowerCase()) {
                case "tangent":
                    return 0 /* Tangent */;
                case "chain":
                    return 1 /* Chain */;
                case "chainscale":
                    return 2 /* ChainScale */;
                default:
                    return 0 /* Tangent */;
            }
        };
        DataParser._getDisplayType = function (value) {
            switch (value.toLowerCase()) {
                case "image":
                    return 0 /* Image */;
                case "mesh":
                    return 2 /* Mesh */;
                case "armature":
                    return 1 /* Armature */;
                case "boundingbox":
                    return 3 /* BoundingBox */;
                case "path":
                    return 4 /* Path */;
                default:
                    return 0 /* Image */;
            }
        };
        DataParser._getBoundingBoxType = function (value) {
            switch (value.toLowerCase()) {
                case "rectangle":
                    return 0 /* Rectangle */;
                case "ellipse":
                    return 1 /* Ellipse */;
                case "polygon":
                    return 2 /* Polygon */;
                default:
                    return 0 /* Rectangle */;
            }
        };
        DataParser._getBlendMode = function (value) {
            switch (value.toLowerCase()) {
                case "normal":
                    return 0 /* Normal */;
                case "add":
                    return 1 /* Add */;
                case "alpha":
                    return 2 /* Alpha */;
                case "darken":
                    return 3 /* Darken */;
                case "difference":
                    return 4 /* Difference */;
                case "erase":
                    return 5 /* Erase */;
                case "hardlight":
                    return 6 /* HardLight */;
                case "invert":
                    return 7 /* Invert */;
                case "layer":
                    return 8 /* Layer */;
                case "lighten":
                    return 9 /* Lighten */;
                case "multiply":
                    return 10 /* Multiply */;
                case "overlay":
                    return 11 /* Overlay */;
                case "screen":
                    return 12 /* Screen */;
                case "subtract":
                    return 13 /* Subtract */;
                default:
                    return 0 /* Normal */;
            }
        };
        DataParser._getAnimationBlendType = function (value) {
            switch (value.toLowerCase()) {
                case "none":
                    return 0 /* None */;
                case "1d":
                    return 1 /* E1D */;
                default:
                    return 0 /* None */;
            }
        };
        DataParser._getActionType = function (value) {
            switch (value.toLowerCase()) {
                case "play":
                    return 0 /* Play */;
                case "frame":
                    return 10 /* Frame */;
                case "sound":
                    return 11 /* Sound */;
                default:
                    return 0 /* Play */;
            }
        };
        DataParser.DATA_VERSION_2_3 = "2.3";
        DataParser.DATA_VERSION_3_0 = "3.0";
        DataParser.DATA_VERSION_4_0 = "4.0";
        DataParser.DATA_VERSION_4_5 = "4.5";
        DataParser.DATA_VERSION_5_0 = "5.0";
        DataParser.DATA_VERSION_5_5 = "5.5";
        DataParser.DATA_VERSION_5_6 = "5.6";
        DataParser.DATA_VERSION = DataParser.DATA_VERSION_5_6;
        DataParser.DATA_VERSIONS = [
            DataParser.DATA_VERSION_4_0,
            DataParser.DATA_VERSION_4_5,
            DataParser.DATA_VERSION_5_0,
            DataParser.DATA_VERSION_5_5,
            DataParser.DATA_VERSION_5_6
        ];
        DataParser.TEXTURE_ATLAS = "textureAtlas";
        DataParser.SUB_TEXTURE = "SubTexture";
        DataParser.FORMAT = "format";
        DataParser.IMAGE_PATH = "imagePath";
        DataParser.WIDTH = "width";
        DataParser.HEIGHT = "height";
        DataParser.ROTATED = "rotated";
        DataParser.FRAME_X = "frameX";
        DataParser.FRAME_Y = "frameY";
        DataParser.FRAME_WIDTH = "frameWidth";
        DataParser.FRAME_HEIGHT = "frameHeight";
        DataParser.DRADON_BONES = "dragonBones";
        DataParser.USER_DATA = "userData";
        DataParser.ARMATURE = "armature";
        DataParser.CANVAS = "canvas";
        DataParser.BONE = "bone";
        DataParser.SURFACE = "surface";
        DataParser.SLOT = "slot";
        DataParser.CONSTRAINT = "constraint";
        DataParser.SKIN = "skin";
        DataParser.DISPLAY = "display";
        DataParser.FRAME = "frame";
        DataParser.IK = "ik";
        DataParser.PATH_CONSTRAINT = "path";
        DataParser.ANIMATION = "animation";
        DataParser.TIMELINE = "timeline";
        DataParser.FFD = "ffd";
        DataParser.TRANSLATE_FRAME = "translateFrame";
        DataParser.ROTATE_FRAME = "rotateFrame";
        DataParser.SCALE_FRAME = "scaleFrame";
        DataParser.DISPLAY_FRAME = "displayFrame";
        DataParser.COLOR_FRAME = "colorFrame";
        DataParser.DEFAULT_ACTIONS = "defaultActions";
        DataParser.ACTIONS = "actions";
        DataParser.EVENTS = "events";
        DataParser.INTS = "ints";
        DataParser.FLOATS = "floats";
        DataParser.STRINGS = "strings";
        DataParser.TRANSFORM = "transform";
        DataParser.PIVOT = "pivot";
        DataParser.AABB = "aabb";
        DataParser.COLOR = "color";
        DataParser.VERSION = "version";
        DataParser.COMPATIBLE_VERSION = "compatibleVersion";
        DataParser.FRAME_RATE = "frameRate";
        DataParser.TYPE = "type";
        DataParser.SUB_TYPE = "subType";
        DataParser.NAME = "name";
        DataParser.PARENT = "parent";
        DataParser.TARGET = "target";
        DataParser.STAGE = "stage";
        DataParser.SHARE = "share";
        DataParser.PATH = "path";
        DataParser.LENGTH = "length";
        DataParser.DISPLAY_INDEX = "displayIndex";
        DataParser.Z_ORDER = "zOrder";
        DataParser.Z_INDEX = "zIndex";
        DataParser.BLEND_MODE = "blendMode";
        DataParser.INHERIT_TRANSLATION = "inheritTranslation";
        DataParser.INHERIT_ROTATION = "inheritRotation";
        DataParser.INHERIT_SCALE = "inheritScale";
        DataParser.INHERIT_REFLECTION = "inheritReflection";
        DataParser.INHERIT_ANIMATION = "inheritAnimation";
        DataParser.INHERIT_DEFORM = "inheritDeform";
        DataParser.SEGMENT_X = "segmentX";
        DataParser.SEGMENT_Y = "segmentY";
        DataParser.BEND_POSITIVE = "bendPositive";
        DataParser.CHAIN = "chain";
        DataParser.WEIGHT = "weight";
        DataParser.BLEND_TYPE = "blendType";
        DataParser.FADE_IN_TIME = "fadeInTime";
        DataParser.PLAY_TIMES = "playTimes";
        DataParser.SCALE = "scale";
        DataParser.OFFSET = "offset";
        DataParser.POSITION = "position";
        DataParser.DURATION = "duration";
        DataParser.TWEEN_EASING = "tweenEasing";
        DataParser.TWEEN_ROTATE = "tweenRotate";
        DataParser.TWEEN_SCALE = "tweenScale";
        DataParser.CLOCK_WISE = "clockwise";
        DataParser.CURVE = "curve";
        DataParser.SOUND = "sound";
        DataParser.EVENT = "event";
        DataParser.ACTION = "action";
        DataParser.X = "x";
        DataParser.Y = "y";
        DataParser.SKEW_X = "skX";
        DataParser.SKEW_Y = "skY";
        DataParser.SCALE_X = "scX";
        DataParser.SCALE_Y = "scY";
        DataParser.VALUE = "value";
        DataParser.ROTATE = "rotate";
        DataParser.SKEW = "skew";
        DataParser.ALPHA = "alpha";
        DataParser.ALPHA_OFFSET = "aO";
        DataParser.RED_OFFSET = "rO";
        DataParser.GREEN_OFFSET = "gO";
        DataParser.BLUE_OFFSET = "bO";
        DataParser.ALPHA_MULTIPLIER = "aM";
        DataParser.RED_MULTIPLIER = "rM";
        DataParser.GREEN_MULTIPLIER = "gM";
        DataParser.BLUE_MULTIPLIER = "bM";
        DataParser.UVS = "uvs";
        DataParser.VERTICES = "vertices";
        DataParser.TRIANGLES = "triangles";
        DataParser.WEIGHTS = "weights";
        DataParser.SLOT_POSE = "slotPose";
        DataParser.BONE_POSE = "bonePose";
        DataParser.BONES = "bones";
        DataParser.POSITION_MODE = "positionMode";
        DataParser.SPACING_MODE = "spacingMode";
        DataParser.ROTATE_MODE = "rotateMode";
        DataParser.SPACING = "spacing";
        DataParser.ROTATE_OFFSET = "rotateOffset";
        DataParser.ROTATE_MIX = "rotateMix";
        DataParser.TRANSLATE_MIX = "translateMix";
        DataParser.TARGET_DISPLAY = "targetDisplay";
        DataParser.CLOSED = "closed";
        DataParser.CONSTANT_SPEED = "constantSpeed";
        DataParser.VERTEX_COUNT = "vertexCount";
        DataParser.LENGTHS = "lengths";
        DataParser.GOTO_AND_PLAY = "gotoAndPlay";
        DataParser.DEFAULT_NAME = "default";
        return DataParser;
    }());
    dragonBones.DataParser = DataParser;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * @private
     */
    var ObjectDataParser = /** @class */ (function (_super) {
        __extends(ObjectDataParser, _super);
        function ObjectDataParser() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._rawTextureAtlasIndex = 0;
            _this._rawBones = [];
            _this._data = null; //
            _this._armature = null; //
            _this._bone = null; //
            _this._geometry = null; //
            _this._slot = null; //
            _this._skin = null; //
            _this._mesh = null; //
            _this._animation = null; //
            _this._timeline = null; //
            _this._rawTextureAtlases = null;
            _this._frameValueType = 0 /* Step */;
            _this._defaultColorOffset = -1;
            _this._prevClockwise = 0;
            _this._prevRotation = 0.0;
            _this._frameDefaultValue = 0.0;
            _this._frameValueScale = 1.0;
            _this._helpMatrixA = new dragonBones.Matrix();
            _this._helpMatrixB = new dragonBones.Matrix();
            _this._helpTransform = new dragonBones.Transform();
            _this._helpColorTransform = new dragonBones.ColorTransform();
            _this._helpPoint = new dragonBones.Point();
            _this._helpArray = [];
            _this._intArray = [];
            _this._floatArray = [];
            _this._frameIntArray = [];
            _this._frameFloatArray = [];
            _this._frameArray = [];
            _this._timelineArray = [];
            _this._colorArray = [];
            _this._cacheRawMeshes = [];
            _this._cacheMeshes = [];
            _this._actionFrames = [];
            _this._weightSlotPose = {};
            _this._weightBonePoses = {};
            _this._cacheBones = {};
            _this._slotChildActions = {};
            return _this;
        }
        ObjectDataParser._getBoolean = function (rawData, key, defaultValue) {
            if (key in rawData) {
                var value = rawData[key];
                var type = typeof value;
                if (type === "boolean") {
                    return value;
                }
                else if (type === "string") {
                    switch (value) {
                        case "0":
                        case "NaN":
                        case "":
                        case "false":
                        case "null":
                        case "undefined":
                            return false;
                        default:
                            return true;
                    }
                }
                else {
                    return !!value;
                }
            }
            return defaultValue;
        };
        ObjectDataParser._getNumber = function (rawData, key, defaultValue) {
            if (key in rawData) {
                var value = rawData[key];
                if (value === null || value === "NaN") {
                    return defaultValue;
                }
                return +value || 0;
            }
            return defaultValue;
        };
        ObjectDataParser._getString = function (rawData, key, defaultValue) {
            if (key in rawData) {
                var value = rawData[key];
                var type = typeof value;
                if (type === "string") {
                    return value;
                }
                return String(value);
            }
            return defaultValue;
        };
        ObjectDataParser.prototype._getCurvePoint = function (x1, y1, x2, y2, x3, y3, x4, y4, t, result) {
            var l_t = 1.0 - t;
            var powA = l_t * l_t;
            var powB = t * t;
            var kA = l_t * powA;
            var kB = 3.0 * t * powA;
            var kC = 3.0 * l_t * powB;
            var kD = t * powB;
            result.x = kA * x1 + kB * x2 + kC * x3 + kD * x4;
            result.y = kA * y1 + kB * y2 + kC * y3 + kD * y4;
        };
        ObjectDataParser.prototype._samplingEasingCurve = function (curve, samples) {
            var curveCount = curve.length;
            if (curveCount % 3 === 1) {
                var stepIndex = -2;
                for (var i = 0, l = samples.length; i < l; ++i) {
                    var t = (i + 1) / (l + 1); // float
                    while ((stepIndex + 6 < curveCount ? curve[stepIndex + 6] : 1) < t) { // stepIndex + 3 * 2
                        stepIndex += 6;
                    }
                    var isInCurve = stepIndex >= 0 && stepIndex + 6 < curveCount;
                    var x1 = isInCurve ? curve[stepIndex] : 0.0;
                    var y1 = isInCurve ? curve[stepIndex + 1] : 0.0;
                    var x2 = curve[stepIndex + 2];
                    var y2 = curve[stepIndex + 3];
                    var x3 = curve[stepIndex + 4];
                    var y3 = curve[stepIndex + 5];
                    var x4 = isInCurve ? curve[stepIndex + 6] : 1.0;
                    var y4 = isInCurve ? curve[stepIndex + 7] : 1.0;
                    var lower = 0.0;
                    var higher = 1.0;
                    while (higher - lower > 0.0001) {
                        var percentage = (higher + lower) * 0.5;
                        this._getCurvePoint(x1, y1, x2, y2, x3, y3, x4, y4, percentage, this._helpPoint);
                        if (t - this._helpPoint.x > 0.0) {
                            lower = percentage;
                        }
                        else {
                            higher = percentage;
                        }
                    }
                    samples[i] = this._helpPoint.y;
                }
                return true;
            }
            else {
                var stepIndex = 0;
                for (var i = 0, l = samples.length; i < l; ++i) {
                    var t = (i + 1) / (l + 1); // float
                    while (curve[stepIndex + 6] < t) { // stepIndex + 3 * 2
                        stepIndex += 6;
                    }
                    var x1 = curve[stepIndex];
                    var y1 = curve[stepIndex + 1];
                    var x2 = curve[stepIndex + 2];
                    var y2 = curve[stepIndex + 3];
                    var x3 = curve[stepIndex + 4];
                    var y3 = curve[stepIndex + 5];
                    var x4 = curve[stepIndex + 6];
                    var y4 = curve[stepIndex + 7];
                    var lower = 0.0;
                    var higher = 1.0;
                    while (higher - lower > 0.0001) {
                        var percentage = (higher + lower) * 0.5;
                        this._getCurvePoint(x1, y1, x2, y2, x3, y3, x4, y4, percentage, this._helpPoint);
                        if (t - this._helpPoint.x > 0.0) {
                            lower = percentage;
                        }
                        else {
                            higher = percentage;
                        }
                    }
                    samples[i] = this._helpPoint.y;
                }
                return false;
            }
        };
        ObjectDataParser.prototype._parseActionDataInFrame = function (rawData, frameStart, bone, slot) {
            if (dragonBones.DataParser.EVENT in rawData) {
                this._mergeActionFrame(rawData[dragonBones.DataParser.EVENT], frameStart, 10 /* Frame */, bone, slot);
            }
            if (dragonBones.DataParser.SOUND in rawData) {
                this._mergeActionFrame(rawData[dragonBones.DataParser.SOUND], frameStart, 11 /* Sound */, bone, slot);
            }
            if (dragonBones.DataParser.ACTION in rawData) {
                this._mergeActionFrame(rawData[dragonBones.DataParser.ACTION], frameStart, 0 /* Play */, bone, slot);
            }
            if (dragonBones.DataParser.EVENTS in rawData) {
                this._mergeActionFrame(rawData[dragonBones.DataParser.EVENTS], frameStart, 10 /* Frame */, bone, slot);
            }
            if (dragonBones.DataParser.ACTIONS in rawData) {
                this._mergeActionFrame(rawData[dragonBones.DataParser.ACTIONS], frameStart, 0 /* Play */, bone, slot);
            }
        };
        ObjectDataParser.prototype._mergeActionFrame = function (rawData, frameStart, type, bone, slot) {
            var actionOffset = this._armature.actions.length;
            var actions = this._parseActionData(rawData, type, bone, slot);
            var frameIndex = 0;
            var frame = null;
            for (var _i = 0, actions_2 = actions; _i < actions_2.length; _i++) {
                var action = actions_2[_i];
                this._armature.addAction(action, false);
            }
            if (this._actionFrames.length === 0) { // First frame.
                frame = new ActionFrame();
                frame.frameStart = 0;
                this._actionFrames.push(frame);
                frame = null;
            }
            for (var _a = 0, _b = this._actionFrames; _a < _b.length; _a++) { // Get same frame.
                var eachFrame = _b[_a];
                if (eachFrame.frameStart === frameStart) {
                    frame = eachFrame;
                    break;
                }
                else if (eachFrame.frameStart > frameStart) {
                    break;
                }
                frameIndex++;
            }
            if (frame === null) { // Create and cache frame.
                frame = new ActionFrame();
                frame.frameStart = frameStart;
                this._actionFrames.splice(frameIndex, 0, frame);
            }
            for (var i = 0; i < actions.length; ++i) { // Cache action offsets.
                frame.actions.push(actionOffset + i);
            }
        };
        ObjectDataParser.prototype._parseArmature = function (rawData, scale) {
            var armature = dragonBones.BaseObject.borrowObject(dragonBones.ArmatureData);
            armature.name = ObjectDataParser._getString(rawData, dragonBones.DataParser.NAME, "");
            armature.frameRate = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.FRAME_RATE, this._data.frameRate);
            armature.scale = scale;
            if (dragonBones.DataParser.TYPE in rawData && typeof rawData[dragonBones.DataParser.TYPE] === "string") {
                armature.type = dragonBones.DataParser._getArmatureType(rawData[dragonBones.DataParser.TYPE]);
            }
            else {
                armature.type = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.TYPE, 0 /* Armature */);
            }
            if (armature.frameRate === 0) { // Data error.
                armature.frameRate = 24;
            }
            this._armature = armature;
            if (dragonBones.DataParser.CANVAS in rawData) {
                var rawCanvas = rawData[dragonBones.DataParser.CANVAS];
                var canvas = dragonBones.BaseObject.borrowObject(dragonBones.CanvasData);
                if (dragonBones.DataParser.COLOR in rawCanvas) {
                    canvas.hasBackground = true;
                }
                else {
                    canvas.hasBackground = false;
                }
                canvas.color = ObjectDataParser._getNumber(rawCanvas, dragonBones.DataParser.COLOR, 0);
                canvas.x = ObjectDataParser._getNumber(rawCanvas, dragonBones.DataParser.X, 0) * armature.scale;
                canvas.y = ObjectDataParser._getNumber(rawCanvas, dragonBones.DataParser.Y, 0) * armature.scale;
                canvas.width = ObjectDataParser._getNumber(rawCanvas, dragonBones.DataParser.WIDTH, 0) * armature.scale;
                canvas.height = ObjectDataParser._getNumber(rawCanvas, dragonBones.DataParser.HEIGHT, 0) * armature.scale;
                armature.canvas = canvas;
            }
            if (dragonBones.DataParser.AABB in rawData) {
                var rawAABB = rawData[dragonBones.DataParser.AABB];
                armature.aabb.x = ObjectDataParser._getNumber(rawAABB, dragonBones.DataParser.X, 0.0) * armature.scale;
                armature.aabb.y = ObjectDataParser._getNumber(rawAABB, dragonBones.DataParser.Y, 0.0) * armature.scale;
                armature.aabb.width = ObjectDataParser._getNumber(rawAABB, dragonBones.DataParser.WIDTH, 0.0) * armature.scale;
                armature.aabb.height = ObjectDataParser._getNumber(rawAABB, dragonBones.DataParser.HEIGHT, 0.0) * armature.scale;
            }
            if (dragonBones.DataParser.BONE in rawData) {
                var rawBones = rawData[dragonBones.DataParser.BONE];
                for (var _i = 0, rawBones_1 = rawBones; _i < rawBones_1.length; _i++) {
                    var rawBone = rawBones_1[_i];
                    var parentName = ObjectDataParser._getString(rawBone, dragonBones.DataParser.PARENT, "");
                    var bone = this._parseBone(rawBone);
                    if (parentName.length > 0) { // Get bone parent.
                        var parent_1 = armature.getBone(parentName);
                        if (parent_1 !== null) {
                            bone.parent = parent_1;
                        }
                        else { // Cache.
                            if (!(parentName in this._cacheBones)) {
                                this._cacheBones[parentName] = [];
                            }
                            this._cacheBones[parentName].push(bone);
                        }
                    }
                    if (bone.name in this._cacheBones) {
                        for (var _a = 0, _b = this._cacheBones[bone.name]; _a < _b.length; _a++) {
                            var child = _b[_a];
                            child.parent = bone;
                        }
                        delete this._cacheBones[bone.name];
                    }
                    armature.addBone(bone);
                    this._rawBones.push(bone); // Cache raw bones sort.
                }
            }
            if (dragonBones.DataParser.IK in rawData) {
                var rawIKS = rawData[dragonBones.DataParser.IK];
                for (var _c = 0, rawIKS_1 = rawIKS; _c < rawIKS_1.length; _c++) {
                    var rawIK = rawIKS_1[_c];
                    var constraint = this._parseIKConstraint(rawIK);
                    if (constraint) {
                        armature.addConstraint(constraint);
                    }
                }
            }
            armature.sortBones();
            if (dragonBones.DataParser.SLOT in rawData) {
                var zOrder = 0;
                var rawSlots = rawData[dragonBones.DataParser.SLOT];
                for (var _d = 0, rawSlots_1 = rawSlots; _d < rawSlots_1.length; _d++) {
                    var rawSlot = rawSlots_1[_d];
                    armature.addSlot(this._parseSlot(rawSlot, zOrder++));
                }
            }
            if (dragonBones.DataParser.SKIN in rawData) {
                var rawSkins = rawData[dragonBones.DataParser.SKIN];
                for (var _e = 0, rawSkins_1 = rawSkins; _e < rawSkins_1.length; _e++) {
                    var rawSkin = rawSkins_1[_e];
                    armature.addSkin(this._parseSkin(rawSkin));
                }
            }
            if (dragonBones.DataParser.PATH_CONSTRAINT in rawData) {
                var rawPaths = rawData[dragonBones.DataParser.PATH_CONSTRAINT];
                for (var _f = 0, rawPaths_1 = rawPaths; _f < rawPaths_1.length; _f++) {
                    var rawPath = rawPaths_1[_f];
                    var constraint = this._parsePathConstraint(rawPath);
                    if (constraint) {
                        armature.addConstraint(constraint);
                    }
                }
            }
            for (var i = 0, l = this._cacheRawMeshes.length; i < l; ++i) { // Link mesh.
                var rawData_1 = this._cacheRawMeshes[i];
                var shareName = ObjectDataParser._getString(rawData_1, dragonBones.DataParser.SHARE, "");
                if (shareName.length === 0) {
                    continue;
                }
                var skinName = ObjectDataParser._getString(rawData_1, dragonBones.DataParser.SKIN, dragonBones.DataParser.DEFAULT_NAME);
                if (skinName.length === 0) { // 
                    skinName = dragonBones.DataParser.DEFAULT_NAME;
                }
                var shareMesh = armature.getMesh(skinName, "", shareName); // TODO slot;
                if (shareMesh === null) {
                    continue; // Error.
                }
                var mesh = this._cacheMeshes[i];
                mesh.geometry.shareFrom(shareMesh.geometry);
            }
            if (dragonBones.DataParser.ANIMATION in rawData) {
                var rawAnimations = rawData[dragonBones.DataParser.ANIMATION];
                for (var _g = 0, rawAnimations_1 = rawAnimations; _g < rawAnimations_1.length; _g++) {
                    var rawAnimation = rawAnimations_1[_g];
                    var animation = this._parseAnimation(rawAnimation);
                    armature.addAnimation(animation);
                }
            }
            if (dragonBones.DataParser.DEFAULT_ACTIONS in rawData) {
                var actions = this._parseActionData(rawData[dragonBones.DataParser.DEFAULT_ACTIONS], 0 /* Play */, null, null);
                for (var _h = 0, actions_3 = actions; _h < actions_3.length; _h++) {
                    var action = actions_3[_h];
                    armature.addAction(action, true);
                    if (action.type === 0 /* Play */) { // Set default animation from default action.
                        var animation = armature.getAnimation(action.name);
                        if (animation !== null) {
                            armature.defaultAnimation = animation;
                        }
                    }
                }
            }
            if (dragonBones.DataParser.ACTIONS in rawData) {
                var actions = this._parseActionData(rawData[dragonBones.DataParser.ACTIONS], 0 /* Play */, null, null);
                for (var _j = 0, actions_4 = actions; _j < actions_4.length; _j++) {
                    var action = actions_4[_j];
                    armature.addAction(action, false);
                }
            }
            // Clear helper.
            this._rawBones.length = 0;
            this._cacheRawMeshes.length = 0;
            this._cacheMeshes.length = 0;
            this._armature = null;
            for (var k in this._weightSlotPose) {
                delete this._weightSlotPose[k];
            }
            for (var k in this._weightBonePoses) {
                delete this._weightBonePoses[k];
            }
            for (var k in this._cacheBones) {
                delete this._cacheBones[k];
            }
            for (var k in this._slotChildActions) {
                delete this._slotChildActions[k];
            }
            return armature;
        };
        ObjectDataParser.prototype._parseBone = function (rawData) {
            var type = 0 /* Bone */;
            if (dragonBones.DataParser.TYPE in rawData && typeof rawData[dragonBones.DataParser.TYPE] === "string") {
                type = dragonBones.DataParser._getBoneType(rawData[dragonBones.DataParser.TYPE]);
            }
            else {
                type = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.TYPE, 0 /* Bone */);
            }
            if (type === 0 /* Bone */) {
                var scale = this._armature.scale;
                var bone = dragonBones.BaseObject.borrowObject(dragonBones.BoneData);
                bone.inheritTranslation = ObjectDataParser._getBoolean(rawData, dragonBones.DataParser.INHERIT_TRANSLATION, true);
                bone.inheritRotation = ObjectDataParser._getBoolean(rawData, dragonBones.DataParser.INHERIT_ROTATION, true);
                bone.inheritScale = ObjectDataParser._getBoolean(rawData, dragonBones.DataParser.INHERIT_SCALE, true);
                bone.inheritReflection = ObjectDataParser._getBoolean(rawData, dragonBones.DataParser.INHERIT_REFLECTION, true);
                bone.length = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.LENGTH, 0) * scale;
                bone.alpha = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.ALPHA, 1.0);
                bone.name = ObjectDataParser._getString(rawData, dragonBones.DataParser.NAME, "");
                if (dragonBones.DataParser.TRANSFORM in rawData) {
                    this._parseTransform(rawData[dragonBones.DataParser.TRANSFORM], bone.transform, scale);
                }
                return bone;
            }
            var surface = dragonBones.BaseObject.borrowObject(dragonBones.SurfaceData);
            surface.alpha = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.ALPHA, 1.0);
            surface.name = ObjectDataParser._getString(rawData, dragonBones.DataParser.NAME, "");
            surface.segmentX = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.SEGMENT_X, 0);
            surface.segmentY = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.SEGMENT_Y, 0);
            this._parseGeometry(rawData, surface.geometry);
            return surface;
        };
        ObjectDataParser.prototype._parseIKConstraint = function (rawData) {
            var bone = this._armature.getBone(ObjectDataParser._getString(rawData, dragonBones.DataParser.BONE, ""));
            if (bone === null) {
                return null;
            }
            var target = this._armature.getBone(ObjectDataParser._getString(rawData, dragonBones.DataParser.TARGET, ""));
            if (target === null) {
                return null;
            }
            var chain = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.CHAIN, 0);
            var constraint = dragonBones.BaseObject.borrowObject(dragonBones.IKConstraintData);
            constraint.scaleEnabled = ObjectDataParser._getBoolean(rawData, dragonBones.DataParser.SCALE, false);
            constraint.bendPositive = ObjectDataParser._getBoolean(rawData, dragonBones.DataParser.BEND_POSITIVE, true);
            constraint.weight = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.WEIGHT, 1.0);
            constraint.name = ObjectDataParser._getString(rawData, dragonBones.DataParser.NAME, "");
            constraint.type = 0 /* IK */;
            constraint.target = target;
            if (chain > 0 && bone.parent !== null) {
                constraint.root = bone.parent;
                constraint.bone = bone;
            }
            else {
                constraint.root = bone;
                constraint.bone = null;
            }
            return constraint;
        };
        ObjectDataParser.prototype._parsePathConstraint = function (rawData) {
            var target = this._armature.getSlot(ObjectDataParser._getString(rawData, dragonBones.DataParser.TARGET, ""));
            if (target === null) {
                return null;
            }
            var defaultSkin = this._armature.defaultSkin;
            if (defaultSkin === null) {
                return null;
            }
            //TODO
            var targetDisplay = defaultSkin.getDisplay(target.name, ObjectDataParser._getString(rawData, dragonBones.DataParser.TARGET_DISPLAY, target.name));
            if (targetDisplay === null || !(targetDisplay instanceof dragonBones.PathDisplayData)) {
                return null;
            }
            var bones = rawData[dragonBones.DataParser.BONES];
            if (bones === null || bones.length === 0) {
                return null;
            }
            var constraint = dragonBones.BaseObject.borrowObject(dragonBones.PathConstraintData);
            constraint.name = ObjectDataParser._getString(rawData, dragonBones.DataParser.NAME, "");
            constraint.type = 1 /* Path */;
            constraint.pathSlot = target;
            constraint.pathDisplayData = targetDisplay;
            constraint.target = target.parent;
            constraint.positionMode = dragonBones.DataParser._getPositionMode(ObjectDataParser._getString(rawData, dragonBones.DataParser.POSITION_MODE, ""));
            constraint.spacingMode = dragonBones.DataParser._getSpacingMode(ObjectDataParser._getString(rawData, dragonBones.DataParser.SPACING_MODE, ""));
            constraint.rotateMode = dragonBones.DataParser._getRotateMode(ObjectDataParser._getString(rawData, dragonBones.DataParser.ROTATE_MODE, ""));
            constraint.position = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.POSITION, 0);
            constraint.spacing = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.SPACING, 0);
            constraint.rotateOffset = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.ROTATE_OFFSET, 0);
            constraint.rotateMix = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.ROTATE_MIX, 1);
            constraint.translateMix = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.TRANSLATE_MIX, 1);
            //
            for (var _i = 0, bones_3 = bones; _i < bones_3.length; _i++) {
                var boneName = bones_3[_i];
                var bone = this._armature.getBone(boneName);
                if (bone !== null) {
                    constraint.AddBone(bone);
                    if (constraint.root === null) {
                        constraint.root = bone;
                    }
                }
            }
            return constraint;
        };
        ObjectDataParser.prototype._parseSlot = function (rawData, zOrder) {
            var slot = dragonBones.BaseObject.borrowObject(dragonBones.SlotData);
            slot.displayIndex = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.DISPLAY_INDEX, 0);
            slot.zOrder = zOrder;
            slot.zIndex = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.Z_INDEX, 0);
            slot.alpha = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.ALPHA, 1.0);
            slot.name = ObjectDataParser._getString(rawData, dragonBones.DataParser.NAME, "");
            slot.parent = this._armature.getBone(ObjectDataParser._getString(rawData, dragonBones.DataParser.PARENT, "")); //
            if (dragonBones.DataParser.BLEND_MODE in rawData && typeof rawData[dragonBones.DataParser.BLEND_MODE] === "string") {
                slot.blendMode = dragonBones.DataParser._getBlendMode(rawData[dragonBones.DataParser.BLEND_MODE]);
            }
            else {
                slot.blendMode = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.BLEND_MODE, 0 /* Normal */);
            }
            if (dragonBones.DataParser.COLOR in rawData) {
                slot.color = dragonBones.SlotData.createColor();
                this._parseColorTransform(rawData[dragonBones.DataParser.COLOR], slot.color);
            }
            else {
                slot.color = dragonBones.SlotData.DEFAULT_COLOR;
            }
            if (dragonBones.DataParser.ACTIONS in rawData) {
                this._slotChildActions[slot.name] = this._parseActionData(rawData[dragonBones.DataParser.ACTIONS], 0 /* Play */, null, null);
            }
            return slot;
        };
        ObjectDataParser.prototype._parseSkin = function (rawData) {
            var skin = dragonBones.BaseObject.borrowObject(dragonBones.SkinData);
            skin.name = ObjectDataParser._getString(rawData, dragonBones.DataParser.NAME, dragonBones.DataParser.DEFAULT_NAME);
            if (skin.name.length === 0) {
                skin.name = dragonBones.DataParser.DEFAULT_NAME;
            }
            if (dragonBones.DataParser.SLOT in rawData) {
                var rawSlots = rawData[dragonBones.DataParser.SLOT];
                this._skin = skin;
                for (var _i = 0, rawSlots_2 = rawSlots; _i < rawSlots_2.length; _i++) {
                    var rawSlot = rawSlots_2[_i];
                    var slotName = ObjectDataParser._getString(rawSlot, dragonBones.DataParser.NAME, "");
                    var slot = this._armature.getSlot(slotName);
                    if (slot !== null) {
                        this._slot = slot;
                        if (dragonBones.DataParser.DISPLAY in rawSlot) {
                            var rawDisplays = rawSlot[dragonBones.DataParser.DISPLAY];
                            for (var _a = 0, rawDisplays_1 = rawDisplays; _a < rawDisplays_1.length; _a++) {
                                var rawDisplay = rawDisplays_1[_a];
                                if (rawDisplay) {
                                    skin.addDisplay(slotName, this._parseDisplay(rawDisplay));
                                }
                                else {
                                    skin.addDisplay(slotName, null);
                                }
                            }
                        }
                        this._slot = null; //
                    }
                }
                this._skin = null; //
            }
            return skin;
        };
        ObjectDataParser.prototype._parseDisplay = function (rawData) {
            var name = ObjectDataParser._getString(rawData, dragonBones.DataParser.NAME, "");
            var path = ObjectDataParser._getString(rawData, dragonBones.DataParser.PATH, "");
            var type = 0 /* Image */;
            var display = null;
            if (dragonBones.DataParser.TYPE in rawData && typeof rawData[dragonBones.DataParser.TYPE] === "string") {
                type = dragonBones.DataParser._getDisplayType(rawData[dragonBones.DataParser.TYPE]);
            }
            else {
                type = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.TYPE, type);
            }
            switch (type) {
                case 0 /* Image */: {
                    var imageDisplay = display = dragonBones.BaseObject.borrowObject(dragonBones.ImageDisplayData);
                    imageDisplay.name = name;
                    imageDisplay.path = path.length > 0 ? path : name;
                    this._parsePivot(rawData, imageDisplay);
                    break;
                }
                case 1 /* Armature */: {
                    var armatureDisplay = display = dragonBones.BaseObject.borrowObject(dragonBones.ArmatureDisplayData);
                    armatureDisplay.name = name;
                    armatureDisplay.path = path.length > 0 ? path : name;
                    armatureDisplay.inheritAnimation = true;
                    if (dragonBones.DataParser.ACTIONS in rawData) {
                        var actions = this._parseActionData(rawData[dragonBones.DataParser.ACTIONS], 0 /* Play */, null, null);
                        for (var _i = 0, actions_5 = actions; _i < actions_5.length; _i++) {
                            var action = actions_5[_i];
                            armatureDisplay.addAction(action);
                        }
                    }
                    else if (this._slot.name in this._slotChildActions) {
                        var displays = this._skin.getDisplays(this._slot.name);
                        if (displays === null ? this._slot.displayIndex === 0 : this._slot.displayIndex === displays.length) {
                            for (var _a = 0, _b = this._slotChildActions[this._slot.name]; _a < _b.length; _a++) {
                                var action = _b[_a];
                                armatureDisplay.addAction(action);
                            }
                            delete this._slotChildActions[this._slot.name];
                        }
                    }
                    break;
                }
                case 2 /* Mesh */: {
                    var meshDisplay = display = dragonBones.BaseObject.borrowObject(dragonBones.MeshDisplayData);
                    meshDisplay.geometry.inheritDeform = ObjectDataParser._getBoolean(rawData, dragonBones.DataParser.INHERIT_DEFORM, true);
                    meshDisplay.name = name;
                    meshDisplay.path = path.length > 0 ? path : name;
                    if (dragonBones.DataParser.SHARE in rawData) {
                        meshDisplay.geometry.data = this._data;
                        this._cacheRawMeshes.push(rawData);
                        this._cacheMeshes.push(meshDisplay);
                    }
                    else {
                        this._parseMesh(rawData, meshDisplay);
                    }
                    break;
                }
                case 3 /* BoundingBox */: {
                    var boundingBox = this._parseBoundingBox(rawData);
                    if (boundingBox !== null) {
                        var boundingBoxDisplay = display = dragonBones.BaseObject.borrowObject(dragonBones.BoundingBoxDisplayData);
                        boundingBoxDisplay.name = name;
                        boundingBoxDisplay.path = path.length > 0 ? path : name;
                        boundingBoxDisplay.boundingBox = boundingBox;
                    }
                    break;
                }
                case 4 /* Path */: {
                    var rawCurveLengths = rawData[dragonBones.DataParser.LENGTHS];
                    var pathDisplay = display = dragonBones.BaseObject.borrowObject(dragonBones.PathDisplayData);
                    pathDisplay.closed = ObjectDataParser._getBoolean(rawData, dragonBones.DataParser.CLOSED, false);
                    pathDisplay.constantSpeed = ObjectDataParser._getBoolean(rawData, dragonBones.DataParser.CONSTANT_SPEED, false);
                    pathDisplay.name = name;
                    pathDisplay.path = path.length > 0 ? path : name;
                    pathDisplay.curveLengths.length = rawCurveLengths.length;
                    for (var i = 0, l = rawCurveLengths.length; i < l; ++i) {
                        pathDisplay.curveLengths[i] = rawCurveLengths[i];
                    }
                    this._parsePath(rawData, pathDisplay);
                    break;
                }
            }
            if (display !== null && dragonBones.DataParser.TRANSFORM in rawData) {
                this._parseTransform(rawData[dragonBones.DataParser.TRANSFORM], display.transform, this._armature.scale);
            }
            return display;
        };
        ObjectDataParser.prototype._parsePath = function (rawData, display) {
            this._parseGeometry(rawData, display.geometry);
        };
        ObjectDataParser.prototype._parsePivot = function (rawData, display) {
            if (dragonBones.DataParser.PIVOT in rawData) {
                var rawPivot = rawData[dragonBones.DataParser.PIVOT];
                display.pivot.x = ObjectDataParser._getNumber(rawPivot, dragonBones.DataParser.X, 0.0);
                display.pivot.y = ObjectDataParser._getNumber(rawPivot, dragonBones.DataParser.Y, 0.0);
            }
            else {
                display.pivot.x = 0.5;
                display.pivot.y = 0.5;
            }
        };
        ObjectDataParser.prototype._parseMesh = function (rawData, mesh) {
            this._parseGeometry(rawData, mesh.geometry);
            if (dragonBones.DataParser.WEIGHTS in rawData) { // Cache pose data.
                var rawSlotPose = rawData[dragonBones.DataParser.SLOT_POSE];
                var rawBonePoses = rawData[dragonBones.DataParser.BONE_POSE];
                var meshName = this._skin.name + "_" + this._slot.name + "_" + mesh.name;
                this._weightSlotPose[meshName] = rawSlotPose;
                this._weightBonePoses[meshName] = rawBonePoses;
            }
        };
        ObjectDataParser.prototype._parseBoundingBox = function (rawData) {
            var boundingBox = null;
            var type = 0 /* Rectangle */;
            if (dragonBones.DataParser.SUB_TYPE in rawData && typeof rawData[dragonBones.DataParser.SUB_TYPE] === "string") {
                type = dragonBones.DataParser._getBoundingBoxType(rawData[dragonBones.DataParser.SUB_TYPE]);
            }
            else {
                type = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.SUB_TYPE, type);
            }
            switch (type) {
                case 0 /* Rectangle */:
                    boundingBox = dragonBones.BaseObject.borrowObject(dragonBones.RectangleBoundingBoxData);
                    break;
                case 1 /* Ellipse */:
                    boundingBox = dragonBones.BaseObject.borrowObject(dragonBones.EllipseBoundingBoxData);
                    break;
                case 2 /* Polygon */:
                    boundingBox = this._parsePolygonBoundingBox(rawData);
                    break;
            }
            if (boundingBox !== null) {
                boundingBox.color = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.COLOR, 0x000000);
                if (boundingBox.type === 0 /* Rectangle */ || boundingBox.type === 1 /* Ellipse */) {
                    boundingBox.width = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.WIDTH, 0.0);
                    boundingBox.height = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.HEIGHT, 0.0);
                }
            }
            return boundingBox;
        };
        ObjectDataParser.prototype._parsePolygonBoundingBox = function (rawData) {
            var polygonBoundingBox = dragonBones.BaseObject.borrowObject(dragonBones.PolygonBoundingBoxData);
            if (dragonBones.DataParser.VERTICES in rawData) {
                var scale = this._armature.scale;
                var rawVertices = rawData[dragonBones.DataParser.VERTICES];
                var vertices = polygonBoundingBox.vertices;
                vertices.length = rawVertices.length;
                for (var i = 0, l = rawVertices.length; i < l; i += 2) {
                    var x = rawVertices[i] * scale;
                    var y = rawVertices[i + 1] * scale;
                    vertices[i] = x;
                    vertices[i + 1] = y;
                    // AABB.
                    if (i === 0) {
                        polygonBoundingBox.x = x;
                        polygonBoundingBox.y = y;
                        polygonBoundingBox.width = x;
                        polygonBoundingBox.height = y;
                    }
                    else {
                        if (x < polygonBoundingBox.x) {
                            polygonBoundingBox.x = x;
                        }
                        else if (x > polygonBoundingBox.width) {
                            polygonBoundingBox.width = x;
                        }
                        if (y < polygonBoundingBox.y) {
                            polygonBoundingBox.y = y;
                        }
                        else if (y > polygonBoundingBox.height) {
                            polygonBoundingBox.height = y;
                        }
                    }
                }
                polygonBoundingBox.width -= polygonBoundingBox.x;
                polygonBoundingBox.height -= polygonBoundingBox.y;
            }
            else {
                console.warn("Data error.\n Please reexport DragonBones Data to fixed the bug.");
            }
            return polygonBoundingBox;
        };
        ObjectDataParser.prototype._parseAnimation = function (rawData) {
            var animation = dragonBones.BaseObject.borrowObject(dragonBones.AnimationData);
            animation.blendType = dragonBones.DataParser._getAnimationBlendType(ObjectDataParser._getString(rawData, dragonBones.DataParser.BLEND_TYPE, ""));
            animation.frameCount = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.DURATION, 0);
            animation.playTimes = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.PLAY_TIMES, 1);
            animation.duration = animation.frameCount / this._armature.frameRate; // float
            animation.fadeInTime = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.FADE_IN_TIME, 0.0);
            animation.scale = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.SCALE, 1.0);
            animation.name = ObjectDataParser._getString(rawData, dragonBones.DataParser.NAME, dragonBones.DataParser.DEFAULT_NAME);
            if (animation.name.length === 0) {
                animation.name = dragonBones.DataParser.DEFAULT_NAME;
            }
            animation.frameIntOffset = this._frameIntArray.length;
            animation.frameFloatOffset = this._frameFloatArray.length;
            animation.frameOffset = this._frameArray.length;
            this._animation = animation;
            if (dragonBones.DataParser.FRAME in rawData) {
                var rawFrames = rawData[dragonBones.DataParser.FRAME];
                var keyFrameCount = rawFrames.length;
                if (keyFrameCount > 0) {
                    for (var i = 0, frameStart = 0; i < keyFrameCount; ++i) {
                        var rawFrame = rawFrames[i];
                        this._parseActionDataInFrame(rawFrame, frameStart, null, null);
                        frameStart += ObjectDataParser._getNumber(rawFrame, dragonBones.DataParser.DURATION, 1);
                    }
                }
            }
            if (dragonBones.DataParser.Z_ORDER in rawData) {
                this._animation.zOrderTimeline = this._parseTimeline(rawData[dragonBones.DataParser.Z_ORDER], null, dragonBones.DataParser.FRAME, 1 /* ZOrder */, 0 /* Step */, 0, this._parseZOrderFrame);
            }
            if (dragonBones.DataParser.BONE in rawData) {
                var rawTimelines = rawData[dragonBones.DataParser.BONE];
                for (var _i = 0, rawTimelines_1 = rawTimelines; _i < rawTimelines_1.length; _i++) {
                    var rawTimeline = rawTimelines_1[_i];
                    this._parseBoneTimeline(rawTimeline);
                }
            }
            if (dragonBones.DataParser.SLOT in rawData) {
                var rawTimelines = rawData[dragonBones.DataParser.SLOT];
                for (var _a = 0, rawTimelines_2 = rawTimelines; _a < rawTimelines_2.length; _a++) {
                    var rawTimeline = rawTimelines_2[_a];
                    this._parseSlotTimeline(rawTimeline);
                }
            }
            if (dragonBones.DataParser.FFD in rawData) {
                var rawTimelines = rawData[dragonBones.DataParser.FFD];
                for (var _b = 0, rawTimelines_3 = rawTimelines; _b < rawTimelines_3.length; _b++) {
                    var rawTimeline = rawTimelines_3[_b];
                    var skinName = ObjectDataParser._getString(rawTimeline, dragonBones.DataParser.SKIN, dragonBones.DataParser.DEFAULT_NAME);
                    var slotName = ObjectDataParser._getString(rawTimeline, dragonBones.DataParser.SLOT, "");
                    var displayName = ObjectDataParser._getString(rawTimeline, dragonBones.DataParser.NAME, "");
                    if (skinName.length === 0) { //
                        skinName = dragonBones.DataParser.DEFAULT_NAME;
                    }
                    this._slot = this._armature.getSlot(slotName);
                    this._mesh = this._armature.getMesh(skinName, slotName, displayName);
                    if (this._slot === null || this._mesh === null) {
                        continue;
                    }
                    var timeline = this._parseTimeline(rawTimeline, null, dragonBones.DataParser.FRAME, 22 /* SlotDeform */, 2 /* Float */, 0, this._parseSlotDeformFrame);
                    if (timeline !== null) {
                        this._animation.addSlotTimeline(slotName, timeline);
                    }
                    this._slot = null; //
                    this._mesh = null; //
                }
            }
            if (dragonBones.DataParser.IK in rawData) {
                var rawTimelines = rawData[dragonBones.DataParser.IK];
                for (var _c = 0, rawTimelines_4 = rawTimelines; _c < rawTimelines_4.length; _c++) {
                    var rawTimeline = rawTimelines_4[_c];
                    var constraintName = ObjectDataParser._getString(rawTimeline, dragonBones.DataParser.NAME, "");
                    var constraint = this._armature.getConstraint(constraintName);
                    if (constraint === null) {
                        continue;
                    }
                    var timeline = this._parseTimeline(rawTimeline, null, dragonBones.DataParser.FRAME, 30 /* IKConstraint */, 1 /* Int */, 2, this._parseIKConstraintFrame);
                    if (timeline !== null) {
                        this._animation.addConstraintTimeline(constraintName, timeline);
                    }
                }
            }
            if (this._actionFrames.length > 0) {
                this._animation.actionTimeline = this._parseTimeline(null, this._actionFrames, "", 0 /* Action */, 0 /* Step */, 0, this._parseActionFrame);
                this._actionFrames.length = 0;
            }
            if (dragonBones.DataParser.TIMELINE in rawData) {
                var rawTimelines = rawData[dragonBones.DataParser.TIMELINE];
                for (var _d = 0, rawTimelines_5 = rawTimelines; _d < rawTimelines_5.length; _d++) {
                    var rawTimeline = rawTimelines_5[_d];
                    var timelineType = ObjectDataParser._getNumber(rawTimeline, dragonBones.DataParser.TYPE, 0 /* Action */);
                    var timelineName = ObjectDataParser._getString(rawTimeline, dragonBones.DataParser.NAME, "");
                    var timeline = null;
                    switch (timelineType) {
                        case 0 /* Action */:
                            // TODO
                            break;
                        case 20 /* SlotDisplay */: // TODO
                        case 23 /* SlotZIndex */:
                        case 60 /* BoneAlpha */:
                        case 24 /* SlotAlpha */:
                        case 40 /* AnimationProgress */:
                        case 41 /* AnimationWeight */:
                            if (timelineType === 20 /* SlotDisplay */) {
                                this._frameValueType = 0 /* Step */;
                                this._frameValueScale = 1.0;
                            }
                            else {
                                this._frameValueType = 1 /* Int */;
                                if (timelineType === 23 /* SlotZIndex */) {
                                    this._frameValueScale = 1.0;
                                }
                                else if (timelineType === 40 /* AnimationProgress */ ||
                                    timelineType === 41 /* AnimationWeight */) {
                                    this._frameValueScale = 10000.0;
                                }
                                else {
                                    this._frameValueScale = 100.0;
                                }
                            }
                            if (timelineType === 60 /* BoneAlpha */ ||
                                timelineType === 24 /* SlotAlpha */ ||
                                timelineType === 41 /* AnimationWeight */) {
                                this._frameDefaultValue = 1.0;
                            }
                            else {
                                this._frameDefaultValue = 0.0;
                            }
                            if (timelineType === 40 /* AnimationProgress */ && animation.blendType !== 0 /* None */) {
                                timeline = dragonBones.BaseObject.borrowObject(dragonBones.AnimationTimelineData);
                                var animaitonTimeline = timeline;
                                animaitonTimeline.x = ObjectDataParser._getNumber(rawTimeline, dragonBones.DataParser.X, 0.0);
                                animaitonTimeline.y = ObjectDataParser._getNumber(rawTimeline, dragonBones.DataParser.Y, 0.0);
                            }
                            timeline = this._parseTimeline(rawTimeline, null, dragonBones.DataParser.FRAME, timelineType, this._frameValueType, 1, this._parseSingleValueFrame, timeline);
                            break;
                        case 11 /* BoneTranslate */:
                        case 12 /* BoneRotate */:
                        case 13 /* BoneScale */:
                        case 30 /* IKConstraint */:
                        case 42 /* AnimationParameter */:
                            if (timelineType === 30 /* IKConstraint */ ||
                                timelineType === 42 /* AnimationParameter */) {
                                this._frameValueType = 1 /* Int */;
                                if (timelineType === 42 /* AnimationParameter */) {
                                    this._frameValueScale = 10000.0;
                                }
                                else {
                                    this._frameValueScale = 100.0;
                                }
                            }
                            else {
                                if (timelineType === 12 /* BoneRotate */) {
                                    this._frameValueScale = dragonBones.Transform.DEG_RAD;
                                }
                                else {
                                    this._frameValueScale = 1.0;
                                }
                                this._frameValueType = 2 /* Float */;
                            }
                            if (timelineType === 13 /* BoneScale */ ||
                                timelineType === 30 /* IKConstraint */) {
                                this._frameDefaultValue = 1.0;
                            }
                            else {
                                this._frameDefaultValue = 0.0;
                            }
                            timeline = this._parseTimeline(rawTimeline, null, dragonBones.DataParser.FRAME, timelineType, this._frameValueType, 2, this._parseDoubleValueFrame);
                            break;
                        case 1 /* ZOrder */:
                            // TODO
                            break;
                        case 50 /* Surface */: {
                            var surface = this._armature.getBone(timelineName);
                            if (surface === null) {
                                continue;
                            }
                            this._geometry = surface.geometry;
                            timeline = this._parseTimeline(rawTimeline, null, dragonBones.DataParser.FRAME, timelineType, 2 /* Float */, 0, this._parseDeformFrame);
                            this._geometry = null; //
                            break;
                        }
                        case 22 /* SlotDeform */: {
                            this._geometry = null; //
                            for (var skinName in this._armature.skins) {
                                var skin = this._armature.skins[skinName];
                                for (var slontName in skin.displays) {
                                    var displays = skin.displays[slontName];
                                    for (var _e = 0, displays_1 = displays; _e < displays_1.length; _e++) {
                                        var display = displays_1[_e];
                                        if (display !== null && display.name === timelineName) {
                                            this._geometry = display.geometry;
                                            break;
                                        }
                                    }
                                }
                            }
                            if (this._geometry === null) {
                                continue;
                            }
                            timeline = this._parseTimeline(rawTimeline, null, dragonBones.DataParser.FRAME, timelineType, 2 /* Float */, 0, this._parseDeformFrame);
                            this._geometry = null; //
                            break;
                        }
                        case 21 /* SlotColor */:
                            timeline = this._parseTimeline(rawTimeline, null, dragonBones.DataParser.FRAME, timelineType, 1 /* Int */, 1, this._parseSlotColorFrame);
                            break;
                    }
                    if (timeline !== null) {
                        switch (timelineType) {
                            case 0 /* Action */:
                                // TODO
                                break;
                            case 1 /* ZOrder */:
                                // TODO
                                break;
                            case 11 /* BoneTranslate */:
                            case 12 /* BoneRotate */:
                            case 13 /* BoneScale */:
                            case 50 /* Surface */:
                            case 60 /* BoneAlpha */:
                                this._animation.addBoneTimeline(timelineName, timeline);
                                break;
                            case 20 /* SlotDisplay */:
                            case 21 /* SlotColor */:
                            case 22 /* SlotDeform */:
                            case 23 /* SlotZIndex */:
                            case 24 /* SlotAlpha */:
                                this._animation.addSlotTimeline(timelineName, timeline);
                                break;
                            case 30 /* IKConstraint */:
                                this._animation.addConstraintTimeline(timelineName, timeline);
                                break;
                            case 40 /* AnimationProgress */:
                            case 41 /* AnimationWeight */:
                            case 42 /* AnimationParameter */:
                                this._animation.addAnimationTimeline(timelineName, timeline);
                                break;
                        }
                    }
                }
            }
            this._animation = null; //
            return animation;
        };
        ObjectDataParser.prototype._parseTimeline = function (rawData, rawFrames, framesKey, timelineType, frameValueType, frameValueCount, frameParser, timeline) {
            if (timeline === void 0) { timeline = null; }
            if (rawData !== null && framesKey.length > 0 && framesKey in rawData) {
                rawFrames = rawData[framesKey];
            }
            if (rawFrames === null) {
                return null;
            }
            var keyFrameCount = rawFrames.length;
            if (keyFrameCount === 0) {
                return null;
            }
            var frameIntArrayLength = this._frameIntArray.length;
            var frameFloatArrayLength = this._frameFloatArray.length;
            var timelineOffset = this._timelineArray.length;
            if (timeline === null) {
                timeline = dragonBones.BaseObject.borrowObject(dragonBones.TimelineData);
            }
            timeline.type = timelineType;
            timeline.offset = timelineOffset;
            this._frameValueType = frameValueType;
            this._timeline = timeline;
            this._timelineArray.length += 1 + 1 + 1 + 1 + 1 + keyFrameCount;
            if (rawData !== null) {
                this._timelineArray[timelineOffset + 0 /* TimelineScale */] = Math.round(ObjectDataParser._getNumber(rawData, dragonBones.DataParser.SCALE, 1.0) * 100);
                this._timelineArray[timelineOffset + 1 /* TimelineOffset */] = Math.round(ObjectDataParser._getNumber(rawData, dragonBones.DataParser.OFFSET, 0.0) * 100);
            }
            else {
                this._timelineArray[timelineOffset + 0 /* TimelineScale */] = 100;
                this._timelineArray[timelineOffset + 1 /* TimelineOffset */] = 0;
            }
            this._timelineArray[timelineOffset + 2 /* TimelineKeyFrameCount */] = keyFrameCount;
            this._timelineArray[timelineOffset + 3 /* TimelineFrameValueCount */] = frameValueCount;
            switch (this._frameValueType) {
                case 0 /* Step */:
                    this._timelineArray[timelineOffset + 4 /* TimelineFrameValueOffset */] = 0;
                    break;
                case 1 /* Int */:
                    this._timelineArray[timelineOffset + 4 /* TimelineFrameValueOffset */] = frameIntArrayLength - this._animation.frameIntOffset;
                    break;
                case 2 /* Float */:
                    this._timelineArray[timelineOffset + 4 /* TimelineFrameValueOffset */] = frameFloatArrayLength - this._animation.frameFloatOffset;
                    break;
            }
            if (keyFrameCount === 1) { // Only one frame.
                timeline.frameIndicesOffset = -1;
                this._timelineArray[timelineOffset + 5 /* TimelineFrameOffset */ + 0] = frameParser.call(this, rawFrames[0], 0, 0) - this._animation.frameOffset;
            }
            else {
                var totalFrameCount = this._animation.frameCount + 1; // One more frame than animation.
                var frameIndices = this._data.frameIndices;
                var frameIndicesOffset = frameIndices.length;
                frameIndices.length += totalFrameCount;
                timeline.frameIndicesOffset = frameIndicesOffset;
                for (var i = 0, iK = 0, frameStart = 0, frameCount = 0; i < totalFrameCount; ++i) {
                    if (frameStart + frameCount <= i && iK < keyFrameCount) {
                        var rawFrame = rawFrames[iK];
                        frameStart = i; // frame.frameStart;
                        if (iK === keyFrameCount - 1) {
                            frameCount = this._animation.frameCount - frameStart;
                        }
                        else {
                            if (rawFrame instanceof ActionFrame) {
                                frameCount = this._actionFrames[iK + 1].frameStart - frameStart;
                            }
                            else {
                                frameCount = ObjectDataParser._getNumber(rawFrame, dragonBones.DataParser.DURATION, 1);
                            }
                        }
                        this._timelineArray[timelineOffset + 5 /* TimelineFrameOffset */ + iK] = frameParser.call(this, rawFrame, frameStart, frameCount) - this._animation.frameOffset;
                        iK++;
                    }
                    frameIndices[frameIndicesOffset + i] = iK - 1;
                }
            }
            this._timeline = null; //
            return timeline;
        };
        ObjectDataParser.prototype._parseBoneTimeline = function (rawData) {
            var bone = this._armature.getBone(ObjectDataParser._getString(rawData, dragonBones.DataParser.NAME, ""));
            if (bone === null) {
                return;
            }
            this._bone = bone;
            this._slot = this._armature.getSlot(this._bone.name);
            if (dragonBones.DataParser.TRANSLATE_FRAME in rawData) {
                this._frameDefaultValue = 0.0;
                this._frameValueScale = 1.0;
                var timeline = this._parseTimeline(rawData, null, dragonBones.DataParser.TRANSLATE_FRAME, 11 /* BoneTranslate */, 2 /* Float */, 2, this._parseDoubleValueFrame);
                if (timeline !== null) {
                    this._animation.addBoneTimeline(bone.name, timeline);
                }
            }
            if (dragonBones.DataParser.ROTATE_FRAME in rawData) {
                this._frameDefaultValue = 0.0;
                this._frameValueScale = 1.0;
                var timeline = this._parseTimeline(rawData, null, dragonBones.DataParser.ROTATE_FRAME, 12 /* BoneRotate */, 2 /* Float */, 2, this._parseBoneRotateFrame);
                if (timeline !== null) {
                    this._animation.addBoneTimeline(bone.name, timeline);
                }
            }
            if (dragonBones.DataParser.SCALE_FRAME in rawData) {
                this._frameDefaultValue = 1.0;
                this._frameValueScale = 1.0;
                var timeline = this._parseTimeline(rawData, null, dragonBones.DataParser.SCALE_FRAME, 13 /* BoneScale */, 2 /* Float */, 2, this._parseBoneScaleFrame);
                if (timeline !== null) {
                    this._animation.addBoneTimeline(bone.name, timeline);
                }
            }
            if (dragonBones.DataParser.FRAME in rawData) {
                var timeline = this._parseTimeline(rawData, null, dragonBones.DataParser.FRAME, 10 /* BoneAll */, 2 /* Float */, 6, this._parseBoneAllFrame);
                if (timeline !== null) {
                    this._animation.addBoneTimeline(bone.name, timeline);
                }
            }
            this._bone = null; //
            this._slot = null; //
        };
        ObjectDataParser.prototype._parseSlotTimeline = function (rawData) {
            var slot = this._armature.getSlot(ObjectDataParser._getString(rawData, dragonBones.DataParser.NAME, ""));
            if (slot === null) {
                return;
            }
            var displayTimeline = null;
            var colorTimeline = null;
            this._slot = slot;
            if (dragonBones.DataParser.DISPLAY_FRAME in rawData) {
                displayTimeline = this._parseTimeline(rawData, null, dragonBones.DataParser.DISPLAY_FRAME, 20 /* SlotDisplay */, 0 /* Step */, 0, this._parseSlotDisplayFrame);
            }
            else {
                displayTimeline = this._parseTimeline(rawData, null, dragonBones.DataParser.FRAME, 20 /* SlotDisplay */, 0 /* Step */, 0, this._parseSlotDisplayFrame);
            }
            if (dragonBones.DataParser.COLOR_FRAME in rawData) {
                colorTimeline = this._parseTimeline(rawData, null, dragonBones.DataParser.COLOR_FRAME, 21 /* SlotColor */, 1 /* Int */, 1, this._parseSlotColorFrame);
            }
            else {
                colorTimeline = this._parseTimeline(rawData, null, dragonBones.DataParser.FRAME, 21 /* SlotColor */, 1 /* Int */, 1, this._parseSlotColorFrame);
            }
            if (displayTimeline !== null) {
                this._animation.addSlotTimeline(slot.name, displayTimeline);
            }
            if (colorTimeline !== null) {
                this._animation.addSlotTimeline(slot.name, colorTimeline);
            }
            this._slot = null; //
        };
        ObjectDataParser.prototype._parseFrame = function (rawData, frameStart, frameCount) {
            // tslint:disable-next-line:no-unused-expression
            rawData;
            // tslint:disable-next-line:no-unused-expression
            frameCount;
            var frameOffset = this._frameArray.length;
            this._frameArray.length += 1;
            this._frameArray[frameOffset + 0 /* FramePosition */] = frameStart;
            return frameOffset;
        };
        ObjectDataParser.prototype._parseTweenFrame = function (rawData, frameStart, frameCount) {
            var frameOffset = this._parseFrame(rawData, frameStart, frameCount);
            if (frameCount > 0) {
                if (dragonBones.DataParser.CURVE in rawData) {
                    var sampleCount = frameCount + 1;
                    this._helpArray.length = sampleCount;
                    var isOmited = this._samplingEasingCurve(rawData[dragonBones.DataParser.CURVE], this._helpArray);
                    this._frameArray.length += 1 + 1 + this._helpArray.length;
                    this._frameArray[frameOffset + 1 /* FrameTweenType */] = 2 /* Curve */;
                    this._frameArray[frameOffset + 2 /* FrameTweenEasingOrCurveSampleCount */] = isOmited ? sampleCount : -sampleCount;
                    for (var i = 0; i < sampleCount; ++i) {
                        this._frameArray[frameOffset + 3 /* FrameCurveSamples */ + i] = Math.round(this._helpArray[i] * 10000.0);
                    }
                }
                else {
                    var noTween = -2.0;
                    var tweenEasing = noTween;
                    if (dragonBones.DataParser.TWEEN_EASING in rawData) {
                        tweenEasing = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.TWEEN_EASING, noTween);
                    }
                    if (tweenEasing === noTween) {
                        this._frameArray.length += 1;
                        this._frameArray[frameOffset + 1 /* FrameTweenType */] = 0 /* None */;
                    }
                    else if (tweenEasing === 0.0) {
                        this._frameArray.length += 1;
                        this._frameArray[frameOffset + 1 /* FrameTweenType */] = 1 /* Line */;
                    }
                    else if (tweenEasing < 0.0) {
                        this._frameArray.length += 1 + 1;
                        this._frameArray[frameOffset + 1 /* FrameTweenType */] = 3 /* QuadIn */;
                        this._frameArray[frameOffset + 2 /* FrameTweenEasingOrCurveSampleCount */] = Math.round(-tweenEasing * 100.0);
                    }
                    else if (tweenEasing <= 1.0) {
                        this._frameArray.length += 1 + 1;
                        this._frameArray[frameOffset + 1 /* FrameTweenType */] = 4 /* QuadOut */;
                        this._frameArray[frameOffset + 2 /* FrameTweenEasingOrCurveSampleCount */] = Math.round(tweenEasing * 100.0);
                    }
                    else {
                        this._frameArray.length += 1 + 1;
                        this._frameArray[frameOffset + 1 /* FrameTweenType */] = 5 /* QuadInOut */;
                        this._frameArray[frameOffset + 2 /* FrameTweenEasingOrCurveSampleCount */] = Math.round(tweenEasing * 100.0 - 100.0);
                    }
                }
            }
            else {
                this._frameArray.length += 1;
                this._frameArray[frameOffset + 1 /* FrameTweenType */] = 0 /* None */;
            }
            return frameOffset;
        };
        ObjectDataParser.prototype._parseSingleValueFrame = function (rawData, frameStart, frameCount) {
            var frameOffset = 0;
            switch (this._frameValueType) {
                case 0: {
                    frameOffset = this._parseFrame(rawData, frameStart, frameCount);
                    this._frameArray.length += 1;
                    this._frameArray[frameOffset + 1] = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.VALUE, this._frameDefaultValue);
                    break;
                }
                case 1: {
                    frameOffset = this._parseTweenFrame(rawData, frameStart, frameCount);
                    var frameValueOffset = this._frameIntArray.length;
                    this._frameIntArray.length += 1;
                    this._frameIntArray[frameValueOffset] = Math.round(ObjectDataParser._getNumber(rawData, dragonBones.DataParser.VALUE, this._frameDefaultValue) * this._frameValueScale);
                    break;
                }
                case 2: {
                    frameOffset = this._parseTweenFrame(rawData, frameStart, frameCount);
                    var frameValueOffset = this._frameFloatArray.length;
                    this._frameFloatArray.length += 1;
                    this._frameFloatArray[frameValueOffset] = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.VALUE, this._frameDefaultValue) * this._frameValueScale;
                    break;
                }
            }
            return frameOffset;
        };
        ObjectDataParser.prototype._parseDoubleValueFrame = function (rawData, frameStart, frameCount) {
            var frameOffset = 0;
            switch (this._frameValueType) {
                case 0: {
                    frameOffset = this._parseFrame(rawData, frameStart, frameCount);
                    this._frameArray.length += 2;
                    this._frameArray[frameOffset + 1] = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.X, this._frameDefaultValue);
                    this._frameArray[frameOffset + 2] = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.Y, this._frameDefaultValue);
                    break;
                }
                case 1: {
                    frameOffset = this._parseTweenFrame(rawData, frameStart, frameCount);
                    var frameValueOffset = this._frameIntArray.length;
                    this._frameIntArray.length += 2;
                    this._frameIntArray[frameValueOffset] = Math.round(ObjectDataParser._getNumber(rawData, dragonBones.DataParser.X, this._frameDefaultValue) * this._frameValueScale);
                    this._frameIntArray[frameValueOffset + 1] = Math.round(ObjectDataParser._getNumber(rawData, dragonBones.DataParser.Y, this._frameDefaultValue) * this._frameValueScale);
                    break;
                }
                case 2: {
                    frameOffset = this._parseTweenFrame(rawData, frameStart, frameCount);
                    var frameValueOffset = this._frameFloatArray.length;
                    this._frameFloatArray.length += 2;
                    this._frameFloatArray[frameValueOffset] = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.X, this._frameDefaultValue) * this._frameValueScale;
                    this._frameFloatArray[frameValueOffset + 1] = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.Y, this._frameDefaultValue) * this._frameValueScale;
                    break;
                }
            }
            return frameOffset;
        };
        ObjectDataParser.prototype._parseActionFrame = function (frame, frameStart, frameCount) {
            // tslint:disable-next-line:no-unused-expression
            frameCount;
            var frameOffset = this._frameArray.length;
            var actionCount = frame.actions.length;
            this._frameArray.length += 1 + 1 + actionCount;
            this._frameArray[frameOffset + 0 /* FramePosition */] = frameStart;
            this._frameArray[frameOffset + 0 /* FramePosition */ + 1] = actionCount; // Action count.
            for (var i = 0; i < actionCount; ++i) { // Action offsets.
                this._frameArray[frameOffset + 0 /* FramePosition */ + 2 + i] = frame.actions[i];
            }
            return frameOffset;
        };
        ObjectDataParser.prototype._parseZOrderFrame = function (rawData, frameStart, frameCount) {
            var frameOffset = this._parseFrame(rawData, frameStart, frameCount);
            if (dragonBones.DataParser.Z_ORDER in rawData) {
                var rawZOrder = rawData[dragonBones.DataParser.Z_ORDER];
                if (rawZOrder.length > 0) {
                    var slotCount = this._armature.sortedSlots.length;
                    var unchanged = new Array(slotCount - rawZOrder.length / 2);
                    var zOrders = new Array(slotCount);
                    for (var i_1 = 0; i_1 < unchanged.length; ++i_1) {
                        unchanged[i_1] = 0;
                    }
                    for (var i_2 = 0; i_2 < slotCount; ++i_2) {
                        zOrders[i_2] = -1;
                    }
                    var originalIndex = 0;
                    var unchangedIndex = 0;
                    for (var i_3 = 0, l = rawZOrder.length; i_3 < l; i_3 += 2) {
                        var slotIndex = rawZOrder[i_3];
                        var zOrderOffset = rawZOrder[i_3 + 1];
                        while (originalIndex !== slotIndex) {
                            unchanged[unchangedIndex++] = originalIndex++;
                        }
                        var index = originalIndex + zOrderOffset;
                        zOrders[index] = originalIndex++;
                    }
                    while (originalIndex < slotCount) {
                        unchanged[unchangedIndex++] = originalIndex++;
                    }
                    this._frameArray.length += 1 + slotCount;
                    this._frameArray[frameOffset + 1] = slotCount;
                    var i = slotCount;
                    while (i--) {
                        if (zOrders[i] === -1) {
                            this._frameArray[frameOffset + 2 + i] = unchanged[--unchangedIndex] || 0;
                        }
                        else {
                            this._frameArray[frameOffset + 2 + i] = zOrders[i] || 0;
                        }
                    }
                    return frameOffset;
                }
            }
            this._frameArray.length += 1;
            this._frameArray[frameOffset + 1] = 0;
            return frameOffset;
        };
        ObjectDataParser.prototype._parseBoneAllFrame = function (rawData, frameStart, frameCount) {
            this._helpTransform.identity();
            if (dragonBones.DataParser.TRANSFORM in rawData) {
                this._parseTransform(rawData[dragonBones.DataParser.TRANSFORM], this._helpTransform, 1.0);
            }
            // Modify rotation.
            var rotation = this._helpTransform.rotation;
            if (frameStart !== 0) {
                if (this._prevClockwise === 0) {
                    rotation = this._prevRotation + dragonBones.Transform.normalizeRadian(rotation - this._prevRotation);
                }
                else {
                    if (this._prevClockwise > 0 ? rotation >= this._prevRotation : rotation <= this._prevRotation) {
                        this._prevClockwise = this._prevClockwise > 0 ? this._prevClockwise - 1 : this._prevClockwise + 1;
                    }
                    rotation = this._prevRotation + rotation - this._prevRotation + dragonBones.Transform.PI_D * this._prevClockwise;
                }
            }
            this._prevClockwise = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.TWEEN_ROTATE, 0.0);
            this._prevRotation = rotation;
            //
            var frameOffset = this._parseTweenFrame(rawData, frameStart, frameCount);
            var frameFloatOffset = this._frameFloatArray.length;
            this._frameFloatArray.length += 6;
            this._frameFloatArray[frameFloatOffset++] = this._helpTransform.x;
            this._frameFloatArray[frameFloatOffset++] = this._helpTransform.y;
            this._frameFloatArray[frameFloatOffset++] = rotation;
            this._frameFloatArray[frameFloatOffset++] = this._helpTransform.skew;
            this._frameFloatArray[frameFloatOffset++] = this._helpTransform.scaleX;
            this._frameFloatArray[frameFloatOffset++] = this._helpTransform.scaleY;
            this._parseActionDataInFrame(rawData, frameStart, this._bone, this._slot);
            return frameOffset;
        };
        ObjectDataParser.prototype._parseBoneTranslateFrame = function (rawData, frameStart, frameCount) {
            var frameOffset = this._parseTweenFrame(rawData, frameStart, frameCount);
            var frameFloatOffset = this._frameFloatArray.length;
            this._frameFloatArray.length += 2;
            this._frameFloatArray[frameFloatOffset++] = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.X, 0.0);
            this._frameFloatArray[frameFloatOffset++] = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.Y, 0.0);
            return frameOffset;
        };
        ObjectDataParser.prototype._parseBoneRotateFrame = function (rawData, frameStart, frameCount) {
            // Modify rotation.
            var rotation = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.ROTATE, 0.0) * dragonBones.Transform.DEG_RAD;
            if (frameStart !== 0) {
                if (this._prevClockwise === 0) {
                    rotation = this._prevRotation + dragonBones.Transform.normalizeRadian(rotation - this._prevRotation);
                }
                else {
                    if (this._prevClockwise > 0 ? rotation >= this._prevRotation : rotation <= this._prevRotation) {
                        this._prevClockwise = this._prevClockwise > 0 ? this._prevClockwise - 1 : this._prevClockwise + 1;
                    }
                    rotation = this._prevRotation + rotation - this._prevRotation + dragonBones.Transform.PI_D * this._prevClockwise;
                }
            }
            this._prevClockwise = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.CLOCK_WISE, 0);
            this._prevRotation = rotation;
            //
            var frameOffset = this._parseTweenFrame(rawData, frameStart, frameCount);
            var frameFloatOffset = this._frameFloatArray.length;
            this._frameFloatArray.length += 2;
            this._frameFloatArray[frameFloatOffset++] = rotation;
            this._frameFloatArray[frameFloatOffset++] = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.SKEW, 0.0) * dragonBones.Transform.DEG_RAD;
            return frameOffset;
        };
        ObjectDataParser.prototype._parseBoneScaleFrame = function (rawData, frameStart, frameCount) {
            var frameOffset = this._parseTweenFrame(rawData, frameStart, frameCount);
            var frameFloatOffset = this._frameFloatArray.length;
            this._frameFloatArray.length += 2;
            this._frameFloatArray[frameFloatOffset++] = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.X, 1.0);
            this._frameFloatArray[frameFloatOffset++] = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.Y, 1.0);
            return frameOffset;
        };
        ObjectDataParser.prototype._parseSlotDisplayFrame = function (rawData, frameStart, frameCount) {
            var frameOffset = this._parseFrame(rawData, frameStart, frameCount);
            this._frameArray.length += 1;
            if (dragonBones.DataParser.VALUE in rawData) {
                this._frameArray[frameOffset + 1] = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.VALUE, 0);
            }
            else {
                this._frameArray[frameOffset + 1] = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.DISPLAY_INDEX, 0);
            }
            this._parseActionDataInFrame(rawData, frameStart, this._slot.parent, this._slot);
            return frameOffset;
        };
        ObjectDataParser.prototype._parseSlotColorFrame = function (rawData, frameStart, frameCount) {
            var frameOffset = this._parseTweenFrame(rawData, frameStart, frameCount);
            var colorOffset = -1;
            if (dragonBones.DataParser.VALUE in rawData || dragonBones.DataParser.COLOR in rawData) {
                var rawColor = dragonBones.DataParser.VALUE in rawData ? rawData[dragonBones.DataParser.VALUE] : rawData[dragonBones.DataParser.COLOR];
                for (var k in rawColor) { // Detects the presence of color.
                    // tslint:disable-next-line:no-unused-expression
                    k;
                    this._parseColorTransform(rawColor, this._helpColorTransform);
                    colorOffset = this._colorArray.length;
                    this._colorArray.length += 8;
                    this._colorArray[colorOffset++] = Math.round(this._helpColorTransform.alphaMultiplier * 100);
                    this._colorArray[colorOffset++] = Math.round(this._helpColorTransform.redMultiplier * 100);
                    this._colorArray[colorOffset++] = Math.round(this._helpColorTransform.greenMultiplier * 100);
                    this._colorArray[colorOffset++] = Math.round(this._helpColorTransform.blueMultiplier * 100);
                    this._colorArray[colorOffset++] = Math.round(this._helpColorTransform.alphaOffset);
                    this._colorArray[colorOffset++] = Math.round(this._helpColorTransform.redOffset);
                    this._colorArray[colorOffset++] = Math.round(this._helpColorTransform.greenOffset);
                    this._colorArray[colorOffset++] = Math.round(this._helpColorTransform.blueOffset);
                    colorOffset -= 8;
                    break;
                }
            }
            if (colorOffset < 0) {
                if (this._defaultColorOffset < 0) {
                    this._defaultColorOffset = colorOffset = this._colorArray.length;
                    this._colorArray.length += 8;
                    this._colorArray[colorOffset++] = 100;
                    this._colorArray[colorOffset++] = 100;
                    this._colorArray[colorOffset++] = 100;
                    this._colorArray[colorOffset++] = 100;
                    this._colorArray[colorOffset++] = 0;
                    this._colorArray[colorOffset++] = 0;
                    this._colorArray[colorOffset++] = 0;
                    this._colorArray[colorOffset++] = 0;
                }
                colorOffset = this._defaultColorOffset;
            }
            var frameIntOffset = this._frameIntArray.length;
            this._frameIntArray.length += 1;
            this._frameIntArray[frameIntOffset] = colorOffset;
            return frameOffset;
        };
        ObjectDataParser.prototype._parseSlotDeformFrame = function (rawData, frameStart, frameCount) {
            var frameFloatOffset = this._frameFloatArray.length;
            var frameOffset = this._parseTweenFrame(rawData, frameStart, frameCount);
            var rawVertices = dragonBones.DataParser.VERTICES in rawData ? rawData[dragonBones.DataParser.VERTICES] : null;
            var offset = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.OFFSET, 0); // uint
            var vertexCount = this._intArray[this._mesh.geometry.offset + 0 /* GeometryVertexCount */];
            var meshName = this._mesh.parent.name + "_" + this._slot.name + "_" + this._mesh.name;
            var weight = this._mesh.geometry.weight;
            var x = 0.0;
            var y = 0.0;
            var iB = 0;
            var iV = 0;
            if (weight !== null) {
                var rawSlotPose = this._weightSlotPose[meshName];
                this._helpMatrixA.copyFromArray(rawSlotPose, 0);
                this._frameFloatArray.length += weight.count * 2;
                iB = weight.offset + 2 /* WeigthBoneIndices */ + weight.bones.length;
            }
            else {
                this._frameFloatArray.length += vertexCount * 2;
            }
            for (var i = 0; i < vertexCount * 2; i += 2) {
                if (rawVertices === null) { // Fill 0.
                    x = 0.0;
                    y = 0.0;
                }
                else {
                    if (i < offset || i - offset >= rawVertices.length) {
                        x = 0.0;
                    }
                    else {
                        x = rawVertices[i - offset];
                    }
                    if (i + 1 < offset || i + 1 - offset >= rawVertices.length) {
                        y = 0.0;
                    }
                    else {
                        y = rawVertices[i + 1 - offset];
                    }
                }
                if (weight !== null) { // If mesh is skinned, transform point by bone bind pose.
                    var rawBonePoses = this._weightBonePoses[meshName];
                    var vertexBoneCount = this._intArray[iB++];
                    this._helpMatrixA.transformPoint(x, y, this._helpPoint, true);
                    x = this._helpPoint.x;
                    y = this._helpPoint.y;
                    for (var j = 0; j < vertexBoneCount; ++j) {
                        var boneIndex = this._intArray[iB++];
                        this._helpMatrixB.copyFromArray(rawBonePoses, boneIndex * 7 + 1);
                        this._helpMatrixB.invert();
                        this._helpMatrixB.transformPoint(x, y, this._helpPoint, true);
                        this._frameFloatArray[frameFloatOffset + iV++] = this._helpPoint.x;
                        this._frameFloatArray[frameFloatOffset + iV++] = this._helpPoint.y;
                    }
                }
                else {
                    this._frameFloatArray[frameFloatOffset + i] = x;
                    this._frameFloatArray[frameFloatOffset + i + 1] = y;
                }
            }
            if (frameStart === 0) {
                var frameIntOffset = this._frameIntArray.length;
                this._frameIntArray.length += 1 + 1 + 1 + 1 + 1;
                this._frameIntArray[frameIntOffset + 0 /* DeformVertexOffset */] = this._mesh.geometry.offset;
                this._frameIntArray[frameIntOffset + 1 /* DeformCount */] = this._frameFloatArray.length - frameFloatOffset;
                this._frameIntArray[frameIntOffset + 2 /* DeformValueCount */] = this._frameFloatArray.length - frameFloatOffset;
                this._frameIntArray[frameIntOffset + 3 /* DeformValueOffset */] = 0;
                this._frameIntArray[frameIntOffset + 4 /* DeformFloatOffset */] = frameFloatOffset - this._animation.frameFloatOffset;
                this._timelineArray[this._timeline.offset + 3 /* TimelineFrameValueCount */] = frameIntOffset - this._animation.frameIntOffset;
            }
            return frameOffset;
        };
        ObjectDataParser.prototype._parseIKConstraintFrame = function (rawData, frameStart, frameCount) {
            var frameOffset = this._parseTweenFrame(rawData, frameStart, frameCount);
            var frameIntOffset = this._frameIntArray.length;
            this._frameIntArray.length += 2;
            this._frameIntArray[frameIntOffset++] = ObjectDataParser._getBoolean(rawData, dragonBones.DataParser.BEND_POSITIVE, true) ? 1 : 0;
            this._frameIntArray[frameIntOffset++] = Math.round(ObjectDataParser._getNumber(rawData, dragonBones.DataParser.WEIGHT, 1.0) * 100.0);
            return frameOffset;
        };
        ObjectDataParser.prototype._parseActionData = function (rawData, type, bone, slot) {
            var actions = new Array();
            if (typeof rawData === "string") {
                var action = dragonBones.BaseObject.borrowObject(dragonBones.ActionData);
                action.type = type;
                action.name = rawData;
                action.bone = bone;
                action.slot = slot;
                actions.push(action);
            }
            else if (rawData instanceof Array) {
                for (var _i = 0, rawData_2 = rawData; _i < rawData_2.length; _i++) {
                    var rawAction = rawData_2[_i];
                    var action = dragonBones.BaseObject.borrowObject(dragonBones.ActionData);
                    if (dragonBones.DataParser.GOTO_AND_PLAY in rawAction) {
                        action.type = 0 /* Play */;
                        action.name = ObjectDataParser._getString(rawAction, dragonBones.DataParser.GOTO_AND_PLAY, "");
                    }
                    else {
                        if (dragonBones.DataParser.TYPE in rawAction && typeof rawAction[dragonBones.DataParser.TYPE] === "string") {
                            action.type = dragonBones.DataParser._getActionType(rawAction[dragonBones.DataParser.TYPE]);
                        }
                        else {
                            action.type = ObjectDataParser._getNumber(rawAction, dragonBones.DataParser.TYPE, type);
                        }
                        action.name = ObjectDataParser._getString(rawAction, dragonBones.DataParser.NAME, "");
                    }
                    if (dragonBones.DataParser.BONE in rawAction) {
                        var boneName = ObjectDataParser._getString(rawAction, dragonBones.DataParser.BONE, "");
                        action.bone = this._armature.getBone(boneName);
                    }
                    else {
                        action.bone = bone;
                    }
                    if (dragonBones.DataParser.SLOT in rawAction) {
                        var slotName = ObjectDataParser._getString(rawAction, dragonBones.DataParser.SLOT, "");
                        action.slot = this._armature.getSlot(slotName);
                    }
                    else {
                        action.slot = slot;
                    }
                    var userData = null;
                    if (dragonBones.DataParser.INTS in rawAction) {
                        if (userData === null) {
                            userData = dragonBones.BaseObject.borrowObject(dragonBones.UserData);
                        }
                        var rawInts = rawAction[dragonBones.DataParser.INTS];
                        for (var _a = 0, rawInts_1 = rawInts; _a < rawInts_1.length; _a++) {
                            var rawValue = rawInts_1[_a];
                            userData.addInt(rawValue);
                        }
                    }
                    if (dragonBones.DataParser.FLOATS in rawAction) {
                        if (userData === null) {
                            userData = dragonBones.BaseObject.borrowObject(dragonBones.UserData);
                        }
                        var rawFloats = rawAction[dragonBones.DataParser.FLOATS];
                        for (var _b = 0, rawFloats_1 = rawFloats; _b < rawFloats_1.length; _b++) {
                            var rawValue = rawFloats_1[_b];
                            userData.addFloat(rawValue);
                        }
                    }
                    if (dragonBones.DataParser.STRINGS in rawAction) {
                        if (userData === null) {
                            userData = dragonBones.BaseObject.borrowObject(dragonBones.UserData);
                        }
                        var rawStrings = rawAction[dragonBones.DataParser.STRINGS];
                        for (var _c = 0, rawStrings_1 = rawStrings; _c < rawStrings_1.length; _c++) {
                            var rawValue = rawStrings_1[_c];
                            userData.addString(rawValue);
                        }
                    }
                    action.data = userData;
                    actions.push(action);
                }
            }
            return actions;
        };
        ObjectDataParser.prototype._parseDeformFrame = function (rawData, frameStart, frameCount) {
            var frameFloatOffset = this._frameFloatArray.length;
            var frameOffset = this._parseTweenFrame(rawData, frameStart, frameCount);
            var rawVertices = dragonBones.DataParser.VERTICES in rawData ?
                rawData[dragonBones.DataParser.VERTICES] :
                (dragonBones.DataParser.VALUE in rawData ? rawData[dragonBones.DataParser.VALUE] : null);
            var offset = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.OFFSET, 0); // uint
            var vertexCount = this._intArray[this._geometry.offset + 0 /* GeometryVertexCount */];
            var weight = this._geometry.weight;
            var x = 0.0;
            var y = 0.0;
            if (weight !== null) {
                // TODO
            }
            else {
                this._frameFloatArray.length += vertexCount * 2;
                for (var i = 0; i < vertexCount * 2; i += 2) {
                    if (rawVertices !== null) {
                        if (i < offset || i - offset >= rawVertices.length) {
                            x = 0.0;
                        }
                        else {
                            x = rawVertices[i - offset];
                        }
                        if (i + 1 < offset || i + 1 - offset >= rawVertices.length) {
                            y = 0.0;
                        }
                        else {
                            y = rawVertices[i + 1 - offset];
                        }
                    }
                    else {
                        x = 0.0;
                        y = 0.0;
                    }
                    this._frameFloatArray[frameFloatOffset + i] = x;
                    this._frameFloatArray[frameFloatOffset + i + 1] = y;
                }
            }
            if (frameStart === 0) {
                var frameIntOffset = this._frameIntArray.length;
                this._frameIntArray.length += 1 + 1 + 1 + 1 + 1;
                this._frameIntArray[frameIntOffset + 0 /* DeformVertexOffset */] = this._geometry.offset;
                this._frameIntArray[frameIntOffset + 1 /* DeformCount */] = this._frameFloatArray.length - frameFloatOffset;
                this._frameIntArray[frameIntOffset + 2 /* DeformValueCount */] = this._frameFloatArray.length - frameFloatOffset;
                this._frameIntArray[frameIntOffset + 3 /* DeformValueOffset */] = 0;
                this._frameIntArray[frameIntOffset + 4 /* DeformFloatOffset */] = frameFloatOffset - this._animation.frameFloatOffset;
                this._timelineArray[this._timeline.offset + 3 /* TimelineFrameValueCount */] = frameIntOffset - this._animation.frameIntOffset;
            }
            return frameOffset;
        };
        ObjectDataParser.prototype._parseTransform = function (rawData, transform, scale) {
            transform.x = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.X, 0.0) * scale;
            transform.y = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.Y, 0.0) * scale;
            if (dragonBones.DataParser.ROTATE in rawData || dragonBones.DataParser.SKEW in rawData) {
                transform.rotation = dragonBones.Transform.normalizeRadian(ObjectDataParser._getNumber(rawData, dragonBones.DataParser.ROTATE, 0.0) * dragonBones.Transform.DEG_RAD);
                transform.skew = dragonBones.Transform.normalizeRadian(ObjectDataParser._getNumber(rawData, dragonBones.DataParser.SKEW, 0.0) * dragonBones.Transform.DEG_RAD);
            }
            else if (dragonBones.DataParser.SKEW_X in rawData || dragonBones.DataParser.SKEW_Y in rawData) {
                transform.rotation = dragonBones.Transform.normalizeRadian(ObjectDataParser._getNumber(rawData, dragonBones.DataParser.SKEW_Y, 0.0) * dragonBones.Transform.DEG_RAD);
                transform.skew = dragonBones.Transform.normalizeRadian(ObjectDataParser._getNumber(rawData, dragonBones.DataParser.SKEW_X, 0.0) * dragonBones.Transform.DEG_RAD) - transform.rotation;
            }
            transform.scaleX = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.SCALE_X, 1.0);
            transform.scaleY = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.SCALE_Y, 1.0);
        };
        ObjectDataParser.prototype._parseColorTransform = function (rawData, color) {
            color.alphaMultiplier = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.ALPHA_MULTIPLIER, 100) * 0.01;
            color.redMultiplier = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.RED_MULTIPLIER, 100) * 0.01;
            color.greenMultiplier = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.GREEN_MULTIPLIER, 100) * 0.01;
            color.blueMultiplier = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.BLUE_MULTIPLIER, 100) * 0.01;
            color.alphaOffset = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.ALPHA_OFFSET, 0);
            color.redOffset = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.RED_OFFSET, 0);
            color.greenOffset = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.GREEN_OFFSET, 0);
            color.blueOffset = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.BLUE_OFFSET, 0);
        };
        ObjectDataParser.prototype._parseGeometry = function (rawData, geometry) {
            var rawVertices = rawData[dragonBones.DataParser.VERTICES];
            var vertexCount = Math.floor(rawVertices.length / 2); // uint
            var triangleCount = 0;
            var geometryOffset = this._intArray.length;
            var verticesOffset = this._floatArray.length;
            //
            geometry.offset = geometryOffset;
            geometry.data = this._data;
            //
            this._intArray.length += 1 + 1 + 1 + 1;
            this._intArray[geometryOffset + 0 /* GeometryVertexCount */] = vertexCount;
            this._intArray[geometryOffset + 2 /* GeometryFloatOffset */] = verticesOffset;
            this._intArray[geometryOffset + 3 /* GeometryWeightOffset */] = -1; //
            // 
            this._floatArray.length += vertexCount * 2;
            for (var i = 0, l = vertexCount * 2; i < l; ++i) {
                this._floatArray[verticesOffset + i] = rawVertices[i];
            }
            if (dragonBones.DataParser.TRIANGLES in rawData) {
                var rawTriangles = rawData[dragonBones.DataParser.TRIANGLES];
                triangleCount = Math.floor(rawTriangles.length / 3); // uint
                //
                this._intArray.length += triangleCount * 3;
                for (var i = 0, l = triangleCount * 3; i < l; ++i) {
                    this._intArray[geometryOffset + 4 /* GeometryVertexIndices */ + i] = rawTriangles[i];
                }
            }
            // Fill triangle count.
            this._intArray[geometryOffset + 1 /* GeometryTriangleCount */] = triangleCount;
            if (dragonBones.DataParser.UVS in rawData) {
                var rawUVs = rawData[dragonBones.DataParser.UVS];
                var uvOffset = verticesOffset + vertexCount * 2;
                this._floatArray.length += vertexCount * 2;
                for (var i = 0, l = vertexCount * 2; i < l; ++i) {
                    this._floatArray[uvOffset + i] = rawUVs[i];
                }
            }
            if (dragonBones.DataParser.WEIGHTS in rawData) {
                var rawWeights = rawData[dragonBones.DataParser.WEIGHTS];
                var weightCount = Math.floor(rawWeights.length - vertexCount) / 2; // uint
                var weightOffset = this._intArray.length;
                var floatOffset = this._floatArray.length;
                var weightBoneCount = 0;
                var sortedBones = this._armature.sortedBones;
                var weight = dragonBones.BaseObject.borrowObject(dragonBones.WeightData);
                weight.count = weightCount;
                weight.offset = weightOffset;
                this._intArray.length += 1 + 1 + weightBoneCount + vertexCount + weightCount;
                this._intArray[weightOffset + 1 /* WeigthFloatOffset */] = floatOffset;
                if (dragonBones.DataParser.BONE_POSE in rawData) {
                    var rawSlotPose = rawData[dragonBones.DataParser.SLOT_POSE];
                    var rawBonePoses = rawData[dragonBones.DataParser.BONE_POSE];
                    var weightBoneIndices = new Array();
                    weightBoneCount = Math.floor(rawBonePoses.length / 7); // uint
                    weightBoneIndices.length = weightBoneCount;
                    for (var i = 0; i < weightBoneCount; ++i) {
                        var rawBoneIndex = rawBonePoses[i * 7]; // uint
                        var bone = this._rawBones[rawBoneIndex];
                        weight.addBone(bone);
                        weightBoneIndices[i] = rawBoneIndex;
                        this._intArray[weightOffset + 2 /* WeigthBoneIndices */ + i] = sortedBones.indexOf(bone);
                    }
                    this._floatArray.length += weightCount * 3;
                    this._helpMatrixA.copyFromArray(rawSlotPose, 0);
                    for (var i = 0, iW = 0, iB = weightOffset + 2 /* WeigthBoneIndices */ + weightBoneCount, iV = floatOffset; i < vertexCount; ++i) {
                        var iD = i * 2;
                        var vertexBoneCount = this._intArray[iB++] = rawWeights[iW++]; // uint
                        var x = this._floatArray[verticesOffset + iD];
                        var y = this._floatArray[verticesOffset + iD + 1];
                        this._helpMatrixA.transformPoint(x, y, this._helpPoint);
                        x = this._helpPoint.x;
                        y = this._helpPoint.y;
                        for (var j = 0; j < vertexBoneCount; ++j) {
                            var rawBoneIndex = rawWeights[iW++]; // uint
                            var boneIndex = weightBoneIndices.indexOf(rawBoneIndex);
                            this._helpMatrixB.copyFromArray(rawBonePoses, boneIndex * 7 + 1);
                            this._helpMatrixB.invert();
                            this._helpMatrixB.transformPoint(x, y, this._helpPoint);
                            this._intArray[iB++] = boneIndex;
                            this._floatArray[iV++] = rawWeights[iW++];
                            this._floatArray[iV++] = this._helpPoint.x;
                            this._floatArray[iV++] = this._helpPoint.y;
                        }
                    }
                }
                else {
                    var rawBones = rawData[dragonBones.DataParser.BONES];
                    weightBoneCount = rawBones.length;
                    for (var i = 0; i < weightBoneCount; i++) {
                        var rawBoneIndex = rawBones[i];
                        var bone = this._rawBones[rawBoneIndex];
                        weight.addBone(bone);
                        this._intArray[weightOffset + 2 /* WeigthBoneIndices */ + i] = sortedBones.indexOf(bone);
                    }
                    this._floatArray.length += weightCount * 3;
                    for (var i = 0, iW = 0, iV = 0, iB = weightOffset + 2 /* WeigthBoneIndices */ + weightBoneCount, iF = floatOffset; i < weightCount; i++) {
                        var vertexBoneCount = rawWeights[iW++];
                        this._intArray[iB++] = vertexBoneCount;
                        for (var j = 0; j < vertexBoneCount; j++) {
                            var boneIndex = rawWeights[iW++];
                            var boneWeight = rawWeights[iW++];
                            var x = rawVertices[iV++];
                            var y = rawVertices[iV++];
                            this._intArray[iB++] = rawBones.indexOf(boneIndex);
                            this._floatArray[iF++] = boneWeight;
                            this._floatArray[iF++] = x;
                            this._floatArray[iF++] = y;
                        }
                    }
                }
                geometry.weight = weight;
            }
        };
        ObjectDataParser.prototype._parseArray = function (rawData) {
            // tslint:disable-next-line:no-unused-expression
            rawData;
            this._intArray.length = 0;
            this._floatArray.length = 0;
            this._frameIntArray.length = 0;
            this._frameFloatArray.length = 0;
            this._frameArray.length = 0;
            this._timelineArray.length = 0;
            this._colorArray.length = 0;
        };
        ObjectDataParser.prototype._modifyArray = function () {
            // Align.
            if ((this._intArray.length % Int16Array.BYTES_PER_ELEMENT) !== 0) {
                this._intArray.push(0);
            }
            if ((this._frameIntArray.length % Int16Array.BYTES_PER_ELEMENT) !== 0) {
                this._frameIntArray.push(0);
            }
            if ((this._frameArray.length % Int16Array.BYTES_PER_ELEMENT) !== 0) {
                this._frameArray.push(0);
            }
            if ((this._timelineArray.length % Uint16Array.BYTES_PER_ELEMENT) !== 0) {
                this._timelineArray.push(0);
            }
            if ((this._timelineArray.length % Int16Array.BYTES_PER_ELEMENT) !== 0) {
                this._colorArray.push(0);
            }
            var l1 = this._intArray.length * Int16Array.BYTES_PER_ELEMENT;
            var l2 = this._floatArray.length * Float32Array.BYTES_PER_ELEMENT;
            var l3 = this._frameIntArray.length * Int16Array.BYTES_PER_ELEMENT;
            var l4 = this._frameFloatArray.length * Float32Array.BYTES_PER_ELEMENT;
            var l5 = this._frameArray.length * Int16Array.BYTES_PER_ELEMENT;
            var l6 = this._timelineArray.length * Uint16Array.BYTES_PER_ELEMENT;
            var l7 = this._colorArray.length * Int16Array.BYTES_PER_ELEMENT;
            var lTotal = l1 + l2 + l3 + l4 + l5 + l6 + l7;
            //
            var binary = new ArrayBuffer(lTotal);
            var intArray = new Int16Array(binary, 0, this._intArray.length);
            var floatArray = new Float32Array(binary, l1, this._floatArray.length);
            var frameIntArray = new Int16Array(binary, l1 + l2, this._frameIntArray.length);
            var frameFloatArray = new Float32Array(binary, l1 + l2 + l3, this._frameFloatArray.length);
            var frameArray = new Int16Array(binary, l1 + l2 + l3 + l4, this._frameArray.length);
            var timelineArray = new Uint16Array(binary, l1 + l2 + l3 + l4 + l5, this._timelineArray.length);
            var colorArray = new Int16Array(binary, l1 + l2 + l3 + l4 + l5 + l6, this._colorArray.length);
            for (var i = 0, l = this._intArray.length; i < l; ++i) {
                intArray[i] = this._intArray[i];
            }
            for (var i = 0, l = this._floatArray.length; i < l; ++i) {
                floatArray[i] = this._floatArray[i];
            }
            for (var i = 0, l = this._frameIntArray.length; i < l; ++i) {
                frameIntArray[i] = this._frameIntArray[i];
            }
            for (var i = 0, l = this._frameFloatArray.length; i < l; ++i) {
                frameFloatArray[i] = this._frameFloatArray[i];
            }
            for (var i = 0, l = this._frameArray.length; i < l; ++i) {
                frameArray[i] = this._frameArray[i];
            }
            for (var i = 0, l = this._timelineArray.length; i < l; ++i) {
                timelineArray[i] = this._timelineArray[i];
            }
            for (var i = 0, l = this._colorArray.length; i < l; ++i) {
                colorArray[i] = this._colorArray[i];
            }
            this._data.binary = binary;
            this._data.intArray = intArray;
            this._data.floatArray = floatArray;
            this._data.frameIntArray = frameIntArray;
            this._data.frameFloatArray = frameFloatArray;
            this._data.frameArray = frameArray;
            this._data.timelineArray = timelineArray;
            this._data.colorArray = colorArray;
            this._defaultColorOffset = -1;
        };
        ObjectDataParser.prototype.parseDragonBonesData = function (rawData, scale) {
            if (scale === void 0) { scale = 1; }
            console.assert(rawData !== null && rawData !== undefined, "Data error.");
            var version = ObjectDataParser._getString(rawData, dragonBones.DataParser.VERSION, "");
            var compatibleVersion = ObjectDataParser._getString(rawData, dragonBones.DataParser.COMPATIBLE_VERSION, "");
            if (dragonBones.DataParser.DATA_VERSIONS.indexOf(version) >= 0 ||
                dragonBones.DataParser.DATA_VERSIONS.indexOf(compatibleVersion) >= 0) {
                var data = dragonBones.BaseObject.borrowObject(dragonBones.DragonBonesData);
                data.version = version;
                data.name = ObjectDataParser._getString(rawData, dragonBones.DataParser.NAME, "");
                data.frameRate = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.FRAME_RATE, 24);
                if (data.frameRate === 0) { // Data error.
                    data.frameRate = 24;
                }
                if (dragonBones.DataParser.ARMATURE in rawData) {
                    this._data = data;
                    this._parseArray(rawData);
                    var rawArmatures = rawData[dragonBones.DataParser.ARMATURE];
                    for (var _i = 0, rawArmatures_1 = rawArmatures; _i < rawArmatures_1.length; _i++) {
                        var rawArmature = rawArmatures_1[_i];
                        data.addArmature(this._parseArmature(rawArmature, scale));
                    }
                    if (!this._data.binary) { // DragonBones.webAssembly ? 0 : null;
                        this._modifyArray();
                    }
                    if (dragonBones.DataParser.STAGE in rawData) {
                        data.stage = data.getArmature(ObjectDataParser._getString(rawData, dragonBones.DataParser.STAGE, ""));
                    }
                    else if (data.armatureNames.length > 0) {
                        data.stage = data.getArmature(data.armatureNames[0]);
                    }
                    this._data = null;
                }
                if (dragonBones.DataParser.TEXTURE_ATLAS in rawData) {
                    this._rawTextureAtlases = rawData[dragonBones.DataParser.TEXTURE_ATLAS];
                }
                return data;
            }
            else {
                console.assert(false, "Nonsupport data version: " + version + "\n" +
                    "Please convert DragonBones data to support version.\n" +
                    "Read more: https://github.com/DragonBones/Tools/");
            }
            return null;
        };
        ObjectDataParser.prototype.parseTextureAtlasData = function (rawData, textureAtlasData, scale) {
            if (scale === void 0) { scale = 1.0; }
            console.assert(rawData !== undefined);
            if (rawData === null) {
                if (this._rawTextureAtlases === null || this._rawTextureAtlases.length === 0) {
                    return false;
                }
                var rawTextureAtlas = this._rawTextureAtlases[this._rawTextureAtlasIndex++];
                this.parseTextureAtlasData(rawTextureAtlas, textureAtlasData, scale);
                if (this._rawTextureAtlasIndex >= this._rawTextureAtlases.length) {
                    this._rawTextureAtlasIndex = 0;
                    this._rawTextureAtlases = null;
                }
                return true;
            }
            // Texture format.
            textureAtlasData.width = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.WIDTH, 0);
            textureAtlasData.height = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.HEIGHT, 0);
            textureAtlasData.scale = scale === 1.0 ? (1.0 / ObjectDataParser._getNumber(rawData, dragonBones.DataParser.SCALE, 1.0)) : scale;
            textureAtlasData.name = ObjectDataParser._getString(rawData, dragonBones.DataParser.NAME, "");
            textureAtlasData.imagePath = ObjectDataParser._getString(rawData, dragonBones.DataParser.IMAGE_PATH, "");
            if (dragonBones.DataParser.SUB_TEXTURE in rawData) {
                var rawTextures = rawData[dragonBones.DataParser.SUB_TEXTURE];
                for (var i = 0, l = rawTextures.length; i < l; ++i) {
                    var rawTexture = rawTextures[i];
                    var frameWidth = ObjectDataParser._getNumber(rawTexture, dragonBones.DataParser.FRAME_WIDTH, -1.0);
                    var frameHeight = ObjectDataParser._getNumber(rawTexture, dragonBones.DataParser.FRAME_HEIGHT, -1.0);
                    var textureData = textureAtlasData.createTexture();
                    textureData.rotated = ObjectDataParser._getBoolean(rawTexture, dragonBones.DataParser.ROTATED, false);
                    textureData.name = ObjectDataParser._getString(rawTexture, dragonBones.DataParser.NAME, "");
                    textureData.region.x = ObjectDataParser._getNumber(rawTexture, dragonBones.DataParser.X, 0.0);
                    textureData.region.y = ObjectDataParser._getNumber(rawTexture, dragonBones.DataParser.Y, 0.0);
                    textureData.region.width = ObjectDataParser._getNumber(rawTexture, dragonBones.DataParser.WIDTH, 0.0);
                    textureData.region.height = ObjectDataParser._getNumber(rawTexture, dragonBones.DataParser.HEIGHT, 0.0);
                    if (frameWidth > 0.0 && frameHeight > 0.0) {
                        textureData.frame = dragonBones.TextureData.createRectangle();
                        textureData.frame.x = ObjectDataParser._getNumber(rawTexture, dragonBones.DataParser.FRAME_X, 0.0);
                        textureData.frame.y = ObjectDataParser._getNumber(rawTexture, dragonBones.DataParser.FRAME_Y, 0.0);
                        textureData.frame.width = frameWidth;
                        textureData.frame.height = frameHeight;
                    }
                    textureAtlasData.addTexture(textureData);
                }
            }
            return true;
        };
        /**
         * - Deprecated, please refer to {@link dragonBones.BaseFactory#parseDragonBonesData()}.
         * @deprecated
         * @language en_US
         */
        /**
         * - 已废弃，请参考 {@link dragonBones.BaseFactory#parseDragonBonesData()}。
         * @deprecated
         * @language zh_CN
         */
        ObjectDataParser.getInstance = function () {
            if (ObjectDataParser._objectDataParserInstance === null) {
                ObjectDataParser._objectDataParserInstance = new ObjectDataParser();
            }
            return ObjectDataParser._objectDataParserInstance;
        };
        ObjectDataParser._objectDataParserInstance = null;
        return ObjectDataParser;
    }(dragonBones.DataParser));
    dragonBones.ObjectDataParser = ObjectDataParser;
    /**
     * @private
     */
    var ActionFrame = /** @class */ (function () {
        function ActionFrame() {
            this.frameStart = 0;
            this.actions = [];
        }
        return ActionFrame;
    }());
    dragonBones.ActionFrame = ActionFrame;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * @private
     */
    var BinaryDataParser = /** @class */ (function (_super) {
        __extends(BinaryDataParser, _super);
        function BinaryDataParser() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BinaryDataParser.prototype._inRange = function (a, min, max) {
            return min <= a && a <= max;
        };
        BinaryDataParser.prototype._decodeUTF8 = function (data) {
            var EOF_byte = -1;
            var EOF_code_point = -1;
            var FATAL_POINT = 0xFFFD;
            var pos = 0;
            var result = "";
            var code_point;
            var utf8_code_point = 0;
            var utf8_bytes_needed = 0;
            var utf8_bytes_seen = 0;
            var utf8_lower_boundary = 0;
            while (data.length > pos) {
                var _byte = data[pos++];
                if (_byte === EOF_byte) {
                    if (utf8_bytes_needed !== 0) {
                        code_point = FATAL_POINT;
                    }
                    else {
                        code_point = EOF_code_point;
                    }
                }
                else {
                    if (utf8_bytes_needed === 0) {
                        if (this._inRange(_byte, 0x00, 0x7F)) {
                            code_point = _byte;
                        }
                        else {
                            if (this._inRange(_byte, 0xC2, 0xDF)) {
                                utf8_bytes_needed = 1;
                                utf8_lower_boundary = 0x80;
                                utf8_code_point = _byte - 0xC0;
                            }
                            else if (this._inRange(_byte, 0xE0, 0xEF)) {
                                utf8_bytes_needed = 2;
                                utf8_lower_boundary = 0x800;
                                utf8_code_point = _byte - 0xE0;
                            }
                            else if (this._inRange(_byte, 0xF0, 0xF4)) {
                                utf8_bytes_needed = 3;
                                utf8_lower_boundary = 0x10000;
                                utf8_code_point = _byte - 0xF0;
                            }
                            else {
                            }
                            utf8_code_point = utf8_code_point * Math.pow(64, utf8_bytes_needed);
                            code_point = null;
                        }
                    }
                    else if (!this._inRange(_byte, 0x80, 0xBF)) {
                        utf8_code_point = 0;
                        utf8_bytes_needed = 0;
                        utf8_bytes_seen = 0;
                        utf8_lower_boundary = 0;
                        pos--;
                        code_point = _byte;
                    }
                    else {
                        utf8_bytes_seen += 1;
                        utf8_code_point = utf8_code_point + (_byte - 0x80) * Math.pow(64, utf8_bytes_needed - utf8_bytes_seen);
                        if (utf8_bytes_seen !== utf8_bytes_needed) {
                            code_point = null;
                        }
                        else {
                            var cp = utf8_code_point;
                            var lower_boundary = utf8_lower_boundary;
                            utf8_code_point = 0;
                            utf8_bytes_needed = 0;
                            utf8_bytes_seen = 0;
                            utf8_lower_boundary = 0;
                            if (this._inRange(cp, lower_boundary, 0x10FFFF) && !this._inRange(cp, 0xD800, 0xDFFF)) {
                                code_point = cp;
                            }
                            else {
                                code_point = _byte;
                            }
                        }
                    }
                }
                //Decode string
                if (code_point !== null && code_point !== EOF_code_point) {
                    if (code_point <= 0xFFFF) {
                        if (code_point > 0)
                            result += String.fromCharCode(code_point);
                    }
                    else {
                        code_point -= 0x10000;
                        result += String.fromCharCode(0xD800 + ((code_point >> 10) & 0x3ff));
                        result += String.fromCharCode(0xDC00 + (code_point & 0x3ff));
                    }
                }
            }
            return result;
        };
        BinaryDataParser.prototype._parseBinaryTimeline = function (type, offset, timelineData) {
            if (timelineData === void 0) { timelineData = null; }
            var timeline = timelineData !== null ? timelineData : dragonBones.BaseObject.borrowObject(dragonBones.TimelineData);
            timeline.type = type;
            timeline.offset = offset;
            this._timeline = timeline;
            var keyFrameCount = this._timelineArrayBuffer[timeline.offset + 2 /* TimelineKeyFrameCount */];
            if (keyFrameCount === 1) {
                timeline.frameIndicesOffset = -1;
            }
            else {
                var frameIndicesOffset = 0;
                var totalFrameCount = this._animation.frameCount + 1; // One more frame than animation.
                var frameIndices = this._data.frameIndices;
                frameIndicesOffset = frameIndices.length;
                frameIndices.length += totalFrameCount;
                timeline.frameIndicesOffset = frameIndicesOffset;
                for (var i = 0, iK = 0, frameStart = 0, frameCount = 0; i < totalFrameCount; ++i) {
                    if (frameStart + frameCount <= i && iK < keyFrameCount) {
                        frameStart = this._frameArrayBuffer[this._animation.frameOffset + this._timelineArrayBuffer[timeline.offset + 5 /* TimelineFrameOffset */ + iK]];
                        if (iK === keyFrameCount - 1) {
                            frameCount = this._animation.frameCount - frameStart;
                        }
                        else {
                            frameCount = this._frameArrayBuffer[this._animation.frameOffset + this._timelineArrayBuffer[timeline.offset + 5 /* TimelineFrameOffset */ + iK + 1]] - frameStart;
                        }
                        iK++;
                    }
                    frameIndices[frameIndicesOffset + i] = iK - 1;
                }
            }
            this._timeline = null; //
            return timeline;
        };
        BinaryDataParser.prototype._parseAnimation = function (rawData) {
            var animation = dragonBones.BaseObject.borrowObject(dragonBones.AnimationData);
            animation.blendType = dragonBones.DataParser._getAnimationBlendType(dragonBones.ObjectDataParser._getString(rawData, dragonBones.DataParser.BLEND_TYPE, ""));
            animation.frameCount = dragonBones.ObjectDataParser._getNumber(rawData, dragonBones.DataParser.DURATION, 0);
            animation.playTimes = dragonBones.ObjectDataParser._getNumber(rawData, dragonBones.DataParser.PLAY_TIMES, 1);
            animation.duration = animation.frameCount / this._armature.frameRate; // float
            animation.fadeInTime = dragonBones.ObjectDataParser._getNumber(rawData, dragonBones.DataParser.FADE_IN_TIME, 0.0);
            animation.scale = dragonBones.ObjectDataParser._getNumber(rawData, dragonBones.DataParser.SCALE, 1.0);
            animation.name = dragonBones.ObjectDataParser._getString(rawData, dragonBones.DataParser.NAME, dragonBones.DataParser.DEFAULT_NAME);
            if (animation.name.length === 0) {
                animation.name = dragonBones.DataParser.DEFAULT_NAME;
            }
            // Offsets.
            var offsets = rawData[dragonBones.DataParser.OFFSET];
            animation.frameIntOffset = offsets[0];
            animation.frameFloatOffset = offsets[1];
            animation.frameOffset = offsets[2];
            this._animation = animation;
            if (dragonBones.DataParser.ACTION in rawData) {
                animation.actionTimeline = this._parseBinaryTimeline(0 /* Action */, rawData[dragonBones.DataParser.ACTION]);
            }
            if (dragonBones.DataParser.Z_ORDER in rawData) {
                animation.zOrderTimeline = this._parseBinaryTimeline(1 /* ZOrder */, rawData[dragonBones.DataParser.Z_ORDER]);
            }
            if (dragonBones.DataParser.BONE in rawData) {
                var rawTimeliness = rawData[dragonBones.DataParser.BONE];
                for (var k in rawTimeliness) {
                    var rawTimelines = rawTimeliness[k];
                    var bone = this._armature.getBone(k);
                    if (bone === null) {
                        continue;
                    }
                    for (var i = 0, l = rawTimelines.length; i < l; i += 2) {
                        var timelineType = rawTimelines[i];
                        var timelineOffset = rawTimelines[i + 1];
                        var timeline = this._parseBinaryTimeline(timelineType, timelineOffset);
                        this._animation.addBoneTimeline(bone.name, timeline);
                    }
                }
            }
            if (dragonBones.DataParser.SLOT in rawData) {
                var rawTimeliness = rawData[dragonBones.DataParser.SLOT];
                for (var k in rawTimeliness) {
                    var rawTimelines = rawTimeliness[k];
                    var slot = this._armature.getSlot(k);
                    if (slot === null) {
                        continue;
                    }
                    for (var i = 0, l = rawTimelines.length; i < l; i += 2) {
                        var timelineType = rawTimelines[i];
                        var timelineOffset = rawTimelines[i + 1];
                        var timeline = this._parseBinaryTimeline(timelineType, timelineOffset);
                        this._animation.addSlotTimeline(slot.name, timeline);
                    }
                }
            }
            if (dragonBones.DataParser.CONSTRAINT in rawData) {
                var rawTimeliness = rawData[dragonBones.DataParser.CONSTRAINT];
                for (var k in rawTimeliness) {
                    var rawTimelines = rawTimeliness[k];
                    var constraint = this._armature.getConstraint(k);
                    if (constraint === null) {
                        continue;
                    }
                    for (var i = 0, l = rawTimelines.length; i < l; i += 2) {
                        var timelineType = rawTimelines[i];
                        var timelineOffset = rawTimelines[i + 1];
                        var timeline = this._parseBinaryTimeline(timelineType, timelineOffset);
                        this._animation.addConstraintTimeline(constraint.name, timeline);
                    }
                }
            }
            if (dragonBones.DataParser.TIMELINE in rawData) {
                var rawTimelines = rawData[dragonBones.DataParser.TIMELINE];
                for (var _i = 0, rawTimelines_6 = rawTimelines; _i < rawTimelines_6.length; _i++) {
                    var rawTimeline = rawTimelines_6[_i];
                    var timelineOffset = dragonBones.ObjectDataParser._getNumber(rawTimeline, dragonBones.DataParser.OFFSET, 0);
                    if (timelineOffset >= 0) {
                        var timelineType = dragonBones.ObjectDataParser._getNumber(rawTimeline, dragonBones.DataParser.TYPE, 0 /* Action */);
                        var timelineName = dragonBones.ObjectDataParser._getString(rawTimeline, dragonBones.DataParser.NAME, "");
                        var timeline = null;
                        if (timelineType === 40 /* AnimationProgress */ && animation.blendType !== 0 /* None */) {
                            timeline = dragonBones.BaseObject.borrowObject(dragonBones.AnimationTimelineData);
                            var animaitonTimeline = timeline;
                            animaitonTimeline.x = dragonBones.ObjectDataParser._getNumber(rawTimeline, dragonBones.DataParser.X, 0.0);
                            animaitonTimeline.y = dragonBones.ObjectDataParser._getNumber(rawTimeline, dragonBones.DataParser.Y, 0.0);
                        }
                        timeline = this._parseBinaryTimeline(timelineType, timelineOffset, timeline);
                        switch (timelineType) {
                            case 0 /* Action */:
                                // TODO
                                break;
                            case 1 /* ZOrder */:
                                // TODO
                                break;
                            case 11 /* BoneTranslate */:
                            case 12 /* BoneRotate */:
                            case 13 /* BoneScale */:
                            case 50 /* Surface */:
                            case 60 /* BoneAlpha */:
                                this._animation.addBoneTimeline(timelineName, timeline);
                                break;
                            case 20 /* SlotDisplay */:
                            case 21 /* SlotColor */:
                            case 22 /* SlotDeform */:
                            case 23 /* SlotZIndex */:
                            case 24 /* SlotAlpha */:
                                this._animation.addSlotTimeline(timelineName, timeline);
                                break;
                            case 30 /* IKConstraint */:
                                this._animation.addConstraintTimeline(timelineName, timeline);
                                break;
                            case 40 /* AnimationProgress */:
                            case 41 /* AnimationWeight */:
                            case 42 /* AnimationParameter */:
                                this._animation.addAnimationTimeline(timelineName, timeline);
                                break;
                        }
                    }
                }
            }
            this._animation = null;
            return animation;
        };
        BinaryDataParser.prototype._parseGeometry = function (rawData, geometry) {
            geometry.offset = rawData[dragonBones.DataParser.OFFSET];
            geometry.data = this._data;
            var weightOffset = this._intArrayBuffer[geometry.offset + 3 /* GeometryWeightOffset */];
            if (weightOffset < -1) { // -1 is a special flag that there is no bones weight.
                weightOffset += 65536; // Fixed out of bounds bug. 
            }
            if (weightOffset >= 0) {
                var weight = dragonBones.BaseObject.borrowObject(dragonBones.WeightData);
                var vertexCount = this._intArrayBuffer[geometry.offset + 0 /* GeometryVertexCount */];
                var boneCount = this._intArrayBuffer[weightOffset + 0 /* WeigthBoneCount */];
                weight.offset = weightOffset;
                for (var i = 0; i < boneCount; ++i) {
                    var boneIndex = this._intArrayBuffer[weightOffset + 2 /* WeigthBoneIndices */ + i];
                    weight.addBone(this._rawBones[boneIndex]);
                }
                var boneIndicesOffset = weightOffset + 2 /* WeigthBoneIndices */ + boneCount;
                var weightCount = 0;
                for (var i = 0, l = vertexCount; i < l; ++i) {
                    var vertexBoneCount = this._intArrayBuffer[boneIndicesOffset++];
                    weightCount += vertexBoneCount;
                    boneIndicesOffset += vertexBoneCount;
                }
                weight.count = weightCount;
                geometry.weight = weight;
            }
        };
        BinaryDataParser.prototype._parseArray = function (rawData) {
            var offsets = rawData[dragonBones.DataParser.OFFSET];
            var l1 = offsets[1];
            var l2 = offsets[3];
            var l3 = offsets[5];
            var l4 = offsets[7];
            var l5 = offsets[9];
            var l6 = offsets[11];
            var l7 = offsets.length > 12 ? offsets[13] : 0; // Color.
            var intArray = new Int16Array(this._binary, this._binaryOffset + offsets[0], l1 / Int16Array.BYTES_PER_ELEMENT);
            var floatArray = new Float32Array(this._binary, this._binaryOffset + offsets[2], l2 / Float32Array.BYTES_PER_ELEMENT);
            var frameIntArray = new Int16Array(this._binary, this._binaryOffset + offsets[4], l3 / Int16Array.BYTES_PER_ELEMENT);
            var frameFloatArray = new Float32Array(this._binary, this._binaryOffset + offsets[6], l4 / Float32Array.BYTES_PER_ELEMENT);
            var frameArray = new Int16Array(this._binary, this._binaryOffset + offsets[8], l5 / Int16Array.BYTES_PER_ELEMENT);
            var timelineArray = new Uint16Array(this._binary, this._binaryOffset + offsets[10], l6 / Uint16Array.BYTES_PER_ELEMENT);
            var colorArray = l7 > 0 ? new Int16Array(this._binary, this._binaryOffset + offsets[12], l7 / Uint16Array.BYTES_PER_ELEMENT) : intArray; // Color.
            this._data.binary = this._binary;
            this._data.intArray = this._intArrayBuffer = intArray;
            this._data.floatArray = floatArray;
            this._data.frameIntArray = frameIntArray;
            this._data.frameFloatArray = frameFloatArray;
            this._data.frameArray = this._frameArrayBuffer = frameArray;
            this._data.timelineArray = this._timelineArrayBuffer = timelineArray;
            this._data.colorArray = colorArray;
        };
        BinaryDataParser.prototype.parseDragonBonesData = function (rawData, scale) {
            if (scale === void 0) { scale = 1; }
            console.assert(rawData !== null && rawData !== undefined && rawData instanceof ArrayBuffer, "Data error.");
            var tag = new Uint8Array(rawData, 0, 8);
            if (tag[0] !== "D".charCodeAt(0) ||
                tag[1] !== "B".charCodeAt(0) ||
                tag[2] !== "D".charCodeAt(0) ||
                tag[3] !== "T".charCodeAt(0)) {
                console.assert(false, "Nonsupport data.");
                return null;
            }
            var headerLength = new Uint32Array(rawData, 8, 1)[0];
            var headerBytes = new Uint8Array(rawData, 8 + 4, headerLength);
            var headerString = this._decodeUTF8(headerBytes);
            var header = JSON.parse(headerString);
            //
            this._binaryOffset = 8 + 4 + headerLength;
            this._binary = rawData;
            return _super.prototype.parseDragonBonesData.call(this, header, scale);
        };
        /**
         * - Deprecated, please refer to {@link dragonBones.BaseFactory#parseDragonBonesData()}.
         * @deprecated
         * @language en_US
         */
        /**
         * - 已废弃，请参考 {@link dragonBones.BaseFactory#parseDragonBonesData()}。
         * @deprecated
         * @language zh_CN
         */
        BinaryDataParser.getInstance = function () {
            if (BinaryDataParser._binaryDataParserInstance === null) {
                BinaryDataParser._binaryDataParserInstance = new BinaryDataParser();
            }
            return BinaryDataParser._binaryDataParserInstance;
        };
        BinaryDataParser._binaryDataParserInstance = null;
        return BinaryDataParser;
    }(dragonBones.ObjectDataParser));
    dragonBones.BinaryDataParser = BinaryDataParser;
})(dragonBones || (dragonBones = {}));
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2018 DragonBones team and other contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var dragonBones;
(function (dragonBones) {
    /**
     * - Base class for the factory that create the armatures. (Typically only one global factory instance is required)
     * The factory instance create armatures by parsed and added DragonBonesData instances and TextureAtlasData instances.
     * Once the data has been parsed, it has been cached in the factory instance and does not need to be parsed again until it is cleared by the factory instance.
     * @see dragonBones.DragonBonesData
     * @see dragonBones.TextureAtlasData
     * @see dragonBones.ArmatureData
     * @see dragonBones.Armature
     * @version DragonBones 3.0
     * @language en_US
     */
    /**
     * - 创建骨架的工厂基类。 （通常只需要一个全局工厂实例）
     * 工厂通过解析并添加的 DragonBonesData 实例和 TextureAtlasData 实例来创建骨架。
     * 当数据被解析过之后，已经添加到工厂中，在没有被工厂清理之前，不需要再次解析。
     * @see dragonBones.DragonBonesData
     * @see dragonBones.TextureAtlasData
     * @see dragonBones.ArmatureData
     * @see dragonBones.Armature
     * @version DragonBones 3.0
     * @language zh_CN
     */
    var BaseFactory = /** @class */ (function () {
        /**
         * - Create a factory instance. (typically only one global factory instance is required)
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 创建一个工厂实例。 （通常只需要一个全局工厂实例）
         * @version DragonBones 3.0
         * @language zh_CN
         */
        function BaseFactory(dataParser) {
            if (dataParser === void 0) { dataParser = null; }
            /**
             * @private
             */
            this.autoSearch = false;
            this._dragonBonesDataMap = {};
            this._textureAtlasDataMap = {};
            this._dragonBones = null;
            this._dataParser = null;
            if (BaseFactory._objectParser === null) {
                BaseFactory._objectParser = new dragonBones.ObjectDataParser();
            }
            if (BaseFactory._binaryParser === null) {
                BaseFactory._binaryParser = new dragonBones.BinaryDataParser();
            }
            this._dataParser = dataParser !== null ? dataParser : BaseFactory._objectParser;
        }
        BaseFactory.prototype._isSupportMesh = function () {
            return true;
        };
        BaseFactory.prototype._getTextureData = function (textureAtlasName, textureName) {
            if (textureAtlasName in this._textureAtlasDataMap) {
                for (var _i = 0, _a = this._textureAtlasDataMap[textureAtlasName]; _i < _a.length; _i++) {
                    var textureAtlasData = _a[_i];
                    var textureData = textureAtlasData.getTexture(textureName);
                    if (textureData !== null) {
                        return textureData;
                    }
                }
            }
            if (this.autoSearch) { // Will be search all data, if the autoSearch is true.
                for (var k in this._textureAtlasDataMap) {
                    for (var _b = 0, _c = this._textureAtlasDataMap[k]; _b < _c.length; _b++) {
                        var textureAtlasData = _c[_b];
                        if (textureAtlasData.autoSearch) {
                            var textureData = textureAtlasData.getTexture(textureName);
                            if (textureData !== null) {
                                return textureData;
                            }
                        }
                    }
                }
            }
            return null;
        };
        BaseFactory.prototype._fillBuildArmaturePackage = function (dataPackage, dragonBonesName, armatureName, skinName, textureAtlasName) {
            var dragonBonesData = null;
            var armatureData = null;
            if (dragonBonesName.length > 0) {
                if (dragonBonesName in this._dragonBonesDataMap) {
                    dragonBonesData = this._dragonBonesDataMap[dragonBonesName];
                    armatureData = dragonBonesData.getArmature(armatureName);
                }
            }
            if (armatureData === null && (dragonBonesName.length === 0 || this.autoSearch)) { // Will be search all data, if do not give a data name or the autoSearch is true.
                for (var k in this._dragonBonesDataMap) {
                    dragonBonesData = this._dragonBonesDataMap[k];
                    if (dragonBonesName.length === 0 || dragonBonesData.autoSearch) {
                        armatureData = dragonBonesData.getArmature(armatureName);
                        if (armatureData !== null) {
                            dragonBonesName = k;
                            break;
                        }
                    }
                }
            }
            if (armatureData !== null) {
                dataPackage.dataName = dragonBonesName;
                dataPackage.textureAtlasName = textureAtlasName;
                dataPackage.data = dragonBonesData;
                dataPackage.armature = armatureData;
                dataPackage.skin = null;
                if (skinName.length > 0) {
                    dataPackage.skin = armatureData.getSkin(skinName);
                    if (dataPackage.skin === null && this.autoSearch) {
                        for (var k in this._dragonBonesDataMap) {
                            var skinDragonBonesData = this._dragonBonesDataMap[k];
                            var skinArmatureData = skinDragonBonesData.getArmature(skinName);
                            if (skinArmatureData !== null) {
                                dataPackage.skin = skinArmatureData.defaultSkin;
                                break;
                            }
                        }
                    }
                }
                if (dataPackage.skin === null) {
                    dataPackage.skin = armatureData.defaultSkin;
                }
                return true;
            }
            return false;
        };
        BaseFactory.prototype._buildBones = function (dataPackage, armature) {
            for (var _i = 0, _a = dataPackage.armature.sortedBones; _i < _a.length; _i++) {
                var boneData = _a[_i];
                var bone = dragonBones.BaseObject.borrowObject(boneData.type === 0 /* Bone */ ? dragonBones.Bone : dragonBones.Surface);
                bone.init(boneData, armature);
            }
        };
        /**
         * @private
         */
        BaseFactory.prototype._buildSlots = function (dataPackage, armature) {
            var currentSkin = dataPackage.skin;
            var defaultSkin = dataPackage.armature.defaultSkin;
            if (currentSkin === null || defaultSkin === null) {
                return;
            }
            var skinSlots = {};
            for (var k in defaultSkin.displays) {
                var displays = defaultSkin.getDisplays(k);
                skinSlots[k] = displays;
            }
            if (currentSkin !== defaultSkin) {
                for (var k in currentSkin.displays) {
                    var displays = currentSkin.getDisplays(k);
                    skinSlots[k] = displays;
                }
            }
            for (var _i = 0, _a = dataPackage.armature.sortedSlots; _i < _a.length; _i++) {
                var slotData = _a[_i];
                var displayDatas = slotData.name in skinSlots ? skinSlots[slotData.name] : null;
                var slot = this._buildSlot(dataPackage, slotData, armature);
                if (displayDatas !== null) {
                    slot.displayFrameCount = displayDatas.length;
                    for (var i = 0, l = slot.displayFrameCount; i < l; ++i) {
                        var displayData = displayDatas[i];
                        slot.replaceRawDisplayData(displayData, i);
                        if (displayData !== null) {
                            if (dataPackage.textureAtlasName.length > 0) {
                                var textureData = this._getTextureData(dataPackage.textureAtlasName, displayData.path);
                                slot.replaceTextureData(textureData, i);
                            }
                            var display = this._getSlotDisplay(dataPackage, displayData, slot);
                            slot.replaceDisplay(display, i);
                        }
                        else {
                            slot.replaceDisplay(null);
                        }
                    }
                }
                slot._setDisplayIndex(slotData.displayIndex, true);
            }
        };
        BaseFactory.prototype._buildConstraints = function (dataPackage, armature) {
            var constraints = dataPackage.armature.constraints;
            for (var k in constraints) {
                var constraintData = constraints[k];
                // TODO more constraint type.
                switch (constraintData.type) {
                    case 0 /* IK */:
                        var ikConstraint = dragonBones.BaseObject.borrowObject(dragonBones.IKConstraint);
                        ikConstraint.init(constraintData, armature);
                        armature._addConstraint(ikConstraint);
                        break;
                    case 1 /* Path */:
                        var pathConstraint = dragonBones.BaseObject.borrowObject(dragonBones.PathConstraint);
                        pathConstraint.init(constraintData, armature);
                        armature._addConstraint(pathConstraint);
                        break;
                    default:
                        var constraint = dragonBones.BaseObject.borrowObject(dragonBones.IKConstraint);
                        constraint.init(constraintData, armature);
                        armature._addConstraint(constraint);
                        break;
                }
            }
        };
        BaseFactory.prototype._buildChildArmature = function (dataPackage, _slot, displayData) {
            return this.buildArmature(displayData.path, dataPackage !== null ? dataPackage.dataName : "", "", dataPackage !== null ? dataPackage.textureAtlasName : "");
        };
        BaseFactory.prototype._getSlotDisplay = function (dataPackage, displayData, slot) {
            var dataName = dataPackage !== null ? dataPackage.dataName : displayData.parent.parent.parent.name;
            var display = null;
            switch (displayData.type) {
                case 0 /* Image */: {
                    var imageDisplayData = displayData;
                    if (imageDisplayData.texture === null) {
                        imageDisplayData.texture = this._getTextureData(dataName, displayData.path);
                    }
                    display = slot.rawDisplay;
                    break;
                }
                case 2 /* Mesh */: {
                    var meshDisplayData = displayData;
                    if (meshDisplayData.texture === null) {
                        meshDisplayData.texture = this._getTextureData(dataName, meshDisplayData.path);
                    }
                    if (this._isSupportMesh()) {
                        display = slot.meshDisplay;
                    }
                    else {
                        display = slot.rawDisplay;
                    }
                    break;
                }
                case 1 /* Armature */: {
                    var armatureDisplayData = displayData;
                    var childArmature = this._buildChildArmature(dataPackage, slot, armatureDisplayData);
                    if (childArmature !== null) {
                        childArmature.inheritAnimation = armatureDisplayData.inheritAnimation;
                        if (!childArmature.inheritAnimation) {
                            var actions = armatureDisplayData.actions.length > 0 ? armatureDisplayData.actions : childArmature.armatureData.defaultActions;
                            if (actions.length > 0) {
                                for (var _i = 0, actions_6 = actions; _i < actions_6.length; _i++) {
                                    var action = actions_6[_i];
                                    var eventObject = dragonBones.BaseObject.borrowObject(dragonBones.EventObject);
                                    dragonBones.EventObject.actionDataToInstance(action, eventObject, slot.armature);
                                    eventObject.slot = slot;
                                    slot.armature._bufferAction(eventObject, false);
                                }
                            }
                            else {
                                childArmature.animation.play();
                            }
                        }
                        armatureDisplayData.armature = childArmature.armatureData; // 
                    }
                    display = childArmature;
                    break;
                }
                case 3 /* BoundingBox */:
                    break;
                default:
                    break;
            }
            return display;
        };
        /**
         * - Parse the raw data to a DragonBonesData instance and cache it to the factory.
         * @param rawData - The raw data.
         * @param name - Specify a cache name for the instance so that the instance can be obtained through this name. (If not set, use the instance name instead)
         * @param scale - Specify a scaling value for all armatures. (Default: 1.0)
         * @returns DragonBonesData instance
         * @see #getDragonBonesData()
         * @see #addDragonBonesData()
         * @see #removeDragonBonesData()
         * @see dragonBones.DragonBonesData
         * @version DragonBones 4.5
         * @language en_US
         */
        /**
         * - 将原始数据解析为 DragonBonesData 实例，并缓存到工厂中。
         * @param rawData - 原始数据。
         * @param name - 为该实例指定一个缓存名称，以便可以通过此名称获取该实例。 （如果未设置，则使用该实例中的名称）
         * @param scale - 为所有的骨架指定一个缩放值。 （默认: 1.0）
         * @returns DragonBonesData 实例
         * @see #getDragonBonesData()
         * @see #addDragonBonesData()
         * @see #removeDragonBonesData()
         * @see dragonBones.DragonBonesData
         * @version DragonBones 4.5
         * @language zh_CN
         */
        BaseFactory.prototype.parseDragonBonesData = function (rawData, name, scale) {
            if (name === void 0) { name = null; }
            if (scale === void 0) { scale = 1.0; }
            var dataParser = rawData instanceof ArrayBuffer ? BaseFactory._binaryParser : this._dataParser;
            var dragonBonesData = dataParser.parseDragonBonesData(rawData, scale);
            while (true) {
                var textureAtlasData = this._buildTextureAtlasData(null, null);
                if (dataParser.parseTextureAtlasData(null, textureAtlasData, scale)) {
                    this.addTextureAtlasData(textureAtlasData, name);
                }
                else {
                    textureAtlasData.returnToPool();
                    break;
                }
            }
            if (dragonBonesData !== null) {
                this.addDragonBonesData(dragonBonesData, name);
            }
            return dragonBonesData;
        };
        /**
         * - Parse the raw texture atlas data and the texture atlas object to a TextureAtlasData instance and cache it to the factory.
         * @param rawData - The raw texture atlas data.
         * @param textureAtlas - The texture atlas object.
         * @param name - Specify a cache name for the instance so that the instance can be obtained through this name. (If not set, use the instance name instead)
         * @param scale - Specify a scaling value for the map set. (Default: 1.0)
         * @returns TextureAtlasData instance
         * @see #getTextureAtlasData()
         * @see #addTextureAtlasData()
         * @see #removeTextureAtlasData()
         * @see dragonBones.TextureAtlasData
         * @version DragonBones 4.5
         * @language en_US
         */
        /**
         * - 将原始贴图集数据和贴图集对象解析为 TextureAtlasData 实例，并缓存到工厂中。
         * @param rawData - 原始贴图集数据。
         * @param textureAtlas - 贴图集对象。
         * @param name - 为该实例指定一个缓存名称，以便可以通过此名称获取该实例。 （如果未设置，则使用该实例中的名称）
         * @param scale - 为贴图集指定一个缩放值。 （默认: 1.0）
         * @returns TextureAtlasData 实例
         * @see #getTextureAtlasData()
         * @see #addTextureAtlasData()
         * @see #removeTextureAtlasData()
         * @see dragonBones.TextureAtlasData
         * @version DragonBones 4.5
         * @language zh_CN
         */
        BaseFactory.prototype.parseTextureAtlasData = function (rawData, textureAtlas, name, scale) {
            if (name === void 0) { name = null; }
            if (scale === void 0) { scale = 1.0; }
            var textureAtlasData = this._buildTextureAtlasData(null, null);
            this._dataParser.parseTextureAtlasData(rawData, textureAtlasData, scale);
            this._buildTextureAtlasData(textureAtlasData, textureAtlas || null);
            this.addTextureAtlasData(textureAtlasData, name);
            return textureAtlasData;
        };
        /**
         * - Update texture atlases.
         * @param textureAtlases - The texture atlas objects.
         * @param name - The texture atlas name.
         * @version DragonBones 5.7
         * @language en_US
         */
        /**
         * - 更新贴图集对象。
         * @param textureAtlases - 多个贴图集对象。
         * @param name - 贴图集名称。
         * @version DragonBones 5.7
         * @language zh_CN
         */
        BaseFactory.prototype.updateTextureAtlases = function (textureAtlases, name) {
            var textureAtlasDatas = this.getTextureAtlasData(name);
            if (textureAtlasDatas !== null) {
                for (var i = 0, l = textureAtlasDatas.length; i < l; ++i) {
                    if (i < textureAtlases.length) {
                        this._buildTextureAtlasData(textureAtlasDatas[i], textureAtlases[i]);
                    }
                }
            }
        };
        /**
         * - Get a specific DragonBonesData instance.
         * @param name - The DragonBonesData instance cache name.
         * @returns DragonBonesData instance
         * @see #parseDragonBonesData()
         * @see #addDragonBonesData()
         * @see #removeDragonBonesData()
         * @see dragonBones.DragonBonesData
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 获取特定的 DragonBonesData 实例。
         * @param name - DragonBonesData 实例的缓存名称。
         * @returns DragonBonesData 实例
         * @see #parseDragonBonesData()
         * @see #addDragonBonesData()
         * @see #removeDragonBonesData()
         * @see dragonBones.DragonBonesData
         * @version DragonBones 3.0
         * @language zh_CN
         */
        BaseFactory.prototype.getDragonBonesData = function (name) {
            return (name in this._dragonBonesDataMap) ? this._dragonBonesDataMap[name] : null;
        };
        /**
         * - Cache a DragonBonesData instance to the factory.
         * @param data - The DragonBonesData instance.
         * @param name - Specify a cache name for the instance so that the instance can be obtained through this name. (if not set, use the instance name instead)
         * @see #parseDragonBonesData()
         * @see #getDragonBonesData()
         * @see #removeDragonBonesData()
         * @see dragonBones.DragonBonesData
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 将 DragonBonesData 实例缓存到工厂中。
         * @param data - DragonBonesData 实例。
         * @param name - 为该实例指定一个缓存名称，以便可以通过此名称获取该实例。 （如果未设置，则使用该实例中的名称）
         * @see #parseDragonBonesData()
         * @see #getDragonBonesData()
         * @see #removeDragonBonesData()
         * @see dragonBones.DragonBonesData
         * @version DragonBones 3.0
         * @language zh_CN
         */
        BaseFactory.prototype.addDragonBonesData = function (data, name) {
            if (name === void 0) { name = null; }
            name = name !== null ? name : data.name;
            if (name in this._dragonBonesDataMap) {
                if (this._dragonBonesDataMap[name] === data) {
                    return;
                }
                console.warn("Can not add same name data: " + name);
                return;
            }
            this._dragonBonesDataMap[name] = data;
        };
        /**
         * - Remove a DragonBonesData instance.
         * @param name - The DragonBonesData instance cache name.
         * @param disposeData - Whether to dispose data. (Default: true)
         * @see #parseDragonBonesData()
         * @see #getDragonBonesData()
         * @see #addDragonBonesData()
         * @see dragonBones.DragonBonesData
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 移除 DragonBonesData 实例。
         * @param name - DragonBonesData 实例缓存名称。
         * @param disposeData - 是否释放数据。 （默认: true）
         * @see #parseDragonBonesData()
         * @see #getDragonBonesData()
         * @see #addDragonBonesData()
         * @see dragonBones.DragonBonesData
         * @version DragonBones 3.0
         * @language zh_CN
         */
        BaseFactory.prototype.removeDragonBonesData = function (name, disposeData) {
            if (disposeData === void 0) { disposeData = true; }
            if (name in this._dragonBonesDataMap) {
                if (disposeData) {
                    this._dragonBones.bufferObject(this._dragonBonesDataMap[name]);
                }
                delete this._dragonBonesDataMap[name];
            }
        };
        /**
         * - Get a list of specific TextureAtlasData instances.
         * @param name - The TextureAtlasData cahce name.
         * @see #parseTextureAtlasData()
         * @see #addTextureAtlasData()
         * @see #removeTextureAtlasData()
         * @see dragonBones.TextureAtlasData
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 获取特定的 TextureAtlasData 实例列表。
         * @param name - TextureAtlasData 实例缓存名称。
         * @see #parseTextureAtlasData()
         * @see #addTextureAtlasData()
         * @see #removeTextureAtlasData()
         * @see dragonBones.TextureAtlasData
         * @version DragonBones 3.0
         * @language zh_CN
         */
        BaseFactory.prototype.getTextureAtlasData = function (name) {
            return (name in this._textureAtlasDataMap) ? this._textureAtlasDataMap[name] : null;
        };
        /**
         * - Cache a TextureAtlasData instance to the factory.
         * @param data - The TextureAtlasData instance.
         * @param name - Specify a cache name for the instance so that the instance can be obtained through this name. (if not set, use the instance name instead)
         * @see #parseTextureAtlasData()
         * @see #getTextureAtlasData()
         * @see #removeTextureAtlasData()
         * @see dragonBones.TextureAtlasData
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 将 TextureAtlasData 实例缓存到工厂中。
         * @param data - TextureAtlasData 实例。
         * @param name - 为该实例指定一个缓存名称，以便可以通过此名称获取该实例。 （如果未设置，则使用该实例中的名称）
         * @see #parseTextureAtlasData()
         * @see #getTextureAtlasData()
         * @see #removeTextureAtlasData()
         * @see dragonBones.TextureAtlasData
         * @version DragonBones 3.0
         * @language zh_CN
         */
        BaseFactory.prototype.addTextureAtlasData = function (data, name) {
            if (name === void 0) { name = null; }
            name = name !== null ? name : data.name;
            var textureAtlasList = (name in this._textureAtlasDataMap) ? this._textureAtlasDataMap[name] : (this._textureAtlasDataMap[name] = []);
            if (textureAtlasList.indexOf(data) < 0) {
                textureAtlasList.push(data);
            }
        };
        /**
         * - Remove a TextureAtlasData instance.
         * @param name - The TextureAtlasData instance cache name.
         * @param disposeData - Whether to dispose data.
         * @see #parseTextureAtlasData()
         * @see #getTextureAtlasData()
         * @see #addTextureAtlasData()
         * @see dragonBones.TextureAtlasData
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 移除 TextureAtlasData 实例。
         * @param name - TextureAtlasData 实例的缓存名称。
         * @param disposeData - 是否释放数据。
         * @see #parseTextureAtlasData()
         * @see #getTextureAtlasData()
         * @see #addTextureAtlasData()
         * @see dragonBones.TextureAtlasData
         * @version DragonBones 3.0
         * @language zh_CN
         */
        BaseFactory.prototype.removeTextureAtlasData = function (name, disposeData) {
            if (disposeData === void 0) { disposeData = true; }
            if (name in this._textureAtlasDataMap) {
                var textureAtlasDataList = this._textureAtlasDataMap[name];
                if (disposeData) {
                    for (var _i = 0, textureAtlasDataList_1 = textureAtlasDataList; _i < textureAtlasDataList_1.length; _i++) {
                        var textureAtlasData = textureAtlasDataList_1[_i];
                        this._dragonBones.bufferObject(textureAtlasData);
                    }
                }
                delete this._textureAtlasDataMap[name];
            }
        };
        /**
         * - Get a specific armature data.
         * @param name - The armature data name.
         * @param dragonBonesName - The cached name for DragonbonesData instance.
         * @see dragonBones.ArmatureData
         * @version DragonBones 5.1
         * @language en_US
         */
        /**
         * - 获取特定的骨架数据。
         * @param name - 骨架数据名称。
         * @param dragonBonesName - DragonBonesData 实例的缓存名称。
         * @see dragonBones.ArmatureData
         * @version DragonBones 5.1
         * @language zh_CN
         */
        BaseFactory.prototype.getArmatureData = function (name, dragonBonesName) {
            if (dragonBonesName === void 0) { dragonBonesName = ""; }
            var dataPackage = new BuildArmaturePackage();
            if (!this._fillBuildArmaturePackage(dataPackage, dragonBonesName, name, "", "")) {
                return null;
            }
            return dataPackage.armature;
        };
        /**
         * - Clear all cached DragonBonesData instances and TextureAtlasData instances.
         * @param disposeData - Whether to dispose data.
         * @version DragonBones 4.5
         * @language en_US
         */
        /**
         * - 清除缓存的所有 DragonBonesData 实例和 TextureAtlasData 实例。
         * @param disposeData - 是否释放数据。
         * @version DragonBones 4.5
         * @language zh_CN
         */
        BaseFactory.prototype.clear = function (disposeData) {
            if (disposeData === void 0) { disposeData = true; }
            for (var k in this._dragonBonesDataMap) {
                if (disposeData) {
                    this._dragonBones.bufferObject(this._dragonBonesDataMap[k]);
                }
                delete this._dragonBonesDataMap[k];
            }
            for (var k in this._textureAtlasDataMap) {
                if (disposeData) {
                    var textureAtlasDataList = this._textureAtlasDataMap[k];
                    for (var _i = 0, textureAtlasDataList_2 = textureAtlasDataList; _i < textureAtlasDataList_2.length; _i++) {
                        var textureAtlasData = textureAtlasDataList_2[_i];
                        this._dragonBones.bufferObject(textureAtlasData);
                    }
                }
                delete this._textureAtlasDataMap[k];
            }
        };
        /**
         * - Create a armature from cached DragonBonesData instances and TextureAtlasData instances.
         * Note that when the created armature that is no longer in use, you need to explicitly dispose {@link #dragonBones.Armature#dispose()}.
         * @param armatureName - The armature data name.
         * @param dragonBonesName - The cached name of the DragonBonesData instance. (If not set, all DragonBonesData instances are retrieved, and when multiple DragonBonesData instances contain a the same name armature data, it may not be possible to accurately create a specific armature)
         * @param skinName - The skin name, you can set a different ArmatureData name to share it's skin data. (If not set, use the default skin data)
         * @returns The armature.
         * @example
         * <pre>
         *     let armature = factory.buildArmature("armatureName", "dragonBonesName");
         *     armature.clock = factory.clock;
         * </pre>
         * @see dragonBones.DragonBonesData
         * @see dragonBones.ArmatureData
         * @version DragonBones 3.0
         * @language en_US
         */
        /**
         * - 通过缓存的 DragonBonesData 实例和 TextureAtlasData 实例创建一个骨架。
         * 注意，创建的骨架不再使用时，需要显式释放 {@link #dragonBones.Armature#dispose()}。
         * @param armatureName - 骨架数据名称。
         * @param dragonBonesName - DragonBonesData 实例的缓存名称。 （如果未设置，将检索所有的 DragonBonesData 实例，当多个 DragonBonesData 实例中包含同名的骨架数据时，可能无法准确的创建出特定的骨架）
         * @param skinName - 皮肤名称，可以设置一个其他骨架数据名称来共享其皮肤数据。（如果未设置，则使用默认的皮肤数据）
         * @returns 骨架。
         * @example
         * <pre>
         *     let armature = factory.buildArmature("armatureName", "dragonBonesName");
         *     armature.clock = factory.clock;
         * </pre>
         * @see dragonBones.DragonBonesData
         * @see dragonBones.ArmatureData
         * @version DragonBones 3.0
         * @language zh_CN
         */
        BaseFactory.prototype.buildArmature = function (armatureName, dragonBonesName, skinName, textureAtlasName) {
            if (dragonBonesName === void 0) { dragonBonesName = ""; }
            if (skinName === void 0) { skinName = ""; }
            if (textureAtlasName === void 0) { textureAtlasName = ""; }
            var dataPackage = new BuildArmaturePackage();
            if (!this._fillBuildArmaturePackage(dataPackage, dragonBonesName || "", armatureName, skinName || "", textureAtlasName || "")) {
                console.warn("No armature data: " + armatureName + ", " + (dragonBonesName !== null ? dragonBonesName : ""));
                return null;
            }
            var armature = this._buildArmature(dataPackage);
            this._buildBones(dataPackage, armature);
            this._buildSlots(dataPackage, armature);
            this._buildConstraints(dataPackage, armature);
            armature.invalidUpdate(null, true);
            armature.advanceTime(0.0); // Update armature pose.
            return armature;
        };
        /**
         * @private
         */
        BaseFactory.prototype.replaceDisplay = function (slot, displayData, displayIndex) {
            if (displayIndex === void 0) { displayIndex = -1; }
            if (displayIndex < 0) {
                displayIndex = slot.displayIndex;
            }
            if (displayIndex < 0) {
                displayIndex = 0;
            }
            slot.replaceDisplayData(displayData, displayIndex);
            if (displayData !== null) {
                var display = this._getSlotDisplay(null, displayData, slot);
                if (displayData.type === 0 /* Image */) {
                    var rawDisplayData = slot.getDisplayFrameAt(displayIndex).rawDisplayData;
                    if (rawDisplayData !== null &&
                        rawDisplayData.type === 2 /* Mesh */) {
                        display = slot.meshDisplay;
                    }
                }
                slot.replaceDisplay(display, displayIndex);
            }
            else {
                slot.replaceDisplay(null, displayIndex);
            }
        };
        /**
         * - Replaces the current display data for a particular slot with a specific display data.
         * Specify display data with "dragonBonesName/armatureName/slotName/displayName".
         * @param dragonBonesName - The DragonBonesData instance cache name.
         * @param armatureName - The armature data name.
         * @param slotName - The slot data name.
         * @param displayName - The display data name.
         * @param slot - The slot.
         * @param displayIndex - The index of the display data that is replaced. (If it is not set, replaces the current display data)
         * @example
         * <pre>
         *     let slot = armature.getSlot("weapon");
         *     factory.replaceSlotDisplay("dragonBonesName", "armatureName", "slotName", "displayName", slot);
         * </pre>
         * @version DragonBones 4.5
         * @language en_US
         */
        /**
         * - 用特定的显示对象数据替换特定插槽当前的显示对象数据。
         * 用 "dragonBonesName/armatureName/slotName/displayName" 指定显示对象数据。
         * @param dragonBonesName - DragonBonesData 实例的缓存名称。
         * @param armatureName - 骨架数据名称。
         * @param slotName - 插槽数据名称。
         * @param displayName - 显示对象数据名称。
         * @param slot - 插槽。
         * @param displayIndex - 被替换的显示对象数据的索引。 （如果未设置，则替换当前的显示对象数据）
         * @example
         * <pre>
         *     let slot = armature.getSlot("weapon");
         *     factory.replaceSlotDisplay("dragonBonesName", "armatureName", "slotName", "displayName", slot);
         * </pre>
         * @version DragonBones 4.5
         * @language zh_CN
         */
        BaseFactory.prototype.replaceSlotDisplay = function (dragonBonesName, armatureName, slotName, displayName, slot, displayIndex) {
            if (displayIndex === void 0) { displayIndex = -1; }
            var armatureData = this.getArmatureData(armatureName, dragonBonesName || "");
            if (armatureData === null || armatureData.defaultSkin === null) {
                return false;
            }
            var displayData = armatureData.defaultSkin.getDisplay(slotName, displayName);
            this.replaceDisplay(slot, displayData, displayIndex);
            return true;
        };
        /**
         * @private
         */
        BaseFactory.prototype.replaceSlotDisplayList = function (dragonBonesName, armatureName, slotName, slot) {
            var armatureData = this.getArmatureData(armatureName, dragonBonesName || "");
            if (!armatureData || !armatureData.defaultSkin) {
                return false;
            }
            var displayDatas = armatureData.defaultSkin.getDisplays(slotName);
            if (!displayDatas) {
                return false;
            }
            slot.displayFrameCount = displayDatas.length;
            for (var i = 0, l = slot.displayFrameCount; i < l; ++i) {
                var displayData = displayDatas[i];
                this.replaceDisplay(slot, displayData, i);
            }
            return true;
        };
        /**
         * - Share specific skin data with specific armature.
         * @param armature - The armature.
         * @param skin - The skin data.
         * @param isOverride - Whether it completely override the original skin. (Default: false)
         * @param exclude - A list of slot names that do not need to be replace.
         * @example
         * <pre>
         *     let armatureA = factory.buildArmature("armatureA", "dragonBonesA");
         *     let armatureDataB = factory.getArmatureData("armatureB", "dragonBonesB");
         *     if (armatureDataB && armatureDataB.defaultSkin) {
         *     factory.replaceSkin(armatureA, armatureDataB.defaultSkin, false, ["arm_l", "weapon_l"]);
         *     }
         * </pre>
         * @see dragonBones.Armature
         * @see dragonBones.SkinData
         * @version DragonBones 5.6
         * @language en_US
         */
        /**
         * - 将特定的皮肤数据共享给特定的骨架使用。
         * @param armature - 骨架。
         * @param skin - 皮肤数据。
         * @param isOverride - 是否完全覆盖原来的皮肤。 （默认: false）
         * @param exclude - 不需要被替换的插槽名称列表。
         * @example
         * <pre>
         *     let armatureA = factory.buildArmature("armatureA", "dragonBonesA");
         *     let armatureDataB = factory.getArmatureData("armatureB", "dragonBonesB");
         *     if (armatureDataB && armatureDataB.defaultSkin) {
         *     factory.replaceSkin(armatureA, armatureDataB.defaultSkin, false, ["arm_l", "weapon_l"]);
         *     }
         * </pre>
         * @see dragonBones.Armature
         * @see dragonBones.SkinData
         * @version DragonBones 5.6
         * @language zh_CN
         */
        BaseFactory.prototype.replaceSkin = function (armature, skin, isOverride, exclude) {
            if (isOverride === void 0) { isOverride = false; }
            if (exclude === void 0) { exclude = null; }
            var success = false;
            var defaultSkin = skin.parent.defaultSkin;
            for (var _i = 0, _a = armature.getSlots(); _i < _a.length; _i++) {
                var slot = _a[_i];
                if (exclude !== null && exclude.indexOf(slot.name) >= 0) {
                    continue;
                }
                var displayDatas = skin.getDisplays(slot.name);
                if (displayDatas === null) {
                    if (defaultSkin !== null && skin !== defaultSkin) {
                        displayDatas = defaultSkin.getDisplays(slot.name);
                    }
                    if (displayDatas === null) {
                        if (isOverride) {
                            slot.displayFrameCount = 0;
                        }
                        continue;
                    }
                }
                slot.displayFrameCount = displayDatas.length;
                for (var i = 0, l = slot.displayFrameCount; i < l; ++i) {
                    var displayData = displayDatas[i];
                    slot.replaceRawDisplayData(displayData, i);
                    if (displayData !== null) {
                        slot.replaceDisplay(this._getSlotDisplay(null, displayData, slot), i);
                    }
                    else {
                        slot.replaceDisplay(null, i);
                    }
                }
                success = true;
            }
            return success;
        };
        /**
         * - Replaces the existing animation data for a specific armature with the animation data for the specific armature data.
         * This enables you to make a armature template so that other armature without animations can share it's animations.
         * @param armature - The armtaure.
         * @param armatureData - The armature data.
         * @param isOverride - Whether to completely overwrite the original animation. (Default: false)
         * @example
         * <pre>
         *     let armatureA = factory.buildArmature("armatureA", "dragonBonesA");
         *     let armatureDataB = factory.getArmatureData("armatureB", "dragonBonesB");
         *     if (armatureDataB) {
         *     factory.replaceAnimation(armatureA, armatureDataB);
         *     }
         * </pre>
         * @see dragonBones.Armature
         * @see dragonBones.ArmatureData
         * @version DragonBones 5.6
         * @language en_US
         */
        /**
         * - 用特定骨架数据的动画数据替换特定骨架现有的动画数据。
         * 这样就能实现制作一个骨架动画模板，让其他没有制作动画的骨架共享该动画。
         * @param armature - 骨架。
         * @param armatureData - 骨架数据。
         * @param isOverride - 是否完全覆盖原来的动画。（默认: false）
         * @example
         * <pre>
         *     let armatureA = factory.buildArmature("armatureA", "dragonBonesA");
         *     let armatureDataB = factory.getArmatureData("armatureB", "dragonBonesB");
         *     if (armatureDataB) {
         *     factory.replaceAnimation(armatureA, armatureDataB);
         *     }
         * </pre>
         * @see dragonBones.Armature
         * @see dragonBones.ArmatureData
         * @version DragonBones 5.6
         * @language zh_CN
         */
        BaseFactory.prototype.replaceAnimation = function (armature, armatureData, isOverride) {
            if (isOverride === void 0) { isOverride = true; }
            var skinData = armatureData.defaultSkin;
            if (skinData === null) {
                return false;
            }
            if (isOverride) {
                armature.animation.animations = armatureData.animations;
            }
            else {
                var rawAnimations = armature.animation.animations;
                var animations = {};
                for (var k in rawAnimations) {
                    animations[k] = rawAnimations[k];
                }
                for (var k in armatureData.animations) {
                    animations[k] = armatureData.animations[k];
                }
                armature.animation.animations = animations;
            }
            for (var _i = 0, _a = armature.getSlots(); _i < _a.length; _i++) {
                var slot = _a[_i];
                var index = 0;
                for (var _b = 0, _c = slot.displayList; _b < _c.length; _b++) {
                    var display = _c[_b];
                    if (display instanceof dragonBones.Armature) {
                        var displayDatas = skinData.getDisplays(slot.name);
                        if (displayDatas !== null && index < displayDatas.length) {
                            var displayData = displayDatas[index];
                            if (displayData !== null && displayData.type === 1 /* Armature */) {
                                var childArmatureData = this.getArmatureData(displayData.path, displayData.parent.parent.parent.name);
                                if (childArmatureData) {
                                    this.replaceAnimation(display, childArmatureData, isOverride);
                                }
                            }
                        }
                    }
                    index++;
                }
            }
            return true;
        };
        /**
         * @private
         */
        BaseFactory.prototype.getAllDragonBonesData = function () {
            return this._dragonBonesDataMap;
        };
        /**
         * @private
         */
        BaseFactory.prototype.getAllTextureAtlasData = function () {
            return this._textureAtlasDataMap;
        };
        Object.defineProperty(BaseFactory.prototype, "clock", {
            /**
             * - An Worldclock instance updated by engine.
             * @version DragonBones 5.7
             * @language en_US
             */
            /**
             * - 由引擎驱动的 WorldClock 实例。
             * @version DragonBones 5.7
             * @language zh_CN
             */
            get: function () {
                return this._dragonBones.clock;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseFactory.prototype, "dragonBones", {
            /**
             * @private
             */
            get: function () {
                return this._dragonBones;
            },
            enumerable: true,
            configurable: true
        });
        BaseFactory._objectParser = null;
        BaseFactory._binaryParser = null;
        return BaseFactory;
    }());
    dragonBones.BaseFactory = BaseFactory;
    /**
     * @private
     */
    var BuildArmaturePackage = /** @class */ (function () {
        function BuildArmaturePackage() {
            this.dataName = "";
            this.textureAtlasName = "";
            this.skin = null;
        }
        return BuildArmaturePackage;
    }());
    dragonBones.BuildArmaturePackage = BuildArmaturePackage;
})(dragonBones || (dragonBones = {}));
var dragonBones;
(function (dragonBones) {
    var phaser;
    (function (phaser) {
        var util;
        (function (util) {
            var EventDispatcher = /** @class */ (function (_super) {
                __extends(EventDispatcher, _super);
                function EventDispatcher() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                EventDispatcher.prototype.hasDBEventListener = function (type) {
                    return this.listenerCount(type) > 0;
                };
                EventDispatcher.prototype.dispatchDBEvent = function (type, eventObject) {
                    this.emit(type, eventObject);
                };
                EventDispatcher.prototype.addDBEventListener = function (type, listener, thisObject) {
                    this.on(type, listener, thisObject);
                };
                EventDispatcher.prototype.removeDBEventListener = function (type, listener, thisObject) {
                    this.off(type, listener, thisObject);
                };
                return EventDispatcher;
            }(Phaser.Events.EventEmitter));
            util.EventDispatcher = EventDispatcher;
        })(util = phaser.util || (phaser.util = {}));
    })(phaser = dragonBones.phaser || (dragonBones.phaser = {}));
})(dragonBones || (dragonBones = {}));
var dragonBones;
(function (dragonBones) {
    var phaser;
    (function (phaser) {
        var util;
        (function (util) {
            util.Skew = {
                getSkewX: function () {
                    return this._skewX || 0;
                },
                setSkewX: function (v) {
                    this._skewX = v;
                },
                getSkewY: function () {
                    return this._skewY || 0;
                },
                setSkewY: function (v) {
                    this._skewY = v;
                },
                setSkew: function (sx, sy) {
                    sy = sy === void 0 ? sx : sy;
                    this._skewX = sx;
                    this._skewY = sy;
                }
            };
            util.extendSkew = function (clazz) {
                Object.defineProperty(clazz.prototype, "skewX", {
                    get: util.Skew.getSkewX,
                    set: util.Skew.setSkewX,
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(clazz.prototype, "skewY", {
                    get: util.Skew.getSkewY,
                    set: util.Skew.setSkewY,
                    enumerable: true,
                    configurable: true
                });
                clazz.prototype.setSkew = util.Skew.setSkew;
            };
        })(util = phaser.util || (phaser.util = {}));
    })(phaser = dragonBones.phaser || (dragonBones.phaser = {}));
})(dragonBones || (dragonBones = {}));
var dragonBones;
(function (dragonBones) {
    var phaser;
    (function (phaser) {
        var util;
        (function (util) {
            var TransformMatrix = /** @class */ (function (_super) {
                __extends(TransformMatrix, _super);
                function TransformMatrix(a, b, c, d, tx, ty) {
                    var _this = _super.call(this, a, b, c, d, tx, ty) || this;
                    _this.decomposedMatrix.skewX = 0;
                    _this.decomposedMatrix.skewY = 0;
                    return _this;
                }
                TransformMatrix.prototype.decomposeMatrix = function () {
                    // sort out rotation / skew..
                    var a = this.a;
                    var b = this.b;
                    var c = this.c;
                    var d = this.d;
                    var skewX = -Math.atan2(-c, d);
                    var skewY = Math.atan2(b, a);
                    var delta = Math.abs(skewX + skewY);
                    if (delta < 0.00001 || Math.abs(Phaser.Math.PI2 - delta) < 0.00001) {
                        this.decomposedMatrix.rotation = skewY;
                        if (a < 0 && d >= 0)
                            this.decomposedMatrix.rotation += (this.decomposedMatrix.rotation <= 0) ? Math.PI : -Math.PI;
                        this.decomposedMatrix.skewX = this.decomposedMatrix.skewY = 0;
                    }
                    else {
                        this.decomposedMatrix.rotation = 0;
                        this.decomposedMatrix.skewX = skewX;
                        this.decomposedMatrix.skewY = skewY;
                    }
                    // next set scale
                    this.decomposedMatrix.scaleX = Math.sqrt((a * a) + (b * b));
                    this.decomposedMatrix.scaleY = Math.sqrt((c * c) + (d * d));
                    // next set position
                    this.decomposedMatrix.translateX = this.tx;
                    this.decomposedMatrix.translateY = this.ty;
                    return this.decomposedMatrix;
                };
                TransformMatrix.prototype.applyITRSC = function (x, y, rotation, scaleX, scaleY, skewX, skewY) {
                    this.a = Math.cos(rotation - skewY) * scaleX;
                    this.b = Math.sin(rotation - skewY) * scaleX;
                    this.c = -Math.sin(rotation + skewX) * scaleY;
                    this.d = Math.cos(rotation + skewX) * scaleY;
                    this.tx = x;
                    this.ty = y;
                    return this;
                };
                Object.defineProperty(TransformMatrix.prototype, "skewX", {
                    get: function () {
                        return -Math.atan2(-this.c, this.d);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TransformMatrix.prototype, "skewY", {
                    get: function () {
                        return Math.atan2(this.b, this.a);
                    },
                    enumerable: true,
                    configurable: true
                });
                return TransformMatrix;
            }(Phaser.GameObjects.Components.TransformMatrix));
            util.TransformMatrix = TransformMatrix;
        })(util = phaser.util || (phaser.util = {}));
    })(phaser = dragonBones.phaser || (dragonBones.phaser = {}));
})(dragonBones || (dragonBones = {}));
var dragonBones;
(function (dragonBones) {
    var phaser;
    (function (phaser) {
        var display;
        (function (display) {
            // this class will be refactored due to official Container will be removed soon.
            var DisplayContainer = /** @class */ (function (_super) {
                __extends(DisplayContainer, _super);
                function DisplayContainer(scene, x, y, children) {
                    var _this = _super.call(this, scene, x, y, children) || this;
                    _this._skewX = 0;
                    _this._skewY = 0;
                    _this.tempTransformMatrix = new phaser.util.TransformMatrix();
                    return _this;
                }
                DisplayContainer.prototype.pointToContainer = function (source, output) {
                    if (output === undefined)
                        output = new Phaser.Math.Vector2();
                    if (this.parentContainer)
                        return this.parentContainer.pointToContainer(source, output);
                    var tempMatrix = this.tempTransformMatrix;
                    //  No need to loadIdentity because applyITRSC overwrites every value anyway
                    tempMatrix.applyITRSC(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this._skewX, this._skewY);
                    tempMatrix.invert();
                    tempMatrix.transformPoint(source.x, source.y, output);
                    return output;
                };
                Object.defineProperty(DisplayContainer.prototype, "skewX", {
                    get: function () {
                        return this._skewX;
                    },
                    set: function (v) {
                        this._skewX = v;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DisplayContainer.prototype, "skewY", {
                    get: function () {
                        return this._skewY;
                    },
                    set: function (v) {
                        this._skewY = v;
                    },
                    enumerable: true,
                    configurable: true
                });
                DisplayContainer.prototype.setSkew = function (sx, sy) {
                    sy = sy === void 0 ? sx : sy;
                    this.skewX = sx;
                    this.skewY = sy;
                    return this;
                };
                return DisplayContainer;
            }(Phaser.GameObjects.Container));
            display.DisplayContainer = DisplayContainer;
        })(display = phaser.display || (phaser.display = {}));
    })(phaser = dragonBones.phaser || (dragonBones.phaser = {}));
})(dragonBones || (dragonBones = {}));
var dragonBones;
(function (dragonBones) {
    var phaser;
    (function (phaser) {
        var display;
        (function (display_1) {
            var ArmatureDisplay = /** @class */ (function (_super) {
                __extends(ArmatureDisplay, _super);
                function ArmatureDisplay(scene) {
                    var _this = _super.call(this, scene) || this;
                    _this.debugDraw = false;
                    return _this;
                }
                ArmatureDisplay.prototype.dbInit = function (armature) {
                    this._armature = armature;
                };
                ArmatureDisplay.prototype.dbClear = function () {
                    this.removeAllListeners();
                    if (this._armature)
                        this._armature.dispose();
                    this._armature = null;
                };
                ArmatureDisplay.prototype.dbUpdate = function () {
                    // TODO: draw debug graphics
                    if (this.debugDraw) {
                    }
                };
                ArmatureDisplay.prototype.dispose = function (disposeProxy) {
                    this.dbClear();
                    if (disposeProxy === true)
                        _super.prototype.destroy.call(this);
                };
                ArmatureDisplay.prototype.destroy = function () {
                    this.dispose(true);
                };
                ArmatureDisplay.prototype.dispatchDBEvent = function (type, eventObject) {
                    this.emit(type, eventObject);
                };
                ArmatureDisplay.prototype.hasDBEventListener = function (type) {
                    return this.listenerCount(type) > 0;
                };
                ArmatureDisplay.prototype.addDBEventListener = function (type, listener, scope) {
                    this.on(type, listener, scope);
                };
                ArmatureDisplay.prototype.removeDBEventListener = function (type, listener, scope) {
                    this.off(type, listener, scope);
                };
                Object.defineProperty(ArmatureDisplay.prototype, "armature", {
                    get: function () {
                        return this._armature;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ArmatureDisplay.prototype, "animation", {
                    get: function () {
                        return this._armature.animation;
                    },
                    enumerable: true,
                    configurable: true
                });
                ArmatureDisplay.prototype.getBounds = function (output) {
                    if (output === undefined) {
                        output = new Phaser.Geom.Rectangle();
                    }
                    var helpRectangle = new Phaser.Geom.Rectangle();
                    var matrix = this.getBoundsTransformMatrix();
                    var isFirst = true;
                    for (var _i = 0, _a = this._armature.getSlots(); _i < _a.length; _i++) {
                        var slot = _a[_i];
                        var display_2 = slot.display;
                        if (!display_2) {
                            continue;
                        }
                        if (display_2 === slot.meshDisplay) {
                            var vertices = display_2.fakeVertices;
                            if (vertices && vertices.length > 0) {
                                helpRectangle.setTo(999999.0, 999999.0, -999999.0, -999999.0);
                                for (var i = 0, l = vertices.length; i < l; i += 2) {
                                    var x = vertices[i];
                                    var y = vertices[i + 1];
                                    if (helpRectangle.x > x)
                                        helpRectangle.x = x;
                                    if (helpRectangle.width < x)
                                        helpRectangle.width = x;
                                    if (helpRectangle.y > y)
                                        helpRectangle.y = y;
                                    if (helpRectangle.height < y)
                                        helpRectangle.height = y;
                                }
                                helpRectangle.width -= helpRectangle.x;
                                helpRectangle.height -= helpRectangle.y;
                            }
                            else {
                                continue;
                            }
                        }
                        else if (slot._displayFrame) {
                            var textureData = slot._displayFrame.getTextureData();
                            if (textureData) {
                                var scale = textureData.parent.scale;
                                helpRectangle.width = textureData.region.width * scale;
                                helpRectangle.height = textureData.region.height * scale;
                                helpRectangle.x = -helpRectangle.width / 2;
                                helpRectangle.y = -helpRectangle.height / 2;
                            }
                            else {
                                continue;
                            }
                        }
                        helpRectangle.width *= this.scaleX;
                        helpRectangle.height *= this.scaleY;
                        matrix.transformPoint(helpRectangle.x, helpRectangle.y, helpRectangle);
                        if (isFirst) {
                            output.x = helpRectangle.x;
                            output.y = helpRectangle.y;
                            output.width = helpRectangle.width;
                            output.height = helpRectangle.height;
                            isFirst = false;
                        }
                        else {
                            Phaser.Geom.Rectangle.Union(helpRectangle, output, output);
                        }
                    }
                    return output;
                };
                return ArmatureDisplay;
            }(display_1.DisplayContainer));
            display_1.ArmatureDisplay = ArmatureDisplay;
        })(display = phaser.display || (phaser.display = {}));
    })(phaser = dragonBones.phaser || (dragonBones.phaser = {}));
})(dragonBones || (dragonBones = {}));
var dragonBones;
(function (dragonBones) {
    var phaser;
    (function (phaser) {
        var display;
        (function (display) {
            var SlotImage = /** @class */ (function (_super) {
                __extends(SlotImage, _super);
                function SlotImage(scene, x, y, texture, frame) {
                    var _this = _super.call(this, scene, x, y, texture, frame) || this;
                    _this.setPipeline("PhaserTextureTintPipeline"); // use customized pipeline
                    return _this;
                }
                return SlotImage;
            }(Phaser.GameObjects.Image));
            display.SlotImage = SlotImage;
            phaser.util.extendSkew(SlotImage); // skew mixin
        })(display = phaser.display || (phaser.display = {}));
    })(phaser = dragonBones.phaser || (dragonBones.phaser = {}));
})(dragonBones || (dragonBones = {}));
var dragonBones;
(function (dragonBones) {
    var phaser;
    (function (phaser) {
        var display;
        (function (display) {
            var SlotSprite = /** @class */ (function (_super) {
                __extends(SlotSprite, _super);
                function SlotSprite(scene, x, y, texture, frame) {
                    var _this = _super.call(this, scene, x, y, texture, frame) || this;
                    _this.setPipeline("PhaserTextureTintPipeline"); // use customized pipeline
                    return _this;
                }
                return SlotSprite;
            }(Phaser.GameObjects.Sprite));
            display.SlotSprite = SlotSprite;
            phaser.util.extendSkew(SlotSprite); // skew mixin
        })(display = phaser.display || (phaser.display = {}));
    })(phaser = dragonBones.phaser || (dragonBones.phaser = {}));
})(dragonBones || (dragonBones = {}));
var dragonBones;
(function (dragonBones) {
    var phaser;
    (function (phaser) {
        var display;
        (function (display) {
            var SlotMesh = /** @class */ (function (_super) {
                __extends(SlotMesh, _super);
                function SlotMesh(scene, x, y, vertices, uv, colors, alphas, texture, frame) {
                    var _this = _super.call(this, scene, x, y, vertices, uv, colors, alphas, texture, frame) || this;
                    _this.setPipeline("PhaserTextureTintPipeline"); // use customized pipeline
                    return _this;
                }
                SlotMesh.prototype.setTint = function (topLeft, topRight, bottomLeft, bottomRight) {
                    // NOTHING
                };
                SlotMesh.prototype.updateVertices = function () {
                    var fakeIndices = this.fakeIndices;
                    var fakeVertices = this.fakeVertices;
                    var fakeUvs = this.fakeUvs;
                    this.vertices = new Float32Array(fakeIndices.length * 2);
                    this.uv = new Float32Array(fakeIndices.length * 2);
                    this.alphas = new Uint32Array(fakeIndices.length);
                    this.colors = new Uint32Array(fakeIndices.length);
                    for (var i = 0; i < fakeIndices.length; i++) {
                        this.vertices[i * 2] = fakeVertices[fakeIndices[i] * 2];
                        this.vertices[i * 2 + 1] = fakeVertices[fakeIndices[i] * 2 + 1];
                        this.uv[i * 2] = fakeUvs[fakeIndices[i] * 2];
                        this.uv[i * 2 + 1] = fakeUvs[fakeIndices[i] * 2 + 1];
                        this.alphas[i] = 1.0;
                        this.colors[i] = 0xFFFFFF;
                    }
                    // this.tintFill = true;
                    // for (let i = 0; i < fakeIndices.length / 3; i++) {
                    //     this.colors[i * 3] = 0xFF0000;
                    //     this.colors[i * 3 + 1] = 0x00FF00;
                    //     this.colors[i * 3 + 2] = 0x0000FF;
                    // }
                };
                return SlotMesh;
            }(Phaser.GameObjects.Mesh));
            display.SlotMesh = SlotMesh;
            phaser.util.extendSkew(SlotMesh); // skew mixin
        })(display = phaser.display || (phaser.display = {}));
    })(phaser = dragonBones.phaser || (dragonBones.phaser = {}));
})(dragonBones || (dragonBones = {}));
var dragonBones;
(function (dragonBones) {
    var phaser;
    (function (phaser) {
        var display;
        (function (display) {
            var Slot = /** @class */ (function (_super) {
                __extends(Slot, _super);
                function Slot() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                Slot.toString = function () {
                    return "[class dragonBones.PhaserSlot]";
                };
                Slot.prototype._onClear = function () {
                    _super.prototype._onClear.call(this);
                    this._textureScale = 1.0;
                    if (this._renderDisplay) {
                        this._renderDisplay.destroy();
                        this._renderDisplay = null;
                    }
                };
                Slot.prototype._initDisplay = function (rawDisplay, isRetain) {
                };
                Slot.prototype._disposeDisplay = function (prevDisplay, isRelease) {
                    // do nothing here, prevDisplay normally is an user customized GameObject set for this slot, so user need to destroy it manually.
                };
                Slot.prototype._onUpdateDisplay = function () {
                    this._renderDisplay = this._display || this._rawDisplay;
                };
                // Phaser will soone remove the functionality of nested container, so here we need to look for an alternative solution for display.add(childArmatureDisplay)
                Slot.prototype._addDisplay = function () {
                    this.armature.display.add(this._renderDisplay);
                };
                Slot.prototype._replaceDisplay = function (prevDisplay) {
                    if (!this._renderDisplay["setSkew"]) {
                        console.warn("please call dragonBones.phaser.util.extendSkew to mix skew component into your display object,\n                                and set its pipeline to 'PhaserTextureTintPipeline' by calling 'setPiepline' method, more detail please refer to the 'ReplaceSlotDisplay.ts' example");
                        return;
                    }
                    this.armature.display.replace(prevDisplay, this._renderDisplay);
                    this._renderDisplay.parentContainer = this.armature.display;
                };
                Slot.prototype._removeDisplay = function () {
                    // can't use this._armature.display.remove here, perphaps this._renderDisplay is a child of armature.
                    this._renderDisplay.parentContainer.remove(this._renderDisplay);
                };
                Slot.prototype._updateDisplayData = function () {
                    _super.prototype._updateDisplayData.call(this);
                    if (this.armature.replacedTexture !== null) {
                        this._textureDirty = true;
                    }
                };
                Slot.prototype._updateZOrder = function () {
                    if (this._renderDisplay.depth === this._zOrder)
                        return;
                    this._renderDisplay.setDepth(this._zOrder);
                };
                Slot.prototype._updateVisible = function () {
                    this._renderDisplay.setVisible(this._parent.visible && this._visible);
                };
                Slot.prototype._updateBlendMode = function () {
                    var mode = Phaser.BlendModes.NORMAL;
                    switch (this._blendMode) {
                        case 0 /* Normal */:
                            mode = Phaser.BlendModes.NORMAL;
                            break;
                        case 1 /* Add */:
                            mode = Phaser.BlendModes.ADD;
                            break;
                        case 3 /* Darken */:
                            mode = Phaser.BlendModes.DARKEN;
                            break;
                        case 4 /* Difference */:
                            mode = Phaser.BlendModes.DIFFERENCE;
                            break;
                        case 6 /* HardLight */:
                            mode = Phaser.BlendModes.HARD_LIGHT;
                            break;
                        case 9 /* Lighten */:
                            mode = Phaser.BlendModes.LIGHTEN;
                            break;
                        case 10 /* Multiply */:
                            mode = Phaser.BlendModes.MULTIPLY;
                            break;
                        case 11 /* Overlay */:
                            mode = Phaser.BlendModes.OVERLAY;
                            break;
                        case 12 /* Screen */:
                            mode = Phaser.BlendModes.SCREEN;
                            break;
                        default:
                            break;
                    }
                    this._renderDisplay.setBlendMode(mode);
                };
                Slot.prototype._updateColor = function () {
                    var c = this._colorTransform;
                    var a = this._globalAlpha * c.alphaMultiplier + c.alphaOffset;
                    this._renderDisplay.setAlpha(a);
                    if (this._renderDisplay instanceof display.DisplayContainer)
                        return;
                    var r = 0xff * c.redMultiplier + c.redOffset;
                    var g = 0xff * c.greenMultiplier + c.greenOffset;
                    var b = 0xff * c.blueMultiplier + c.blueOffset;
                    var rgb = (r << 16) | (g << 8) | b;
                    this._renderDisplay.setTint(rgb);
                };
                Slot.prototype._updateFrame = function () {
                    if (this._renderDisplay instanceof display.DisplayContainer)
                        return;
                    var currentTextureData = this._textureData;
                    if (this._displayIndex >= 0 && this._display !== null && currentTextureData !== null) {
                        var currentTextureAtlasData = currentTextureData.parent;
                        if (this.armature.replacedTexture !== null) { // Update replaced texture atlas.
                            if (this.armature._replaceTextureAtlasData === null) {
                                currentTextureAtlasData = dragonBones.BaseObject.borrowObject(display.TextureAtlasData);
                                currentTextureAtlasData.copyFrom(currentTextureData.parent);
                                currentTextureAtlasData.renderTexture = this.armature.replacedTexture;
                                this.armature._replaceTextureAtlasData = currentTextureAtlasData;
                            }
                            else
                                currentTextureAtlasData = this.armature._replaceTextureAtlasData;
                            currentTextureData = currentTextureAtlasData.getTexture(currentTextureData.name);
                        }
                        var frame = currentTextureData.renderTexture;
                        if (frame !== null) {
                            if (this._geometryData !== null) { // Mesh.
                                var data = this._geometryData.data;
                                var intArray = data.intArray;
                                var floatArray = data.floatArray;
                                var vertexCount = intArray[this._geometryData.offset + 0 /* GeometryVertexCount */];
                                var triangleCount = intArray[this._geometryData.offset + 1 /* GeometryTriangleCount */];
                                var vertexOffset = intArray[this._geometryData.offset + 2 /* GeometryFloatOffset */];
                                if (vertexOffset < 0) {
                                    vertexOffset += 65536; // Fixed out of bouds bug.
                                }
                                var uvOffset = vertexOffset + vertexCount * 2;
                                var scale = this._armature._armatureData.scale;
                                var meshDisplay = this._renderDisplay;
                                var region = currentTextureData.region;
                                meshDisplay.fakeVertices = new Float32Array(vertexCount * 2);
                                meshDisplay.fakeUvs = new Float32Array(vertexCount * 2);
                                meshDisplay.fakeIndices = new Uint16Array(triangleCount * 3);
                                for (var i = 0, l = vertexCount * 2; i < l; ++i) {
                                    meshDisplay.fakeVertices[i] = floatArray[vertexOffset + i] * scale;
                                }
                                for (var i = 0; i < triangleCount * 3; ++i) {
                                    meshDisplay.fakeIndices[i] = intArray[this._geometryData.offset + 4 /* GeometryVertexIndices */ + i];
                                }
                                for (var i = 0, l = vertexCount * 2; i < l; i += 2) {
                                    var u = floatArray[uvOffset + i];
                                    var v = floatArray[uvOffset + i + 1];
                                    if (currentTextureData.rotated) {
                                        meshDisplay.fakeUvs[i] = (region.x + (1.0 - v) * region.width) / currentTextureAtlasData.width;
                                        meshDisplay.fakeUvs[i + 1] = (region.y + u * region.height) / currentTextureAtlasData.height;
                                    }
                                    else {
                                        meshDisplay.fakeUvs[i] = (region.x + u * region.width) / currentTextureAtlasData.width;
                                        meshDisplay.fakeUvs[i + 1] = (region.y + v * region.height) / currentTextureAtlasData.height;
                                    }
                                }
                                this._textureScale = 1.0;
                                meshDisplay.texture = frame.texture;
                                meshDisplay.frame = frame;
                                meshDisplay.updateVertices();
                                var isSkinned = this._geometryData.weight !== null;
                                var isSurface = this._parent._boneData.type !== 0 /* Bone */;
                                if (isSkinned || isSurface) {
                                    this._identityTransform();
                                }
                            }
                            else { // normal texture.
                                this._renderDisplay.texture = frame.texture;
                                this._renderDisplay.frame = frame;
                                this._renderDisplay.setDisplayOrigin(this._pivotX, this._pivotY);
                                this._textureScale = currentTextureData.parent.scale * this.armature.armatureData.scale;
                                this._renderDisplay.setScale(this._textureScale);
                            }
                            this._visibleDirty = true;
                            return;
                        }
                    }
                    else {
                        this._renderDisplay.x = 0.0;
                        this._renderDisplay.y = 0.0;
                        this._renderDisplay.setTexture(undefined);
                    }
                };
                Slot.prototype._updateMesh = function () {
                    var scale = this._armature._armatureData.scale;
                    var deformVertices = this._displayFrame.deformVertices;
                    var bones = this._geometryBones;
                    var geometryData = this._geometryData;
                    var weightData = geometryData.weight;
                    var hasDeform = deformVertices.length > 0 && geometryData.inheritDeform;
                    var meshDisplay = this._renderDisplay;
                    if (weightData !== null) {
                        var data = geometryData.data;
                        var intArray = data.intArray;
                        var floatArray = data.floatArray;
                        var vertexCount = intArray[geometryData.offset + 0 /* GeometryVertexCount */];
                        var weightFloatOffset = intArray[weightData.offset + 1 /* WeigthFloatOffset */];
                        if (weightFloatOffset < 0) {
                            weightFloatOffset += 65536; // Fixed out of bouds bug.
                        }
                        for (var i = 0, iD = 0, iB = weightData.offset + 2 /* WeigthBoneIndices */ + bones.length, iV = weightFloatOffset, iF = 0; i < vertexCount; ++i) {
                            var boneCount = intArray[iB++];
                            var xG = 0.0, yG = 0.0;
                            for (var j = 0; j < boneCount; ++j) {
                                var boneIndex = intArray[iB++];
                                var bone = bones[boneIndex];
                                if (bone !== null) {
                                    var matrix = bone.globalTransformMatrix;
                                    var weight = floatArray[iV++];
                                    var xL = floatArray[iV++] * scale;
                                    var yL = floatArray[iV++] * scale;
                                    if (hasDeform) {
                                        xL += deformVertices[iF++];
                                        yL += deformVertices[iF++];
                                    }
                                    xG += (matrix.a * xL + matrix.c * yL + matrix.tx) * weight;
                                    yG += (matrix.b * xL + matrix.d * yL + matrix.ty) * weight;
                                }
                            }
                            meshDisplay.fakeVertices[iD++] = xG;
                            meshDisplay.fakeVertices[iD++] = yG;
                        }
                    }
                    else {
                        var isSurface = this._parent._boneData.type !== 0 /* Bone */;
                        var data = geometryData.data;
                        var intArray = data.intArray;
                        var floatArray = data.floatArray;
                        var vertexCount = intArray[geometryData.offset + 0 /* GeometryVertexCount */];
                        var vertexOffset = intArray[geometryData.offset + 2 /* GeometryFloatOffset */];
                        if (vertexOffset < 0) {
                            vertexOffset += 65536; // Fixed out of bouds bug.
                        }
                        for (var i = 0, l = vertexCount * 2; i < l; i += 2) {
                            var x = floatArray[vertexOffset + i] * scale;
                            var y = floatArray[vertexOffset + i + 1] * scale;
                            if (hasDeform) {
                                x += deformVertices[i];
                                y += deformVertices[i + 1];
                            }
                            if (isSurface) {
                                var matrix = this._parent._getGlobalTransformMatrix(x, y);
                                meshDisplay.fakeVertices[i] = matrix.a * x + matrix.c * y + matrix.tx;
                                meshDisplay.fakeVertices[i + 1] = matrix.b * x + matrix.d * y + matrix.ty;
                            }
                            else {
                                meshDisplay.fakeVertices[i] = x;
                                meshDisplay.fakeVertices[i + 1] = y;
                            }
                        }
                    }
                    meshDisplay.updateVertices();
                };
                Slot.prototype._updateTransform = function () {
                    this.updateGlobalTransform();
                    var transform = this.global;
                    this._renderDisplay.x = transform.x; // No need to calcuate pivot offset manually here as Phaser.GameObjects.GameObject takes that into account already.
                    this._renderDisplay.y = transform.y;
                    this._renderDisplay.rotation = transform.rotation;
                    this._renderDisplay["setSkew"](transform.skew, 0);
                    this._renderDisplay.setScale(transform.scaleX * this._textureScale, transform.scaleY * this._textureScale);
                };
                Slot.prototype._identityTransform = function () {
                    this._renderDisplay.setPosition();
                    this._renderDisplay.setRotation();
                    this._textureScale = 1.0;
                    this._renderDisplay.setScale(this._textureScale);
                    this._renderDisplay["setSkew"](0);
                };
                return Slot;
            }(dragonBones.Slot));
            display.Slot = Slot;
        })(display = phaser.display || (phaser.display = {}));
    })(phaser = dragonBones.phaser || (dragonBones.phaser = {}));
})(dragonBones || (dragonBones = {}));
var dragonBones;
(function (dragonBones) {
    var phaser;
    (function (phaser) {
        var display;
        (function (display) {
            var TextureAtlasData = /** @class */ (function (_super) {
                __extends(TextureAtlasData, _super);
                function TextureAtlasData() {
                    var _this = _super !== null && _super.apply(this, arguments) || this;
                    _this._renderTexture = null;
                    return _this;
                }
                TextureAtlasData.toString = function () {
                    return "[class dragonBones.PhaserTextureAtlasData]";
                };
                TextureAtlasData.prototype._onClear = function () {
                    _super.prototype._onClear.call(this);
                    if (this._renderTexture !== null)
                        this._renderTexture.destroy();
                    this._renderTexture = null;
                };
                TextureAtlasData.prototype.createTexture = function () {
                    return dragonBones.BaseObject.borrowObject(TextureData);
                };
                Object.defineProperty(TextureAtlasData.prototype, "renderTexture", {
                    get: function () {
                        return this._renderTexture;
                    },
                    // TODO: test set value runtime
                    set: function (value) {
                        if (!value || this._renderTexture === value)
                            return;
                        if (this._renderTexture)
                            this._renderTexture.destroy();
                        this._renderTexture = value;
                        for (var k in this.textures) {
                            var data = this.textures[k];
                            var frame = this._renderTexture.has(k) ? this._renderTexture.get(k) : this._renderTexture.add(k, 0, // all textures were added through `textures.addImage`, so their sourceIndex are all 0
                            data.region.x, data.region.y, data.region.width, data.region.height);
                            if (data.rotated) {
                                frame.rotated = true;
                                frame.updateUVsInverted();
                            }
                            data.renderTexture = frame;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                return TextureAtlasData;
            }(dragonBones.TextureAtlasData));
            display.TextureAtlasData = TextureAtlasData;
            var TextureData = /** @class */ (function (_super) {
                __extends(TextureData, _super);
                function TextureData() {
                    var _this = _super !== null && _super.apply(this, arguments) || this;
                    _this.renderTexture = null; // Initial value.
                    return _this;
                }
                TextureData.toString = function () {
                    return "[class dragonBones.PhaserTextureData]";
                };
                TextureData.prototype._onClear = function () {
                    _super.prototype._onClear.call(this);
                    if (this.renderTexture !== null)
                        this.renderTexture.destroy();
                    this.renderTexture = null;
                };
                return TextureData;
            }(dragonBones.TextureData));
            display.TextureData = TextureData;
        })(display = phaser.display || (phaser.display = {}));
    })(phaser = dragonBones.phaser || (dragonBones.phaser = {}));
})(dragonBones || (dragonBones = {}));
var dragonBones;
(function (dragonBones) {
    var phaser;
    (function (phaser) {
        var pipeline;
        (function (pipeline) {
            var TextureTintPipeline = /** @class */ (function (_super) {
                __extends(TextureTintPipeline, _super);
                function TextureTintPipeline(config) {
                    var _this = _super.call(this, config) || this;
                    _this._tempMatrix1 = new phaser.util.TransformMatrix();
                    _this._tempMatrix2 = new phaser.util.TransformMatrix();
                    _this._tempMatrix3 = new phaser.util.TransformMatrix();
                    return _this;
                }
                TextureTintPipeline.prototype.batchSprite = function (sprite, camera, parentTransformMatrix) {
                    this.renderer.setPipeline(this);
                    var camMatrix = this._tempMatrix1;
                    var spriteMatrix = this._tempMatrix2;
                    var calcMatrix = this._tempMatrix3;
                    var frame = sprite.frame;
                    var texture = frame.glTexture;
                    var u0 = frame.u0;
                    var v0 = frame.v0;
                    var u1 = frame.u1;
                    var v1 = frame.v1;
                    var frameX = frame.x;
                    var frameY = frame.y;
                    var frameWidth = frame.width;
                    var frameHeight = frame.height;
                    var x = -sprite.displayOriginX + frameX;
                    var y = -sprite.displayOriginY + frameY;
                    if (sprite.isCropped) {
                        var crop = sprite["_crop"];
                        if (crop.flipX !== sprite.flipX || crop.flipY !== sprite.flipY)
                            frame.updateCropUVs(crop, sprite.flipX, sprite.flipY);
                        u0 = crop.u0;
                        v0 = crop.v0;
                        u1 = crop.u1;
                        v1 = crop.v1;
                        frameWidth = crop.width;
                        frameHeight = crop.height;
                        frameX = crop.x;
                        frameY = crop.y;
                        x = -sprite.displayOriginX + frameX;
                        y = -sprite.displayOriginY + frameY;
                    }
                    if (sprite.flipX) {
                        x += frameWidth;
                        frameWidth *= -1;
                    }
                    if (sprite.flipY) {
                        y += frameHeight;
                        frameHeight *= -1;
                    }
                    var xw = x + frameWidth;
                    var yh = y + frameHeight;
                    spriteMatrix.applyITRSC(sprite.x, sprite.y, sprite.rotation, sprite.scaleX, sprite.scaleY, sprite["skewX"] || 0, sprite["skewY"] || 0);
                    camMatrix.copyFrom(camera["matrix"]);
                    if (parentTransformMatrix) {
                        //  Multiply the camera by the parent matrix
                        camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * sprite.scrollFactorX, -camera.scrollY * sprite.scrollFactorY);
                        //  Undo the camera scroll
                        spriteMatrix.e = sprite.x;
                        spriteMatrix.f = sprite.y;
                        //  Multiply by the Sprite matrix, store result in calcMatrix
                        camMatrix.multiply(spriteMatrix, calcMatrix);
                    }
                    else {
                        spriteMatrix.e -= camera.scrollX * sprite.scrollFactorX;
                        spriteMatrix.f -= camera.scrollY * sprite.scrollFactorY;
                        //  Multiply by the Sprite matrix, store result in calcMatrix
                        camMatrix.multiply(spriteMatrix, calcMatrix);
                    }
                    var tx0 = calcMatrix.getX(x, y);
                    var ty0 = calcMatrix.getY(x, y);
                    var tx1 = calcMatrix.getX(x, yh);
                    var ty1 = calcMatrix.getY(x, yh);
                    var tx2 = calcMatrix.getX(xw, yh);
                    var ty2 = calcMatrix.getY(xw, yh);
                    var tx3 = calcMatrix.getX(xw, y);
                    var ty3 = calcMatrix.getY(xw, y);
                    var tintTL = Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlpha(sprite["_tintTL"], camera.alpha * sprite["_alphaTL"]);
                    var tintTR = Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlpha(sprite["_tintTR"], camera.alpha * sprite["_alphaTR"]);
                    var tintBL = Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlpha(sprite["_tintBL"], camera.alpha * sprite["_alphaBL"]);
                    var tintBR = Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlpha(sprite["_tintBR"], camera.alpha * sprite["_alphaBR"]);
                    if (camera.roundPixels) {
                        tx0 |= 0;
                        ty0 |= 0;
                        tx1 |= 0;
                        ty1 |= 0;
                        tx2 |= 0;
                        ty2 |= 0;
                        tx3 |= 0;
                        ty3 |= 0;
                    }
                    this.setTexture2D(texture, 0);
                    var tintEffect = (sprite["_isTinted"] && sprite.tintFill);
                    this.batchQuad(tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, u0, v0, u1, v1, tintTL, tintTR, tintBL, tintBR, tintEffect);
                };
                return TextureTintPipeline;
            }(Phaser.Renderer.WebGL.Pipelines.TextureTintPipeline));
            pipeline.TextureTintPipeline = TextureTintPipeline;
        })(pipeline = phaser.pipeline || (phaser.pipeline = {}));
    })(phaser = dragonBones.phaser || (dragonBones.phaser = {}));
})(dragonBones || (dragonBones = {}));
var dragonBones;
(function (dragonBones) {
    var phaser;
    (function (phaser) {
        var plugin;
        (function (plugin) {
            plugin.FileTypes = {
                IMAGE: "imageFile",
                JSON: "jsonFile",
                BINARY: "binaryFile",
                map: {
                    imageFile: Phaser.Loader.FileTypes.ImageFile,
                    jsonFile: Phaser.Loader.FileTypes.JSONFile,
                    binaryFile: Phaser.Loader.FileTypes.BinaryFile
                },
                setType: function (type, clazz) {
                    plugin.FileTypes.map[type] = clazz;
                },
                getType: function (type) {
                    return plugin.FileTypes.map[type];
                }
            };
        })(plugin = phaser.plugin || (phaser.plugin = {}));
    })(phaser = dragonBones.phaser || (dragonBones.phaser = {}));
})(dragonBones || (dragonBones = {}));
var dragonBones;
(function (dragonBones) {
    var phaser;
    (function (phaser) {
        var plugin;
        (function (plugin) {
            var DragonBonesFile = /** @class */ (function (_super) {
                __extends(DragonBonesFile, _super);
                function DragonBonesFile(loader, key, textureURL, atlasURL, boneURL, textureXhrSettings, atlasXhrSettings, boneXhrSettings) {
                    var _this = this;
                    var image;
                    var data;
                    var boneData;
                    var keyName;
                    var binFileType = plugin.FileTypes.getType(plugin.FileTypes.BINARY);
                    var jsonFileType = plugin.FileTypes.getType(plugin.FileTypes.JSON);
                    var imageFileType = plugin.FileTypes.getType(plugin.FileTypes.IMAGE);
                    var createBoneFileByType = function (loader, key, boneURL, boneXhrSettings) {
                        var type = "json";
                        if (boneXhrSettings && boneXhrSettings.responseType) {
                            switch (boneXhrSettings.responseType) {
                                case "arraybuffer":
                                case "blob":
                                    type = "bin";
                                    break;
                                case "json":
                                case "text":
                                    type = "json";
                                    break;
                            }
                        }
                        return type === "bin" ?
                            new binFileType(loader, key, boneURL, boneXhrSettings) :
                            new jsonFileType(loader, key, boneURL, boneXhrSettings);
                    };
                    if (Phaser.Utils.Objects.IsPlainObject(key)) {
                        // key is actually a config object
                        var config = key;
                        keyName = Phaser.Utils.Objects.GetFastValue(config, 'key');
                        image = new imageFileType(loader, {
                            key: keyName,
                            url: Phaser.Utils.Objects.GetFastValue(config, 'textureURL'),
                            extension: Phaser.Utils.Objects.GetFastValue(config, 'textureExtension', 'png'),
                            xhrSettings: Phaser.Utils.Objects.GetFastValue(config, 'textureXhrSettings')
                        });
                        data = new jsonFileType(loader, {
                            key: keyName + "_atlasjson",
                            url: Phaser.Utils.Objects.GetFastValue(config, 'atlasURL'),
                            extension: Phaser.Utils.Objects.GetFastValue(config, 'atlasExtension', 'json'),
                            xhrSettings: Phaser.Utils.Objects.GetFastValue(config, 'atlasXhrSettings')
                        });
                        boneData = createBoneFileByType(loader, keyName, Phaser.Utils.Objects.GetFastValue(config, 'boneURL'), Phaser.Utils.Objects.GetFastValue(config, 'boneXhrSettings'));
                    }
                    else {
                        keyName = key;
                        image = new imageFileType(loader, keyName, textureURL, textureXhrSettings);
                        data = new jsonFileType(loader, keyName + "_atlasjson", atlasURL, atlasXhrSettings);
                        boneData = createBoneFileByType(loader, keyName, boneURL, boneXhrSettings);
                    }
                    boneData.cache = loader["cacheManager"].custom.dragonbone;
                    _this = _super.call(this, loader, 'dragonbone', keyName, [image, data, boneData]) || this;
                    return _this;
                }
                DragonBonesFile.prototype.addToCache = function () {
                    if (this.isReadyToProcess()) {
                        var image = this.files[0];
                        var json = this.files[1];
                        var bone = this.files[2];
                        json.addToCache();
                        bone.addToCache();
                        image.addToCache();
                        this.complete = true;
                    }
                };
                return DragonBonesFile;
            }(Phaser.Loader.MultiFile));
            plugin.DragonBonesFile = DragonBonesFile;
        })(plugin = phaser.plugin || (phaser.plugin = {}));
    })(phaser = dragonBones.phaser || (dragonBones.phaser = {}));
})(dragonBones || (dragonBones = {}));
var dragonBones;
(function (dragonBones_2) {
    var phaser;
    (function (phaser) {
        var plugin;
        (function (plugin) {
            var DragonBonesScenePlugin = /** @class */ (function (_super) {
                __extends(DragonBonesScenePlugin, _super);
                function DragonBonesScenePlugin(scene, pluginManager) {
                    var _this = _super.call(this, scene, pluginManager) || this;
                    var game = _this.game;
                    // bone data store
                    game.cache.addCustom("dragonbone");
                    if (_this.game.config.renderType === Phaser.WEBGL) {
                        var renderer = _this.game.renderer;
                        if (!renderer.hasPipeline('PhaserTextureTintPipeline'))
                            renderer.addPipeline('PhaserTextureTintPipeline', new phaser.pipeline.TextureTintPipeline({ game: game, renderer: renderer }));
                    }
                    // Add dragonBones only
                    pluginManager.registerGameObject("dragonBones", CreateDragonBonesRegisterHandler);
                    // Add armature, this will add dragonBones when not exist
                    pluginManager.registerGameObject("armature", CreateArmatureRegisterHandler);
                    pluginManager.registerGameObject("dragonBoneFactory", CreateDragonBoneFactoryRegisterHandler);
                    pluginManager.registerFileType("dragonbone", DragonBoneFileRegisterHandler, scene);
                    return _this;
                }
                DragonBonesScenePlugin.prototype.createArmature = function (armature, dragonBones, skinName, atlasTextureName, textureScale) {
                    if (textureScale === void 0) { textureScale = 1.0; }
                    var display = this.factory.buildArmatureDisplay(armature, dragonBones, skinName, atlasTextureName, textureScale);
                    this.systems.displayList.add(display);
                    // use db.clock instead, if here we just use this.systems.updateList.add(display), that will cause the db event is dispatched with 1 or more frames delay
                    this._dbInst.clock.add(display.armature);
                    return display;
                };
                DragonBonesScenePlugin.prototype.createDragonBones = function (dragonBonesName, textureScale) {
                    if (textureScale === void 0) { textureScale = 1.0; }
                    return this.factory.buildDragonBonesData(dragonBonesName, textureScale);
                };
                Object.defineProperty(DragonBonesScenePlugin.prototype, "factory", {
                    get: function () {
                        if (!this._factory) {
                            this._dbInst = new dragonBones.DragonBones(new phaser.util.EventDispatcher());
                            this._factory = new phaser.Factory(this._dbInst, this.scene);
                        }
                        return this._factory;
                    },
                    enumerable: true,
                    configurable: true
                });
                /*
                * Slot has a default display, usually it is a transparent image, here you could create a display whatever you want as the default one which -
                * has both skewX / skewY attributes and use "PhaserTextureTintPipeline" to render itself, or simply just use SlotImage or SlotSprite.
                */
                DragonBonesScenePlugin.prototype.createSlotDisplayPlaceholder = function () {
                    return new phaser.display.SlotImage(this.scene, 0, 0);
                };
                DragonBonesScenePlugin.prototype.boot = function () {
                    this.systems.events.once('destroy', this.destroy, this);
                    this.start();
                };
                DragonBonesScenePlugin.prototype.start = function () {
                    var ee = this.systems.events;
                    ee.on('update', this.update, this);
                    ee.once('shutdown', this.shutdown, this);
                };
                DragonBonesScenePlugin.prototype.update = function (time, delta) {
                    this._dbInst && this._dbInst.advanceTime(delta * 0.001);
                };
                DragonBonesScenePlugin.prototype.shutdown = function () {
                    var ee = this.systems.events;
                    ee.off('update', this.update, this);
                    ee.off('shutdown', this.shutdown, this);
                };
                DragonBonesScenePlugin.prototype.destroy = function () {
                    this.shutdown();
                    this._factory =
                        this._dbInst = null;
                    this.pluginManager =
                        this.game =
                            this.scene =
                                this.systems = null;
                };
                DragonBonesScenePlugin.prototype.createMeshDisplayPlaceholder = function () {
                    return new phaser.display.SlotMesh(this.scene, 0, 0, [], [], [], [], null, null);
                };
                return DragonBonesScenePlugin;
            }(Phaser.Plugins.ScenePlugin));
            plugin.DragonBonesScenePlugin = DragonBonesScenePlugin;
            var CreateDragonBonesRegisterHandler = function (dragonBonesName, textureScale) {
                if (textureScale === void 0) { textureScale = 1.0; }
                return this.scene.dragonbone.createDragonBones(dragonBonesName, textureScale);
            };
            var CreateArmatureRegisterHandler = function (armature, dragonBones, skinName, atlasTextureName) {
                return this.scene.dragonbone.createArmature(armature, dragonBones, skinName, atlasTextureName);
            };
            var CreateDragonBoneFactoryRegisterHandler = function () {
                return this.scene.dragonbone.factory;
            };
            var DragonBoneFileRegisterHandler = function (dragonbonesName, textureURL, atlasURL, boneURL, textureXhrSettings, atlasXhrSettings, boneXhrSettings) {
                var multifile = new plugin.DragonBonesFile(this, dragonbonesName, textureURL, atlasURL, boneURL, textureXhrSettings, atlasXhrSettings, boneXhrSettings);
                this.addFile(multifile.files);
                return this;
            };
        })(plugin = phaser.plugin || (phaser.plugin = {}));
    })(phaser = dragonBones_2.phaser || (dragonBones_2.phaser = {}));
})(dragonBones || (dragonBones = {}));
var dragonBones;
(function (dragonBones_3) {
    var phaser;
    (function (phaser) {
        var Factory = /** @class */ (function (_super) {
            __extends(Factory, _super);
            function Factory(dragonBones, scene, dataParser) {
                var _this = _super.call(this, dataParser) || this;
                _this._scene = scene;
                _this._dragonBones = dragonBones;
                return _this;
            }
            Factory.prototype._isSupportMesh = function () {
                return true;
            };
            Factory.prototype._buildTextureAtlasData = function (textureAtlasData, textureAtlas) {
                if (textureAtlasData) {
                    textureAtlasData.renderTexture = textureAtlas;
                }
                else
                    textureAtlasData = dragonBones_3.BaseObject.borrowObject(phaser.display.TextureAtlasData);
                return textureAtlasData;
            };
            Factory.prototype._buildArmature = function (dataPackage) {
                var armature = dragonBones_3.BaseObject.borrowObject(dragonBones_3.Armature);
                var armatureDisplay = new phaser.display.ArmatureDisplay(this._scene);
                armature.init(dataPackage.armature, armatureDisplay, armatureDisplay, this._dragonBones);
                return armature;
            };
            Factory.prototype._buildSlot = function (dataPackage, slotData, armature) {
                var slot = dragonBones_3.BaseObject.borrowObject(phaser.display.Slot);
                var rawDisplay = this._scene.dragonbone.createSlotDisplayPlaceholder();
                var meshDisplay = this._scene.dragonbone.createMeshDisplayPlaceholder();
                slot.init(slotData, armature, rawDisplay, meshDisplay);
                return slot;
            };
            // dragonBonesName must be assigned, or can't find in cache inside
            Factory.prototype.buildArmatureDisplay = function (armatureName, dragonBonesName, skinName, textureAtlasName, textureScale) {
                if (skinName === void 0) { skinName = ""; }
                if (textureAtlasName === void 0) { textureAtlasName = ""; }
                if (textureScale === void 0) { textureScale = 1.0; }
                var armature;
                if (this.buildDragonBonesData(dragonBonesName, textureScale)) {
                    armature = this.buildArmature(armatureName, dragonBonesName, skinName, textureAtlasName);
                }
                return armature.display;
            };
            Factory.prototype.buildDragonBonesData = function (dragonBonesName, textureScale) {
                if (textureScale === void 0) { textureScale = 1.0; }
                var data = this._dragonBonesDataMap[dragonBonesName];
                if (!data) {
                    var cache = this._scene.cache;
                    var boneRawData = cache.custom.dragonbone.get(dragonBonesName);
                    if (boneRawData) {
                        // parse raw data and add to cache map
                        data = this.parseDragonBonesData(boneRawData, dragonBonesName, textureScale);
                        var texture = this._scene.textures.get(dragonBonesName);
                        var json = cache.json.get(dragonBonesName + "_atlasjson");
                        this.parseTextureAtlasData(json, texture, texture.key, textureScale);
                    }
                }
                return data;
            };
            Object.defineProperty(Factory.prototype, "soundEventManager", {
                /**
                 * - A global sound event manager.
                 * Sound events can be listened to uniformly from the manager.
                 * @version DragonBones 4.5
                 * @language en_US
                 */
                get: function () {
                    return this._dragonBones.eventManager;
                },
                enumerable: true,
                configurable: true
            });
            return Factory;
        }(dragonBones_3.BaseFactory));
        phaser.Factory = Factory;
    })(phaser = dragonBones_3.phaser || (dragonBones_3.phaser = {}));
})(dragonBones || (dragonBones = {}));


/***/ }),
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var net_socket_packet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var net_socket_packet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(net_socket_packet__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var buffer___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30);
/* harmony import */ var buffer___WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(buffer___WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
/* harmony import */ var worker_loader_name_js_hash_name_js_networker__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(131);
/* harmony import */ var worker_loader_name_js_hash_name_js_networker__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(worker_loader_name_js_hash_name_js_networker__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var worker_loader_name_js_hash_name_js_heartbeatworker__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(132);
/* harmony import */ var worker_loader_name_js_hash_name_js_heartbeatworker__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(worker_loader_name_js_hash_name_js_heartbeatworker__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var pixelpai_proto__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2);
/* harmony import */ var pixelpai_proto__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(pixelpai_proto__WEBPACK_IMPORTED_MODULE_5__);



// import {op_client, op_gameconfig, op_gameconfig_01, op_gateway, op_virtual_world} from "pixelpai_proto";
// PBpacket.addProtocol(op_client);
// PBpacket.addProtocol(op_gateway);
// PBpacket.addProtocol(op_gameconfig);
// PBpacket.addProtocol(op_virtual_world);
// PBpacket.addProtocol(op_gameconfig_01);



for (var key in pixelpai_proto__WEBPACK_IMPORTED_MODULE_5__) {
    net_socket_packet__WEBPACK_IMPORTED_MODULE_0__["PBpacket"].addProtocol(pixelpai_proto__WEBPACK_IMPORTED_MODULE_5__[key]);
}
// 网络连接器
// 使用webworker启动socket，无webworker时直接启动socket
var Connection = /** @class */ (function () {
    function Connection(listener) {
        this.mPacketHandlers = [];
        this.mReConnectCount = 0;
        this.mListener = listener;
    }
    Connection.prototype.startConnect = function (addr, keepalive) {
        this.mCachedServerAddress = addr;
        try {
            this.mHeartBeatWorker = new worker_loader_name_js_hash_name_js_heartbeatworker__WEBPACK_IMPORTED_MODULE_4___default.a();
            this.mWorker = new worker_loader_name_js_hash_name_js_networker__WEBPACK_IMPORTED_MODULE_3___default.a();
            this._doConnect();
        }
        catch (e) {
            throw new Error("startConnect Error: " + e);
        }
    };
    Connection.prototype.closeConnect = function () {
        this.mWorker.terminate();
        this.mHeartBeatWorker.terminate();
        this.mCachedServerAddress = undefined;
        this.mReConnectCount = 0;
        this.mTimeout = null;
        this.clearPacketListeners();
    };
    Connection.prototype.clearHeartBeat = function () {
        if (this.mHeartBeatWorker) {
            this.mHeartBeatWorker.postMessage({ method: "clearBeat" });
        }
    };
    Connection.prototype.addPacketListener = function (listener) {
        this.mPacketHandlers.push(listener);
    };
    Connection.prototype.send = function (packet) {
        if (!this.mWorker) {
            throw new Error("NetWorker is undefined.");
        }
        this.mWorker.postMessage({
            "method": "send",
            "buffer": packet.Serialization(),
        });
    };
    Connection.prototype.clearReconnectCount = function () {
        this.mHeartBeatWorker.postMessage("clearBeat");
    };
    Connection.prototype.removePacketListener = function (listener) {
        var idx = this.mPacketHandlers.indexOf(listener);
        if (idx !== -1) {
            this.mPacketHandlers.splice(idx, 1);
        }
    };
    Connection.prototype.clearPacketListeners = function () {
        if (!this.mPacketHandlers || this.mPacketHandlers.length < 1) {
            return;
        }
        var len = this.mPacketHandlers.length;
        for (var i = 0; i < len; i++) {
            var listener = this.mPacketHandlers[i];
            if (!listener)
                continue;
            this.removePacketListener(listener);
            i--;
        }
    };
    Connection.prototype._doConnect = function () {
        // Logger.getInstance().info(`_doConnect `, this.mCachedServerAddress);
        var self = this;
        if (this.mWorker) {
            this.mWorker.onmessage = function (event) {
                self.onWorkerMessage(event.data);
            };
            if (this.mHeartBeatWorker) {
                this.mHeartBeatWorker.onmessage = function (event) {
                    self.onWorkerMessage(event.data);
                };
            }
            this.mWorker.postMessage({
                "method": "connect",
                "address": self.mCachedServerAddress,
            });
        }
    };
    Connection.prototype.onWorkerMessage = function (data) {
        var self = this;
        var method = data.method;
        switch (method) {
            case "onConnected":
                this.mReConnectCount = 0;
                this.mListener.onConnected();
                if (this.mHeartBeatWorker) {
                    this.mHeartBeatWorker.postMessage({ method: "startBeat" });
                }
                break;
            case "onDisConnected":
                if (!this.mTimeout) {
                    if (this.mReConnectCount < 10)
                        this.mReConnectCount++;
                    var delay = Math.pow(this.mReConnectCount, 2);
                    _utils_log__WEBPACK_IMPORTED_MODULE_2__[/* Logger */ "a"].getInstance().info("ReConnect: delay = " + delay * 1000 + "[c/" + this.mReConnectCount + "]");
                    this.mTimeout = setTimeout(function () {
                        self.mTimeout = undefined;
                        self._doConnect();
                    }, delay * 1000);
                }
                break;
            case "onConnectError":
                _utils_log__WEBPACK_IMPORTED_MODULE_2__[/* Logger */ "a"].getInstance().error("error" + data.error);
                // TODO
                this.reConnect();
                break;
            case "heartBeat":
                this.worldStartHeartBeat();
                break;
            case "endBeat":
                this.endHeartBeat();
                break;
            case "reConnect":
                this.reConnect();
                break;
            case "onData":
                var buf = data.buffer;
                if (buf) {
                    this._onData(buf);
                }
                break;
            default:
                break;
        }
    };
    Connection.prototype._onData = function (data) {
        var protobufPacket = new net_socket_packet__WEBPACK_IMPORTED_MODULE_0__["PBpacket"]();
        protobufPacket.Deserialization(new buffer___WEBPACK_IMPORTED_MODULE_1__["Buffer"](data));
        var handlers = this.mPacketHandlers;
        handlers.forEach(function (handler) {
            handler.onPacketArrived(protobufPacket);
        });
    };
    Connection.prototype.reConnect = function () {
        this.mHeartBeatWorker.postMessage({ method: "endHeartBeat" });
        var world = this.mPacketHandlers[0];
        world.reconnect();
    };
    Connection.prototype.worldStartHeartBeat = function () {
        var world = this.mPacketHandlers[0];
        world.startHeartBeat();
    };
    Connection.prototype.endHeartBeat = function () {
        if (this.mHeartBeatWorker) {
            this.mHeartBeatWorker.terminate();
        }
    };
    return Connection;
}());
/* harmony default export */ __webpack_exports__["a"] = (Connection);


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function() {
  return new Worker(__webpack_require__.p + "js/a96d9779147d446026a2.networker.js");
};

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function() {
  return new Worker(__webpack_require__.p + "js/dff7282425c539e57676.heartbeatworker.js");
};

/***/ }),
/* 133 */,
/* 134 */,
/* 135 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return KeyBoardManager; });
/* harmony import */ var net_socket_packet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var net_socket_packet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(net_socket_packet__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var pixelpai_proto__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var KeyBoardManager = /** @class */ (function (_super) {
    __extends(KeyBoardManager, _super);
    function KeyBoardManager(worldService, keyEvents) {
        var _this = _super.call(this) || this;
        _this.worldService = worldService;
        // 是否初始化获取到了需要监听的key值列表
        _this.mInitilized = true;
        // 所有需要监听key的监听事件
        _this.mKeyboardListeners = [];
        // this.mCodeList = [37, 38, 39, 40, 65, 87, 68, 83];
        _this.mKeyList = [];
        _this.mKeyDownList = [];
        _this.mKeyEvents = keyEvents;
        _this.mTmpUpKeysStr = "";
        _this.mTmpDownKeyStr = "";
        _this.mKeyEventMap = new Map();
        _this.mConnect = _this.worldService.connection;
        return _this;
    }
    /**
     * world中当scene发生变化时，传入当前激活的scene
     * room由world去休眠/激活
     */
    KeyBoardManager.prototype.onRoomChanged = function (currentRoom, previousRoom) {
        var _this = this;
        this.mRoom = currentRoom;
        this.mScene = currentRoom.scene;
        if (!this.mScene)
            return;
        if (this.mKeyEvents) {
            var len = this.mKeyEvents.length;
            var keyEvent = void 0;
            var codes = void 0;
            var eventName = void 0;
            for (var i = 0; i < len; i++) {
                keyEvent = this.mKeyEvents[i];
                codes = keyEvent.keyCodes;
                eventName = keyEvent.tqEvent;
                if (!this.mKeyEventMap.get(eventName)) {
                    this.mKeyEventMap.set(eventName, keyEvent);
                }
            }
            this.mKeyEvents.length = 0;
            this.mKeyEvents = null;
        }
        // 暂时屏蔽
        // this.removeKeyEvents();
        this.mKeyEventMap.forEach(function (keyCodeEvent) {
            if (keyCodeEvent) {
                var keyCodes = keyCodeEvent.keyCodes;
                var codesLen = keyCodes.length;
                var keyCode = void 0;
                for (var i = 0; i < codesLen; i++) {
                    keyCode = keyCodes[i];
                    var key = _this.mScene.input.keyboard.addKey(keyCode, false);
                    _this.addKeyEvent(key, keyCodeEvent.tqEvent);
                }
            }
        });
    };
    KeyBoardManager.prototype.getKeyCodes = function (eventName) {
        if (!this.mKeyEventMap.has(eventName))
            return undefined;
        return this.mKeyEventMap.get(eventName).keyCodes;
    };
    KeyBoardManager.prototype.resize = function (width, height) {
    };
    KeyBoardManager.prototype.addListener = function (l) {
        this.mKeyboardListeners.push(l);
    };
    KeyBoardManager.prototype.removeListener = function (l) {
        var idx = this.mKeyboardListeners.indexOf(l);
        if (idx >= 0) {
            this.mKeyboardListeners.splice(idx, 1);
        }
    };
    Object.defineProperty(KeyBoardManager.prototype, "enable", {
        get: function () {
            return this.mScene !== undefined ? this.mScene.input.keyboard.enabled : false;
        },
        /**
         * 设置键盘开关
         */
        set: function (value) {
            if (!this.mScene)
                return;
            this.mScene.input.keyboard.enabled = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(KeyBoardManager.prototype, "keyList", {
        get: function () {
            return this.mKeyList;
        },
        enumerable: false,
        configurable: true
    });
    KeyBoardManager.prototype.getKeyDowns = function () {
        // let keyCodes: number[] = [];
        if (!this.mInitilized) {
            return [];
        }
        if (!this.mKeyList) {
            return [];
        }
        this.mKeyDownList = this.mKeyList.filter(function (keyDown) { return keyDown.isDown; });
        return this.mKeyDownList.map(function (key) { return key.keyCode; });
    };
    KeyBoardManager.prototype.getKeyUps = function () {
        // 在keyDown列表里面查找是否有键抬起，其余没按的键不必监听
        var keyCodes = [];
        if (!this.mInitilized) {
            return keyCodes;
        }
        if (!this.mKeyDownList) {
            return [];
        }
        var key;
        for (var i = 0; i < this.mKeyDownList.length; i++) {
            key = this.mKeyDownList[i];
            if (key && key.isUp) {
                this.mKeyDownList.splice(i, 1);
                keyCodes.push(key.keyCode);
                i--;
            }
        }
        // this.mKeyDownList = this.mKeyDownList.filter((keyDown) => keyDown.isDown);
        return keyCodes;
    };
    KeyBoardManager.prototype.destroy = function () {
        this.removeKeyEvents();
        if (this.mKeyDownList) {
            this.mKeyDownList.length = 0;
            this.mKeyDownList = null;
        }
        // if (this.mCodeList) {
        //     this.mCodeList.length = 0;
        //     this.mCodeList = null;
        // }
        this.mTmpDownKeyStr = null;
        this.mTmpUpKeysStr = null;
        this.mScene = null;
        this.mConnect = null;
        this.mInitilized = false;
    };
    KeyBoardManager.prototype.concatArr = function (arr1, arr2) {
        var i;
        var len = arr1.length > arr2.length ? arr2.length : arr1.length;
        var parentList = arr1.length > arr2.length ? arr1 : arr2;
        var sonList = arr1.length > arr2.length ? arr2 : arr1;
        for (i = 0; i < len; i++) {
            parentList.push(sonList[i]);
        }
        return parentList;
    };
    KeyBoardManager.prototype.checkMoveKeyDown = function (l) {
        var key;
        var keyList = this.mKeyList;
        var len = keyList.length;
        var keyCodeList = [];
        var keyCode;
        var outPut = 0;
        var keyLeftArr = this.getKeyCodes(pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__["op_def"].TQ_EVENT.TQ_MOVE_LEFT);
        var keyDownArr = this.getKeyCodes(pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__["op_def"].TQ_EVENT.TQ_MOVE_DOWN);
        var keyRightArr = this.getKeyCodes(pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__["op_def"].TQ_EVENT.TQ_MOVE_RIGHT);
        var keyUpArr = this.getKeyCodes(pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__["op_def"].TQ_EVENT.TQ_MOVE_UP);
        for (var i = 0; i < len; i++) {
            key = keyList[i];
            keyCode = key.keyCode;
            if (key && key.isDown) {
                keyCodeList.push(key.keyCode);
                if (keyLeftArr) {
                    var left = keyLeftArr.indexOf(keyCode);
                    if (left > -1) {
                        outPut += -1;
                        continue;
                    }
                }
                if (keyRightArr) {
                    var right = keyRightArr.indexOf(keyCode);
                    if (right > -1) {
                        outPut += 1;
                        continue;
                    }
                }
                if (keyDownArr) {
                    var down = keyDownArr.indexOf(keyCode);
                    if (down > -1) {
                        outPut += 3;
                        continue;
                    }
                }
                if (keyUpArr) {
                    var up = keyUpArr.indexOf(keyCode);
                    if (up > -1) {
                        outPut += -3;
                        continue;
                    }
                }
            }
        }
        if (outPut === 0) {
            return false;
        }
        var curDir = l.getDirection();
        var newDir;
        switch (outPut) {
            case -1:
                newDir = curDir <= 1 ? 1 : 3;
                break;
            case -2:
                newDir = 7;
                break;
            case -3:
                newDir = curDir <= 3 ? 1 : 7;
                break;
            case -4:
                newDir = 1;
                break;
            case 1:
                newDir = curDir <= 5 ? 5 : 7;
                break;
            case 2:
                newDir = 3;
                break;
            case 3:
                newDir = curDir <= 3 ? 3 : 5;
                break;
            case 4:
                newDir = 5;
                break;
        }
        if (this.enable) {
            l.setDirection(newDir);
            l.downHandler(newDir, keyCodeList);
            if (this.mRoom && this.mRoom.playerManager.actor)
                this.mRoom.playerManager.actor.setDirection(newDir);
        }
        return true;
    };
    KeyBoardManager.prototype.checkMoveKeyAllUp = function () {
        var key;
        var keyList = this.mKeyList;
        var len = keyList.length;
        for (var i = 0; i < len; i++) {
            key = keyList[i];
            if (key && key.isDown) {
                return false;
            }
        }
        return true;
    };
    KeyBoardManager.prototype.addKeyEvent = function (key, eventName) {
        key.on("down", this.keyDownHandle, this);
        key.on("up", this.keyUpHandle, this);
        this.mKeyList.push(key);
    };
    KeyBoardManager.prototype.keyDownHandle = function (e) {
        var _this = this;
        if (!this.enable) {
            return;
        }
        var pkt = new net_socket_packet__WEBPACK_IMPORTED_MODULE_0__["PBpacket"](pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__["op_virtual_world"].OPCODE._OP_CLIENT_REQ_GATEWAY_KEYBOARD_DOWN);
        var content = pkt.content;
        var keyArr = this.getKeyDowns();
        if (this.mTmpDownKeyStr === keyArr.toString())
            return;
        this.mTmpUpKeysStr = "";
        this.mTmpDownKeyStr = keyArr.toString();
        content.keyCodes = keyArr;
        this.mConnect.send(pkt);
        // then trigger listener
        this.mKeyboardListeners.forEach(function (l) {
            _this.checkMoveKeyDown(l);
        });
    };
    KeyBoardManager.prototype.keyUpHandle = function (e) {
        var _this = this;
        if (!this.enable) {
            return;
        }
        var pkt = new net_socket_packet__WEBPACK_IMPORTED_MODULE_0__["PBpacket"](pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__["op_virtual_world"].OPCODE._OP_CLIENT_REQ_GATEWAY_KEYBOARD_UP);
        var content = pkt.content;
        var keyArr = this.getKeyUps();
        if (this.mTmpUpKeysStr === keyArr.toString() || keyArr.length < 1)
            return;
        this.mTmpDownKeyStr = "";
        this.mTmpUpKeysStr = keyArr.toString();
        content.keyCodes = keyArr;
        this.mConnect.send(pkt);
        // then trigger listener
        this.mKeyboardListeners.forEach(function (l) {
            if (_this.checkMoveKeyAllUp()) {
                l.upHandler();
                return;
            }
            _this.checkMoveKeyDown(l);
        });
    };
    KeyBoardManager.prototype.removeKeyEvents = function () {
        if (!this.mScene)
            return;
        var key;
        var len = this.mKeyList.length;
        for (var i = 0; i < len; i++) {
            key = this.mKeyList[i];
            if (!key) {
                continue;
            }
            key.off("down", this.keyDownHandle);
            key.off("up", this.keyUpHandle);
            this.mScene.input.keyboard.removeKey(key.keyCode);
        }
        this.mKeyList.length = 0;
        // this.mKeyList = null;
    };
    return KeyBoardManager;
}(net_socket_packet__WEBPACK_IMPORTED_MODULE_0__["PacketHandler"]));



/***/ }),
/* 136 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export MouseEvent */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MouseManager; });
/* harmony import */ var net_socket_packet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var net_socket_packet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(net_socket_packet__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var pixelpai_proto__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _const_MessageType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);
/* harmony import */ var _rooms_display_frames_display__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(34);
/* harmony import */ var _rooms_element__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(36);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();





var MouseEvent;
(function (MouseEvent) {
    MouseEvent[MouseEvent["RightMouseDown"] = 1] = "RightMouseDown";
    MouseEvent[MouseEvent["RightMouseUp"] = 2] = "RightMouseUp";
    MouseEvent[MouseEvent["LeftMouseDown"] = 3] = "LeftMouseDown";
    MouseEvent[MouseEvent["LeftMouseUp"] = 4] = "LeftMouseUp";
    MouseEvent[MouseEvent["WheelDown"] = 5] = "WheelDown";
    MouseEvent[MouseEvent["WheelUp"] = 6] = "WheelUp";
    MouseEvent[MouseEvent["RightMouseHolding"] = 7] = "RightMouseHolding";
    MouseEvent[MouseEvent["LeftMouseHolding"] = 8] = "LeftMouseHolding";
    MouseEvent[MouseEvent["Tap"] = 9] = "Tap";
})(MouseEvent || (MouseEvent = {}));
var MouseManager = /** @class */ (function (_super) {
    __extends(MouseManager, _super);
    function MouseManager(worldService) {
        var _this = _super.call(this) || this;
        _this.worldService = worldService;
        _this.running = false;
        _this.mDownDelay = 2000;
        _this.mGame = worldService.game;
        _this.zoom = _this.worldService.scaleRatio || 1;
        _this.mConnect = _this.worldService.connection;
        return _this;
    }
    MouseManager.prototype.changeRoom = function (room) {
        this.pause();
        this.mScene = room.scene;
        this.mRoom = room;
        if (!this.mScene)
            return;
        try {
            room.addMouseListen();
        }
        catch (e) {
        }
        room.scene.input.on("gameobjectdown", this.groundDown, this);
        // room.scene.input.on("gameobjectup", this.groundUp, this);
        room.scene.input.on("pointerdown", this.pointerDownHandler, this);
        room.scene.input.on("pointerup", this.onPointerUpHandler, this);
        this.resume();
    };
    MouseManager.prototype.resize = function (width, height) {
    };
    MouseManager.prototype.pause = function () {
        this.running = false;
    };
    MouseManager.prototype.resume = function () {
        this.running = true;
    };
    MouseManager.prototype.onUpdate = function (pointer, gameobject) {
        if (this.running === false || pointer === undefined) {
            return;
        }
        var events = [];
        if (pointer.leftButtonDown()) {
            events.push(MouseEvent.LeftMouseDown);
        }
        else if (pointer.leftButtonReleased()) {
            events.push(MouseEvent.LeftMouseUp);
        }
        if (pointer.middleButtonDown()) {
            events.push(MouseEvent.WheelDown);
        }
        else if (pointer.middleButtonReleased()) {
            events.push(MouseEvent.WheelUp);
        }
        if (pointer.rightButtonDown()) {
            events.push(MouseEvent.RightMouseDown);
        }
        else if (pointer.rightButtonReleased()) {
            events.push(MouseEvent.RightMouseUp);
        }
        var id = 0;
        var com = null;
        if (gameobject && gameobject.parentContainer) {
            id = gameobject.parentContainer.getData("id");
            com = gameobject.parentContainer;
        }
        if (pointer.isDown === false) {
            var diffX = Math.abs(pointer.downX - pointer.upX);
            var diffY = Math.abs(pointer.downY - pointer.upY);
            if (diffX < 10 && diffY < 10) {
                // events.push(MouseEvent.Tap);
                this.worldService.emitter.emit("Tap", pointer, gameobject);
                if (pointer.isDown === false) {
                    if (com instanceof _rooms_display_frames_display__WEBPACK_IMPORTED_MODULE_3__[/* FramesDisplay */ "a"]) {
                        // com.element.scaleTween();
                        var ele = com.element;
                        if (ele instanceof _rooms_element__WEBPACK_IMPORTED_MODULE_4__[/* Element */ "a"]) {
                            com.scaleTween();
                        }
                    }
                }
            }
        }
        if (events.length === 0) {
            return;
        }
        var pkt = new net_socket_packet__WEBPACK_IMPORTED_MODULE_0__["PBpacket"](pixelpai_proto__WEBPACK_IMPORTED_MODULE_1__["op_virtual_world"].OPCODE._OP_CLIENT_REQ_VIRTUAL_WORLD_MOUSE_EVENT);
        var content = pkt.content;
        content.id = id;
        content.mouseEvent = events;
        content.point3f = { x: pointer.worldX / this.zoom, y: pointer.worldY / this.zoom };
        this.mConnect.send(pkt);
    };
    Object.defineProperty(MouseManager.prototype, "enable", {
        get: function () {
            if (this.mScene) {
                return this.mScene.input.mouse.enabled;
            }
            return false;
        },
        /**
         * 设置鼠标事件开关
         */
        set: function (value) {
            if (this.mScene) {
                this.mScene.input.mouse.enabled = value;
            }
        },
        enumerable: false,
        configurable: true
    });
    MouseManager.prototype.destroy = function () {
        this.mScene = null;
        this.mConnect = null;
        this.mGroundLayer = null;
        this.running = false;
    };
    MouseManager.prototype.groundDown = function (pointer, gameObject) {
        var _this = this;
        this.mGameObject = gameObject;
        this.mDownTime = setTimeout(function () {
            _this.worldService.emitter.emit(_const_MessageType__WEBPACK_IMPORTED_MODULE_2__[/* MessageType */ "a"].PRESS_ELEMENT, pointer, gameObject);
        }, this.mDownDelay);
    };
    MouseManager.prototype.groundUp = function (pointer, gameObject) {
        // this.mGameObject = null;
        this.onUpdate(pointer, gameObject);
    };
    MouseManager.prototype.pointerDownHandler = function (pointer, gameobject) {
        if (this.worldService) {
            if (this.worldService.emitter) {
                this.worldService.emitter.emit(_const_MessageType__WEBPACK_IMPORTED_MODULE_2__[/* MessageType */ "a"].SCENE_BACKGROUND_CLICK, pointer);
            }
        }
        this.onUpdate(pointer, this.mGameObject);
    };
    MouseManager.prototype.onPointerUpHandler = function (pointer) {
        clearTimeout(this.mDownTime);
        this.onUpdate(pointer, this.mGameObject);
        this.mGameObject = null;
    };
    return MouseManager;
}(net_socket_packet__WEBPACK_IMPORTED_MODULE_0__["PacketHandler"]));



/***/ }),
/* 137 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return JoyStickManager; });
/* unused harmony export JoyStick */
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _rooms_element_element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11);
/* harmony import */ var pixelpai_proto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2);
/* harmony import */ var pixelpai_proto__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(pixelpai_proto__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _rooms_decorate_room__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(96);




var TEMP_CONST = {
    MOUSE_DOWN: 0,
    MOUSE_MOVE: 1,
    MOUSE_UP: 2,
    TOUCH_START: 3,
    TOUCH_MOVE: 4,
    TOUCH_END: 5,
    POINTER_LOCK_CHANGE: 6,
    TOUCH_CANCEL: 7,
    MOUSE_WHEEL: 8
};
var JoyStickManager = /** @class */ (function () {
    function JoyStickManager(worldService, keyEvents) {
        this.worldService = worldService;
        this.mEnabled = false;
        // 用于记录room类型，初始化完成后让joystick处理
        this.mOnListener = false;
        this.mJoyListeners = [];
        this.mScale = worldService.uiScale;
        this.mKeyEvents = keyEvents;
        this.mKeyEventMap = new Map();
        _utils_log__WEBPACK_IMPORTED_MODULE_0__[/* Logger */ "a"].getInstance().debug("JoyStickManager " + worldService.uiScale);
    }
    JoyStickManager.prototype.onRoomChanged = function (currentRoom, previousRoom) {
        if (!this.mJoyStick) {
            this.mOnListener = currentRoom instanceof _rooms_decorate_room__WEBPACK_IMPORTED_MODULE_3__[/* DecorateRoom */ "a"] ? false : true;
            return;
        }
        if (currentRoom instanceof _rooms_decorate_room__WEBPACK_IMPORTED_MODULE_3__[/* DecorateRoom */ "a"]) {
            this.mJoyStick.offListener();
        }
        else {
            this.mJoyStick.onListener();
        }
    };
    JoyStickManager.prototype.setScene = function (scene) {
        this.mScene = scene;
        if (!this.mScene || !this.mKeyEvents)
            return;
        var len = this.mKeyEvents.length;
        var keyEvent;
        var codes;
        var eventName;
        for (var i = 0; i < len; i++) {
            keyEvent = this.mKeyEvents[i];
            codes = keyEvent.keyCodes;
            eventName = keyEvent.tqEvent;
            if (!this.mKeyEventMap.get(eventName)) {
                this.mKeyEventMap.set(eventName, keyEvent);
            }
        }
        this.mKeyEvents.length = 0;
        this.mKeyEvents = null;
        this.mParentcon = this.mScene.add.container(0, 0); // (150, size.height - 150);
        var scale = !this.mScale ? 1 : this.mScale;
        this.mJoyStick = new JoyStick(this.mScene, this.worldService, this.mParentcon, this.mJoyListeners, scale);
        if (this.mOnListener) {
            this.mJoyStick.onListener();
        }
        else {
            this.mJoyStick.offListener();
        }
    };
    JoyStickManager.prototype.resize = function () {
        if (!this.mParentcon)
            return;
        this.mParentcon.scaleX = this.mParentcon.scaleY = this.worldService.uiScale;
        // const size: Size = this.worldService.getSize();
        // const mainUIMed = this.worldService.uiManager.getMediator(MainUIMediator.NAME) as MainUIMediator;
        // const padHei: number = !mainUIMed ? this.mParentcon.height : (mainUIMed.getView() as MainUIMobile).getBottomView().height;
        // if (this.mParentcon) {
        //     if (this.worldService.game.scale.orientation === Phaser.Scale.Orientation.LANDSCAPE) {
        //         this.mParentcon.x = this.mParentcon.width * this.worldService.uiScale;
        //         this.mParentcon.y = size.height - this.mParentcon.height * this.worldService.uiScale;
        //     } else {
        //         this.mParentcon.x = this.mParentcon.width * this.worldService.uiScale;
        //         this.mParentcon.y = size.height - (padHei + this.mParentcon.height) * this.worldService.uiScale;
        //     }
        //     this.mParentcon.scaleX = this.mParentcon.scaleY = this.worldService.uiScale;
        // }
    };
    JoyStickManager.prototype.tweenView = function (show) {
        var toAlpha = show === true ? 1 : 0;
        this.mParentcon.visible = show;
        // const size: Size = this.worldService.getSize();
        // let baseX: number;
        // let baseY: number;
        // const mainUIMed = this.worldService.uiManager.getMediator(MainUIMediator.NAME) as MainUIMediator;
        // const padHei: number = !mainUIMed ? this.mParentcon.height : (mainUIMed.getView() as MainUIMobile).getBottomView().height;
        // if (this.worldService.game.scale.orientation === Phaser.Scale.Orientation.LANDSCAPE) {
        //     baseX = this.mParentcon.width * this.worldService.uiScale;
        //     baseY = size.height - this.mParentcon.height * this.worldService.uiScale;
        // } else {
        //     baseX = this.mParentcon.width * this.worldService.uiScale;
        //     baseY = size.height - (padHei + this.mParentcon.height) * this.worldService.uiScale;
        // }
        // const toX: number = show === true ? baseX : baseX - this.mParentcon.width;
        // const toY: number = baseY;
        // this.mScene.tweens.add({
        //     targets: this.mParentcon,
        //     duration: 200,
        //     ease: "Linear",
        //     props: {
        //         x: { value: toX },
        //         y: { value: toY },
        //         alpha: { value: toAlpha },
        //     },
        // });
    };
    JoyStickManager.prototype.addListener = function (l) {
        this.mJoyListeners.push(l);
        if (this.mJoyStick) {
            this.mJoyStick.changeListeners(this.mJoyListeners);
        }
    };
    JoyStickManager.prototype.getKeyCodes = function (eventName) {
        if (!this.mKeyEventMap.has(eventName))
            return undefined;
        var len = this.mKeyEventMap.get(eventName).keyCodes.length;
        var keyCodes = [];
        for (var i = 0; i < len; i++) {
            var keyCode = this.mKeyEventMap.get(eventName).keyCodes[i];
            keyCodes.push(keyCode);
        }
        return keyCodes;
    };
    JoyStickManager.prototype.removeListener = function (l) {
        // this.mJoyStick.removeListener(l);
        var idx = this.mJoyListeners.indexOf(l);
        if (idx >= 0) {
            this.mJoyListeners.splice(idx, 1);
        }
        if (this.mJoyStick) {
            this.mJoyStick.changeListeners(this.mJoyListeners);
        }
    };
    JoyStickManager.prototype.getKeyDowns = function () {
        return [];
    };
    JoyStickManager.prototype.getKeyUps = function () {
        return [];
    };
    JoyStickManager.prototype.downHandler = function () {
    };
    JoyStickManager.prototype.upHandler = function () {
    };
    Object.defineProperty(JoyStickManager.prototype, "enable", {
        get: function () {
            return this.mEnabled;
        },
        set: function (val) {
            this.mEnabled = val;
        },
        enumerable: false,
        configurable: true
    });
    return JoyStickManager;
}());

var JoyStick = /** @class */ (function () {
    function JoyStick(scene, world, parentCon, joyListeners, scale) {
        this.mDown = false;
        this.mScene = scene;
        this.mWorld = world;
        this.parentCon = parentCon;
        this.mJoyListeners = joyListeners;
        this.mScale = scale;
        this.mKeyCodes = [];
        this.load();
    }
    JoyStick.prototype.load = function () {
        this.mScene.load.atlas("joystick", "./resources/ui/joystick/joystick.png", "./resources/ui/joystick/joystick.json");
        this.mScene.load.once(Phaser.Loader.Events.COMPLETE, this.onLoadCompleteHandler, this);
        this.mScene.load.start();
    };
    JoyStick.prototype.onListener = function () {
        this.mScene.input.on("pointerdown", this.downHandler, this);
        this.mScene.input.on("pointerup", this.upHandler, this);
    };
    JoyStick.prototype.offListener = function () {
        this.parentCon.visible = false;
        this.mScene.input.off("pointermove", this.pointerMove, this);
        this.mScene.input.off("pointerdown", this.downHandler, this);
        this.mScene.input.off("pointerup", this.upHandler, this);
    };
    JoyStick.prototype.changeListeners = function (list) {
        this.mJoyListeners = list;
    };
    JoyStick.prototype.onLoadCompleteHandler = function () {
        var size = this.mWorld.getSize();
        this.bg = this.mScene.make.sprite(undefined, false);
        this.bg.setTexture("joystick", "joystick_bg.png");
        this.bgRadius = this.bg.width + 100 >> 1;
        this.btn = this.mScene.make.sprite(undefined, false);
        this.btn.name = "joystick_btn";
        this.btn.setTexture("joystick", "joystick_tab.png");
        this.btn.x = this.bg.x;
        this.btn.y = this.bg.y;
        this.parentCon.alpha = .5;
        this.parentCon.addAt(this.bg, 0);
        this.parentCon.addAt(this.btn, 1);
        this.btn.setInteractive(new Phaser.Geom.Rectangle(0, 0, this.btn.width, this.btn.height), Phaser.Geom.Rectangle.Contains);
        // this.mScene.input.setDraggable(this.btn);
        // this.mScene.input.on("pointerdown", this.downHandler, this);
        // this.mScene.input.on("pointerup", this.upHandler, this);
        this.parentCon.setSize(this.bg.width, this.bg.height);
        this.parentCon.visible = false;
    };
    // private dragStart(pointer) {
    //     Logger.getInstance().log("dragstart");
    //     this.btn.on("drag", this.dragUpdate, this);
    //     this.btn.off("dragstart", this.dragStart, this);
    //     this.btn.on("dragend", this.dragStop, this);
    //     this.btn.on("dragcancel", this.dragStop, this);
    // }
    JoyStick.prototype.downHandler = function (pointer, gameojectList) {
        if (!this.mWorld.inputManager.enable) {
            return;
        }
        if (this.mDown)
            return;
        if (gameojectList) {
            if (gameojectList.length > 1) {
                return;
            }
            else if (gameojectList.length === 1) {
                if (gameojectList[0].name) {
                    if (gameojectList[0].name !== "joystick_btn") {
                        return;
                    }
                }
                else {
                    return;
                }
            }
        }
        this.mDown = true;
        this.mScene.input.on("pointermove", this.pointerMove, this);
        // 由于app环境下，游戏在浏览器中是全屏模式，所以需要在点击事件上除以当前UIscale调整位置
        this.parentCon.x = pointer.worldX;
        this.parentCon.y = pointer.worldY;
        this.parentCon.visible = true;
        // this.mScene.input.off("pointerdown", this.downHandler, this);
        // this.mScene.input.manager.updateInputPlugins(TEMP_CONST.TOUCH_END, [pointer]);
        // this.btn.on("dragstart", this.dragStart, this);
        // this.mScene.input.manager.updateInputPlugins(TEMP_CONST.TOUCH_START, [pointer]);
        // // phaser 的冒泡事件比较奇葩，没有停止冒泡的参数选项，只会把第一个有返回交互事件的scene返回过来，如果是多层scene，后续scene的交互就会return
        // // 实际是为了防止多个事件派发，其实很蠢，应该给参数让用户自己选择是否派发
        // const play: PlayScene = this.mWorld.game.scene.getScene(PlayScene.name) as PlayScene;
        // if (play) (play.input as any).update(TEMP_CONST.MOUSE_DOWN, [pointer]);
    };
    JoyStick.prototype.pointerMove = function (pointer) {
        var _this = this;
        if (!this.mWorld.inputManager.enable) {
            return;
        }
        var dragX = pointer.worldX - this.parentCon.x;
        var dragY = pointer.worldY - this.parentCon.y;
        var d = Math.sqrt(dragX * dragX + dragY * dragY);
        if (d > this.bgRadius) {
            d = this.bgRadius;
        }
        var r = Math.atan2(dragY, dragX);
        this.btn.x = Math.cos(r) * d;
        this.btn.y = Math.sin(r) * d;
        if (!this.mWorld.inputManager.enable) {
            return;
        }
        var radian = Math.acos(dragX / d);
        if (pointer.worldY > this.parentCon.y) {
            radian = -radian;
        }
        this.mJoyListeners.forEach(function (l) {
            _this.checkdragDown(l, radian);
        });
    };
    // private dragUpdate(pointer, dragX, dragY) {
    //     Logger.getInstance().log("draging");
    //     let d = Math.sqrt(dragX * dragX + dragY * dragY);
    //     if (d > this.bgRadius) {
    //         d = this.bgRadius;
    //     }
    //     const r = Math.atan2(dragY, dragX);
    //     this.btn.x = Math.cos(r) * d + this.bg.x;
    //     this.btn.y = Math.sin(r) * d + this.bg.y;
    //     if (!(this.mWorld.inputManager as JoyStickManager).enable) {
    //         return;
    //     }
    //     this.mJoyListeners.forEach((l: InputListener) => {
    //         this.checkdragDown(l, r);
    //     });
    // }
    JoyStick.prototype.upHandler = function (pointer) {
        var _this = this;
        this.btn.x = this.bg.x;
        this.btn.y = this.bg.y;
        this.mDown = false;
        this.parentCon.visible = false;
        this.mScene.input.off("pointermove", this.pointerMove, this);
        if (!this.mWorld.inputManager.enable) {
            return;
        }
        this.mJoyListeners.forEach(function (l) {
            if (_this.checkdragUp()) {
                l.upHandler();
            }
        });
    };
    JoyStick.prototype.checkdragDown = function (l, r) {
        var dir;
        var keyArr = [];
        var radian = Math.PI * 0.125;
        if (r > -radian && r <= radian) {
            dir = _rooms_element_element__WEBPACK_IMPORTED_MODULE_1__[/* Direction */ "a"].east;
            _utils_log__WEBPACK_IMPORTED_MODULE_0__[/* Logger */ "a"].getInstance().log("dir:Direction.east");
        }
        else if (r > radian && r <= 3 * radian) {
            dir = _rooms_element_element__WEBPACK_IMPORTED_MODULE_1__[/* Direction */ "a"].east_north;
            _utils_log__WEBPACK_IMPORTED_MODULE_0__[/* Logger */ "a"].getInstance().log("dir:Direction.east_north");
        }
        else if (r > 3 * radian && r <= 5 * radian) {
            dir = _rooms_element_element__WEBPACK_IMPORTED_MODULE_1__[/* Direction */ "a"].north;
            _utils_log__WEBPACK_IMPORTED_MODULE_0__[/* Logger */ "a"].getInstance().log("dir:Direction.north");
        }
        else if (r > 5 * radian && r <= 7 * radian) {
            dir = _rooms_element_element__WEBPACK_IMPORTED_MODULE_1__[/* Direction */ "a"].north_west;
            _utils_log__WEBPACK_IMPORTED_MODULE_0__[/* Logger */ "a"].getInstance().log("dir:Direction.nroth_west");
        }
        else if ((r >= 7 * radian && r <= Math.PI) || (r >= -Math.PI && r < -7 * radian)) {
            dir = _rooms_element_element__WEBPACK_IMPORTED_MODULE_1__[/* Direction */ "a"].west;
            _utils_log__WEBPACK_IMPORTED_MODULE_0__[/* Logger */ "a"].getInstance().log("dir:Direction.west");
        }
        else if (r < -5 * radian && r >= -7 * radian) {
            dir = _rooms_element_element__WEBPACK_IMPORTED_MODULE_1__[/* Direction */ "a"].west_south;
            _utils_log__WEBPACK_IMPORTED_MODULE_0__[/* Logger */ "a"].getInstance().log("dir:Direction.west_south");
        }
        else if (r > -5 * radian && r <= -3 * radian) {
            dir = _rooms_element_element__WEBPACK_IMPORTED_MODULE_1__[/* Direction */ "a"].south;
            _utils_log__WEBPACK_IMPORTED_MODULE_0__[/* Logger */ "a"].getInstance().log("dir:Direction.south");
        }
        else if (r > -3 * radian && r <= -radian) {
            dir = _rooms_element_element__WEBPACK_IMPORTED_MODULE_1__[/* Direction */ "a"].south_east;
            _utils_log__WEBPACK_IMPORTED_MODULE_0__[/* Logger */ "a"].getInstance().log("dir:Direction.south_east");
        }
        if (dir === undefined) {
            return;
        }
        keyArr = this.getKeys(dir);
        if (this.mdownStr === keyArr.toString())
            return false;
        this.mdownStr = keyArr.toString();
        l.downHandler(dir, keyArr);
        // if (!(this.mWorld.inputManager as JoyStickManager).enable) {
        //     return false;
        // }
        this.mWorld.roomManager.currentRoom.playerManager.actor.setDirection(dir);
        return true;
    };
    JoyStick.prototype.getKeys = function (dir) {
        var keyArr = this.mKeyCodes[dir];
        if (keyArr) {
            return keyArr;
        }
        switch (dir) {
            case 0:
                keyArr = this.mWorld.inputManager.getKeyCodes(pixelpai_proto__WEBPACK_IMPORTED_MODULE_2__["op_def"].TQ_EVENT.TQ_MOVE_UP);
                break;
            case 1:
                keyArr = Array.prototype.concat.apply(this.mWorld.inputManager.getKeyCodes(pixelpai_proto__WEBPACK_IMPORTED_MODULE_2__["op_def"].TQ_EVENT.TQ_MOVE_UP).concat, this.mWorld.inputManager.getKeyCodes(pixelpai_proto__WEBPACK_IMPORTED_MODULE_2__["op_def"].TQ_EVENT.TQ_MOVE_LEFT));
                break;
            case 2:
                keyArr = this.mWorld.inputManager.getKeyCodes(pixelpai_proto__WEBPACK_IMPORTED_MODULE_2__["op_def"].TQ_EVENT.TQ_MOVE_LEFT);
                break;
            case 3:
                keyArr = Array.prototype.concat.apply(this.mWorld.inputManager.getKeyCodes(pixelpai_proto__WEBPACK_IMPORTED_MODULE_2__["op_def"].TQ_EVENT.TQ_MOVE_DOWN), this.mWorld.inputManager.getKeyCodes(pixelpai_proto__WEBPACK_IMPORTED_MODULE_2__["op_def"].TQ_EVENT.TQ_MOVE_LEFT));
                break;
            case 4:
                keyArr = this.mWorld.inputManager.getKeyCodes(pixelpai_proto__WEBPACK_IMPORTED_MODULE_2__["op_def"].TQ_EVENT.TQ_MOVE_DOWN);
                break;
            case 5:
                keyArr = Array.prototype.concat.apply(this.mWorld.inputManager.getKeyCodes(pixelpai_proto__WEBPACK_IMPORTED_MODULE_2__["op_def"].TQ_EVENT.TQ_MOVE_DOWN), this.mWorld.inputManager.getKeyCodes(pixelpai_proto__WEBPACK_IMPORTED_MODULE_2__["op_def"].TQ_EVENT.TQ_MOVE_RIGHT));
                break;
            case 6:
                keyArr = this.mWorld.inputManager.getKeyCodes(pixelpai_proto__WEBPACK_IMPORTED_MODULE_2__["op_def"].TQ_EVENT.TQ_MOVE_RIGHT);
                break;
            case 7:
                keyArr = Array.prototype.concat.apply(this.mWorld.inputManager.getKeyCodes(pixelpai_proto__WEBPACK_IMPORTED_MODULE_2__["op_def"].TQ_EVENT.TQ_MOVE_UP), this.mWorld.inputManager.getKeyCodes(pixelpai_proto__WEBPACK_IMPORTED_MODULE_2__["op_def"].TQ_EVENT.TQ_MOVE_RIGHT));
                break;
        }
        this.mKeyCodes[dir] = keyArr;
        return keyArr;
    };
    JoyStick.prototype.checkdragUp = function () {
        this.mdownStr = "";
        return true;
    };
    return JoyStick;
}());



/***/ }),
/* 138 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ElementStorage; });
/* harmony import */ var _rooms_display_frames_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35);
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var pixelpai_proto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2);
/* harmony import */ var pixelpai_proto__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(pixelpai_proto__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _rooms_display_animation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(49);
/* harmony import */ var _utils_resUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8);





var ElementStorage = /** @class */ (function () {
    function ElementStorage() {
        this.mModels = new Map();
        this.mElementRef = new Map();
        this.terrainPalette = new Map();
        this.terrainPaletteWithBindId = new Map();
        this.mossPalette = new Map();
        this.event = new Phaser.Events.EventEmitter();
    }
    ElementStorage.prototype.on = function (event, fn, context) {
        this.event.on(event, fn, context);
    };
    ElementStorage.prototype.off = function (event, fn, context) {
        this.event.off(event, fn, context);
    };
    ElementStorage.prototype.setGameConfig = function (config) {
        _utils_log__WEBPACK_IMPORTED_MODULE_1__[/* Logger */ "a"].getInstance().log("TCL: ElementStorage -> config", config);
        if (!config) {
            return;
        }
        var objs = config.objectsList;
        var displayModel = null;
        for (var _i = 0, objs_1 = objs; _i < objs_1.length; _i++) {
            var obj = objs_1[_i];
            if (obj.type === pixelpai_proto__WEBPACK_IMPORTED_MODULE_2__["op_def"].NodeType.ElementNodeType) {
                displayModel = this.mModels.get(obj.id);
                if (!displayModel) {
                    var anis = [];
                    var eleAnis = obj.animations;
                    var objAnis = eleAnis.animationData;
                    for (var _a = 0, objAnis_1 = objAnis; _a < objAnis_1.length; _a++) {
                        var ani = objAnis_1[_a];
                        anis.push(new _rooms_display_animation__WEBPACK_IMPORTED_MODULE_3__[/* Animation */ "a"](ani));
                    }
                    displayModel = new _rooms_display_frames_model__WEBPACK_IMPORTED_MODULE_0__[/* FramesModel */ "a"]({
                        id: obj.id,
                        sn: obj.sn,
                        animations: {
                            defaultAnimationName: eleAnis.defaultAnimationName,
                            display: eleAnis.display,
                            animationData: anis,
                        },
                    });
                    this.mModels.set(obj.id, displayModel);
                }
                var ele = {
                    id: obj.id,
                    displayModel: displayModel,
                };
                this.mElementRef.set(obj.id, ele);
            }
        }
        this.updatePalette(config.root.palette);
        this.updateMoss(config.root.moss);
        this.updateAssets(config.root.assets);
    };
    ElementStorage.prototype.updatePalette = function (palette) {
        for (var _i = 0, _a = Array.from(palette.peersDict.keys()); _i < _a.length; _i++) {
            var key = _a[_i];
            var terrainPalette = palette.peersDict.get(key);
            var terrainModel = this.terrainPalette.get(terrainPalette.id);
            if (!terrainModel) {
                var frameModel = new _rooms_display_frames_model__WEBPACK_IMPORTED_MODULE_0__[/* FramesModel */ "a"]({
                    id: terrainPalette.id,
                    sn: terrainPalette.sn,
                    animations: {
                        defaultAnimationName: terrainPalette.animations.defaultAnimationName,
                        display: terrainPalette.animations.display,
                        animationData: terrainPalette.animations.animationData.map(function (ani) { return new _rooms_display_animation__WEBPACK_IMPORTED_MODULE_3__[/* Animation */ "a"](ani); }),
                    },
                });
                this.terrainPalette.set(key, frameModel);
                this.terrainPaletteWithBindId.set(terrainPalette.id, frameModel);
            }
        }
    };
    ElementStorage.prototype.updateMoss = function (moss) {
        for (var _i = 0, _a = Array.from(moss.peersDict.keys()); _i < _a.length; _i++) {
            var peerKey = _a[_i];
            var elementMoss = moss.peersDict.get(peerKey);
            var elementModel = this.mossPalette.get(elementMoss.id);
            if (!elementModel) {
                var frameModel = new _rooms_display_frames_model__WEBPACK_IMPORTED_MODULE_0__[/* FramesModel */ "a"]({
                    id: elementMoss.id,
                    sn: elementMoss.sn,
                    animations: {
                        defaultAnimationName: elementMoss.animations.defaultAnimationName,
                        display: elementMoss.animations.display,
                        animationData: elementMoss.animations.animationData.map(function (ani) { return new _rooms_display_animation__WEBPACK_IMPORTED_MODULE_3__[/* Animation */ "a"](ani); }),
                    },
                });
                this.mossPalette.set(peerKey, frameModel);
            }
        }
    };
    ElementStorage.prototype.updateAssets = function (assetsNode) {
        var assets = assetsNode.getAssetList();
        this._assets = [];
        for (var _i = 0, assets_1 = assets; _i < assets_1.length; _i++) {
            var asset = assets_1[_i];
            var media = asset.media;
            if (media) {
                var fileType = media.match(/\.([a-zA-Z0-9]+)($|\?)/);
                if (fileType && fileType[1]) {
                    this._assets.push({
                        type: fileType[1],
                        key: asset.key,
                        source: _utils_resUtil__WEBPACK_IMPORTED_MODULE_4__[/* Url */ "c"].getOsdRes(media)
                    });
                }
            }
        }
    };
    ElementStorage.prototype.setSceneConfig = function (config) {
        var objs = config.objectsList;
        var displayModel = null;
        // TODO Lite deserialize可能会有个别Display link失败
        for (var _i = 0, objs_2 = objs; _i < objs_2.length; _i++) {
            var obj = objs_2[_i];
            if (obj.type === pixelpai_proto__WEBPACK_IMPORTED_MODULE_2__["op_def"].NodeType.ElementNodeType) {
                displayModel = this.mModels.get(obj.id);
                if (!displayModel) {
                    var anis = [];
                    var eleAnis = obj.animations;
                    var objAnis = eleAnis.animationData;
                    for (var _a = 0, objAnis_2 = objAnis; _a < objAnis_2.length; _a++) {
                        var ani = objAnis_2[_a];
                        anis.push(new _rooms_display_animation__WEBPACK_IMPORTED_MODULE_3__[/* Animation */ "a"](ani));
                    }
                    displayModel = new _rooms_display_frames_model__WEBPACK_IMPORTED_MODULE_0__[/* FramesModel */ "a"]({
                        id: obj.id,
                        sn: obj.sn,
                        animations: {
                            defaultAnimationName: eleAnis.defaultAnimationName,
                            display: eleAnis.display,
                            animationData: anis,
                        },
                    });
                    this.mModels.set(obj.id, displayModel);
                }
                var ele = {
                    id: obj.id,
                    displayModel: displayModel,
                };
                this.mElementRef.set(obj.id, ele);
            }
        }
        var sceneNode = config.root.children.find(function (node) { return node.type === pixelpai_proto__WEBPACK_IMPORTED_MODULE_2__["op_def"].NodeType.SceneNodeType; });
        this._terrainCollection = sceneNode.terrainCollection;
        this._mossCollection = sceneNode.mossCollection;
        this._scenerys = sceneNode.getScenerys();
        // const scenerys = sceneNode.getScenerys();
        // this._scenerys = [];
        // for (const scenery of scenerys) {
        //     this._scenerys.push(scenery);
        // }
    };
    ElementStorage.prototype.add = function (obj) {
        this.mModels.set(obj.id, obj);
    };
    ElementStorage.prototype.getDisplayModel = function (id) {
        var ele = this.mElementRef.get(id);
        if (ele) {
            return ele.displayModel;
        }
        // Logger.getInstance().error(`can't find element ${id}`);
        return;
    };
    ElementStorage.prototype.getTerrainCollection = function () {
        return this._terrainCollection;
    };
    ElementStorage.prototype.getTerrainPalette = function (key) {
        if (this.terrainPalette.get(key)) {
            return this.terrainPalette.get(key);
        }
    };
    ElementStorage.prototype.getTerrainPaletteByBindId = function (id) {
        if (this.terrainPaletteWithBindId.get(id)) {
            return this.terrainPaletteWithBindId.get(id);
        }
    };
    ElementStorage.prototype.getMossCollection = function () {
        return this._mossCollection;
    };
    ElementStorage.prototype.getMossPalette = function (id) {
        if (this.mossPalette.get(id)) {
            return this.mossPalette.get(id);
        }
    };
    ElementStorage.prototype.getScenerys = function () {
        return this._scenerys;
    };
    ElementStorage.prototype.getAssets = function () {
        return this._assets;
    };
    ElementStorage.prototype.destroy = function () {
        this.mElementRef.clear();
        this.terrainPalette.clear();
        this.mossPalette.clear();
        this._assets = undefined;
    };
    return ElementStorage;
}());



/***/ }),
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */
/***/ (function(module, exports) {

/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */

const DEG_TO_RAD = Math.PI / 180;

/**
 * Convert the given angle from degrees, to the equivalent angle in radians.
 *
 * @function Phaser.Math.DegToRad
 * @since 3.0.0
 *
 * @param {integer} degrees - The angle (in degrees) to convert to radians.
 *
 * @return {number} The given angle converted to radians.
 */
var DegToRad = function (degrees)
{
    return degrees * DEG_TO_RAD;
};

module.exports = DegToRad;


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2019 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */

//  Earcut 2.1.4 (December 4th 2018)

/*
 * ISC License
 * 
 * Copyright (c) 2016, Mapbox
 * 
 * Permission to use, copy, modify, and/or distribute this software for any purpose
 * with or without fee is hereby granted, provided that the above copyright notice
 * and this permission notice appear in all copies.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
 * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
 * THIS SOFTWARE.
 */



module.exports = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(ear, triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, invSize),
        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return p;
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize);
                earcutLinked(c, triangles, dim, minX, minY, invSize);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m.next;

    while (p !== stop) {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    }

    return m;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    if ((equals(p1, q1) && equals(p2, q2)) ||
        (equals(p1, q2) && equals(p2, q1))) return true;
    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2019 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */

var FillPathWebGL = __webpack_require__(180);
var StrokePathWebGL = __webpack_require__(181);

/**
 * Renders this Game Object with the WebGL Renderer to the given Camera.
 * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.
 * This method should not be called directly. It is a utility function of the Render module.
 *
 * @method Phaser.GameObjects.Polygon#renderWebGL
 * @since 3.13.0
 * @private
 *
 * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.
 * @param {Phaser.GameObjects.Polygon} src - The Game Object being rendered in this call.
 * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.
 * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.
 * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested
 */
var PolygonWebGLRenderer = function (renderer, src, interpolationPercentage, camera, parentMatrix)
{
    var pipeline = this.pipeline;

    var camMatrix = pipeline._tempMatrix1;
    var shapeMatrix = pipeline._tempMatrix2;
    var calcMatrix = pipeline._tempMatrix3;

    renderer.setPipeline(pipeline);

    shapeMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);

    camMatrix.copyFrom(camera.matrix);

    if (parentMatrix)
    {
        //  Multiply the camera by the parent matrix
        camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);

        //  Undo the camera scroll
        shapeMatrix.e = src.x;
        shapeMatrix.f = src.y;
    }
    else
    {
        shapeMatrix.e -= camera.scrollX * src.scrollFactorX;
        shapeMatrix.f -= camera.scrollY * src.scrollFactorY;
    }

    camMatrix.multiply(shapeMatrix, calcMatrix);

    var dx = src._displayOriginX;
    var dy = src._displayOriginY;

    var alpha = camera.alpha * src.alpha;

    if (src.isFilled)
    {
        FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
    }

    if (src.isStroked)
    {
        StrokePathWebGL(pipeline, src, alpha, dx, dy);
    }
};

module.exports = PolygonWebGLRenderer;


/***/ }),
/* 180 */
/***/ (function(module, exports) {

/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2019 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */

var Utils = Phaser.Renderer.WebGL.Utils;

/**
 * Renders a filled path for the given Shape.
 *
 * @method Phaser.GameObjects.Shape#FillPathWebGL
 * @since 3.13.0
 * @private
 *
 * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipeline - The WebGL Pipeline used to render this Shape.
 * @param {Phaser.GameObjects.Components.TransformMatrix} calcMatrix - The transform matrix used to get the position values.
 * @param {Phaser.GameObjects.Shape} src - The Game Object shape being rendered in this call.
 * @param {number} alpha - The base alpha value.
 * @param {number} dx - The source displayOriginX.
 * @param {number} dy - The source displayOriginY.
 */
var FillPathWebGL = function (pipeline, calcMatrix, src, alpha, dx, dy)
{
    var fillTintColor = Utils.getTintAppendFloatAlphaAndSwap(src.fillColor, src.fillAlpha * alpha);

    var path = src.pathData;
    var pathIndexes = src.pathIndexes;

    for (var i = 0; i < pathIndexes.length; i += 3)
    {
        var p0 = pathIndexes[i] * 2;
        var p1 = pathIndexes[i + 1] * 2;
        var p2 = pathIndexes[i + 2] * 2;

        var x0 = path[p0 + 0] - dx;
        var y0 = path[p0 + 1] - dy;
        var x1 = path[p1 + 0] - dx;
        var y1 = path[p1 + 1] - dy;
        var x2 = path[p2 + 0] - dx;
        var y2 = path[p2 + 1] - dy;

        var tx0 = calcMatrix.getX(x0, y0);
        var ty0 = calcMatrix.getY(x0, y0);

        var tx1 = calcMatrix.getX(x1, y1);
        var ty1 = calcMatrix.getY(x1, y1);

        var tx2 = calcMatrix.getX(x2, y2);
        var ty2 = calcMatrix.getY(x2, y2);
    
        pipeline.setTexture2D();

        pipeline.batchTri(tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, fillTintColor, fillTintColor, fillTintColor, pipeline.tintEffect);
    }
};

module.exports = FillPathWebGL;


/***/ }),
/* 181 */
/***/ (function(module, exports) {

/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2019 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */

var Utils = Phaser.Renderer.WebGL.Utils;

/**
 * Renders a stroke outline around the given Shape.
 *
 * @method Phaser.GameObjects.Shape#StrokePathWebGL
 * @since 3.13.0
 * @private
 *
 * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipeline - The WebGL Pipeline used to render this Shape.
 * @param {Phaser.GameObjects.Shape} src - The Game Object shape being rendered in this call.
 * @param {number} alpha - The base alpha value.
 * @param {number} dx - The source displayOriginX.
 * @param {number} dy - The source displayOriginY.
 */
var StrokePathWebGL = function (pipeline, src, alpha, dx, dy)
{
    var strokeTint = pipeline.strokeTint;
    var strokeTintColor = Utils.getTintAppendFloatAlphaAndSwap(src.strokeColor, src.strokeAlpha * alpha);

    strokeTint.TL = strokeTintColor;
    strokeTint.TR = strokeTintColor;
    strokeTint.BL = strokeTintColor;
    strokeTint.BR = strokeTintColor;

    var path = src.pathData;
    var pathLength = path.length - 1;
    var lineWidth = src.lineWidth;
    var halfLineWidth = lineWidth / 2;

    var px1 = path[0] - dx;
    var py1 = path[1] - dy;

    if (!src.closePath)
    {
        pathLength -= 2;
    }

    for (var i = 2; i < pathLength; i += 2)
    {
        var px2 = path[i] - dx;
        var py2 = path[i + 1] - dy;

        pipeline.setTexture2D();

        pipeline.batchLine(
            px1,
            py1,
            px2,
            py2,
            halfLineWidth,
            halfLineWidth,
            lineWidth,
            i - 2,
            (src.closePath) ? (i === pathLength - 1) : false
        );

        px1 = px2;
        py1 = py2;
    }
};

module.exports = StrokePathWebGL;


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2019 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */

var FillStyleCanvas = __webpack_require__(183);
var LineStyleCanvas = __webpack_require__(184);
var SetTransform = Phaser.Renderer.Canvas.SetTransform;

/**
 * Renders this Game Object with the Canvas Renderer to the given Camera.
 * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.
 * This method should not be called directly. It is a utility function of the Render module.
 *
 * @method Phaser.GameObjects.Polygon#renderCanvas
 * @since 3.13.0
 * @private
 *
 * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.
 * @param {Phaser.GameObjects.Polygon} src - The Game Object being rendered in this call.
 * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.
 * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.
 * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested
 */
var PolygonCanvasRenderer = function (renderer, src, interpolationPercentage, camera, parentMatrix) {
    var ctx = renderer.currentContext;

    if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
        var dx = src._displayOriginX;
        var dy = src._displayOriginY;

        var path = src.pathData;
        var pathLength = path.length - 1;

        var px1 = path[0] - dx;
        var py1 = path[1] - dy;

        ctx.beginPath();

        ctx.moveTo(px1, py1);

        if (!src.closePath) {
            pathLength -= 2;
        }

        for (var i = 2; i < pathLength; i += 2) {
            var px2 = path[i] - dx;
            var py2 = path[i + 1] - dy;

            ctx.lineTo(px2, py2);
        }

        ctx.closePath();

        if (src.isFilled) {
            FillStyleCanvas(ctx, src);

            ctx.fill();
        }

        if (src.isStroked) {
            LineStyleCanvas(ctx, src);

            ctx.stroke();
        }

        //  Restore the context saved in SetTransform
        ctx.restore();
    }
};

module.exports = PolygonCanvasRenderer;


/***/ }),
/* 183 */
/***/ (function(module, exports) {

/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2019 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */

/**
 * Sets the fillStyle on the target context based on the given Shape.
 *
 * @method Phaser.GameObjects.Shape#FillStyleCanvas
 * @since 3.13.0
 * @private
 *
 * @param {CanvasRenderingContext2D} ctx - The context to set the fill style on.
 * @param {Phaser.GameObjects.Shape} src - The Game Object to set the fill style from.
 * @param {number} [altColor] - An alternative color to render with.
 * @param {number} [altAlpha] - An alternative alpha to render with.
 */
var FillStyleCanvas = function (ctx, src, altColor, altAlpha)
{
    var fillColor = (altColor) ? altColor : src.fillColor;
    var fillAlpha = (altAlpha) ? altAlpha : src.fillAlpha;

    var red = ((fillColor & 0xFF0000) >>> 16);
    var green = ((fillColor & 0xFF00) >>> 8);
    var blue = (fillColor & 0xFF);

    ctx.fillStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + fillAlpha + ')';
};

module.exports = FillStyleCanvas;


/***/ }),
/* 184 */
/***/ (function(module, exports) {

/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2019 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */

/**
 * Sets the strokeStyle and lineWidth on the target context based on the given Shape.
 *
 * @method Phaser.GameObjects.Shape#LineStyleCanvas
 * @since 3.13.0
 * @private
 *
 * @param {CanvasRenderingContext2D} ctx - The context to set the stroke style on.
 * @param {Phaser.GameObjects.Shape} src - The Game Object to set the stroke style from.
 * @param {number} [altColor] - An alternative color to render with.
 * @param {number} [altAlpha] - An alternative alpha to render with.
 */
var LineStyleCanvas = function (ctx, src, altColor, altAlpha)
{
    var strokeColor = (altColor) ? altColor : src.strokeColor;
    var strokeAlpha = (altAlpha) ? altAlpha : src.strokeAlpha;

    var red = ((strokeColor & 0xFF0000) >>> 16);
    var green = ((strokeColor & 0xFF00) >>> 8);
    var blue = (strokeColor & 0xFF);

    ctx.strokeStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + strokeAlpha + ')';
    ctx.lineWidth = src.lineWidth;
};

module.exports = LineStyleCanvas;


/***/ }),
/* 185 */
/***/ (function(module, exports) {

/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2019 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */

//  Source object
//  The key as a string, or an array of keys, i.e. 'banner', or 'banner.hideBanner'
//  The default value to use if the key doesn't exist

/**
 * Retrieves a value from an object.
 *
 * @function Phaser.Utils.Objects.GetValue
 * @since 3.0.0
 *
 * @param {object} source - The object to retrieve the value from.
 * @param {string} key - The name of the property to retrieve from the object. If a property is nested, the names of its preceding properties should be separated by a dot (`.`) - `banner.hideBanner` would return the value of the `hideBanner` property from the object stored in the `banner` property of the `source` object.
 * @param {*} defaultValue - The value to return if the `key` isn't found in the `source` object.
 *
 * @return {*} The value of the requested key.
 */
var GetValue = function (source, key, defaultValue)
{
    if (!source || typeof source === 'number')
    {
        return defaultValue;
    }
    else if (source.hasOwnProperty(key))
    {
        return source[key];
    }
    else if (key.indexOf('.') !== -1)
    {
        var keys = key.split('.');
        var parent = source;
        var value = defaultValue;

        //  Use for loop here so we can break early
        for (var i = 0; i < keys.length; i++)
        {
            if (parent.hasOwnProperty(keys[i]))
            {
                //  Yes it has a key property, let's carry on down
                value = parent[keys[i]];

                parent = parent[keys[i]];
            }
            else
            {
                //  Can't go any further, so reset to default
                value = defaultValue;
                break;
            }
        }

        return value;
    }
    else
    {
        return defaultValue;
    }
};

module.exports = GetValue;


/***/ }),
/* 186 */
/***/ (function(module, exports) {

/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2019 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */

var Utils = Phaser.Renderer.WebGL.Utils;

/**
 * Renders this Game Object with the WebGL Renderer to the given Camera.
 * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.
 * This method should not be called directly. It is a utility function of the Render module.
 *
 * @method Phaser.GameObjects.Text#renderWebGL
 * @since 3.0.0
 * @private
 *
 * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.
 * @param {Phaser.GameObjects.Text} src - The Game Object being rendered in this call.
 * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.
 * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.
 * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested
 */
var TextWebGLRenderer = function (renderer, src, interpolationPercentage, camera, parentMatrix) {
    if ((src.width === 0) || (src.height === 0)) {
        return;
    }

    var frame = src.frame;
    var width = frame.width;
    var height = frame.height;
    var getTint = Utils.getTintAppendFloatAlpha;

    this.pipeline.batchTexture(
        src,
        frame.glTexture,
        width, height,
        src.x, src.y,
        width / src.style.resolution, height / src.style.resolution,
        src.scaleX, src.scaleY,
        src.rotation,
        src.flipX, src.flipY,
        src.scrollFactorX, src.scrollFactorY,
        src.displayOriginX, src.displayOriginY,
        0, 0, width, height,
        getTint(src._tintTL, camera.alpha * src._alphaTL),
        getTint(src._tintTR, camera.alpha * src._alphaTR),
        getTint(src._tintBL, camera.alpha * src._alphaBL),
        getTint(src._tintBR, camera.alpha * src._alphaBR),
        (src._isTinted && src.tintFill),
        0, 0,
        camera,
        parentMatrix
    );
};

module.exports = TextWebGLRenderer;


/***/ }),
/* 187 */
/***/ (function(module, exports) {

/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2019 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */

/**
 * Renders this Game Object with the Canvas Renderer to the given Camera.
 * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.
 * This method should not be called directly. It is a utility function of the Render module.
 *
 * @method Phaser.GameObjects.Text#renderCanvas
 * @since 3.0.0
 * @private
 *
 * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.
 * @param {Phaser.GameObjects.Text} src - The Game Object being rendered in this call.
 * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.
 * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.
 * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested
 */
var TextCanvasRenderer = function (renderer, src, interpolationPercentage, camera, parentMatrix) {
    if ((src.width === 0) || (src.height === 0)) {
        return;
    }

    renderer.batchSprite(src, src.frame, camera, parentMatrix);
};

module.exports = TextCanvasRenderer;


/***/ }),
/* 188 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Account; });
var Account = /** @class */ (function () {
    function Account() {
        // TODO
        // 1. 登陆注册的逻辑在这里做
        // 2. 缓存用户登陆后的帐号咨讯
    }
    Account.prototype.setAccount = function (val) {
        this.mCurAccountData = {
            token: "",
            expire: 0,
            fingerprint: "",
        };
        Object.assign(this.mCurAccountData, val);
    };
    Object.defineProperty(Account.prototype, "accountData", {
        get: function () {
            return this.mCurAccountData;
        },
        enumerable: false,
        configurable: true
    });
    return Account;
}());



/***/ }),
/* 189 */,
/* 190 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GamePauseScene; });
/* harmony import */ var _utils_resUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);
/* harmony import */ var _utils_size__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);
/* harmony import */ var _basic_scene__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(16);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var GamePauseScene = /** @class */ (function (_super) {
    __extends(GamePauseScene, _super);
    function GamePauseScene() {
        return _super.call(this, { key: GamePauseScene.name }) || this;
    }
    GamePauseScene.prototype.preload = function () {
        this.load.image("gamepause.png", _utils_resUtil__WEBPACK_IMPORTED_MODULE_0__[/* Url */ "c"].getRes("gamepause.png"));
    };
    GamePauseScene.prototype.init = function (data) {
        this.mWorld = data.world;
    };
    GamePauseScene.prototype.create = function () {
        var width = this.scale.gameSize.width;
        var height = this.scale.gameSize.height;
        this.bg = this.add.graphics();
        this.bg.fillStyle(0, .8);
        this.bg.fillRect(0, 0, width, height);
        this.pauseImg = this.add.image(width >> 1, height >> 1, "gamepause.png");
        this.tipTF = this.add.text(width - 240 >> 1, height - 50, "点击任意位置开始游戏", { font: "30px Tahoma" });
        this.scale.on("resize", this.checkSize, this);
        this.checkSize(new _utils_size__WEBPACK_IMPORTED_MODULE_1__[/* Size */ "a"](width, height));
        this.input.on("pointerdown", this.downHandler, this);
    };
    GamePauseScene.prototype.awake = function () {
        this.scale.on("resize", this.checkSize, this);
        this.input.on("pointerdown", this.downHandler, this);
        this.scene.wake();
    };
    GamePauseScene.prototype.sleep = function () {
        this.scale.off("resize", this.checkSize, this);
        this.input.off("pointerdown", this.downHandler, this);
        this.scene.sleep();
    };
    GamePauseScene.prototype.getKey = function () {
        return this.sys.config.key;
    };
    GamePauseScene.prototype.downHandler = function () {
        this.mWorld.onFocus();
    };
    GamePauseScene.prototype.checkSize = function (size) {
        var width = size.width;
        var height = size.height;
        this.bg.clear();
        this.bg.fillStyle(0, .8);
        this.bg.fillRect(0, 0, width, height);
        this.pauseImg.scaleX = this.pauseImg.scaleY = this.mWorld.uiScale * .7;
        this.pauseImg.x = width >> 1;
        this.pauseImg.y = height >> 1;
        this.tipTF.scaleX = this.tipTF.scaleY = this.mWorld.uiScale;
        this.tipTF.x = width - 280 * this.mWorld.uiScale >> 1;
        this.tipTF.y = height - 50 * this.mWorld.uiScale;
    };
    return GamePauseScene;
}(_basic_scene__WEBPACK_IMPORTED_MODULE_2__[/* BasicScene */ "a"]));



/***/ }),
/* 191 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return initLocales; });
/* unused harmony export i18n */
/* harmony import */ var i18next__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(200);
/* harmony import */ var i18next_xhr_backend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(192);
/* harmony import */ var i18next_browser_languagedetector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(193);



function initLocales(path) {
    return i18next__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]
        .use(i18next_xhr_backend__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])
        .use(i18next_browser_languagedetector__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])
        .init({
        fallbackLng: "en",
        backend: {
            loadPath: path,
            crossDomain: true
        }
    });
}
var i18n = i18next__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"];


/***/ }),
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export SoundField */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SoundManager; });
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var net_socket_packet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var net_socket_packet__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(net_socket_packet__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var pixelpai_proto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2);
/* harmony import */ var pixelpai_proto__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(pixelpai_proto__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _utils_resUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var SoundField;
(function (SoundField) {
    SoundField[SoundField["Background"] = 0] = "Background";
    SoundField[SoundField["Element"] = 1] = "Element";
    SoundField[SoundField["Effect"] = 2] = "Effect";
})(SoundField || (SoundField = {}));
var SoundManager = /** @class */ (function (_super) {
    __extends(SoundManager, _super);
    function SoundManager(world) {
        var _this = _super.call(this) || this;
        var connection = world.connection;
        if (connection) {
            connection.addPacketListener(_this);
            _this.addHandlerFun(pixelpai_proto__WEBPACK_IMPORTED_MODULE_2__["op_client"].OPCODE._OP_VIRTUAL_WORLD_RES_CLIENT_SOUND_CTL, _this.onPlaySoundHandler);
        }
        return _this;
    }
    SoundManager.prototype.changeRoom = function (room) {
        if (this.mSoundMap) {
            this.mSoundMap.clear();
        }
        this.mSoundMap = new Map();
        this.mScene = room.scene;
    };
    SoundManager.prototype.play = function (config) {
        if (!this.mScene) {
            _utils_log__WEBPACK_IMPORTED_MODULE_0__[/* Logger */ "a"].getInstance().fatal(SoundManager.name + " scene does not exist. play " + config.key + " fatal");
            return;
        }
        var key = config.key;
        if (!key) {
            if (Array.isArray(config.urls)) {
                key = config.urls.join("");
            }
            else {
                key = config.urls;
            }
        }
        var field = config.field || SoundField.Background;
        var sound = this.mSoundMap.get(field);
        if (!sound) {
            sound = new Sound(this.mScene);
            this.mSoundMap.set(field, sound);
        }
        // sound.play(key);
        sound.play(key, config.urls, config.soundConfig);
    };
    SoundManager.prototype.stop = function (field) {
        if (!this.mScene) {
            _utils_log__WEBPACK_IMPORTED_MODULE_0__[/* Logger */ "a"].getInstance().fatal(SoundManager.name + " scene does not exist,can't stop");
            return;
        }
        var sound = this.mSoundMap.get(field);
        if (!sound) {
            return;
        }
        sound.stop();
    };
    SoundManager.prototype.pause = function (field) {
        if (!this.mScene) {
            _utils_log__WEBPACK_IMPORTED_MODULE_0__[/* Logger */ "a"].getInstance().fatal(SoundManager.name + " scene does not exist,can't pause");
            return;
        }
        var sound = this.mSoundMap.get(field);
        if (!sound) {
            return;
        }
        sound.pause();
    };
    SoundManager.prototype.resumes = function (field) {
        if (!this.mScene) {
            _utils_log__WEBPACK_IMPORTED_MODULE_0__[/* Logger */ "a"].getInstance().fatal(SoundManager.name + " scene does not exist,can't resume");
            return;
        }
        var sound = this.mSoundMap.get(field);
        if (!sound) {
            return;
        }
        sound.resume();
    };
    SoundManager.prototype.stopAll = function () {
        if (!this.mScene) {
            _utils_log__WEBPACK_IMPORTED_MODULE_0__[/* Logger */ "a"].getInstance().fatal(SoundManager.name + " scene does not exist,can't stopAll");
            return;
        }
        this.mSoundMap.forEach(function (sound) { if (sound)
            sound.stop(); });
    };
    SoundManager.prototype.pauseAll = function () {
        if (!this.mScene) {
            _utils_log__WEBPACK_IMPORTED_MODULE_0__[/* Logger */ "a"].getInstance().fatal(SoundManager.name + " scene does not exist,can't pauseAll");
            return;
        }
        this.mSoundMap.forEach(function (sound) { if (sound)
            sound.pause(); });
    };
    SoundManager.prototype.resume = function () {
        if (!this.mScene) {
            _utils_log__WEBPACK_IMPORTED_MODULE_0__[/* Logger */ "a"].getInstance().fatal(SoundManager.name + " scene does not exist,can't resumeAll");
            return;
        }
        this.mSoundMap.forEach(function (sound) { if (sound)
            sound.resume(); });
    };
    SoundManager.prototype.destroy = function () {
        if (this.mSoundMap) {
            this.mSoundMap.forEach(function (sound) { if (sound)
                sound.destroy(); });
            this.mSoundMap.clear();
            this.mSoundMap = undefined;
        }
    };
    SoundManager.prototype.onPlaySoundHandler = function (packet) {
        var content = packet.content;
        if (content.loop === undefined) {
            content.loop = true;
        }
        // TODO
        this.play({
            key: content.soundKey,
            urls: _utils_resUtil__WEBPACK_IMPORTED_MODULE_3__[/* Url */ "c"].getOsdRes(content.soundKey),
            field: content.scope,
            soundConfig: { loop: content.loop }
        });
    };
    return SoundManager;
}(net_socket_packet__WEBPACK_IMPORTED_MODULE_1__["PacketHandler"]));

var Sound = /** @class */ (function () {
    function Sound(scene) {
        this.scene = scene;
    }
    Sound.prototype.sound = function () {
        return this.mSound;
    };
    Sound.prototype.play = function (key, urls, soundConfig) {
        if (!this.scene) {
            return;
        }
        if (this.mSound && this.mSound.key === key) {
            if (this.mSound.isPlaying)
                return;
            this.mSound.play();
            return;
        }
        this.mKey = key;
        if (this.scene.cache.audio.exists(key)) {
            this.startPlay();
        }
        else {
            if (!urls) {
                return;
            }
            this.scene.load.once("filecomplete-audio-" + key, this.onSoundCompleteHandler, this);
            this.scene.load.audio(key, urls);
            this.scene.load.start();
        }
    };
    Sound.prototype.pause = function () {
        if (!this.scene) {
            return;
        }
        if (this.mSound) {
            if (this.mSound.isPaused)
                return;
            this.mSound.pause();
            return;
        }
    };
    Sound.prototype.stop = function () {
        if (!this.scene) {
            return;
        }
        if (this.mSound) {
            if (!this.mSound.isPlaying)
                return;
            this.mSound.stop();
            return;
        }
    };
    Sound.prototype.resume = function () {
        if (!this.scene) {
            return;
        }
        if (this.mSound) {
            if (!this.mSound.isPaused)
                return;
            this.mSound.resume();
            return;
        }
    };
    Sound.prototype.destroy = function () {
        if (this.mSound) {
            this.mSound.stop();
            this.mSound.destroy();
            this.mSound = undefined;
        }
    };
    Sound.prototype.onSoundCompleteHandler = function () {
        this.startPlay();
    };
    Sound.prototype.startPlay = function () {
        if (this.mSound) {
            this.mSound.stop();
            this.mSound.destroy();
        }
        this.mSound = this.scene.sound.add(this.mKey);
        this.mSound.play();
    };
    return Sound;
}());


/***/ }),
/* 197 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LoadingManager; });
/* harmony import */ var _scenes_loading__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};

var LoadingManager = /** @class */ (function () {
    function LoadingManager(world) {
        this.world = world;
        this.mResources = [];
    }
    LoadingManager.prototype.start = function (callBack) {
        return __awaiter(this, void 0, void 0, function () {
            var sceneManager;
            var _this = this;
            return __generator(this, function (_a) {
                sceneManager = this.game.scene;
                if (!sceneManager) {
                    return [2 /*return*/, Promise.reject("start faild. SceneManager does not exist")];
                }
                if (!sceneManager.getScene(_scenes_loading__WEBPACK_IMPORTED_MODULE_0__[/* LoadingScene */ "a"].name)) {
                    sceneManager.add(_scenes_loading__WEBPACK_IMPORTED_MODULE_0__[/* LoadingScene */ "a"].name, _scenes_loading__WEBPACK_IMPORTED_MODULE_0__[/* LoadingScene */ "a"]);
                }
                if (sceneManager.isActive(_scenes_loading__WEBPACK_IMPORTED_MODULE_0__[/* LoadingScene */ "a"].name)) {
                    return [2 /*return*/, Promise.resolve()];
                }
                else {
                    sceneManager.start(_scenes_loading__WEBPACK_IMPORTED_MODULE_0__[/* LoadingScene */ "a"].name, {
                        world: this.world,
                        callBack: function (scene) {
                            _this.scene = scene;
                            return Promise.resolve();
                        }
                    });
                }
                return [2 /*return*/];
            });
        });
    };
    LoadingManager.prototype.addAssets = function (assets) {
        return __awaiter(this, void 0, void 0, function () {
            var _i, assets_1, asset;
            return __generator(this, function (_a) {
                if (!this.scene) {
                    return [2 /*return*/, Promise.reject()];
                }
                for (_i = 0, assets_1 = assets; _i < assets_1.length; _i++) {
                    asset = assets_1[_i];
                    this.loadAsset(asset);
                }
                return [2 /*return*/, this.startup(this.scene)];
            });
        });
    };
    LoadingManager.prototype.startup = function (scene) {
        return __awaiter(this, void 0, void 0, function () {
            var _i, _a, asset;
            var _this = this;
            return __generator(this, function (_b) {
                this.scene = scene;
                this.scene.load.once(Phaser.Loader.Events.COMPLETE, function () {
                    _this.mLoading = false;
                    // this.game.scene.remove(LoadingScene.name);
                    return Promise.resolve();
                });
                for (_i = 0, _a = this.mResources; _i < _a.length; _i++) {
                    asset = _a[_i];
                    this.loadAsset(asset);
                }
                this.scene.load.start();
                this.mLoading = true;
                return [2 /*return*/];
            });
        });
    };
    LoadingManager.prototype.destroy = function () {
        if (this.mResources) {
            this.mResources = [];
        }
        this.scene = undefined;
    };
    LoadingManager.prototype.loadAsset = function (asset) {
        var type = this.getLoadType(asset.type);
        if (this.scene.load[type]) {
            this.scene.load[type](asset.key, asset.source);
        }
    };
    Object.defineProperty(LoadingManager.prototype, "game", {
        get: function () {
            if (!this.world) {
                return;
            }
            return this.world.game;
        },
        enumerable: false,
        configurable: true
    });
    LoadingManager.prototype.getLoadType = function (fileType) {
        if (fileType === "mp3" || fileType === "wmv" || fileType === "ogg") {
            return "audio";
        }
        return fileType;
    };
    return LoadingManager;
}());



/***/ }),
/* 198 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ ui_manager_UiManager; });

// EXTERNAL MODULE: ./node_modules/net-socket-packet/dist/index.js
var dist = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/pixelpai_proto/protocols.js
var protocols = __webpack_require__(2);

// EXTERNAL MODULE: ./src/utils/log.ts
var log = __webpack_require__(5);

// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/shape/roundrectangle/geom/RoundRectangle.js
const GetValue = Phaser.Utils.Objects.GetValue;

class RoundRectangle_RoundRectangle {
    constructor(x, y, width, height, radiusConfig) {
        this.cornerRadius = {};
        this._width = 0;
        this._height = 0;
        this.setTo(x, y, width, height, radiusConfig);
    }

    setTo(x, y, width, height, radiusConfig) {
        this.setPosition(x, y);
        this.setRadius(radiusConfig);
        this.setSize(width, height);
        return this;
    }

    setPosition(x, y) {
        if (x === undefined) {
            x = 0;
        }
        if (y === undefined) {
            y = x;
        }
        this.x = x;
        this.y = y;
        return this;
    }

    setRadius(config) {
        if (config === undefined) {
            config = 0;
        }
        var defaultRadiusX, defaultRadiusY;
        if (typeof (config) === 'number') {
            defaultRadiusX = config;
            defaultRadiusY = config;
        } else {
            defaultRadiusX = GetValue(config, 'x', 0);
            defaultRadiusY = GetValue(config, 'y', 0);
        }

        var radius = this.cornerRadius;
        radius.tl = GetRadius(GetValue(config, 'tl', undefined), defaultRadiusX, defaultRadiusY);
        radius.tr = GetRadius(GetValue(config, 'tr', undefined), defaultRadiusX, defaultRadiusY);
        radius.bl = GetRadius(GetValue(config, 'bl', undefined), defaultRadiusX, defaultRadiusY);
        radius.br = GetRadius(GetValue(config, 'br', undefined), defaultRadiusX, defaultRadiusY);
        return this;
    }

    setSize(width, height) {
        this.width = width;
        this.height = height;
        return this;
    }

    get minWidth() {
        var radius = this.cornerRadius;
        return Math.max(radius.tl.x + radius.tr.x, radius.bl.x + radius.br.x);
    }

    get minHeight() {
        var radius = this.cornerRadius;
        return Math.max(radius.tl.y + radius.bl.y, radius.tr.y + radius.br.y);
    }

    get width() {
        return this._width;
    }

    set width(value) {
        if (value == null) {
            value = 0;
        }
        this._width = Math.max(value, this.minWidth);
    }

    get height() {
        return this._height;
    }

    set height(value) {
        if (value == null) {
            value = 0;
        }
        this._height = Math.max(value, this.minHeight);
    }

    get radius() {
        var radius = this.cornerRadius;
        var max = Math.max(
            radius.tl.x,
            radius.tl.y,
            radius.tr.x,
            radius.tr.y,
            radius.bl.x,
            radius.bl.y,
            radius.br.x,
            radius.br.y
        );
        return max;
    }
}

var GetRadius = function (radius, defaultRadiusX, defaultRadiusY) {
    if (radius === undefined) {
        return {
            x: defaultRadiusX,
            y: defaultRadiusY
        };
    } else if (typeof (radius) === 'number') {
        return {
            x: radius,
            y: radius
        };
    } else {
        return radius;
    }
}
/* harmony default export */ var geom_RoundRectangle = (RoundRectangle_RoundRectangle);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/shape/utils/LineTo.js
var LineTo = function (x, y, out) {
    var cnt = out.length;
    if (cnt >= 2) {
        var lastX = out[cnt - 2];
        var lastY = out[cnt - 1];
        if ((x === lastX) && (y === lastY)) {
            return out;
        }
    }

    out.push(x, y);
    return out;
}

/* harmony default export */ var utils_LineTo = (LineTo);
// EXTERNAL MODULE: ./lib/rexui/lib/plugins/utils/math/DegToRad.js
var DegToRad = __webpack_require__(177);
var DegToRad_default = /*#__PURE__*/__webpack_require__.n(DegToRad);

// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/shape/utils/ArcTo.js



var ArcTo = function (centerX, centerY, radiusX, radiusY, startAngle, endAngle, antiClockWise, iteration, out) {
    // startAngle, endAngle: 0 ~ 360
    if (antiClockWise) {
        endAngle += 360;
    }

    startAngle = DegToRad_default()(startAngle);
    endAngle = DegToRad_default()(endAngle);
    var x, y, angle;
    var step = (endAngle - startAngle) / iteration;
    for (var i = 0; i <= iteration; i++) {
        angle = startAngle + (step * i);
        x = centerX + (radiusX * Math.cos(angle));
        y = centerY + (radiusY * Math.sin(angle));
        utils_LineTo(x, y, out);
    }
    return out;
}
/* harmony default export */ var utils_ArcTo = (ArcTo);
// EXTERNAL MODULE: ./lib/rexui/lib/plugins/utils/geom/polygon/Earcut.js
var Earcut = __webpack_require__(178);
var Earcut_default = /*#__PURE__*/__webpack_require__.n(Earcut);

// EXTERNAL MODULE: ./lib/rexui/lib/plugins/gameobjects/shape/roundrectangle/render/WebGLRenderer.js
var WebGLRenderer = __webpack_require__(179);
var WebGLRenderer_default = /*#__PURE__*/__webpack_require__.n(WebGLRenderer);

// EXTERNAL MODULE: ./lib/rexui/lib/plugins/gameobjects/shape/roundrectangle/render/CanvasRenderer.js
var CanvasRenderer = __webpack_require__(182);
var CanvasRenderer_default = /*#__PURE__*/__webpack_require__.n(CanvasRenderer);

// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/object/NOOP.js
var NOOP = function () {
    //  NOOP
};

/* harmony default export */ var object_NOOP = (NOOP);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/shape/roundrectangle/render/Render.js




var renderWebGL = object_NOOP;
var renderCanvas = object_NOOP;

if (true) {
    renderWebGL = WebGLRenderer_default.a;
}

if (true) {
    renderCanvas = CanvasRenderer_default.a;
}

/* harmony default export */ var Render = ({
    renderWebGL: renderWebGL,
    renderCanvas: renderCanvas

});
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/shape/roundrectangle/RoundRectangle.js






const RoundRectangle_GetValue = Phaser.Utils.Objects.GetValue;

class roundrectangle_RoundRectangle_RoundRectangle extends Phaser.GameObjects.Shape {
    constructor(scene, x, y, width, height, radiusConfig, fillColor, fillAlpha) {
        if (x === undefined) {
            x = 0;
        }
        if (y === undefined) {
            y = 0;
        }

        var iteration = RoundRectangle_GetValue(radiusConfig, 'iteration', undefined);
        radiusConfig = RoundRectangle_GetValue(radiusConfig, 'radius', radiusConfig);
        var geom = new geom_RoundRectangle(0, 0, width, height, radiusConfig);
        super(scene, 'RoundRectangle', geom);

        this.setIteration(iteration);
        this.setPosition(x, y);
        // this.setSize(this.geom.width, this.geom.height);

        if (fillColor !== undefined) {
            this.setFillStyle(fillColor, fillAlpha);
        }

        this.updateDisplayOrigin();
        this.updateData();
    }

    updateData() {
        var geom = this.geom;
        var pathData = this.pathData;

        pathData.length = 0;

        var cornerRadius = geom.cornerRadius,
            radius,
            iteration = this.iteration + 1;
        // bottom-right
        radius = cornerRadius.br;
        if (isArcCorner(radius)) {
            var centerX = geom.width - radius.x;
            var centerY = geom.height - radius.y;
            utils_ArcTo(centerX, centerY, radius.x, radius.y, 0, 90, false, iteration, pathData);
        } else {
            utils_LineTo(geom.width, geom.height, pathData);
        }

        // bottom-left
        radius = cornerRadius.bl;
        if (isArcCorner(radius)) {
            var centerX = radius.x;
            var centerY = geom.height - radius.y;
            utils_ArcTo(centerX, centerY, radius.x, radius.y, 90, 180, false, iteration, pathData);
        } else {
            utils_LineTo(0, geom.height, pathData);
        }

        // top-left
        radius = cornerRadius.tl;
        if (isArcCorner(radius)) {
            var centerX = radius.x;
            var centerY = radius.y;
            utils_ArcTo(centerX, centerY, radius.x, radius.y, 180, 270, false, iteration, pathData);
        } else {
            utils_LineTo(0, 0, pathData);
        }

        // top-right
        radius = cornerRadius.tr;
        if (isArcCorner(radius)) {
            var centerX = geom.width - radius.x;
            var centerY = radius.y;
            utils_ArcTo(centerX, centerY, radius.x, radius.y, 270, 360, false, iteration, pathData);
        } else {
            utils_LineTo(geom.width, 0, pathData);
        }

        pathData.push(pathData[0], pathData[1]); // Repeat first point to close curve
        this.pathIndexes = Earcut_default()(pathData);
        return this;
    }

    get width() {
        return this.geom.width;
    }
    set width(value) {
        this.resize(value, this.height);
    }

    get height() {
        return this.geom.height;
    }
    set height(value) {
        this.resize(this.width, value);
    }

    resize(width, height) {
        if (height === undefined) {
            height = width;
        }
        if ((this.geom.width === width) && (this.geom.height === height)) {
            return this;
        }
        this.geom.height = height;
        this.geom.width = width
        this.updateDisplayOrigin();
        this.updateData();

        var input = this.input;
        if (input && !input.customHitArea) {
            input.hitArea.width = width;
            input.hitArea.height = height;
        }
        return this;
    }

    get iteration() {
        return this._iteration;
    }

    set iteration(value) {
        // Set iteration first time
        if (this._iteration === undefined) {
            this._iteration = value;
            return;
        }

        // Change iteration value
        if (this._iteration === value) {
            return;
        }

        this._iteration = value;
        this.updateData();
    }

    setIteration(iteration) {
        if (iteration === undefined) {
            iteration = 6;
        }
        this.iteration = iteration;
        return this;
    }

    get radius() {
        return this.geom.radius;
    }

    set radius(value) {
        this.geom.setRadius(value);
        this.updateDisplayOrigin();
        this.updateData();
    }

    setRadius(value) {
        if (value === undefined) {
            value = 0;
        }
        this.radius = value;
        return this;
    }

    get cornerRadius() {
        return this.geom.cornerRadius;
    }

    set cornerRadius(value) {
        this.radius = value;
    }

    setCornerRadius(value) {
        return this.setRadius(value);
    }
}

var isArcCorner = function (radius) {
    return ((radius.x !== 0) && (radius.y !== 0));
}


Object.assign(
    roundrectangle_RoundRectangle_RoundRectangle.prototype,
    Render
);

/* harmony default export */ var roundrectangle_RoundRectangle = (roundrectangle_RoundRectangle_RoundRectangle);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/containerlite/AddChild.js
/* harmony default export */ var AddChild = ({
    add(gameObject) {
        if (Array.isArray(gameObject)) {
            this.addMultiple(gameObject);
        } else {
            this._add(gameObject);
        }
        return this;
    },

    addMultiple(gameObjects) {
        gameObjects.forEach(this._add, this);
        return this;
    },

    _add(gameObject) {
        this.children.add(gameObject);

        this
            .resetChildState(gameObject)           // Reset local state of child
            .updateChildVisible(gameObject)        // Apply parent's visible to child
            .updateChildActive(gameObject)         // Apply parent's active to child
            .updateChildScrollFactor(gameObject)   // Apply parent's scroll factor to child
            .updateChildMask(gameObject);          // Apply parent's mask to child
        return this;
    },
});
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/containerlite/RemoveChild.js
/* harmony default export */ var RemoveChild = ({
    remove(gameObject, destroyChild) {
        this.children.remove(gameObject, false, destroyChild);
        return this;
    },

    clear(destroyChild) {
        this.children.clear(false, destroyChild);
        return this;
    },
});
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/containerlite/ChildState.js
/* harmony default export */ var ChildState = ({
    getLocalState(gameObject) {
        if (!gameObject.hasOwnProperty('rexContainer')) {
            gameObject.rexContainer = {};
        }
        return gameObject.rexContainer;
    },

    resetChildState(gameObject) {
        this
            .resetChildPositionState(gameObject)
            .resetChildVisibleState(gameObject)
            .resetChildAlphaState(gameObject)
            .resetChildActiveState(gameObject);
        return this;
    },

    resetChildrenState(gameObjects) {
        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
            this.resetChildState(gameObjects[i]);
        }
        return this;
    },

    syncProperties() {
        this
            .syncPosition()
            .syncVisible()
            .syncAlpha()
            .syncActive()
            .syncScrollFactor()
            .syncMask();
        return this;
    }
});
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/containerlite/Transform.js
const RotateAround = Phaser.Math.RotateAround;

/* harmony default export */ var Transform = ({
    worldToLocal(point) {
        // Transform
        point.x -= this.x;
        point.y -= this.y;
        // Rotate
        RotateAround(point, 0, 0, -this.rotation);
        // Scale
        point.x /= this.scaleX;
        point.y /= this.scaleY;
        // Flip
        point.x *= ((!this.flipX) ? 1 : -1);
        point.y *= ((!this.flipY) ? 1 : -1);
        return point;
    },

    localToWorld(point) {
        // Flip
        point.x *= ((!this.flipX) ? 1 : -1);
        point.y *= ((!this.flipY) ? 1 : -1);
        // Scale
        point.x *= this.scaleX;
        point.y *= this.scaleY;
        // Rotate
        RotateAround(point, 0, 0, this.rotation);
        // Transform
        point.x += this.x;
        point.y += this.y;
        return point;
    }
});
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/containerlite/Scale.js
var Scale_Scale = function (a, b) {
    if (a === b) {
        return 1;
    } else {
        return a / b;
    }
}

/* harmony default export */ var containerlite_Scale = (Scale_Scale);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/containerlite/Position.js


/* harmony default export */ var Position = ({
    updateChildPosition(child) {
        if (child.isRexContainerLite) {
            child.syncChildrenEnable = false;
        }
        var state = this.getLocalState(child);
        child.x = state.x;
        child.y = state.y;
        this.localToWorld(child);

        child.scaleX = state.scaleX * this.scaleX;
        child.scaleY = state.scaleY * this.scaleY;

        if (child.flipX !== undefined) {
            child.flipX = (!this.flipX) ? state.flipX : !state.flipX;
            child.flipY = (!this.flipY) ? state.flipY : !state.flipY;
        }

        child.rotation = state.rotation + this.rotation;

        if (child.isRexContainerLite) {
            child.syncChildrenEnable = true;
            child.syncPosition();
        }
        return this;
    },

    syncPosition() {
        if (this.children && this.syncChildrenEnable) {
            this.children.getChildren().forEach(this.updateChildPosition, this);
        }
        return this;
    },

    resetChildPositionState(gameObject) {
        var state = this.getLocalState(gameObject);
        state.x = gameObject.x;
        state.y = gameObject.y;
        this.worldToLocal(state);

        state.scaleX = containerlite_Scale(gameObject.scaleX, this.scaleX);
        state.scaleY = containerlite_Scale(gameObject.scaleY, this.scaleY);

        if (gameObject.flipX !== undefined) {
            state.flipX = gameObject.flipX;
            state.flipY = gameObject.flipY;
        }

        state.rotation = gameObject.rotation - this.rotation;
        return this;
    },
    
    setChildPosition(gameObject, x, y) {
        gameObject.x = x;
        gameObject.y = y;
        this.resetChildPositionState(gameObject);
        return this;
    },

    setChildLocalPosition(gameObject, x, y) {
        var state = this.getLocalState(gameObject);
        state.x = x;
        state.y = y;
        this.updateChildPosition(gameObject);
        return this;
    },
});
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/containerlite/Visible.js
/* harmony default export */ var Visible = ({
    updateChildVisible(child) {
        child.visible = this.visible && this.getLocalState(child).visible;
        return this;
    },

    syncVisible() {
        if (this.children && this.syncChildrenEnable) {
            this.children.getChildren().forEach(this.updateChildVisible, this);
        }
        return this;
    },

    resetChildVisibleState(gameObject) {
        this.getLocalState(gameObject).visible = gameObject.visible;
        return this;
    },

    setChildVisible(gameObject, visible) {
        gameObject.visible = visible;
        this.resetChildVisibleState(gameObject);
        return this;
    },
    
    setChildLocalVisible(gameObject, visible) {
        if (visible === undefined) {
            visible = true;
        }
        this.getLocalState(gameObject).visible = visible;
        this.updateChildVisible(gameObject);
        return this;
    },
});
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/containerlite/Alpha.js


/* harmony default export */ var Alpha = ({
    updateChildAlpha(child) {
        child.alpha = this.alpha * this.getLocalState(child).alpha;
        return this;
    },

    syncAlpha() {
        if (this.children && this.syncChildrenEnable) {
            this.children.getChildren().forEach(this.updateChildAlpha, this);
        }
        return this;
    },

    resetChildAlphaState(gameObject) {
        this.getLocalState(gameObject).alpha = containerlite_Scale(gameObject.alpha, this.alpha);
        return this;
    },
    
    setChildAlpha(gameObject, alpha) {
        gameObject.alpha = alpha;
        this.resetChildAlphaState(gameObject);
        return this._add;
    },
    
    setChildLocalAlpha(gameObject, alpha) {
        this.getLocalState(gameObject).alpha = alpha;
        this.updateChildAlpha(gameObject);
        return this;
    },
});
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/containerlite/Active.js
/* harmony default export */ var Active = ({
    updateChildActive(child) {
        child.active = this.active && this.getLocalState(child).active;
        return this;
    },

    syncActive() {
        if (this.children && this.syncChildrenEnable) {
            this.children.getChildren().forEach(this.updateChildActive, this);
        }
        return this;
    },
    
    resetChildActiveState(gameObject) {
        this.getLocalState(gameObject).active = gameObject.active;
        return this;
    },

    setChildActive(gameObject, active) {
        gameObject.active = active;
        this.resetChildActiveState(gameObject);
        return this;
    },

    setChildLocalActive(gameObject, active) {
        if (active === undefined) {
            active = true;
        }
        this.getLocalState(gameObject).active = active;
        this.updateChildActive(gameObject);
        return this;
    },
});
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/containerlite/ScrollFactor.js
/* harmony default export */ var ScrollFactor = ({
    updateChildScrollFactor(child) {
        child.setScrollFactor(this.scrollFactorX, this.scrollFactorY);
        return this;
    },

    syncScrollFactor() {
        if (this.children && this.syncChildrenEnable) {
            this.children.getChildren().forEach(this.updateChildScrollFactor, this);
        }
        return this;
    },

});
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/containerlite/Mask.js
/* harmony default export */ var Mask = ({
    updateChildMask(child) {
        // Don't propagate null mask to clear children's mask
        if (this.mask == null) {
            return this;
        }

        var maskGameObject = (this.mask.hasOwnProperty('geometryMask')) ? this.mask.geometryMask : this.mask.bitmapMask;
        if (maskGameObject !== child) {
            child.mask = this.mask;
        }
        return this;
    },

    syncMask() {
        if (this.children && this.syncChildrenEnable) {
            this.children.getChildren().forEach(this.updateChildMask, this);
        }
        return this;
    },

    setMask(mask) {
        this.mask = mask;
        return this;
    },

    clearMask(destroyMask) {
        if (destroyMask === undefined) {
            destroyMask = false;
        }

        if (destroyMask && this.mask) {
            this.mask.destroy();
        }
        this.mask = null;
        return this;
    },
});
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/containerlite/Depth.js
/* harmony default export */ var Depth = ({
    setDepth(value) {
        this.depth = value;
        if (this.children) {
            var children = this.getAllChildren();
            for (var i = 0, cnt = children.length; i < cnt; i++) {
                children[i].depth = value;
            }
        }
        return this;
    },

    swapDepth(containerB) {
        var depthA = this.depth;
        var depthB = containerB.depth;
        this.setDepth(depthB);
        containerB.setDepth(depthA);
        return this;
    },

    incDepth(inc) {
        this.depth += inc;
        if (this.children) {
            var children = this.getAllChildren();
            for (var i = 0, cnt = children.length; i < cnt; i++) {
                children[i].depth += inc;
            }
        }
        return this;
    },
});
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/containerlite/Children.js
const ArrayUtils = Phaser.Utils.Array;

/* harmony default export */ var Children = ({
    getChildren() {
        return this.children.getChildren();
    },

    getAllChildren(out) {
        if (out === undefined) {
            out = [];
        }
        var myCildren = this.children.getChildren(),
            myChild;
        for (var i = 0, cnt = myCildren.length; i < cnt; i++) {
            myChild = myCildren[i];
            out.push(myChild);

            if (myChild.hasOwnProperty('isRexContainerLite')) {
                out.push(...myChild.getAllChildren());
            }
        }

        return out;
    },

    contains(gameObject) {
        if (this.children.contains(gameObject)) {
            return true;
        }

        var myCildren = this.children.getChildren(),
            myChild;
        for (var i = 0, cnt = myCildren.length; i < cnt; i++) {
            myChild = myCildren[i];

            if (myChild.isRexContainerLite) {
                if (myChild.contains(gameObject)) {
                    return true;
                }
            }
        }

        return false;
    },

    getByName(name) {
        return ArrayUtils.GetFirst(this.list, 'name', name);
    },

    getRandom(startIndex, length) {
        return ArrayUtils.GetRandom(this.list, startIndex, length);
    },

    getFirst(property, value, startIndex, endIndex) {
        return ArrayUtils.GetFirstElement(this.list, property, value, startIndex, endIndex);
    },

    getAll(property, value, startIndex, endIndex) {
        return ArrayUtils.GetAll(this.list, property, value, startIndex, endIndex);
    },

    count(property, value, startIndex, endIndex) {
        return ArrayUtils.CountAllMatching(this.list, property, value, startIndex, endIndex);
    },

    swap(child1, child2) {
        ArrayUtils.Swap(this.list, child1, child2);
        return this;
    },

    moveTo(child, index) {
        ArrayUtils.MoveTo(this.list, child, index);
        return this;
    },

    setAll(property, value, startIndex, endIndex) {
        ArrayUtils.SetAll(this.list, property, value, startIndex, endIndex);
        return this;
    },
});
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/containerlite/ContainerLite.js













const Zone = Phaser.GameObjects.Zone;
const Components = Phaser.GameObjects.Components;

class ContainerLite extends Zone {
    constructor(scene, x, y, width, height, children) {
        if (Array.isArray(width)) {
            children = width;
            width = undefined;
        }
        if (width === undefined) {
            width = 1;
        }
        if (height === undefined) {
            height = 1;
        }
        super(scene, x, y, width, height);
        this.children = scene.add.group();
        this.type = 'rexContainerLite';
        this.isRexContainerLite = true;
        this.syncChildrenEnable = true;

        this._flipX = false;
        this._flipY = false;
        this._alpha = 1;
        this._active = true;
        this._mask = null;
        this._scrollFactorX = 1;
        this._scrollFactorY = 1;

        if (children) {
            this.add(children);
        }
    }

    destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
            return;
        }

        this.children.destroy(!fromScene);
        this.children = undefined;
        super.destroy(fromScene);
    }

    resize(width, height) {
        this.setSize(width, height);
        return this;
    }

    get x() {
        return this._x;
    }

    set x(value) {
        if (this._x === value) {
            return;
        }
        this._x = value;

        this.syncPosition();
    }

    get y() {
        return this._y;
    }

    set y(value) {
        if (this._y === value) {
            return;
        }
        this._y = value;

        this.syncPosition();
    }

    // Override
    get rotation() {
        return super.rotation;
    }

    set rotation(value) {
        if (this.rotation === value) {
            return;
        }
        super.rotation = value;

        this.syncPosition();
    }

    // Override
    get scaleX() {
        return super.scaleX;
    }

    set scaleX(value) {
        if (this.scaleX === value) {
            return;
        }
        super.scaleX = value;

        this.syncPosition();
    }

    // Override
    get scaleY() {
        return super.scaleY;
    }

    set scaleY(value) {
        if (this.scaleY === value) {
            return;
        }
        super.scaleY = value;

        this.syncPosition();
    }

    // Override
    get flipX() {
        return this._flipX;
    }

    set flipX(value) {
        if (this._flipX === value) {
            return;
        }
        this._flipX = value;

        this.syncPosition();
    }

    // Override
    get flipY() {
        return this._flipY;
    }

    set flipY(value) {
        if (this._flipY === value) {
            return;
        }
        this._flipY = value;

        this.syncPosition();
    }

    // Override
    get visible() {
        return super.visible;
    }

    set visible(value) {
        if (this.visible === value) {
            return;
        }
        super.visible = value;

        this.syncVisible();
    }

    // Override
    get alpha() {
        return this._alpha;
    }

    set alpha(value) {
        if (this._alpha === value) {
            return;
        }
        this._alpha = value;

        this.syncAlpha();
    }

    // Override
    get active() {
        return this._active;
    }

    set active(value) {
        if (this._active === value) {
            return;
        }
        this._active = value;

        this.syncActive();
    }

    // Override
    get mask() {
        return this._mask;
    }
    set mask(mask) {
        if (this._mask === mask) {
            return;
        }
        this._mask = mask;

        this.syncMask();
    }

    // Override
    get scrollFactorX() {
        return this._scrollFactorX;
    }

    set scrollFactorX(value) {
        if (this._scrollFactorX === value) {
            return;
        }

        this._scrollFactorX = value;
        this.syncScrollFactor();
    }
    get scrollFactorY() {
        return this._scrollFactorY;
    }

    set scrollFactorY(value) {
        if (this._scrollFactorY === value) {
            return;
        }

        this._scrollFactorY = value;
        this.syncScrollFactor();
    }

    // Compatiable with container plugin
    get list() {
        return this.children.getChildren();
    }
}

Object.assign(
    ContainerLite.prototype,
    AddChild,
    RemoveChild,
    ChildState,
    Transform,
    Position,
    Visible,
    Alpha,
    ScrollFactor,
    Active,
    Mask,
    Depth,
    Children,

    Components.Alpha,
    Components.Flip
);

/* harmony default export */ var containerlite_ContainerLite = (ContainerLite);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/container/Container.js

/* harmony default export */ var Container = (containerlite_ContainerLite);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/utils/GetSizerConfig.js
var GetSizerConfig = function (gameObject) {
    if (!gameObject.hasOwnProperty('rexSizer')) {
        gameObject.rexSizer = {};
    }
    return gameObject.rexSizer;
}
/* harmony default export */ var utils_GetSizerConfig = (GetSizerConfig);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/defaultbounds/GetDefaultBounds.js
var GetDefaultBounds = function (scene, out) {
    if (out === undefined) {
        if (GlobRectangle === undefined) {
            GlobRectangle = new Phaser.Geom.Rectangle();
        }
        out = GlobRectangle;
    }
    var gameConfig = scene.game.config;
    out.setTo(0, 0, gameConfig.width, gameConfig.height);
    return out;
}

var GlobRectangle;

/* harmony default export */ var defaultbounds_GetDefaultBounds = (GetDefaultBounds);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/basesizer/PushIntoBounds.js


var PushIntoBounds = function (bounds) {
    if (bounds === undefined) {
        bounds = defaultbounds_GetDefaultBounds(this.scene);
    }

    this.left = Math.max(this.left, bounds.left);
    this.right = Math.min(this.right, bounds.right);
    this.top = Math.max(this.top, bounds.top);
    this.bottom = Math.min(this.bottom, bounds.bottom);
    return this;
}

/* harmony default export */ var basesizer_PushIntoBounds = (PushIntoBounds);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/utils/AlignConst.js
const ALIGN = Phaser.Display.Align;
/* harmony default export */ var AlignConst = ({
    center: ALIGN.CENTER,
    left: ALIGN.LEFT_CENTER,
    right: ALIGN.RIGHT_CENTER,
    top: ALIGN.TOP_CENTER,
    bottom: ALIGN.BOTTOM_CENTER,

    'left-top': ALIGN.TOP_LEFT,
    'left-center': ALIGN.LEFT_CENTER,
    'left-bottom': ALIGN.BOTTOM_LEFT,
    'center-top': ALIGN.TOP_CENTER,
    'center-center': ALIGN.CENTER,
    'center-bottom': ALIGN.BOTTOM_CENTER,
    'right-top': ALIGN.TOP_RIGHT,
    'right-center': ALIGN.RIGHT_CENTER,
    'right-bottom': ALIGN.BOTTOM_RIGHT
});
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/actions/GlobZone.js

var globZone = new Phaser.GameObjects.Zone({
    sys: {
        queueDepthSort: object_NOOP,
        events: {
            once: object_NOOP
        }
    }
}, 0, 0, 1, 1);
globZone.setOrigin(0);

/* harmony default export */ var GlobZone = (globZone);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/align/align/const.js
var ALIGN_CONST = {

    /**
    * A constant representing a top-left alignment or position.
    * @constant
    * @name Phaser.Display.Align.TOP_LEFT
    * @since 3.0.0
    * @type {integer}
    */
    TOP_LEFT: 0,

    /**
    * A constant representing a top-center alignment or position.
    * @constant
    * @name Phaser.Display.Align.TOP_CENTER
    * @since 3.0.0
    * @type {integer}
    */
    TOP_CENTER: 1,

    /**
    * A constant representing a top-right alignment or position.
    * @constant
    * @name Phaser.Display.Align.TOP_RIGHT
    * @since 3.0.0
    * @type {integer}
    */
    TOP_RIGHT: 2,

    /**
    * A constant representing a left-top alignment or position.
    * @constant
    * @name Phaser.Display.Align.LEFT_TOP
    * @since 3.0.0
    * @type {integer}
    */
    LEFT_TOP: 3,

    /**
    * A constant representing a left-center alignment or position.
    * @constant
    * @name Phaser.Display.Align.LEFT_CENTER
    * @since 3.0.0
    * @type {integer}
    */
    LEFT_CENTER: 4,

    /**
    * A constant representing a left-bottom alignment or position.
    * @constant
    * @name Phaser.Display.Align.LEFT_BOTTOM
    * @since 3.0.0
    * @type {integer}
    */
    LEFT_BOTTOM: 5,

    /**
    * A constant representing a center alignment or position.
    * @constant
    * @name Phaser.Display.Align.CENTER
    * @since 3.0.0
    * @type {integer}
    */
    CENTER: 6,

    /**
    * A constant representing a right-top alignment or position.
    * @constant
    * @name Phaser.Display.Align.RIGHT_TOP
    * @since 3.0.0
    * @type {integer}
    */
    RIGHT_TOP: 7,

    /**
    * A constant representing a right-center alignment or position.
    * @constant
    * @name Phaser.Display.Align.RIGHT_CENTER
    * @since 3.0.0
    * @type {integer}
    */
    RIGHT_CENTER: 8,

    /**
    * A constant representing a right-bottom alignment or position.
    * @constant
    * @name Phaser.Display.Align.RIGHT_BOTTOM
    * @since 3.0.0
    * @type {integer}
    */
    RIGHT_BOTTOM: 9,

    /**
    * A constant representing a bottom-left alignment or position.
    * @constant
    * @name Phaser.Display.Align.BOTTOM_LEFT
    * @since 3.0.0
    * @type {integer}
    */
    BOTTOM_LEFT: 10,

    /**
    * A constant representing a bottom-center alignment or position.
    * @constant
    * @name Phaser.Display.Align.BOTTOM_CENTER
    * @since 3.0.0
    * @type {integer}
    */
    BOTTOM_CENTER: 11,

    /**
    * A constant representing a bottom-right alignment or position.
    * @constant
    * @name Phaser.Display.Align.BOTTOM_RIGHT
    * @since 3.0.0
    * @type {integer}
    */
    BOTTOM_RIGHT: 12

};

/* harmony default export */ var align_const = (ALIGN_CONST);

// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/size/GetDisplaySize.js
var GetDisplayWidth = function (gameObject) {
    if (gameObject.displayWidth !== undefined) {
        return gameObject.displayWidth;
    } else {
        return gameObject.width;
    }
}

var GetDisplayHeight = function (gameObject) {
    if (gameObject.displayHeight !== undefined) {
        return gameObject.displayHeight;
    } else {
        return gameObject.height;
    }
}


// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/align/bounds/GetBottom.js


var GetBottom = function (gameObject) {
    var height = GetDisplayHeight(gameObject);
    return (gameObject.y + height) - (height * gameObject.originY);
};

/* harmony default export */ var bounds_GetBottom = (GetBottom);

// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/align/bounds/GetCenterX.js


var GetCenterX = function (gameObject) {
    var width = GetDisplayWidth(gameObject);
    return gameObject.x - (width * gameObject.originX) + (width * 0.5);
};

/* harmony default export */ var bounds_GetCenterX = (GetCenterX);

// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/align/bounds/SetBottom.js


var SetBottom = function (gameObject, value) {
    var height = GetDisplayHeight(gameObject);
    gameObject.y = (value - height) + (height * gameObject.originY);
    return gameObject;
};

/* harmony default export */ var bounds_SetBottom = (SetBottom);

// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/align/bounds/SetCenterX.js


var SetCenterX = function (gameObject, x) {
    var width = GetDisplayWidth(gameObject);
    var offsetX = width * gameObject.originX;
    gameObject.x = (x + offsetX) - (width * 0.5);

    return gameObject;
};

/* harmony default export */ var bounds_SetCenterX = (SetCenterX);

// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/align/align/in/BottomCenter.js





var BottomCenter = function (gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    bounds_SetCenterX(gameObject, bounds_GetCenterX(alignIn) + offsetX);
    bounds_SetBottom(gameObject, bounds_GetBottom(alignIn) + offsetY);

    return gameObject;
};

/* harmony default export */ var in_BottomCenter = (BottomCenter);

// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/align/bounds/GetLeft.js


var GetLeft = function (gameObject) {
    var width = GetDisplayWidth(gameObject);
    return gameObject.x - (width * gameObject.originX);
};

/* harmony default export */ var bounds_GetLeft = (GetLeft);

// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/align/bounds/SetLeft.js


var SetLeft = function (gameObject, value) {
    var width = GetDisplayWidth(gameObject);
    gameObject.x = value + (width * gameObject.originX);
    return gameObject;
};

/* harmony default export */ var bounds_SetLeft = (SetLeft);

// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/align/align/in/BottomLeft.js





var BottomLeft = function (gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    bounds_SetLeft(gameObject, bounds_GetLeft(alignIn) - offsetX);
    bounds_SetBottom(gameObject, bounds_GetBottom(alignIn) + offsetY);

    return gameObject;
};

/* harmony default export */ var in_BottomLeft = (BottomLeft);

// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/align/bounds/GetRight.js


var GetRight = function (gameObject) {
    var width = GetDisplayWidth(gameObject);
    return (gameObject.x + width) - (width * gameObject.originX);
};

/* harmony default export */ var bounds_GetRight = (GetRight);

// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/align/bounds/SetRight.js


var SetRight = function (gameObject, value) {
    var width = GetDisplayWidth(gameObject);
    gameObject.x = (value - width) + (width * gameObject.originX);

    return gameObject;
};

/* harmony default export */ var bounds_SetRight = (SetRight);

// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/align/align/in/BottomRight.js





var BottomRight = function (gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    bounds_SetRight(gameObject, bounds_GetRight(alignIn) + offsetX);
    bounds_SetBottom(gameObject, bounds_GetBottom(alignIn) + offsetY);

    return gameObject;
};

/* harmony default export */ var in_BottomRight = (BottomRight);

// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/align/bounds/SetCenterY.js


var SetCenterY = function (gameObject, y) {
    var height = GetDisplayHeight(gameObject);
    var offsetY = height * gameObject.originY;
    gameObject.y = (y + offsetY) - (height * 0.5);

    return gameObject;
};

/* harmony default export */ var bounds_SetCenterY = (SetCenterY);

// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/align/bounds/CenterOn.js



var CenterOn = function (gameObject, x, y) {
    bounds_SetCenterX(gameObject, x);
    return bounds_SetCenterY(gameObject, y);
};

/* harmony default export */ var bounds_CenterOn = (CenterOn);

// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/align/bounds/GetCenterY.js


var GetCenterY = function (gameObject) {
    var height = GetDisplayHeight(gameObject);
    return gameObject.y - (height * gameObject.originY) + (height * 0.5);
};

/* harmony default export */ var bounds_GetCenterY = (GetCenterY);

// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/align/align/in/Center.js




var Center = function (gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    bounds_CenterOn(gameObject, bounds_GetCenterX(alignIn) + offsetX, bounds_GetCenterY(alignIn) + offsetY);

    return gameObject;
};

/* harmony default export */ var in_Center = (Center);

// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/align/align/in/LeftCenter.js





var LeftCenter = function (gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    bounds_SetLeft(gameObject, bounds_GetLeft(alignIn) - offsetX);
    bounds_SetCenterY(gameObject, bounds_GetCenterY(alignIn) + offsetY);

    return gameObject;
};

/* harmony default export */ var in_LeftCenter = (LeftCenter);

// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/align/align/in/RightCenter.js





var RightCenter = function (gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    bounds_SetRight(gameObject, bounds_GetRight(alignIn) + offsetX);
    bounds_SetCenterY(gameObject, bounds_GetCenterY(alignIn) + offsetY);

    return gameObject;
};

/* harmony default export */ var in_RightCenter = (RightCenter);

// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/align/bounds/GetTop.js


var GetTop = function (gameObject) {
    var height = GetDisplayHeight(gameObject);
    return gameObject.y - (height * gameObject.originY);
};

/* harmony default export */ var bounds_GetTop = (GetTop);

// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/align/bounds/SetTop.js


var SetTop = function (gameObject, value) {
    var height = GetDisplayHeight(gameObject);
    gameObject.y = value + (height * gameObject.originY);
    return gameObject;
};

/* harmony default export */ var bounds_SetTop = (SetTop);

// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/align/align/in/TopCenter.js





var TopCenter = function (gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    bounds_SetCenterX(gameObject, bounds_GetCenterX(alignIn) + offsetX);
    bounds_SetTop(gameObject, bounds_GetTop(alignIn) - offsetY);

    return gameObject;
};

/* harmony default export */ var in_TopCenter = (TopCenter);

// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/align/align/in/TopLeft.js





var TopLeft = function (gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    bounds_SetLeft(gameObject, bounds_GetLeft(alignIn) - offsetX);
    bounds_SetTop(gameObject, bounds_GetTop(alignIn) - offsetY);

    return gameObject;
};

/* harmony default export */ var in_TopLeft = (TopLeft);

// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/align/align/in/TopRight.js





var TopRight = function (gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    bounds_SetRight(gameObject, bounds_GetRight(alignIn) + offsetX);
    bounds_SetTop(gameObject, bounds_GetTop(alignIn) - offsetY);

    return gameObject;
};

/* harmony default export */ var in_TopRight = (TopRight);

// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/align/align/in/QuickSet.js











var AlignInMap = [];

AlignInMap[align_const.BOTTOM_CENTER] = in_BottomCenter;
AlignInMap[align_const.BOTTOM_LEFT] = in_BottomLeft;
AlignInMap[align_const.BOTTOM_RIGHT] = in_BottomRight;
AlignInMap[align_const.CENTER] = in_Center;
AlignInMap[align_const.LEFT_CENTER] = in_LeftCenter;
AlignInMap[align_const.RIGHT_CENTER] = in_RightCenter;
AlignInMap[align_const.TOP_CENTER] = in_TopCenter;
AlignInMap[align_const.TOP_LEFT] = in_TopLeft;
AlignInMap[align_const.TOP_RIGHT] = in_TopRight;

var QuickSet = function (child, alignIn, position, offsetX, offsetY) {
    return AlignInMap[position](child, alignIn, offsetX, offsetY);
};

/* harmony default export */ var in_QuickSet = (QuickSet);

// CONCATENATED MODULE: ./lib/rexui/lib/ui/basesizer/DrawBounds.js




const DrawBounds_GetValue = Phaser.Utils.Objects.GetValue;

var DrawBounds = function (graphics, config) {
    var scene = graphics.scene;

    var color;
    var createTextCallback, createTextCallbackScope, textAlign;
    if (typeof (config) === 'number') {
        color = config;
    } else {
        color = DrawBounds_GetValue(config, 'color', 0xffffff);
        var nameTextConfig = DrawBounds_GetValue(config, 'name', false);
        if (nameTextConfig) {
            createTextCallback = DrawBounds_GetValue(nameTextConfig, 'createTextCallback', DefaultCreateTextCallback);
            createTextCallbackScope = DrawBounds_GetValue(nameTextConfig, 'createTextCallbackScope', undefined);
            textAlign = DrawBounds_GetValue(nameTextConfig, 'align', 'left-top');
            if (typeof (textAlign) === 'string') {
                textAlign = AlignConst[textAlign];
            }
        }
    }

    if (createTextCallback && !graphics.children) {
        graphics.children = scene.add.group();
        graphics.on('destroy', function () {
            graphics.children.destroy();
            graphics.children = undefined;
        })
        var graphicsClear = graphics.clear.bind(graphics);
        graphics.clear = function () {
            graphicsClear();
            graphics.children.clear(false, true);
        }
    }

    var children = this.getAllChildren([this]), child;
    var nameText;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (!child.getBounds) {
            continue;
        }
        if (color) {
            graphics
                .lineStyle(1, color)
                .strokeRectShape(child.getBounds(globRect));
        }

        if (child.name && createTextCallback) {
            if (createTextCallbackScope) {
                nameText = createTextCallback.call(createTextCallbackScope, scene);
            } else {
                nameText = createTextCallback(scene);
            }
            if (nameText) {
                nameText.setText(child.name);
                graphics.children.add(nameText);

                GlobZone.setPosition(globRect.x, globRect.y).setSize(globRect.width, globRect.height);
                in_QuickSet(nameText, GlobZone, textAlign);
            }
        }
    }
    return this;
}

var DefaultCreateTextCallback = function (scene, child, childBoundsRect) {
    return scene.add.text(0, 0, '');
}

var globRect = new Phaser.Geom.Rectangle();

/* harmony default export */ var basesizer_DrawBounds = (DrawBounds);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/basesizer/AddChildrenMap.js
var AddChildrenMap = function (key, gameObject) {
    if (this.childrenMap === undefined) {
        this.childrenMap = {};
    }
    this.childrenMap[key] = gameObject;
    return this;
}

/* harmony default export */ var basesizer_AddChildrenMap = (AddChildrenMap);
// EXTERNAL MODULE: ./lib/rexui/lib/plugins/utils/object/IsArray.js
var IsArray = __webpack_require__(46);

// CONCATENATED MODULE: ./lib/rexui/lib/ui/basesizer/GetElement.js


var GetElement = function (mapNameList) {
    if (this.childrenMap === undefined) {
        return undefined;
    }

    if (typeof (mapNameList) === 'string') {
        mapNameList = mapNameList.split('.');
    }
    if (mapNameList.length === 0) {
        return undefined;
    }

    var name = mapNameList.shift(),
        element;
    if (name.charAt(0) === '#') {
        name = name.substring(1);
        element = GetElementByName(this.childrenMap, name);
    } else if (name.indexOf('[') === (-1)) {
        element = this.childrenMap[name];
    } else { // name[]
        var innerMatch = name.match(RE_OBJ);
        if (innerMatch != null) {
            var elements = this.childrenMap[innerMatch[1]];
            if (elements) {
                element = elements[innerMatch[2]];
            }
        }
    }

    if (mapNameList.length === 0) {
        return element;
    } else if (element && element.childrenMap) {
        return element.getElement(mapNameList);
    } else {
        return null;
    }
};

var GetElementByName = function (children, name) {
    var child;
    if (Object(IsArray["a" /* default */])(children)) {
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            child = TestName(children[i], name);
            if (child) {
                return child;
            }
        }
    } else { // Is plain object
        for (var key in children) {
            child = TestName(children[key], name);
            if (child) {
                return child;
            }
        }
    }
}

var TestName = function (gameObject, name) {
    if (!gameObject) {
        return null;
    } else if (gameObject.hasOwnProperty('name')) {
        return (gameObject.name === name) ? gameObject : null;
    } else { // Array, or plain object
        return GetElementByName(gameObject, name);
    }
}

const RE_OBJ = /(\S+)\[(\d+)\]/i;

/* harmony default export */ var basesizer_GetElement = (GetElement);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/basesizer/GetChildrenWidth.js
// Override
var GetChildrenWidth = function () {
    return 0;
}

/* harmony default export */ var basesizer_GetChildrenWidth = (GetChildrenWidth);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/basesizer/GetChildrenHeight.js
// Override
var GetChildrenHeight = function () {
    return 0;
}

/* harmony default export */ var basesizer_GetChildrenHeight = (GetChildrenHeight);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/basesizer/GetAllChildrenSizers.js
var GetAllChildrenSizers = function (out) {
    if (out === undefined) {
        out = [];
    }
    var startIdx = out.length;
    var children = this.getChildrenSizers(out);
    var endIdx = out.length;
    for (var i = startIdx; i < endIdx; i++) {
        children[i].getAllChildrenSizers(out);
    }

    return out;
}
/* harmony default export */ var basesizer_GetAllChildrenSizers = (GetAllChildrenSizers);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/basesizer/GetChildrenSizers.js
// Override
var GetChildrenSizers = function(out) {
    if (out === undefined) {
        out = [];
    }
    return out;
}
/* harmony default export */ var basesizer_GetChildrenSizers = (GetChildrenSizers);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/basesizer/PreLayout.js
var LayoutInit = function (parent) {
    if (parent) {
        return;
    }

    var children = this.getAllChildrenSizers([this]);
    var child, parent;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (!child.rexSizer) {
            continue;
        }
        child._layoutInit();
    }
}
/* harmony default export */ var PreLayout = (LayoutInit);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/basesizer/Layout.js
// Override
var Layout = function (parent, newWidth, newHeight) {
    if (this.rexSizer.hidden) {
        return this;
    }

    this.preLayout()

    // ...

    return this.postLayout();
}
/* harmony default export */ var basesizer_Layout = (Layout);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/basesizer/PostLayout.js
var PostLayout = function (parent, newWidth, newHeight) {
    if (this._anchor) {
        this._anchor.updatePosition();
    }
    return this;
}
/* harmony default export */ var basesizer_PostLayout = (PostLayout);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/basesizer/_layoutInit.js
// Override
var _layoutInit = function () {}
/* harmony default export */ var basesizer_layoutInit = (_layoutInit);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/behaviors/anchor/GetViewport.js
const Rectangle = Phaser.Geom.Rectangle;

var GetViewport = function (scaleManager, out) {
    if (out === undefined) {
        out = new Rectangle();
    }
    var bounds = scaleManager.canvasBounds;
    var scale = scaleManager.displayScale;
    var autoCenter = scaleManager.autoCenter;
    out.x = (bounds.x >= 0) ? 0 : -(bounds.x * scale.x);
    out.y = (bounds.y >= 0) ? 0 : -(bounds.y * scale.y);
    out.width = (bounds.width * scale.x) - out.x;
    out.height = (bounds.height * scale.y) - out.y;
    if ((autoCenter === 1) || (autoCenter === 2)) {
        out.width -= out.x;
    }
    if ((autoCenter === 1) || (autoCenter === 3)) {
        out.height -= out.y;
    }
    return out;
}

/* harmony default export */ var anchor_GetViewport = (GetViewport);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/behaviors/anchor/Anchor.js


const Anchor_Rectangle = Phaser.Geom.Rectangle;

class Anchor_Anchor {
    constructor(gameObject, config) {
        this.gameObject = gameObject;
        this.viewport = new Anchor_Rectangle();
        this.resetFromJSON(config);
        this.boot();
    }

    resetFromJSON(o) {
        var alignX, configX;
        if (o.x !== undefined) {
            alignX = null;
            configX = o.x;
        } else if (o.left !== undefined) {
            alignX = 0;
            configX = o.left;
        } else if (o.right !== undefined) {
            alignX = 1;
            configX = o.right;
        } else if (o.centerX !== undefined) {
            alignX = 0.5;
            configX = o.centerX;
        }

        var alignY, configY;
        if (o.y !== undefined) {
            alignY = null;
            configY = o.y;
        } else if (o.top !== undefined) {
            alignY = 0;
            configY = o.top;
        } else if (o.bottom !== undefined) {
            alignY = 1;
            configY = o.bottom;
        } else if (o.centerY !== undefined) {
            alignY = 0.5;
            configY = o.centerY;
        }

        var percentageX, offsetX;
        if (configX !== undefined) {
            configX = configX.replace('left', '0%').replace('right', '100%').replace('center', '50%').split('%');
            percentageX = parseFloat(configX[0]) / 100;
            offsetX = (configX[1] === '') ? 0 : parseFloat(configX[1]);
        }
        var percentageY, offsetY;
        if (configY !== undefined) {
            configY = configY.replace('top', '0%').replace('bottom', '100%').replace('center', '50%').split('%');
            percentageY = parseFloat(configY[0]) / 100;
            offsetY = (configY[1] === '') ? 0 : parseFloat(configY[1]);
        }

        this.setAlign(alignX, alignY);
        this.setPercentage(percentageX, percentageY);
        this.setOffset(offsetX, offsetY);
        return this;
    }

    boot() {
        this.scaleManamger.on('resize', this.anchor, this);
        this.gameObject.on('destroy', this.destroy, this);

        this.anchor();
    }

    shutdown() {
        this.scaleManamger.off('resize', this.anchor, this);
        this.gameObject = undefined;
    }

    destroy() {
        this.shutdown();
    }

    setAlign(x, y) {
        this.alignX = x;
        this.alignY = y;
        return this;
    }

    setPercentage(x, y) {
        this.percentageX = x;
        this.percentageY = y;
        return this;
    }

    setOffset(x, y) {
        this.offsetX = x;
        this.offsetY = y;
        return this;
    }

    anchor() {
        anchor_GetViewport(this.scaleManamger, this.viewport);
        this.updatePosition();
        return this;
    }

    updatePosition() {
        var gameObject = this.gameObject;

        if (this.alignX === null) {
            gameObject.x = this.anchorX;
        } else if (this.alignX !== undefined) {
            gameObject.x = this.anchorX + (gameObject.displayWidth * (gameObject.originX - this.alignX));
        }

        if (this.alignY === null) {
            this.gameObject.y = this.anchorY;
        } else if (this.alignY !== undefined) {
            gameObject.y = this.anchorY + (gameObject.displayHeight * (gameObject.originY - this.alignY));
        }
        return this;
    }

    get scaleManamger() {
        return this.gameObject.scene.scale;
    }

    get anchorX() {
        return this.viewport.x + (this.viewport.width * this.percentageX) + this.offsetX;
    }

    get anchorY() {
        return this.viewport.y + (this.viewport.height * this.percentageY) + this.offsetY;
    }
}

/* harmony default export */ var anchor_Anchor = (Anchor_Anchor);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/basesizer/SetAnchor.js


var SetAnchor = function (config) {
    if (this._anchor === undefined) {
        this._anchor = new anchor_Anchor(this, config);
    } else {
        this._anchor.resetFromJSON(config)
    }
    return this;
}

/* harmony default export */ var basesizer_SetAnchor = (SetAnchor);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/eventemitter/EventEmitterMethods.js
/* harmony default export */ var EventEmitterMethods = ({
    setEventEmitter(eventEmitter, EventEmitterClass) {
        if (EventEmitterClass === undefined) {
            EventEmitterClass = Phaser.Events.EventEmitter; // Use built-in EventEmitter class by default
        }
        this._privateEE = (eventEmitter === undefined);
        this._eventEmitter = (this._privateEE) ? (new EventEmitterClass()) : eventEmitter;
        return this;
    },

    destroyEventEmitter() {
        if (this._eventEmitter && this._privateEE) {
            this._eventEmitter.shutdown();
        }
        return this;
    },

    getEventEmitter() {
        return this._eventEmitter;
    },

    on: function () {
        if (this._eventEmitter) {
            this._eventEmitter.on.apply(this._eventEmitter, arguments);
        }
        return this;
    },

    once: function () {
        if (this._eventEmitter) {
            this._eventEmitter.once.apply(this._eventEmitter, arguments);
        }
        return this;
    },

    off: function () {
        if (this._eventEmitter) {
            this._eventEmitter.off.apply(this._eventEmitter, arguments);
        }
        return this;
    },

    emit: function (event) {
        if (this._eventEmitter && event) {
            this._eventEmitter.emit.apply(this._eventEmitter, arguments);
        }
        return this;
    },

    addListener: function () {
        if (this._eventEmitter) {
            this._eventEmitter.addListener.apply(this._eventEmitter, arguments);
        }
        return this;
    },

    removeListener: function () {
        if (this._eventEmitter) {
            this._eventEmitter.removeListener.apply(this._eventEmitter, arguments);
        }
        return this;
    },

    removeAllListeners: function () {
        if (this._eventEmitter) {
            this._eventEmitter.removeAllListeners.apply(this._eventEmitter, arguments);
        }
        return this;
    },

    listenerCount: function () {
        if (this._eventEmitter) {
            return this._eventEmitter.listenerCount.apply(this._eventEmitter, arguments);
        }
        return 0;
    },

    listeners: function () {
        if (this._eventEmitter) {
            return this._eventEmitter.listeners.apply(this._eventEmitter, arguments);
        }
        return [];
    }
});
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/system/IsSceneObject.js
const SceneClass = Phaser.Scene;
var IsSceneObject = function (object) {
    return (object instanceof SceneClass);
}
/* harmony default export */ var system_IsSceneObject = (IsSceneObject);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/system/GetSceneObject.js


var GetSceneObject = function (object) {
    if (system_IsSceneObject(object)) { // object = scene
        return object;
    } else if (object.scene && system_IsSceneObject(object.scene)) { // object = game object
        return object.scene;
    } else if (object.parent && object.parent.scene && system_IsSceneObject(object.parent.scene)) { // parent = bob object
        return object.parent.scene;
    }
}

/* harmony default export */ var system_GetSceneObject = (GetSceneObject);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/system/IsGameObject.js
const GameObjectClass = Phaser.GameObjects.GameObject;
var IsGameObject = function (object) {
    return (object instanceof GameObjectClass);
}
/* harmony default export */ var system_IsGameObject = (IsGameObject);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/tween/TweenBase.js





const TweenBase_GetValue = Phaser.Utils.Objects.GetValue;

class TweenBase_TweenBase {
    constructor(parent, config) {
        this.parent = parent;
        this.scene = system_GetSceneObject(parent);

        /*
        eventEmitter:
        - false(default value): Use tween's event emitter.
        - true: Create a private event emitter.
        */
        var eventEmitter = TweenBase_GetValue(config, 'eventEmitter', false);
        if (eventEmitter === true) {
            eventEmitter = undefined;
        }
        this.setEventEmitter(eventEmitter);
        this.boot();
    }

    boot() {
        if (system_IsGameObject(this.parent)) { // Parent is Game Object
            if (this.parent.once) { // oops, bob object does not have event emitter
                this.parent.on('destroy', this.destroy, this);
            }
        } else if (system_IsSceneObject(this.parent)) { // Parent is Scene Object
            this.parent.events.once('shutdown', this.destroy, this);
        } else {
            // ??
        }
    }

    shutdown() {
        this.stop();
        if (system_IsSceneObject(this.parent)) {  // Parent is Scene Object
            this.parent.events.off('shutdown', this.destroy, this);
        }
        this.destroyEventEmitter();
        this.parent = undefined;
        this.scene = undefined;
        return this;
    }


    destroy() {
        this.shutdown();
        return this;
    }

    start(tweenConfig) {
        if (this.isRunning) {
            return this;
        }

        this.tween = this.scene.tweens.add(tweenConfig)
            .on('complete', this.complete, this);
        if (this.getEventEmitter() === false) {
            this.setEventEmitter(this.tween);
        }
        return this;
    }

    restart() {
        this.stop().start();
        return this;
    }

    stop() {
        if (!this.tween) {
            return this;
        }

        if (this.getEventEmitter() === this.tween) {
            this.setEventEmitter(false);
        }
        this.tween.remove();
        this.tween = undefined;
        return this;
    }

    complete() {
        this.stop();
        if (this.getEventEmitter()) {
            this.emit('complete');
        }
        return this;
    }

    get isRunning() {
        return (!!this.tween);
    }
}

Object.assign(
    TweenBase_TweenBase.prototype,
    EventEmitterMethods
);

/* harmony default export */ var tween_TweenBase = (TweenBase_TweenBase);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/behaviors/scale/Scale.js


const Scale_GetValue = Phaser.Utils.Objects.GetValue;
const GetAdvancedValue = Phaser.Utils.Objects.GetAdvancedValue;

class scale_Scale_Scale extends tween_TweenBase{
    constructor(gameObject, config) {
        super(gameObject);
        this.gameObject = gameObject;

        this.scaleStart = {};
        this.scaleEnd = {};
        this.resetFromJSON(config);
    }

    resetFromJSON(o) {
        this.setMode(Scale_GetValue(o, 'mode', 0));
        this.setScaleRange(
            GetAdvancedValue(o, 'start', undefined),
            GetAdvancedValue(o, 'end', 0)
        );
        this.setDelay(GetAdvancedValue(o, 'delay', 0));
        this.setDuration(GetAdvancedValue(o, 'duration', 1000));
        this.setEase(Scale_GetValue(o, 'ease', undefined));
        return this;
    }

    toJSON() {
        return {
            mode: this.mode,
            start: this.scaleStart,
            end: this.scaleEnd,
            delay: this.delay,
            duration: this.duration
        };
    }

    setMode(m) {
        if (typeof (m) === 'string') {
            m = MODE[m];
        }
        this.mode = m;
        return this;
    }

    setScaleRange(start, end) {
        if (typeof (start) === 'number') {
            this.scaleStart.x = start;
            this.scaleStart.y = start;
        } else {
            this.scaleStart.x = Scale_GetValue(start, 'x', this.gameObject.scaleX);
            this.scaleStart.y = Scale_GetValue(start, 'y', this.gameObject.scaleY);
        }
        if (typeof (end) === 'number') {
            this.scaleEnd.x = end;
            this.scaleEnd.y = end;
        } else {
            this.scaleEnd.x = Scale_GetValue(end, 'x', this.scaleStart.x);
            this.scaleEnd.y = Scale_GetValue(end, 'y', this.scaleStart.y);
        }
        return this;
    }

    setDelay(time) {
        this.delay = time;
        return this;
    }

    setDuration(time) {
        this.duration = time;
        return this;
    }

    setEase(ease) {
        if (ease === undefined) {
            ease = 'Linear';
        }
        this.ease = ease;
        return this;
    }

    start() {
        if (this.isRunning) {
            return this;
        }

        this.gameObject.setScale(this.scaleStart.x, this.scaleStart.y);
        super.start({
            targets: this.gameObject,
            scaleX: this.scaleEnd.x,
            scaleY: this.scaleEnd.y,

            duration: this.duration,
            ease: this.ease,
            yoyo: (this.mode == 2),
            repeat: ((this.mode == 2) ? -1 : 0)
        });
        return this;
    }

    complete() {
        super.complete();
        if (this.mode === 1) {
            this.gameObject.destroy();
        }
        return this;
    }

}

const MODE = {
    stop: 0,
    destroy: 1,
    yoyo: 2
}

/* harmony default export */ var scale_Scale = (scale_Scale_Scale);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/scale.js

/* harmony default export */ var plugins_scale = (scale_Scale);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/popup.js


var PopUp = function (gameObject, duration, orientation, ease, scale) {
    defaultConfig.mode = 0;
    switch (orientation) {
        case 0:
        case 'x':
            defaultConfig.start = {
                x: 0
            };
            break;
        case 1:
        case 'y':
            defaultConfig.start = {
                y: 0
            };
            break;
        default:
            defaultConfig.start = 0;
            break;
    }
    defaultConfig.end = 1;
    defaultConfig.duration = duration;
    defaultConfig.ease = (ease === undefined) ? 'Cubic' : ease;

    if (scale === undefined) {
        scale = new plugins_scale(gameObject, defaultConfig);
    } else {
        scale.resetFromJSON(defaultConfig);
    }
    scale.restart();

    return scale;
};

var defaultConfig = {}; // reuse this config

/* harmony default export */ var popup = (PopUp);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/scale-down-destroy.js


var ScaleDownDestroy = function (gameObject, duration, orientation, ease, destroyMode, scale) {
    if (destroyMode instanceof plugins_scale) {
        scale = destroyMode;
        destroyMode = undefined;
    }

    if (destroyMode === undefined) {
        destroyMode = true;
    }

    scale_down_destroy_defaultConfig.mode = (destroyMode) ? 1 : 0;
    switch (orientation) {
        case 0:
        case 'x':
            scale_down_destroy_defaultConfig.end = {
                x: 0
            };
            break;
        case 1:
        case 'y':
            scale_down_destroy_defaultConfig.end = {
                y: 0
            };
            break;
        default:
            scale_down_destroy_defaultConfig.end = 0;
            break;
    }
    scale_down_destroy_defaultConfig.duration = duration;
    scale_down_destroy_defaultConfig.ease = (ease === undefined) ? 'Linear' : ease;

    if (scale === undefined) {
        scale = new plugins_scale(gameObject, scale_down_destroy_defaultConfig);
    } else {
        scale.resetFromJSON(scale_down_destroy_defaultConfig);
    }
    scale.restart();

    return scale;
};

var scale_down_destroy_defaultConfig = {}; // reuse this config

/* harmony default export */ var scale_down_destroy = (ScaleDownDestroy);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/promise/WaitEvent.js
var WaitEvent = function (eventEmitter, eventName) {
    return new Promise(function (resolve, reject) {
        eventEmitter.once(eventName, function () {
            resolve();
        });
    });
}

var WaitComplete = function (eventEmitter) {
    return WaitEvent(eventEmitter, 'complete');
}


// CONCATENATED MODULE: ./lib/rexui/lib/ui/basesizer/ScaleMethods.js




const IsPlainObject = Phaser.Utils.Objects.IsPlainObject;
const ScaleMethods_GetValue = Phaser.Utils.Objects.GetValue;

/* harmony default export */ var ScaleMethods = ({
    popUp(duration, orientation, ease) {
        if (IsPlainObject(duration)) {
            var config = duration;
            duration = ScaleMethods_GetValue(config, 'duration', undefined);
            orientation = ScaleMethods_GetValue(config, 'orientation', undefined);
            ease = ScaleMethods_GetValue(config, 'ease', undefined);
        }

        this._scale = popup(this, duration, orientation, ease, this._scale);
        this._scale.once('complete', function () {
            this.emit('popup.complete', this);
        }, this);
        return this;
    },

    popUpPromise(duration, orientation, ease) {
        this.popUp(duration, orientation, ease);
        return WaitComplete(this._scale);
    },

    scaleDownDestroy(duration, orientation, ease, destroyMode) {
        if (IsPlainObject(duration)) {
            var config = duration;
            duration = ScaleMethods_GetValue(config, 'duration', undefined);
            orientation = ScaleMethods_GetValue(config, 'orientation', undefined);
            ease = ScaleMethods_GetValue(config, 'ease', undefined);
            destroyMode = ScaleMethods_GetValue(config, 'destroy', undefined);
        }

        this._scale = scale_down_destroy(this, duration, orientation, ease, destroyMode, this._scale);
        this._scale.once('complete', function () {
            this.emit('scaledown.complete', this);
        }, this);
        return this;
    },

    scaleDownDestroyPromise(duration, orientation, ease, destroyMode) {
        this.scaleDownDestroy(duration, orientation, ease, destroyMode);
        return WaitComplete(this._scale);
    },

    scaleDown(duration, orientation, ease) {
        this.scaleDownDestroy(duration, orientation, ease, false);
        return this;
    },

    scaleDownPromise(duration, orientation, ease) {
        this.scaleDown(duration, orientation, ease);
        return WaitComplete(this._scale);
    }


});
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/behaviors/fade/Fade.js


const Fade_GetValue = Phaser.Utils.Objects.GetValue;
const Fade_GetAdvancedValue = Phaser.Utils.Objects.GetAdvancedValue;

class Fade_Fade extends tween_TweenBase {
    constructor(gameObject, config) {
        super(gameObject);
        this.gameObject = gameObject;

        this.alphaStart = undefined;
        this.alphaEnd = undefined;
        this.resetFromJSON(config);
    }

    resetFromJSON(o) {
        this.setMode(Fade_GetValue(o, 'mode', 0));
        this.setAlphaRange(
            Fade_GetAdvancedValue(o, 'start', this.gameObject.alpha),
            Fade_GetAdvancedValue(o, 'end', 0)
        );
        this.setDelay(Fade_GetAdvancedValue(o, 'delay', 0));
        this.setDuration(Fade_GetAdvancedValue(o, 'duration', 1000));
        return this;
    }

    toJSON() {
        return {
            mode: this.mode,
            start: this.alphaStart,
            end: this.alphaEnd,
            delay: this.delay,
            duration: this.duration
        };
    }

    shutdown() {
        super.shutdown();
        this.gameObject = undefined;
        return this;
    }

    setMode(m) {
        if (typeof (m) === 'string') {
            m = Fade_MODE[m];
        }
        this.mode = m;
        return this;
    }

    setAlphaRange(start, end) {
        this.alphaStart = start;
        this.alphaEnd = end;
        return this;
    }

    setDelay(time) {
        this.delay = time;
        return this;
    }

    setDuration(time) {
        this.duration = time;
        return this;
    }

    start() {
        if (this.isRunning) {
            return this;
        }

        this.gameObject.setAlpha(this.alphaStart);
        super.start({
            targets: this.gameObject,
            alpha: this.alphaEnd,

            delay: this.delay,
            duration: this.duration,
            ease: 'Linear',
            yoyo: (this.mode == 2),
            repeat: ((this.mode == 2) ? -1 : 0)
        });
        return this;
    }

    complete() {
        super.complete();
        if (this.mode === 1) {
            this.gameObject.destroy();
        }
        return this;
    }

}

const Fade_MODE = {
    stop: 0,
    destroy: 1,
    yoyo: 2
}

/* harmony default export */ var fade_Fade = (Fade_Fade);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/fade.js

/* harmony default export */ var plugins_fade = (fade_Fade);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/fade-in.js


const fade_in_IsPlainObject = Phaser.Utils.Objects.IsPlainObject;

var FadeIn = function (gameObject, duration, alpha, fade) {
    var startAlpha, endAlpha;
    if (fade_in_IsPlainObject(alpha)) {
        startAlpha = alpha.start;
        endAlpha = alpha.end;
    } else {
        endAlpha = alpha;
    }
    if (startAlpha === undefined) {
        startAlpha = 0
    }
    if (endAlpha === undefined) {
        endAlpha = gameObject.alpha;
    }
    fade_in_defaultConfig.mode = 0;
    fade_in_defaultConfig.start = startAlpha;
    fade_in_defaultConfig.end = endAlpha;
    fade_in_defaultConfig.duration = duration;

    if (fade === undefined) {
        fade = new plugins_fade(gameObject, fade_in_defaultConfig);
    } else {
        fade.resetFromJSON(fade_in_defaultConfig);
    }
    fade.restart();

    return fade;
};

var fade_in_defaultConfig = {}; // reuse this config

/* harmony default export */ var fade_in = (FadeIn);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/fade-out-destroy.js


var FadeOutDestroy = function (gameObject, duration, destroyMode, fade) {
    if (destroyMode instanceof plugins_fade) {
        fade = destroyMode;
        destroyMode = undefined;
    }

    if (destroyMode === undefined) {
        destroyMode = true;
    }

    fade_out_destroy_defaultConfig.mode = (destroyMode) ? 1 : 0;
    fade_out_destroy_defaultConfig.end = 0;
    fade_out_destroy_defaultConfig.duration = duration;

    if (fade === undefined) {
        fade = new plugins_fade(gameObject, fade_out_destroy_defaultConfig);
    } else {
        fade.resetFromJSON(fade_out_destroy_defaultConfig);
    }
    fade.restart();

    return fade;
};

var fade_out_destroy_defaultConfig = {}; // reuse this config

/* harmony default export */ var fade_out_destroy = (FadeOutDestroy);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/basesizer/FadeMethods.js




const FadeMethods_IsPlainObject = Phaser.Utils.Objects.IsPlainObject;
const FadeMethods_GetValue = Phaser.Utils.Objects.GetValue;

/* harmony default export */ var FadeMethods = ({
    fadeIn(duration, alpha) {
        if (FadeMethods_IsPlainObject(duration)) {
            var config = duration;
            duration = FadeMethods_GetValue(config, 'duration', undefined);
        }

        this._fade = fade_in(this, duration, alpha, this._fade);
        this._fade.once('complete', function () {
            this.emit('fadein.complete', this);
        }, this);
        return this;
    },

    fadeInPromoise(duration, alpha) {
        this.fadeIn(duration, alpha);
        return WaitComplete(this._fade);
    },

    fadeOutDestroy(duration, destroyMode) {
        if (FadeMethods_IsPlainObject(duration)) {
            var config = duration;
            duration = FadeMethods_GetValue(config, 'duration', undefined);
            destroyMode = FadeMethods_GetValue(config, 'destroy', undefined);
        }
        this._fade = fade_out_destroy(this, duration, destroyMode, this._fade);
        this._fade.once('complete', function () {
            this.emit('fadeout.complete', this);
        }, this);
        return this;
    },

    fadeOutDestroyPromise(duration, destroyMode) {
        this.fadeOutDestroy(duration, destroyMode);
        return WaitComplete(this._fade);
    },

    fadeOut(duration) {
        this.fadeOutDestroy(duration, false);
        return this;
    },

    fadeOutPromise(duration) {
        this.fadeOut(duration);
        return WaitComplete(this._fade);
    }
});
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/input/IsPointerInBounds.js
var IsPointerInBounds = function (gameObject, pointer, preTest, postTest) {
    if (IsPointerInBounds_globRect === undefined) {
        IsPointerInBounds_globRect = new Phaser.Geom.Rectangle();
    }
    gameObject.getBounds(IsPointerInBounds_globRect);

    if (pointer) {
        if (preTest && !preTest(gameObject, pointer)) {
            return false;
        }
        if (!IsPointerInBounds_globRect.contains(pointer.x, pointer.y)) {
            return false;
        }
        if (postTest && !postTest(gameObject, pointer)) {
            return false;
        }
        return true;

    } else {
        var inputManager = gameObject.scene.input.manager;
        var pointersTotal = inputManager.pointersTotal;
        var pointers = inputManager.pointers;
        for (var i = 0; i < pointersTotal; i++) {
            pointer = pointers[i];
            if (preTest && !preTest(gameObject, pointer)) {
                continue;
            }
            if (!IsPointerInBounds_globRect.contains(pointer.x, pointer.y)) {
                continue;
            }
            if (postTest && !postTest(gameObject, pointer)) {
                continue;
            }
            return true;
        }
        return false;

    }

}

var IsPointerInBounds_globRect = undefined;

/* harmony default export */ var input_IsPointerInBounds = (IsPointerInBounds);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/basesizer/IsInTouching.js


/* harmony default export */ var IsInTouching = (function (pointer) {
    return input_IsPointerInBounds(this, pointer);
});
// CONCATENATED MODULE: ./lib/rexui/lib/ui/utils/GetParentSizer.js


var GetParentSizer = function (gameObject) {
    return utils_GetSizerConfig(gameObject).parent;
}

/* harmony default export */ var utils_GetParentSizer = (GetParentSizer);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/basesizer/GetParentSizer.js


/* harmony default export */ var basesizer_GetParentSizer = (function () {
    return utils_GetParentSizer(this);
});
// CONCATENATED MODULE: ./lib/rexui/lib/ui/utils/GetTopmostSizer.js


var GetTopmostSizer = function (gameObject) {
    var parent = utils_GetParentSizer(gameObject);
    while (parent) {
        gameObject = parent;
        parent = utils_GetParentSizer(parent);
    }
    return gameObject;
}

/* harmony default export */ var utils_GetTopmostSizer = (GetTopmostSizer);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/basesizer/GetTopmostSizer.js


/* harmony default export */ var basesizer_GetTopmostSizer = (function () {
    return utils_GetTopmostSizer(this);
});
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/size/ResizeGameObject.js
var ResizeGameObject = function (gameObject, newWidth, newHeight) {
    if (!gameObject || ((newWidth === undefined) && (newHeight === undefined))) {
        return;
    }
    if (gameObject.resize) { // Has `resize` method
        if (newWidth === undefined) {
            newWidth = gameObject.width;
        }
        if (newHeight === undefined) {
            newHeight = gameObject.height;
        }
        gameObject.resize(newWidth, newHeight);
    } else { // Set display width/height
        if (newWidth !== undefined) {
            gameObject.displayWidth = newWidth;
        }
        if (newHeight !== undefined) {
            gameObject.displayHeight = newHeight;
        }
    }
}

/* harmony default export */ var size_ResizeGameObject = (ResizeGameObject);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/basesizer/LayoutBackgrounds.js




const ALIGN_CENTER = Phaser.Display.Align.CENTER;

var LayoutBackgrounds = function () {
    if (this.backgroundChildren === undefined) {
        return;
    }
    var backgrounds = this.backgroundChildren;

    var child;
    var x = this.left,
        y = this.top,
        width = this.width,
        height = this.height;

    for (var i = 0, cnt = backgrounds.length; i < cnt; i++) {
        child = backgrounds[i];
        if (child.rexSizer.hidden) {
            continue;
        }
        size_ResizeGameObject(child, width, height);
        GlobZone.setPosition(x, y).setSize(width, height);
        in_QuickSet(child, GlobZone, ALIGN_CENTER);
        this.resetChildPositionState(child);
    }
}

/* harmony default export */ var basesizer_LayoutBackgrounds = (LayoutBackgrounds);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/basesizer/SetDraggable.js
var SetDraggable = function (senser, draggable) {
    var senserType = typeof (senser);
    if (senserType === 'string') {
        senser = this.getElement(senser);
    } else if ((senser === undefined) || (senserType != 'object')) {
        draggable = senser;
        senser = this;
    }
    if (draggable === undefined) {
        draggable = true;
    }

    if (senser.input && senser.input.hasOwnProperty('draggable')) {
        // Draggable is already registered
        senser.input.draggable = draggable;
    } else if (draggable) {
        // Register draggable
        senser.setInteractive();
        senser.scene.input.setDraggable(senser);
        senser.on('drag', onDrag, this);
    } else {
        // Not draggable and draggable is not registered yet, do nothing
    }
    return this;
}

var onDrag = function (pointer, dragX, dragY) {
    var topmostParent = this.getTopmostSizer();
    topmostParent.x += (dragX - this.x);
    topmostParent.y += (dragY - this.y);
}

/* harmony default export */ var basesizer_SetDraggable = (SetDraggable);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/basesizer/Methods.js























var methods = {
    getSizerConfig: utils_GetSizerConfig,
    pushIntoBounds: basesizer_PushIntoBounds,
    drawBounds: basesizer_DrawBounds,
    getChildrenWidth: basesizer_GetChildrenWidth,
    getChildrenHeight: basesizer_GetChildrenHeight,
    addChildrenMap: basesizer_AddChildrenMap,
    addElement: basesizer_AddChildrenMap,
    getElement: basesizer_GetElement,
    getAllChildrenSizers: basesizer_GetAllChildrenSizers,
    getChildrenSizers: basesizer_GetChildrenSizers,
    preLayout: PreLayout,
    _layoutInit: basesizer_layoutInit,
    layout: basesizer_Layout,
    layoutBackgrounds: basesizer_LayoutBackgrounds,
    postLayout: basesizer_PostLayout,

    setAnchor: basesizer_SetAnchor,
    isInTouching: IsInTouching,
    getParentSizer: basesizer_GetParentSizer,
    getTopmostSizer: basesizer_GetTopmostSizer,
    setDraggable: basesizer_SetDraggable,
};

Object.assign(
    methods,
    FadeMethods,
    ScaleMethods
);

/* harmony default export */ var Methods = (methods);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/basesizer/BaseSizer.js




const BaseSizer_GetValue = Phaser.Utils.Objects.GetValue;

class BaseSizer_Base extends Container {
    constructor(scene, x, y, minWidth, minHeight, config) {
        super(scene, x, y, 2, 2);

        this.isRexSizer = true;
        this.setMinSize(minWidth, minHeight);
        this.setName(BaseSizer_GetValue(config, 'name', ''));
        this.rexSizer = {};
        this.backgroundChildren = undefined;

        var anchorConfig = BaseSizer_GetValue(config, 'anchor', undefined);
        if (anchorConfig) {
            this.setAnchor(anchorConfig);
        }

        this.setDraggable(BaseSizer_GetValue(config, 'draggable', false));
    }

    destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
            return;
        }
        if (this.backgroundChildren !== undefined) {
            this.backgroundChildren.length = 0;
        }
        super.destroy(fromScene);
    }

    setMinSize(minWidth, minHeight) {
        this.setMinWidth(minWidth).setMinHeight(minHeight);
        return this;
    }

    setMinWidth(minWidth) {
        if (minWidth == null) {
            minWidth = 0;
        }
        this.minWidth = minWidth;
        return this;
    }

    setMinHeight(minHeight) {
        if (minHeight == null) {
            minHeight = 0;
        }
        this.minHeight = minHeight;
        return this;
    }

    get childrenWidth() {
        if (this._childrenWidth === undefined) {
            this._childrenWidth = this.getChildrenWidth();
        }
        return this._childrenWidth;
    }

    get childrenHeight() {
        if (this._childrenHeight === undefined) {
            this._childrenHeight = this.getChildrenHeight();
        }
        return this._childrenHeight;
    }

    get left() {
        return this.x - (GetDisplayWidth(this) * this.originX);
    }

    set left(value) {
        this.x += (value - this.left);
    }

    alignLeft(value) {
        this.left = value;
        return this;
    }

    get right() {
        return this.left + GetDisplayWidth(this);
    }

    set right(value) {
        this.x += (value - this.right);
    }

    alignRight(value) {
        this.right = value;
        return this;
    }

    get centerX() {
        return this.left + (GetDisplayWidth(this) / 2);
    }

    set centerX(value) {
        this.x += (value - this.centerX);
    }

    alignCenterX(value) {
        this.centerX = value;
        return this;
    }

    get top() {
        return this.y - (GetDisplayHeight(this) * this.originY);
    }

    set top(value) {
        this.y += (value - this.top);
    }

    alignTop(value) {
        this.top = value;
        return this;
    }

    get bottom() {
        return this.top + GetDisplayHeight(this);
    }

    set bottom(value) {
        this.y += (value - this.bottom);
    }

    alignBottom(value) {
        this.bottom = value;
        return this;
    }

    get centerY() {
        return this.top + (GetDisplayHeight(this) / 2);
    }

    set centerY(value) {
        this.y += (value - this.centerY);
    }

    alignCenterY(value) {
        this.centerY = value;
        return this;
    }

    pin(gameObject) {
        super.add(gameObject);
        return this;
    }

    addBackground(gameObject, childKey) {
        if (this.backgroundChildren === undefined) {
            this.backgroundChildren = [];
        }

        super.add(gameObject);

        var config = this.getSizerConfig(gameObject);
        config.parent = this;
        this.backgroundChildren.push(gameObject);

        if (childKey !== undefined) {
            this.addChildrenMap(childKey, gameObject)
        }
        return this;
    }
}

Object.assign(
    BaseSizer_Base.prototype,
    Methods
);

/* harmony default export */ var BaseSizer = (BaseSizer_Base);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/sizer/GetChildrenWidth.js


var GetChildrenWidth_GetChildrenWidth = function (minimumMode) {
    if (this.rexSizer.hidden) {
        return 0;
    }

    if (minimumMode === undefined) {
        minimumMode = true;
    }

    var result = 0;
    var children = this.sizerChildren;
    var child, padding, childWidth;
    if (this.orientation === 0) { // x
        // Get summation of minimum width
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            child = children[i];
            if (child.rexSizer.hidden) {
                continue;
            }

            if (
                (child.rexSizer.proportion === 0) ||
                (minimumMode && (!child.isRexSpace) && (child.rexSizer.proportion > 0))
            ) {
                childWidth = (child.isRexSizer) ?
                    Math.max(child.minWidth, child.childrenWidth) :
                    GetDisplayWidth(child);
            } else {
                childWidth = 0;
            }
            padding = child.rexSizer.padding;
            childWidth += (padding.left + padding.right);
            result += childWidth;
        }
    } else {
        // Get maximun width
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            child = children[i];
            if (!child.hasOwnProperty('rexSizer')) {
                continue;
            }
            if (child.rexSizer.hidden) {
                continue;
            }

            childWidth = (child.isRexSizer) ?
                Math.max(child.minWidth, child.childrenWidth) :
                GetDisplayWidth(child);

            padding = child.rexSizer.padding;
            childWidth += (padding.left + padding.right);
            result = Math.max(childWidth, result);
        }
    }
    return result;
}

/* harmony default export */ var sizer_GetChildrenWidth = (GetChildrenWidth_GetChildrenWidth);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/sizer/GetChildrenHeight.js


var GetChildrenHeight_GetChildrenHeight = function (minimumMode) {
    if (this.rexSizer.hidden) {
        return 0;
    }

    if (minimumMode === undefined) {
        minimumMode = true;
    }

    var result = 0;
    var children = this.sizerChildren;
    var child, padding, childHeight;
    if (this.orientation === 0) { // x
        // Get maximun height
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            child = children[i];
            if (child.rexSizer.hidden) {
                continue;
            }

            childHeight = (child.isRexSizer) ?
                Math.max(child.minHeight, child.childrenHeight) :
                GetDisplayHeight(child);

            padding = child.rexSizer.padding;
            childHeight += (padding.top + padding.bottom);
            result = Math.max(childHeight, result);
        }
    } else {
        // Get summation of minimum height
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            child = children[i];
            if (!child.hasOwnProperty('rexSizer')) {
                continue;
            }
            if (child.rexSizer.hidden) {
                continue;
            }

            if (
                (child.rexSizer.proportion === 0) ||
                (minimumMode && (!child.isRexSpace) && (child.rexSizer.proportion > 0))
            ) {
                childHeight = (child.isRexSizer) ?
                    Math.max(child.minHeight, child.childrenHeight) :
                    GetDisplayHeight(child);
            } else {
                childHeight = 0;
            }
            padding = child.rexSizer.padding;
            childHeight += (padding.top + padding.bottom);
            result += childHeight;
        }
    }
    return result;
}

/* harmony default export */ var sizer_GetChildrenHeight = (GetChildrenHeight_GetChildrenHeight);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/sizer/GetChildrenProportion.js
var GetChildrenProportion = function () {
    var result = 0;
    var children = this.sizerChildren;
    var child, proportion;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (child.rexSizer.hidden) {
            continue;
        }
        proportion = child.rexSizer.proportion;
        if (proportion > 0) {
            result += proportion;
        }
    }
    return result;
}
/* harmony default export */ var sizer_GetChildrenProportion = (GetChildrenProportion);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/sizer/GetChildrenSizers.js
var GetChildrenSizers_GetChildrenSizers = function(out) {
    if (out === undefined) {
        out = [];
    }
    var children = this.sizerChildren,
        child;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (child.isRexSizer) {
            out.push(child);
        }
    }
    return out;
}
/* harmony default export */ var sizer_GetChildrenSizers = (GetChildrenSizers_GetChildrenSizers);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/sizer/GetExpandedChildWidth.js
var GetExpandedChildWidth = function (parent, child) {
    var newWidth;
    var childConfig = child.rexSizer;
    var padding = childConfig.padding;
    if (parent.orientation === 0) { // x
        if ((childConfig.proportion > 0) && (parent.proportionLength > 0)) {
            newWidth = (childConfig.proportion * parent.proportionLength);
        }
    } else { // y
        if (childConfig.expand) {
            newWidth = parent.width - padding.left - padding.right;
        }
    }
    return newWidth;
}

/* harmony default export */ var sizer_GetExpandedChildWidth = (GetExpandedChildWidth);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/sizer/GetExpandedChildHeight.js
var GetExpandedChildHeight = function (parent, child) {
    var newHeight;
    var childConfig = child.rexSizer;
    var padding = childConfig.padding;
    if (parent.orientation === 0) { // x
        if (childConfig.expand) {
            newHeight = parent.height - padding.top - padding.bottom;
        }
    } else { // y
        if ((childConfig.proportion > 0) && (parent.proportionLength > 0)) {
            newHeight = (childConfig.proportion * parent.proportionLength);
        }
    }
    return newHeight;
}

/* harmony default export */ var sizer_GetExpandedChildHeight = (GetExpandedChildHeight);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/sizer/Layout.js







var Layout_Layout = function (parent, newWidth, newHeight) {
    // Skip invisible sizer
    if (this.rexSizer.hidden) {
        return this;
    }

    this.preLayout(parent);

    // Set size
    if (newWidth === undefined) {
        newWidth = Math.max(this.childrenWidth, this.minWidth);
    }
    if (newHeight === undefined) {
        newHeight = Math.max(this.childrenHeight, this.minHeight);
    }
    this.resize(newWidth, newHeight);

    var proportionLength;
    if (this.childrenProportion > 0) {
        var remainder = (this.orientation === 0) ?
            (this.width - this.childrenWidth) :
            (this.height - this.childrenHeight);

        if (remainder > 0) {
            remainder = (this.orientation === 0) ?
                (this.width - this.getChildrenWidth(false)) :
                (this.height - this.getChildrenHeight(false));
            proportionLength = remainder / this.childrenProportion;
        } else {
            proportionLength = 0;
        }
    } else {
        proportionLength = 0;
    }
    this.proportionLength = proportionLength;

    // Layout children    
    var children = this.sizerChildren;
    var child, childConfig, padding;
    var startX = this.left,
        startY = this.top;
    var itemX = startX,
        itemY = startY;
    var x, y, width, height; // Align zone
    var childWidth, childHeight;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (child.rexSizer.hidden) {
            continue;
        }

        childConfig = child.rexSizer;
        padding = childConfig.padding;

        // Set size
        childWidth = sizer_GetExpandedChildWidth(this, child);
        childHeight = sizer_GetExpandedChildHeight(this, child);
        if (child.isRexSizer) {
            child.layout(this, childWidth, childHeight);
        } else {
            size_ResizeGameObject(child, childWidth, childHeight);
        }

        if (childWidth === undefined) {
            childWidth = GetDisplayWidth(child);
        }
        if (childHeight === undefined) {
            childHeight = GetDisplayHeight(child);
        }

        // Set position
        if (this.orientation === 0) { // x
            x = (itemX + padding.left);
            if ((childConfig.proportion === 0) || (proportionLength === 0)) {
                width = childWidth;
            } else {
                width = (childConfig.proportion * proportionLength);
            }

            y = (itemY + padding.top);
            height = (this.height - padding.top - padding.bottom);
        } else { // y
            x = (itemX + padding.left);
            width = (this.width - padding.left - padding.right);

            y = (itemY + padding.top);
            if ((childConfig.proportion === 0) || (proportionLength === 0)) {
                height = childHeight;
            } else {
                height = (childConfig.proportion * proportionLength);
            }
        }

        GlobZone.setPosition(x, y).setSize(width, height);
        in_QuickSet(child, GlobZone, childConfig.align);
        this.resetChildPositionState(child);

        if (this.orientation === 0) { // x
            itemX += (width + padding.left + padding.right);
        } else { // y
            itemY += (height + padding.top + padding.bottom);
        }
    }

    // Layout background children
    this.layoutBackgrounds();

    return this.postLayout();
}

/* harmony default export */ var sizer_Layout = (Layout_Layout);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/sizer/_layoutInit.js
var LayoutInitChild = function () {
    this._childrenWidth = undefined;
    this._childrenHeight = undefined;
    this._childrenProportion = undefined;
}
/* harmony default export */ var sizer_layoutInit = (LayoutInitChild);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/sizer/Methods.js







/* harmony default export */ var sizer_Methods = ({
    getChildrenWidth: sizer_GetChildrenWidth,
    getChildrenHeight: sizer_GetChildrenHeight,
    getChildrenProportion: sizer_GetChildrenProportion,
    getChildrenSizers: sizer_GetChildrenSizers,
    layout: sizer_Layout,
    _layoutInit: sizer_layoutInit,
});
// CONCATENATED MODULE: ./lib/rexui/lib/ui/utils/GetBoundsConfig.js
const GetBoundsConfig_GetValue = Phaser.Utils.Objects.GetValue;
var GetBoundsConfig = function (config, out) {
    if (out === undefined) {
        out = {};
    }
    if (typeof (config) === 'number') {
        out.left = config;
        out.right = config;
        out.top = config;
        out.bottom = config;
    } else {
        out.left = GetBoundsConfig_GetValue(config, 'left', 0);
        out.right = GetBoundsConfig_GetValue(config, 'right', 0);
        out.top = GetBoundsConfig_GetValue(config, 'top', 0);
        out.bottom = GetBoundsConfig_GetValue(config, 'bottom', 0);
    }
    return out;
}
/* harmony default export */ var utils_GetBoundsConfig = (GetBoundsConfig);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/utils/OrientationConst.js
/* harmony default export */ var OrientationConst = ({
    x: 0,
    h: 0,
    horizontal: 0,
    'left-to-right': 0,
    y: 1,
    v: 1,
    vertical: 1,
    'top-to-bottom': 1
});
// CONCATENATED MODULE: ./lib/rexui/lib/ui/utils/Space.js
var Space = function (scene) {
    var gameObject = scene.add.zone(0, 0, 1, 1);
    gameObject.isRexSpace = true;
    return gameObject;
}
/* harmony default export */ var utils_Space = (Space);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/sizer/Sizer.js







const Sizer_IsPlainObject = Phaser.Utils.Objects.IsPlainObject;
const Sizer_GetValue = Phaser.Utils.Objects.GetValue;
const RemoveItem = Phaser.Utils.Array.Remove;
const Sizer_ALIGN_CENTER = Phaser.Display.Align.CENTER;

class Sizer_Sizer extends BaseSizer {
    constructor(scene, x, y, minWidth, minHeight, orientation, config) {
        if (Sizer_IsPlainObject(x)) {
            config = x;
            x = Sizer_GetValue(config, 'x', 0);
            y = Sizer_GetValue(config, 'y', 0);
            minWidth = Sizer_GetValue(config, 'width', undefined);
            minHeight = Sizer_GetValue(config, 'height', undefined);
        } else if (Sizer_IsPlainObject(minWidth)) {
            config = minWidth;
            minWidth = Sizer_GetValue(config, 'width', undefined);
            minHeight = Sizer_GetValue(config, 'height', undefined);
        } else if (Sizer_IsPlainObject(orientation)) {
            config = orientation;
        }

        if (config !== undefined) {
            orientation = Sizer_GetValue(config, 'orientation', 0);
        }
        if (orientation === undefined) {
            orientation = 0;
        }
        super(scene, x, y, minWidth, minHeight, config);

        this.type = 'rexSizer';
        this.sizerChildren = [];
        this.setOrientation(orientation);
    }

    destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
            return;
        }
        this.sizerChildren.length = 0;
        super.destroy(fromScene);
    }

    setOrientation(orientation) {
        if (typeof (orientation) === 'string') {
            orientation = OrientationConst[orientation];
        }
        this.orientation = orientation;
        return this;
    }

    add(gameObject, proportion, align, paddingConfig, expand, childKey) {
        super.add(gameObject);

        var proportionType = typeof (proportion);
        if (proportion === null) {
            return this;
        } else if (proportionType === 'number') {

        } else if (proportionType === 'string') {
            proportion = PROPORTIONMODE[proportion];
        } else if (Sizer_IsPlainObject(proportion)) {
            var config = proportion;
            proportion = Sizer_GetValue(config, 'proportion', 0);
            align = Sizer_GetValue(config, 'align', Sizer_ALIGN_CENTER);
            paddingConfig = Sizer_GetValue(config, 'padding', 0);
            expand = Sizer_GetValue(config, 'expand', false);
            childKey = Sizer_GetValue(config, 'key', undefined);
        }

        if (typeof (align) === 'string') {
            align = AlignConst[align];
        }

        if (proportion === undefined) {
            proportion = 0;
        }
        if (align === undefined) {
            align = Sizer_ALIGN_CENTER;
        }
        if (paddingConfig === undefined) {
            paddingConfig = 0;
        }
        if (expand === undefined) {
            expand = false;
        }

        var config = this.getSizerConfig(gameObject);
        config.parent = this;
        config.proportion = proportion;
        config.align = align;
        config.padding = utils_GetBoundsConfig(paddingConfig);
        config.expand = expand;
        this.sizerChildren.push(gameObject);

        if (childKey !== undefined) {
            this.addChildrenMap(childKey, gameObject)
        }
        return this;
    }

    addSpace(proportion) {
        if (proportion === undefined) {
            proportion = 1;
        }
        this.add(utils_Space(this.scene), proportion);
        return this;
    }

    insert(index, gameObject, proportion, align, paddingConfig, expand) {
        this.add(gameObject, proportion, align, paddingConfig, expand);
        this.moveTo(gameObject, index);
        return this;
    }

    remove(gameObject) {
        var config = this.getSizerConfig(gameObject);
        if (config.parent !== this) {
            return this;
        }
        config.parent = undefined;
        RemoveItem(this.sizerChildren, gameObject);
        super.remove(gameObject);
        return this;
    }

    clear(destroyChild) {
        for (var i = 0, cnt = this.sizerChildren.length; i < cnt; i++) {
            this.getSizerConfig(this.sizerChildren[i]).parent = undefined;
        }
        this.sizerChildren.length = 0;
        super.clear(destroyChild);
        return this;
    }

    get childrenProportion() {
        if (this._childrenProportion === undefined) {
            this._childrenProportion = this.getChildrenProportion();
        }
        return this._childrenProportion;
    }
}

Object.assign(
    Sizer_Sizer.prototype,
    sizer_Methods
);

const PROPORTIONMODE = {
    min: 0,
    full: -1,
}
/* harmony default export */ var sizer_Sizer = (Sizer_Sizer);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/utils/ScrollModeConst.js
/* harmony default export */ var ScrollModeConst = ({
    v: 0,
    vertical: 0,
    h: 1,
    horizontal: 1
});
// CONCATENATED MODULE: ./lib/rexui/lib/ui/utils/GetScrollMode.js


const GetScrollMode_GetValue = Phaser.Utils.Objects.GetValue;

var GetScrollMode = function (config, key) {
    if (key === undefined) {
        key = 'scrollMode';
    }
    var scrollMode = GetScrollMode_GetValue(config, 'scrollMode', 0); // Vertical
    if (typeof (scrollMode) === 'string') {
        scrollMode = ScrollModeConst[scrollMode];
    }
    return scrollMode;
}
/* harmony default export */ var utils_GetScrollMode = (GetScrollMode);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/slider/PositionToPercent.js
const Percent = Phaser.Math.Percent;

var PositionToPercent = function (startPoint, endPoint, currentPoint) {
    var min, max, value;
    if (startPoint.y === endPoint.y) {
        min = Math.min(startPoint.x, endPoint.x);
        max = Math.max(startPoint.x, endPoint.x);
        value = Percent(currentPoint.x, min, max);
    } else if (startPoint.x === endPoint.x) {
        min = Math.min(startPoint.y, endPoint.y);
        max = Math.max(startPoint.y, endPoint.y);
        value = Percent(currentPoint.y, min, max);
    }
    return value
}

/* harmony default export */ var slider_PositionToPercent = (PositionToPercent);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/slider/OnDragThumb.js


var OnDragThumb = function (pointer, dragX, dragY) {
    if (!this.enable) {
        return;
    }
    tmpPoint.x = dragX;
    tmpPoint.y = dragY;
    this.value = slider_PositionToPercent(this.getStartPoint(), this.getEndPoint(), tmpPoint);
}
var tmpPoint = {};

/* harmony default export */ var slider_OnDragThumb = (OnDragThumb);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/slider/OnTouchTrack.js


var OnTouchTrack = function (pointer, localX, localY) {
    if (!this.enable) {
        return;
    }
    if (!pointer.isDown) {
        return;
    }
    OnTouchTrack_tmpPoint.x = pointer.worldX;
    OnTouchTrack_tmpPoint.y = pointer.worldY;
    this.value = slider_PositionToPercent(this.getStartPoint(), this.getEndPoint(), OnTouchTrack_tmpPoint);
}
var OnTouchTrack_tmpPoint = {};

/* harmony default export */ var slider_OnTouchTrack = (OnTouchTrack);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/slider/GetThumbAlignPoint.js


var GetThumbAlignPoint = function (align, out) {
    if (out === undefined) {
        out = GetThumbAlignPoint_tmpPoint;
    }
    var thumb = this.childrenMap.thumb;
    var currentX = thumb.x;
    var currentY = thumb.y;

    in_QuickSet(thumb, this, align);
    out.x = thumb.x;
    out.y = thumb.y;

    thumb.x = currentX;
    thumb.y = currentY;

    return out;
}

var GetThumbAlignPoint_tmpPoint = {};

/* harmony default export */ var slider_GetThumbAlignPoint = (GetThumbAlignPoint);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/slider/GetStartPoint.js


const AlignLeft = Phaser.Display.Align.LEFT_CENTER;
const AlignTop = Phaser.Display.Align.TOP_CENTER;

var GetStartPoint = function (out) {
    if (out === undefined) {
        out = GetStartPoint_tmpPoint;
    }
    if (this.childrenMap.thumb) {
        var align = (this.orientation === 0) ? AlignTop : AlignLeft;
        slider_GetThumbAlignPoint.call(this, align, out);
    } else {
        if (this.orientation === 0) {
            out.x = this.centerX;
            out.y = this.top + 1; // Add 1 pixel margin
        } else {
            out.x = this.left + 1; // Add 1 pixel margin
            out.y = this.centerY;
        }
    }
    return out;
}

var GetStartPoint_tmpPoint = {};

/* harmony default export */ var slider_GetStartPoint = (GetStartPoint);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/slider/GetEndPoint.js


const AlignRight = Phaser.Display.Align.RIGHT_CENTER;
const AlignBottom = Phaser.Display.Align.BOTTOM_CENTER;

var GetEndoint = function (out) {
    if (out === undefined) {
        out = GetEndPoint_tmpPoint;
    }
    if (this.childrenMap.thumb) {
        var align = (this.orientation === 1) ? AlignRight : AlignBottom;
        slider_GetThumbAlignPoint.call(this, align, out);
    } else {
        if (this.orientation === 0) {
            out.x = this.centerX;
            out.y = this.bottom - 1; // Add 1 pixel margin
        } else {
            out.x = this.right - 1; // Add 1 pixel margin
            out.y = this.centerY;
        }
    }
    return out;
}

var GetEndPoint_tmpPoint = {};

/* harmony default export */ var GetEndPoint = (GetEndoint);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/slider/PercentToPosition.js
const Linear = Phaser.Math.Linear;

var PercentToPosition = function (t, startPoint, endPoint, out) {
    if (out === undefined) {
        out = tmpOut;
    }
    out.x = Linear(startPoint.x, endPoint.x, t);
    out.y = Linear(startPoint.y, endPoint.y, t);
    return out;
}
var tmpOut = {};

/* harmony default export */ var slider_PercentToPosition = (PercentToPosition);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/slider/UpdateThumb.js


var UpdateThumb = function (t) {
    var thumb = this.childrenMap.thumb;
    if (thumb === undefined) {
        return this;
    }

    if (t === undefined) {
        t = this.value;
    }
    slider_PercentToPosition(t, this.getStartPoint(), this.getEndPoint(), thumb);
    this.resetChildPositionState(thumb);
    return this;
}

/* harmony default export */ var slider_UpdateThumb = (UpdateThumb);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/slider/UpdateIndicator.js




const UpdateIndicator_AlignLeft = Phaser.Display.Align.LEFT_CENTER;
const UpdateIndicator_AlignTop = Phaser.Display.Align.TOP_CENTER;

var UpdateIndicator = function (t) {
    var indicator = this.childrenMap.indicator;
    if (indicator === undefined) {
        return this;
    }

    if (t === undefined) {
        t = this.value;
    }

    var newWidth, newHeight;
    var thumb = this.childrenMap.thumb;
    if (thumb) {
        if (this.orientation === 0) { // x, extend height
            var thumbHeight = GetDisplayHeight(thumb);
            var thumbBottom = (thumb.y - (thumbHeight * thumb.originY)) + thumbHeight;
            newHeight = thumbBottom - this.top;
        } else { // y, extend width
            var thumbWidth = GetDisplayWidth(thumb);
            var thumbRight = (thumb.x - (thumbWidth * thumb.originX)) + thumbWidth;
            newWidth = thumbRight - this.left;
        }
    } else {
        if (this.orientation === 0) { // x, extend height
            newHeight = this.height * t;
        } else { // y, extend width
            newWidth = this.width * t;
        }
    }
    size_ResizeGameObject(indicator, newWidth, newHeight);
    var align = (this.orientation === 1) ? UpdateIndicator_AlignLeft : UpdateIndicator_AlignTop;
    in_QuickSet(indicator, this, align);
    this.resetChildPositionState(indicator);
}

/* harmony default export */ var slider_UpdateIndicator = (UpdateIndicator);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/slider/Slider.js








const Slider_GetValue = Phaser.Utils.Objects.GetValue;
const Clamp = Phaser.Math.Clamp;
const Slider_Linear = Phaser.Math.Linear;
const Slider_Percent = Phaser.Math.Percent;
const SnapTo = Phaser.Math.Snap.To;

class Slider_Slider extends sizer_Sizer {
    constructor(scene, config) {
        // Create sizer
        super(scene, config);
        this.type = 'rexSlider';
        this.eventEmitter = Slider_GetValue(config, 'eventEmitter', this);

        // Add elements
        var background = Slider_GetValue(config, 'background', undefined);
        var track = Slider_GetValue(config, 'track', undefined);
        var indicator = Slider_GetValue(config, 'indicator', undefined);
        var thumb = Slider_GetValue(config, 'thumb', undefined);

        // Space
        var paddingLeft = Slider_GetValue(config, 'space.left', 0);
        var paddingRight = Slider_GetValue(config, 'space.right', 0);
        var paddingTop = Slider_GetValue(config, 'space.top', 0);
        var paddingBottom = Slider_GetValue(config, 'space.bottom', 0);

        if (background) {
            this.addBackground(background);
        }

        if (track) {
            var padding = {
                left: paddingLeft,
                right: paddingRight,
                top: paddingTop,
                bottom: paddingBottom
            }
            this.add(track, 0, undefined, padding, true);
        }

        if (indicator) {
            this.add(indicator, null); // Put into container but not layout it
        }

        if (thumb) {
            this.add(thumb, null); // Put into container but not layout it

        }

        // Input
        var inputMode = Slider_GetValue(config, 'input', 0);
        if (typeof (inputMode) === 'string') {
            inputMode = INPUTMODE[inputMode];
        }
        switch (inputMode) {
            case 0: // 'drag'
                if (thumb) {
                    thumb.setInteractive();
                    this.scene.input.setDraggable(thumb);
                    thumb.on('drag', slider_OnDragThumb, this);
                }
                break;
            case 1: // 'click'
                this.setInteractive()
                    .on('pointerdown', slider_OnTouchTrack, this)
                    .on('pointermove', slider_OnTouchTrack, this);
                break;
        }

        this.addChildrenMap('background', background);
        this.addChildrenMap('track', track);
        this.addChildrenMap('indicator', indicator);
        this.addChildrenMap('thumb', thumb);

        var callback = Slider_GetValue(config, 'valuechangeCallback', null);
        if (callback !== null) {
            var scope = Slider_GetValue(config, 'valuechangeCallbackScope', undefined);
            this.eventEmitter.on('valuechange', callback, scope);
        }
        this.setEnable(Slider_GetValue(config, 'enable', undefined));
        this.setGap(Slider_GetValue(config, 'gap', undefined));
        this.setValue(Slider_GetValue(config, 'value', 0));
    }

    setEnable(enable) {
        if (enable === undefined) {
            enable = true;
        }
        this.enable = enable;
        return this;
    }

    setGap(gap) {
        this.gap = gap;
        return this;
    }

    get value() {
        return this._value;
    }

    set value(value) {
        if (this.gap !== undefined) {
            value = SnapTo(value, this.gap);
        }
        var oldValue = this._value;
        this._value = Clamp(value, 0, 1);

        if (oldValue !== this._value) {
            this.updateThumb(this._value);
            this.updateIndicator(this._value);
            this.eventEmitter.emit('valuechange', this._value, oldValue, this.eventEmitter);
        }
    }

    setValue(value, min, max) {
        if ((value === undefined) || (value === null)) {
            return this;
        }

        if (min !== undefined) {
            value = Slider_Percent(value, min, max);
        }
        this.value = value;
        return this;
    }

    addValue(inc, min, max) {
        if (min !== undefined) {
            inc = Slider_Percent(inc, min, max);
        }
        this.value += inc;
        return this;
    }

    getValue(min, max) {
        var value = this.value;
        if (min !== undefined) {
            value = Slider_Linear(min, max, value);
        }
        return value;
    }

    layout(parent, newWidth, newHeight) {
        super.layout(parent, newWidth, newHeight);
        this.updateThumb();
        this.updateIndicator();
        return this;
    }
}

const INPUTMODE = {
    drag: 0,
    click: 1,
    none: -1,
}

var Slider_methods = {
    getStartPoint: slider_GetStartPoint,
    getEndPoint: GetEndPoint,
    updateThumb: slider_UpdateThumb,
    updateIndicator: slider_UpdateIndicator,
}
Object.assign(
    Slider_Slider.prototype,
    Slider_methods
);

/* harmony default export */ var slider_Slider = (Slider_Slider);
// EXTERNAL MODULE: ./lib/rexui/lib/plugins/utils/object/GetValue.js
var object_GetValue = __webpack_require__(185);
var GetValue_default = /*#__PURE__*/__webpack_require__.n(object_GetValue);

// CONCATENATED MODULE: ./lib/rexui/lib/plugins/logic/fsm/FSM.js



class FSM_FSM {
    /*
    var config = {
        start: 'A',   // default: undefined
        states: {
            A: {
                next: 'B',  // function() { return 'B'; }
                enter: function() {},
                exit: function() {}
            },
            // ...
        },        
        extend: {
            i: 0,
            name: 'abc'
            // ...
        },
        init: function() {},
        enable: true,
        eventEmitter: true,
    };
    */
    constructor(config) {
        // Attach get-next-state function
        var states = GetValue_default()(config, 'states', undefined);
        if (states) {
            this.addStates(states);
        }

        // Attach extend members
        var extend = GetValue_default()(config, 'extend', undefined);
        if (extend) {
            for (var name in extend) {
                if (!this.hasOwnProperty(name) || this[name] === undefined) {
                    this[name] = extend[name];
                }
            }
        }

        // Event emitter
        var eventEmitter = GetValue_default()(config, 'eventEmitter', undefined);
        var EventEmitterClass = GetValue_default()(config, 'EventEmitterClass', undefined);
        this.setEventEmitter(eventEmitter, EventEmitterClass);

        this._stateLock = false;
        this.resetFromJSON(config);
    }

    shutdown() {
        this.destroyEventEmitter();
    }

    destroy() {
        this.shutdown();
    }

    resetFromJSON(o) {
        this.setEnable(GetValue_default()(o, 'enable', true));
        this.start(GetValue_default()(o, 'start', undefined));
        var init = GetValue_default()(o, 'init', undefined);
        if (init) {
            init.call(this);
        }
        return this;
    }

    toJSON() {
        return {
            curState: this.state,
            prevState: this.prevState,

            enable: this.enable,
            start: this._start
        };
    }

    setEnable(e) {
        if (e === undefined) {
            e = true;
        }
        this.enable = e;
        return this;
    }

    set state(newState) {
        if (!this.enable || this._stateLock) {
            return;
        }
        if (this._state === newState) {
            return;
        }
        this._prevState = this._state;
        this._state = newState;

        this._stateLock = true; // lock state

        this.emit('statechange', this);

        if (this._prevState != null) {
            var exitEventName = 'exit_' + this._prevState;
            var exitCallback = this[exitEventName];
            if (exitCallback) {
                exitCallback.call(this);
            }
            this.emit(exitEventName, this);
        }

        this._stateLock = false;

        if (this._state != null) {
            var enterEventName = 'enter_' + this._state;
            var enterCallback = this[enterEventName];
            if (enterCallback) {
                enterCallback.call(this);
            }
            this.emit(enterEventName, this);
        }
    }

    get state() {
        return this._state;
    }

    get prevState() {
        return this._prevState;
    }

    start(state) {
        this._start = state;
        this._prevState = undefined;
        this._state = state; // Won't fire statechange events
        return this;
    }

    goto(nextState) {
        if (nextState != null) {
            this.state = nextState;
        }
        return this;
    }

    next() {
        var nextState;
        var getNextState = this['next_' + this.state];
        if (getNextState) {
            if (typeof (getNextState) === 'string') {
                nextState = getNextState;
            } else {
                nextState = getNextState.call(this);
            }
        }

        this.goto(nextState);
        return this;
    }

    addState(name, config) {
        var getNextStateCallback = GetValue_default()(config, 'next', undefined);
        if (getNextStateCallback) {
            this['next_' + name] = getNextStateCallback;
        }

        var exitCallback = GetValue_default()(config, 'exit', undefined);
        if (exitCallback) {
            this['exit_' + name] = exitCallback;
        }

        var enterCallback = GetValue_default()(config, 'enter', undefined);
        if (enterCallback) {
            this['enter_' + name] = enterCallback;
        }
        return this;
    }

    addStates(states) {
        for (var name in states) {
            this.addState(name, states[name]);
        }
        return this;
    }

    update(time, delta, key) {
        if (key === undefined) {
            key = 'update';
        }
        var fn = this[key + '_' + this.state];
        if (fn) {
            fn.call(this, time, delta);
        }
    }

    preupdate(time, delta) {
        this.update(time, delta, 'preupdate');
    }

    postupdate(time, delta) {
        this.update(time, delta, 'postupdate');
    }
}

Object.assign(
    FSM_FSM.prototype,
    EventEmitterMethods
);

/* harmony default export */ var fsm_FSM = (FSM_FSM);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/fsm.js

/* harmony default export */ var fsm = (fsm_FSM);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/input/scroller/State.js


class State_State extends fsm {
    constructor(parent, config) {
        super(config);
        this.parent = parent;
        this.init();
    }

    init() {
        this.start('IDLE');
    }

    // IDLE -> DRAGBEGIN|DRAG
    next_IDLE() {
        var nextState,
            parent = this.parent,
            dragState = parent.dragState;
        if (dragState.isDown) {
            nextState = (parent.dragThreshold === 0) ? 'DRAG' : 'DRAGBEGIN';
        }
        return nextState;
    }
    update_IDLE(time, delta) {
        this.next();
    }
    // IDLE

    // DRAGBEGIN -> DRAG|IDLE
    next_DRAGBEGIN() {
        var nextState,
            parent = this.parent,
            dragState = parent.dragState;
        if (dragState.isDown) {
            nextState = (dragState.pointer.getDistance() >= parent.dragThreshold) ? 'DRAG' : 'DRAGBEGIN';
        } else { // dragState.isUp
            nextState = 'IDLE';
        }
        return nextState;
    }
    update_DRAGBEGIN(time, delta) {
        this.next();
    }
    // DRAGBEGIN

    // DRAG -> BACK|SLIDE|IDLE
    next_DRAG() {
        var nextState,
            parent = this.parent,
            dragState = parent.dragState;
        if (dragState.isUp) {
            if (parent.outOfBounds) {
                nextState = 'BACK';
            } else if (parent.slidingEnable) {
                nextState = 'SLIDE';
            } else {
                nextState = 'IDLE';
            }
        }
        return nextState;
    }
    update_DRAG(time, delta) {
        var parent = this.parent,
            dragState = parent.dragState;
        if (dragState.justMoved) {
            parent.dragging();
        }
        this.next();
    }
    // DRAG    

    // SLIDE -> DRAG|IDLE
    next_SLIDE() {
        var nextState,
            parent = this.parent,
            dragState = parent.dragState;
        if (dragState.isDown) {
            nextState = 'DRAG';
        } else if (!parent.isSliding) {
            nextState = 'IDLE';
        }
        return nextState;
    }
    enter_SLIDE() {
        this.parent.onSliding();
    }
    exit_SLIDE() {
        this.parent.stop();
    }
    update_SLIDE(time, delta) {
        this.parent.sliding(time, delta);
        this.next();
    }
    // SLIDE    

    // BACK -> DRAG|IDLE
    next_BACK() {
        var nextState,
            parent = this.parent,
            dragState = parent.dragState;
        if (dragState.isDown) {
            nextState = 'DRAG';
        } else if (!parent.isPullBack) {
            nextState = 'IDLE';
        }
        return nextState;
    }
    enter_BACK() {
        this.parent.onPullBack();
    }
    exit_BACK() {
        this.parent.stop();
    }
    update_BACK(time, delta) {
        this.parent.pullBack(time, delta);
        this.next();
    }
    // BACK
}

/* harmony default export */ var scroller_State = (State_State);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/input/dragspeed/DragSpeed.js



const DragSpeed_GetValue = Phaser.Utils.Objects.GetValue;
const DistanceBetween = Phaser.Math.Distance.Between;

class DragSpeed_DragSpeed {
    constructor(gameObject, config) {
        this.gameObject = gameObject;
        this.scene = system_GetSceneObject(gameObject);
        // Event emitter
        this.setEventEmitter(DragSpeed_GetValue(config, 'eventEmitter', undefined));

        gameObject.setInteractive(DragSpeed_GetValue(config, "inputConfig", undefined));
        this.resetFromJSON(config);
        this.boot();
    }

    resetFromJSON(o) {
        this.pointer = undefined;
        this.isInTouched = false;
        this.holdStartTime = undefined;
        this.x = undefined;
        this.y = undefined;
        this.preX = undefined;
        this.preY = undefined;
        this.localX = undefined;
        this.localY = undefined;
        this.justMoved = false;
        this.setEnable(DragSpeed_GetValue(o, "enable", true));
        this.holdThreshold = DragSpeed_GetValue(o, "holdThreshold", 50); // ms
        return this;
    }

    boot() {
        this.gameObject.on('pointerdown', this.onPointIn, this);
        this.gameObject.on('pointerover', this.onPointIn, this);
        this.gameObject.on('pointerup', this.onPointOut, this);
        this.gameObject.on('pointerout', this.onPointOut, this);
        this.gameObject.on('pointermove', this.onPointerMove, this);
        this.gameObject.on('destroy', this.destroy, this);
        this.scene.events.on('preupdate', this.preupdate, this);
    }

    shutdown() {
        if (this.scene) { // Scene might be destoryed
            this.scene.events.off('preupdate', this.preupdate, this);
        }
        this.pointer = undefined;
        this.gameObject = undefined;
        this.scene = undefined;
        // GameObject events will be removed when this gameObject destroyed 
        this.destroyEventEmitter();
    }

    destroy() {
        this.shutdown();
    }

    setEnable(e) {
        if (e === undefined) {
            e = true;
        }

        if (this.enable === e) {
            return this;
        }

        if (!e) {
            this.isInTouched = false;
            this.pointer = undefined;
        }
        this.enable = e;
        this.gameObject.input.enabled = e;
        return this;
    }

    get isDown() {
        return this.pointer && this.pointer.isDown;
    }

    get isUp() {
        return !this.isDown;
    }

    get dx() {
        return this.x - this.preX;
    }

    get dy() {
        return this.y - this.preY;
    }

    get dt() {
        var game = this.scene.sys.game;
        var delta = game.loop.delta;
        return delta;
    }

    get speed() {
        if ((this.x === this.preX) && (this.y === this.preY)) {
            return 0;
        }
        var d = DistanceBetween(this.preX, this.preY, this.x, this.y);
        var speed = d / (this.dt * 0.001);
        return speed;
    }

    get speedX() {
        return this.dx / (this.dt * 0.001);
    }

    get speedY() {
        return this.dy / (this.dt * 0.001);
    }

    // internal
    onPointIn(pointer, localX, localY) {
        if (!pointer.isDown ||
            (this.pointer !== undefined)) {
            return;
        }
        this.pointer = pointer;
        this.localX = localX;
        this.localY = localY;
    }

    onPointOut(pointer) {
        if (this.pointer !== pointer) {
            return;
        }
        this.pointer = undefined;
    }

    onPointerMove(pointer, localX, localY) {
        if (!pointer.isDown ||
            (this.pointer !== pointer)) {
            return;
        }
        this.localX = localX;
        this.localY = localY;
    }

    preupdate(time, delta) {
        var pointer = this.pointer;
        this.justMoved = false;
        if (pointer && (!this.isInTouched)) {
            // Touch start
            this.x = pointer.x;
            this.y = pointer.y;
            this.preX = pointer.x;
            this.preY = pointer.y;
            this.isInTouched = true;
            this.holdStartTime = undefined;
            this.emit('touchstart', pointer, this.localX, this.localY);

        } else if (pointer && this.isInTouched) {
            // In touch
            if ((this.x === pointer.x) && (this.y === pointer.y)) {
                // Hold
                if (this.holdStartTime === undefined) {
                    this.holdStartTime = time;
                } else if (time - this.holdStartTime > this.holdThreshold) {
                    this.preX = this.x;
                    this.preY = this.y;
                }
            } else {
                // Move
                this.preX = this.x;
                this.preY = this.y;
                this.x = pointer.x;
                this.y = pointer.y;
                this.holdStartTime = undefined;
                this.justMoved = true;
                this.emit('touchmove', pointer, this.localX, this.localY);
            }

        } else if ((!pointer) && this.isInTouched) {
            // Touch end
            this.isInTouched = false;
            this.holdStartTime = undefined;
            this.emit('touchend', pointer);

        }
    }
}

Object.assign(
    DragSpeed_DragSpeed.prototype,
    EventEmitterMethods
);

/* harmony default export */ var dragspeed_DragSpeed = (DragSpeed_DragSpeed);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/dragspeed.js

/* harmony default export */ var dragspeed = (dragspeed_DragSpeed);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/movement/Movement.js
const Movement_GetValue = Phaser.Utils.Objects.GetValue;

class Movement {
    constructor(config) {
        this.resetFromJSON(config);
    }

    resetFromJSON(o) {
        this.setValue(Movement_GetValue(o, 'value', 0));
        this.setSpeed(Movement_GetValue(o, 'speed', 0));
        this.setAcceleration(Movement_GetValue(o, 'acceleration', 0));
        return this;
    }

    reset() {
        this.setValue(0);
        this.setSpeed(0);
        this.setAcceleration(0);
    }

    setValue(value) {
        this.value = value;
        return this;
    }

    setSpeed(speed) {
        // speed == 0 : stop
        // speed  > 0 : move
        this.speed = speed;
        return this;        
    }

    setAcceleration(acc) {
        // acc == 0 : constant speed
        // acc  > 0 : acceleration
        // acc  < 0 : deceleration
        this.acceleration = acc;
        return this;
    }

    updateSpeed(delta) {
        // delta in sec
        if (this.acceleration !== 0) {
            this.speed += (this.acceleration * delta);
            if (this.speed < 0) {
                this.speed = 0;
            }
        }
        return this;
    }

    getDeltaValue(delta) {
        // delta in sec
        this.updateSpeed(delta);
        if (this.speed <= 0) {
            return 0;
        }
        return (this.speed * delta);
    }

    update(delta) {
        // delta in sec
        this.updateSpeed(delta);
        if (this.speed > 0) {
            this.value += this.getDeltaValue(delta);
        }
        return this;
    }

    get isMoving() {
        return (this.speed > 0);
    }
}
/* harmony default export */ var movement_Movement = (Movement);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/movement/SlowDown.js


class SlowDown_SlowDown {
    constructor() {
        this.value;
        this.dir; // true:+, false:-
        this.movement = new movement_Movement();
    }

    init(start, dir, speed, dec, end) {
        this.value = start;
        this.end = end;
        if (end !== undefined) {
            this.dir = (start < end);
        } else {
            this.dir = dir;
        }

        this.movement
            .setSpeed(speed)
            .setAcceleration(-dec);
        return this;
    }

    stop() {
        this.movement.reset();
    }

    update(delta) {
        // delta in sec
        var d = this.movement.getDeltaValue(delta);
        if (!this.dir) {
            d = -d;
        }

        if (this.end === undefined) {
            this.value += d;
        } else {
            if (d === 0) {
                this.value = this.end;
            } else {
                this.value += d;
                if (this.dir) { // +
                    if (this.value > this.end) {
                        this.value = this.end;
                    }
                } else { // -
                    if (this.value < this.end) {
                        this.value = this.end;
                    }
                }
            }
        }
        return this;
    }

    get isMoving() {
        return this.movement.isMoving;
    }
}
/* harmony default export */ var movement_SlowDown = (SlowDown_SlowDown);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/input/scroller/Scroller.js






const Scroller_GetValue = Phaser.Utils.Objects.GetValue;

class Scroller_Scroller {
    constructor(gameObject, config) {
        this.gameObject = gameObject;
        this.scene = system_GetSceneObject(gameObject);
        // Event emitter
        this.setEventEmitter(Scroller_GetValue(config, 'eventEmitter', undefined));

        var enable = Scroller_GetValue(config, 'enable', true);
        var stateConfig = {
            enable: enable,
            eventEmitter: false,
        }
        this._state = new scroller_State(this, stateConfig);

        var drapSpeedConfig = {
            inputConfig: Scroller_GetValue(config, 'inputConfig', undefined),
            enable: enable,
            eventEmitter: false,
        };
        this.dragState = new dragspeed(gameObject, drapSpeedConfig);

        this._value = undefined;
        this._slowDown = new movement_SlowDown();

        var callback = Scroller_GetValue(config, 'valuechangeCallback', null);
        if (callback !== null) {
            var scope = Scroller_GetValue(config, 'valuechangeCallbackScope', undefined);
            this.on('valuechange', callback, scope);
        }
        callback = Scroller_GetValue(config, 'overmaxCallback', null);
        if (callback !== null) {
            var scope = Scroller_GetValue(config, 'overmaxCallbackScope', undefined);
            this.on('overmax', callback, scope);
        }
        callback = Scroller_GetValue(config, 'overminCallback', null);
        if (callback !== null) {
            var scope = Scroller_GetValue(config, 'overminCallbackScope', undefined);
            this.on('overmin', callback, scope);
        }

        this.resetFromJSON(config);
        this.boot();
    }

    resetFromJSON(o) {
        this.setOrientationMode(Scroller_GetValue(o, 'orientation', 0));
        this.setDragThreshold(Scroller_GetValue(o, 'threshold', 10));
        this.setSlidingDeceleration(Scroller_GetValue(o, 'slidingDeceleration', 5000));
        this.setBackDeceleration(Scroller_GetValue(o, 'backDeceleration', 2000));
        this.boundPad0 = Scroller_GetValue(o, 'boundPad0', 0);
        this.boundPad1 = Scroller_GetValue(o, 'boundPad1', 0);
        var bounds = Scroller_GetValue(o, 'bounds', undefined);
        if (bounds) {
            this.setBounds(bounds);
        } else {
            this.setBounds(Scroller_GetValue(o, 'max', 0), Scroller_GetValue(o, 'min', 0));
        }
        this.setValue(Scroller_GetValue(o, 'value', this.maxValue || 0 + this.boundPad1));
        this.setEnable(Scroller_GetValue(o, "enable", true));
        return this;
    }

    boot() {
        this.scene.events.on('update', this._state.update, this._state);
        this.gameObject.on('destroy', this.destroy, this);
    }

    shutdown() {
        this.destroyEventEmitter();
        if (this.scene) { // Scene might be destoryed
            this.scene.events.off('update', this._state.update, this._state);
        }
        this.gameObject = undefined;
        this.scene = undefined;
        this._state.destroy();
        this.dragState.destroy();
        // gameObject events will be removed when this gameObject destroyed 
    }

    destroy() {
        this.shutdown();
    }

    setOrientationMode(m) {
        if (typeof (m) === 'string') {
            m = ORIENTATIONMODE[m];
        }
        this.orientationMode = m;
        return this;
    }

    setDragThreshold(distance) {
        this.dragThreshold = distance;
        return this;
    }

    setSlidingDeceleration(dec) {
        this.slidingDeceleration = dec;
        return this;
    }

    setBackDeceleration(dec) {
        this.backDeceleration = dec;
        return this;
    }

    setBounds(value0, value1) {
        if (Array.isArray(value0)) {
            var bounds = value0;
            value0 = bounds[0];
            value1 = bounds[1];
        }
        if (value0 < value1) {
            this.minValue = value0 + this.boundPad0;
            this.maxValue = value1 + this.boundPad1;
        } else {
            this.minValue = value1 + this.boundPad0;
            this.maxValue = value0 + this.boundPad1;
        }
        return this;
    }

    get value() {
        return this._value;
    }

    set value(value) {
        if (value === this._value) {
            return;
        }

        var oldValue = this._value;
        var isOverMax = this.overMax(value);
        var isOverMin = this.overMin(value);
        if (isOverMax) {
            this.emit('overmax', value, oldValue);
        }
        if (isOverMin) {
            this.emit('overmin', value, oldValue);
        }
        if (!this.backEnable) {
            if (isOverMax) {
                value = this.maxValue;
            }
            if (isOverMin) {
                value = this.minValue;
            }
        }

        this._value = value;
        this.emit('valuechange', value, oldValue);
    }

    setValue(value) {
        this.value = value;
    }

    setEnable(e) {
        this._state.setEnable(e);
        this.dragState.setEnable(e);
        return this;
    }

    get state() {
        return this._state.state;
    }

    get isDragging() {
        return this.dragState.isInTouched;
    }

    get outOfMaxBound() {
        return this.overMax(this.value);
    }

    get outOfMinBound() {
        return this.overMin(this.value);
    }

    get outOfBounds() {
        return this.outOfMinBound || this.outOfMaxBound;
    }

    // internal
    overMax(value) {
        return (this.maxValue != null) && (value > this.maxValue);
    }

    overMin(value) {
        return (this.minValue != null) && (value < this.minValue);
    }

    get backEnable() {
        return (typeof (this.backDeceleration) === 'number');
    }

    get isPullBack() {
        return this._slowDown.isMoving;
    }

    get slidingEnable() {
        return (typeof (this.slidingDeceleration) === 'number');
    }

    get isSliding() {
        return this._slowDown.isMoving;
    }

    get dragDelta() {
        if (this.orientationMode === 0) { // y
            return this.dragState.dy;
        } else if (this.orientationMode === 1) { // x
            return this.dragState.dx;
        } else {
            return 0;
        }
    }

    get dragSpeed() {
        if (this.orientationMode === 0) { // y
            return this.dragState.speedY;
        } else if (this.orientationMode === 1) { // x
            return this.dragState.speedX;
        } else {
            return 0;
        }
    }

    // everyTick_DRAG
    dragging() {
        this.value += this.dragDelta;
    }

    // enter_SLIDE 
    onSliding() {
        var start = this.value;
        var speed = this.dragSpeed;
        if (speed === 0) {
            this._slowDown.stop();
            this._state.next();
            return;
        }
        var dec = this.slidingDeceleration;
        this._slowDown.init(start, (speed > 0), Math.abs(speed), dec)
    }

    // everyTick_SLIDE
    sliding(time, delta) {
        delta *= 0.001;
        var newValue = this._slowDown.update(delta).value;
        if (this.overMax(newValue)) {
            this.value = this.maxValue;
            this._slowDown.stop();
        } else if (this.overMin(newValue)) {
            this.value = this.minValue;
            this._slowDown.stop();
        } else {
            this.value = newValue;
        }
    }

    // enter_BACK
    onPullBack() {
        var start = this.value;
        var end = (this.outOfMinBound) ? this.minValue : this.maxValue;
        var dist = Math.abs(end - start);
        var dec = this.backDeceleration;
        var speed = Math.sqrt(2 * dec * dist);
        this._slowDown.init(start, undefined, speed, dec, end);
    }

    // everyTick_BACK
    pullBack(time, delta) {
        delta *= 0.001;
        this.value = this._slowDown.update(delta).value;

        if (!this._slowDown.isMoving) {
            this._state.next();
        }
    }

    // exit_SLIDE, exit_BACK
    stop() {
        this._slowDown.stop();
    }

}

Object.assign(
    Scroller_Scroller.prototype,
    EventEmitterMethods
);

/** @private */
const ORIENTATIONMODE = {
    y: 0,
    v: 0,
    vertical: 0,
    x: 1,
    h: 1,
    horizontal: 1,
};

/* harmony default export */ var scroller_Scroller = (Scroller_Scroller);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/scroller.js

/* harmony default export */ var plugins_scroller = (scroller_Scroller);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/utils/scrollable/CreateScrollableSizer.js





const CreateScrollableSizer_GetValue = Phaser.Utils.Objects.GetValue;

var CreateScrollableSizer = function (config) {
    var scene = this.scene;
    var scrollMode = utils_GetScrollMode(config);
    var scrollableSizer = new sizer_Sizer(scene, { orientation: scrollMode });

    var child = CreateScrollableSizer_GetValue(config, 'child.gameObject', undefined);
    var sliderConfig = CreateScrollableSizer_GetValue(config, 'slider', undefined), slider;
    var scrollerConfig = CreateScrollableSizer_GetValue(config, 'scroller', true), scroller;

    // Child, slider, scroller
    if (child) {
        var childSpace = CreateScrollableSizer_GetValue(config, 'space.child', 0);
        this.childPadding = {};
        if (typeof (childSpace) !== 'number') {
            var childPadding = childSpace;
            if (scrollMode === 0) {
                childSpace = CreateScrollableSizer_GetValue(childPadding, 'right', 0);
                this.childPadding.top = CreateScrollableSizer_GetValue(childPadding, 'top', 0);
                this.childPadding.bottom = CreateScrollableSizer_GetValue(childPadding, 'bottom', 0);
            } else {
                childSpace = CreateScrollableSizer_GetValue(childPadding, 'bottom', 0);
                this.childPadding.top = CreateScrollableSizer_GetValue(childPadding, 'left', 0);
                this.childPadding.bottom = CreateScrollableSizer_GetValue(childPadding, 'right', 0);
            }
        } else {
            this.childPadding.top = 0;
            this.childPadding.bottom = 0;
        }

        var proportion = CreateScrollableSizer_GetValue(config, 'child.proportion', 1);
        var expand = CreateScrollableSizer_GetValue(config, 'child.expand', true);
        var padding;
        if (scrollMode === 0) {
            padding = {
                right: (sliderConfig) ? childSpace : 0,
            };
        } else {
            padding = {
                bottom: (sliderConfig) ? childSpace : 0
            };
        }
        scrollableSizer.add(child, proportion, 'center', padding, expand);

        if (sliderConfig) {
            if (sliderConfig === true) {
                sliderConfig = {};
            }
            sliderConfig.orientation = scrollableSizer.orientation;
            slider = new slider_Slider(scene, sliderConfig);
            scrollableSizer.add(slider, 0, 'center', 0, true);
        }


        if (scrollerConfig) {
            if (scrollerConfig === true) {
                scrollerConfig = {};
            }
            scrollerConfig.orientation = scrollMode;
            scroller = new plugins_scroller(child, scrollerConfig);
        }
    }

    // Control
    if (slider) {
        slider.on('valuechange', function (newValue) {
            this.t = newValue;
        }, this);
    }
    if (scroller) {
        scroller.on('valuechange', function (newValue) {
            this.childOY = newValue;
        }, this);
    }

    this.addChildrenMap('child', child);
    this.addChildrenMap('slider', slider);
    this.addChildrenMap('scroller', scroller);

    return scrollableSizer;
}

/* harmony default export */ var scrollable_CreateScrollableSizer = (CreateScrollableSizer);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/utils/scrollable/ResizeController.js
var ResizeController = function () {
    var topChildOY = this.topChildOY;
    var bottomChildOY = this.bottomChildOY;
    var scroller = this.childrenMap.scroller;
    var slider = this.childrenMap.slider;
    if (scroller) {
        scroller.setBounds(bottomChildOY, topChildOY);
    }
    if (slider) {
        slider.setEnable(bottomChildOY !== topChildOY);
    }
    this.updateController();
    return this;
}

/* harmony default export */ var scrollable_ResizeController = (ResizeController);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/utils/scrollable/UpdateController.js
var UpdateController = function () {
    var scroller = this.childrenMap.scroller;
    var slider = this.childrenMap.slider;
    if (scroller) {
        scroller.setValue(this.childOY);
    }
    if (slider) {
        slider.setValue(this.t);
    }
}

/* harmony default export */ var scrollable_UpdateController = (UpdateController);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/utils/scrollable/Scrollable.js






const Scrollable_GetValue = Phaser.Utils.Objects.GetValue;
class Scrollable_Scrollable extends sizer_Sizer {
    constructor(scene, config) {
        if (config === undefined) {
            config = {};
        }

        var scrollMode = utils_GetScrollMode(config); // Left-to-right, or top-to-bottom
        // Create sizer
        config.orientation = (scrollMode === 0) ? 1 : 0;
        super(scene, config);
        this.type = Scrollable_GetValue(config, 'type', 'rexScrollable');

        // Add elements
        var background = Scrollable_GetValue(config, 'background', undefined);
        var scrollableSizer = scrollable_CreateScrollableSizer.call(this, config);
        var header = Scrollable_GetValue(config, 'header', undefined);
        var footer = Scrollable_GetValue(config, 'footer', undefined);

        // Space
        var paddingLeft = Scrollable_GetValue(config, 'space.left', 0);
        var paddingRight = Scrollable_GetValue(config, 'space.right', 0);
        var paddingTop = Scrollable_GetValue(config, 'space.top', 0);
        var paddingBottom = Scrollable_GetValue(config, 'space.bottom', 0);

        // Background
        if (background) {
            this.addBackground(background);
        }

        if (header) {
            var align = Scrollable_GetValue(config, 'align.header', 'center');
            var headerSpace = Scrollable_GetValue(config, 'space.header', 0);
            var padding;
            if (scrollMode === 0) {
                padding = {
                    left: paddingLeft,
                    right: paddingRight,
                    top: paddingTop,
                    bottom: headerSpace,
                };
            } else {
                padding = {
                    left: paddingLeft,
                    right: headerSpace,
                    top: paddingTop,
                    bottom: paddingBottom,
                };
            }
            var expand = Scrollable_GetValue(config, 'expand.header', true);
            this.add(header, 0, align, padding, expand);
        }

        if (scrollableSizer) {
            var padding;
            if (scrollMode === 0) {
                padding = {
                    left: paddingLeft,
                    right: paddingRight,
                    top: (header) ? 0 : paddingTop,
                    bottom: (footer) ? 0 : paddingBottom,
                };
            } else {
                padding = {
                    left: (header) ? 0 : paddingLeft,
                    right: (footer) ? 0 : paddingRight,
                    top: paddingTop,
                    bottom: paddingBottom,
                };
            }
            this.add(scrollableSizer, 1, 'center', padding, true);
        }

        if (footer) {
            var align = Scrollable_GetValue(config, 'align.footer', 'center');
            var footerSpace = Scrollable_GetValue(config, 'space.footer', 0);
            var padding;
            if (scrollMode === 0) {
                padding = {
                    left: paddingLeft,
                    right: paddingRight,
                    top: footerSpace,
                    bottom: paddingBottom,
                };
            } else {
                padding = {
                    left: footerSpace,
                    right: paddingRight,
                    top: paddingTop,
                    bottom: paddingBottom,
                };
            }
            var expand = Scrollable_GetValue(config, 'expand.footer', true);
            this.add(footer, 0, align, padding, expand);
        }

        this.addChildrenMap('background', background);
        this.addChildrenMap('header', header);
        this.addChildrenMap('footer', footer);

        // Necessary properties of child object
        // child.t (RW), child.childOY (RW), child.topChildOY (R), child.bottomChildOY (R)
    }

    layout(parent, newWidth, newHeight) {
        super.layout(parent, newWidth, newHeight);
        this.resizeController();
        return this;
    }

    set t(t) {
        // Get inner childT
        var childPadding = this.childPadding;
        if ((childPadding.top !== 0) || (childPadding.bottom !== 0)) {
            var child = this.childrenMap.child
            var innerHeight = (child.topChildOY - child.bottomChildOY);
            var outterHeight = innerHeight + childPadding.top + childPadding.bottom;
            var innerChildOY = (outterHeight * t) - childPadding.top;
            t = innerChildOY / innerHeight;
        }

        this.childrenMap.child.t = t;
        this.updateController();
    }

    get t() {
        var t = this.childrenMap.child.t;

        // Get outter childT
        var childPadding = this.childPadding;
        if ((childPadding.top !== 0) || (childPadding.bottom !== 0)) {
            var child = this.childrenMap.child
            var innerHeight = (child.topChildOY - child.bottomChildOY);
            var outterHeight = innerHeight + childPadding.top + childPadding.bottom;
            var outterChildOY = (innerHeight * t) + childPadding.top;
            t = outterChildOY / outterHeight;
        }
        return t;
    }

    set childOY(value) {
        this.childrenMap.child.childOY = value;
        this.updateController();
    }

    get childOY() {
        return this.childrenMap.child.childOY;
    }

    get topChildOY() {
        return this.childrenMap.child.topChildOY + this.childPadding.top;
    }

    get bottomChildOY() {
        return this.childrenMap.child.bottomChildOY - this.childPadding.bottom;
    }

    setChildOY(value) {
        this.childOY = value;
        return this;
    }

    setT(value) {
        this.t = value;
        return this;
    }

    scrollToTop() {
        this.t = 0;
        return this;
    }

    scrollToBottom() {
        this.t = 1;
        return this;
    }

    get sliderEnable() {
        var slider = this.childrenMap.slider;
        if (!slider) {
            return undefined;
        }

        return slider.enable;
    }

    set sliderEnable(value) {
        var slider = this.childrenMap.slider;
        if (!slider) {
            return;
        }
        slider.setEnable(value);
    }

    setSliderEnable(enabled) {
        if (enabled === undefined) {
            enabled = true;
        }
        this.sliderEnable = enabled;
        return this;
    }

    get scrollerEnable() {
        var scroller = this.childrenMap.scroller;
        if (!scroller) {
            return undefined;
        }

        return scroller.enable;
    }

    set scrollerEnable(value) {
        var scroller = this.childrenMap.scroller;
        if (!scroller) {
            return;
        }
        scroller.setEnable(value);
    }

    setScrollerEnable(enabled) {
        if (enabled === undefined) {
            enabled = true;
        }
        this.scrollerEnable = enabled;
        return this;
    }
}

var Scrollable_Methods = {
    resizeController: scrollable_ResizeController,
    updateController: scrollable_UpdateController
}

// mixin
Object.assign(
    Scrollable_Scrollable.prototype,
    Scrollable_Methods
);

/* harmony default export */ var scrollable_Scrollable = (Scrollable_Scrollable);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/text/IsTextGameObject.js
const TextKlass = Phaser.GameObjects.Text;

var IsTextGameObject = function (gameObject) {
    return (gameObject instanceof TextKlass);
}

/* harmony default export */ var text_IsTextGameObject = (IsTextGameObject);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/mask/DefaultMask.js
const Graphics = Phaser.GameObjects.Graphics;

class DefaultMask extends Graphics {
    constructor(parent, shape, padding) {
        if (shape === undefined) {
            shape = 0;
        }
        if (typeof (shape) === 'string') {
            shaep = SHAPEMODE[shape];
        }
        if (padding === undefined) {
            padding = 0;
        }

        super(parent.scene);
        this.parent = parent;
        this.shape = shape;
        this.padding = padding;
        this.setPosition().resize();
        // Don't add it to display list
        // Graphics does not have origin, bounds
    }

    destroy() {
        this.parent = undefined;
        super.destroy();
        return this;
    }

    setPosition(x, y) {
        var parent = this.parent;
        if (x === undefined) {
            x = parent.x;
        }
        if (y === undefined) {
            y = parent.y;
        }
        super.setPosition(x, y);
        return this;
    }

    resize(width, height, padding) {
        var parent = this.parent;
        if (width === undefined) {
            width = parent.width;
        }
        if (height === undefined) {
            height = parent.height;
        }
        if (padding === undefined) {
            padding = this.padding;
        }
        if ((this.widthSave === width) && (this.heightSave === height) && (this.paddingSave === padding)) {
            return this;
        }

        this.clear().fillStyle(0xffffff);
        switch (this.shape) {
            case 1: // circle
                var radius = Math.min(width, height) / 2;
                this.fillCircle(
                    0,
                    0,
                    radius + padding
                );
                break;
            default: // 0|'rectangle'
                this.fillRect(
                    -(width * parent.originX) - padding,
                    -(height * parent.originY) - padding,
                    width + (2 * padding),
                    height + (2 * padding)
                );
                break;
        }
        this.widthSave = width;
        this.heightSave = height;
        this.paddingSave = padding;
        return this;
    }
}

const SHAPEMODE = {
    rectangle: 0,
    circle: 1,
}
/* harmony default export */ var mask_DefaultMask = (DefaultMask);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/textblock/SetTextObject.js




const ALIGN_LEFTTOP = Phaser.Display.Align.TOP_LEFT;

var SetTextObject = function (gameObject, maskEnable) {
    if (maskEnable === undefined) {
        maskEnable = true;
    }

    this.add(gameObject);

    var config = this.getSizerConfig(gameObject);
    config.parent = this;
    config.align = ALIGN_LEFTTOP;
    config.padding = utils_GetBoundsConfig(0);
    config.expand = true;
    this.textObject = gameObject;
    this.textObjectType = (text_IsTextGameObject(gameObject)) ? 0 : 1;
    // Add more variables
    config.preOffsetY = 0;
    config.offsetY = 0;

    // Create mask of text object
    if (maskEnable) {
        this.textMask = new mask_DefaultMask(this);
        this.textObject.setMask(this.textMask.createGeometryMask());
        this.pin(this.textMask);
    }
    return this;
}

/* harmony default export */ var textblock_SetTextObject = (SetTextObject);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/textblock/SetText.js
var SetText = function (text) {
    if (text !== undefined) {
        this.text = text;
    }

    // Wrap content in lines
    if (this.textObjectType === 0) {
        this.lines = this.textObject.getWrappedText(this.text); // lines in array
    } else {
        this.lines = this.textObject.getPenManager(this.text, this.lines); // pen manager
    }

    this.updateTextObject();
    return this;
}
/* harmony default export */ var textblock_SetText = (SetText);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/textblock/TextHeightToLinesCount.js
var TextHeightToLinesCount = function (height) {
    // height = (maxLines * (lineHeight + lineSpacing)) - lineSpacing
    return (height - this.textLineSpacing) / (this.textLineHeight + this.textLineSpacing);
}
/* harmony default export */ var textblock_TextHeightToLinesCount = (TextHeightToLinesCount);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/textblock/LinesCountToTextHeight.js
var LinesCountToTextHeight = function (linesCount) {
    // height = (maxLines * (lineHeight + lineSpacing)) - lineSpacing
    return (linesCount * (this.textLineHeight + this.textLineSpacing)) - this.textLineSpacing;
}
/* harmony default export */ var textblock_LinesCountToTextHeight = (LinesCountToTextHeight);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/textblock/GetLines.js
var GetLines = function (startLineIdx) {
    var endLineIdx = startLineIdx + this.textObject.style.maxLines;
    var text;
    if (this.textObjectType === 0) {
        text = this.lines.slice(startLineIdx, endLineIdx).join('\n');
    } else {
        var startIdx = this.lines.getLineStartIndex(startLineIdx);
        var endIdx = this.lines.getLineEndIndex(endLineIdx - 1);
        text = this.lines.getSliceTagText(startIdx, endIdx, true);
    }
    return text;
}

/* harmony default export */ var textblock_GetLines = (GetLines);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/textblock/ResetTextObjectPosition.js
var ResetTextObjectPosition = function () {
    var config = this.textObject.rexSizer;
    this.textObject.y += (config.offsetY - config.preOffsetY);
    config.preOffsetY = config.offsetY;
    this.resetChildPositionState(this.textObject);
}
/* harmony default export */ var textblock_ResetTextObjectPosition = (ResetTextObjectPosition);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/textblock/UpdateTextObject.js





var UpdateTextObject = function () {
    var startLineIndex = Math.max(Math.floor(textblock_TextHeightToLinesCount.call(this, -this.textOY)), 0);
    var textOffset = textblock_LinesCountToTextHeight.call(this, startLineIndex) + this.textOY;

    this.textObject.setText(textblock_GetLines.call(this, startLineIndex));
    this.textObject.rexSizer.offsetY = textOffset;
    textblock_ResetTextObjectPosition.call(this);
    return this;
}
/* harmony default export */ var textblock_UpdateTextObject = (UpdateTextObject);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/textblock/ResizeText.js


var ResizeText = function (textObject, width, height) {
    height += this.textLineHeight + this.textLineSpacing; // Add 1 text line
    if ((textObject.width === width) && (textObject.height === height)) {
        return;
    }

    textObject.setFixedSize(width, height);

    var style = textObject.style;
    var wrapWidth = Math.max(width, 0);

    var maxLines = Math.ceil(textblock_TextHeightToLinesCount.call(this, height)) + 1;

    if (this.textObjectType === 0) {
        style.wordWrapWidth = wrapWidth;
        style.maxLines = maxLines;
    } else {
        style.wrapWidth = wrapWidth;
        style.maxLines = maxLines;
    }

    // Render content again
    this.setText();
}

/* harmony default export */ var textblock_ResizeText = (ResizeText);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/textblock/Layout.js





var textblock_Layout_Layout = function (parent, newWidth, newHeight) {
    // Skip invisible sizer
    if (this.rexSizer.hidden) {
        return this;
    }

    this.preLayout(parent);

    // Set size
    if (newWidth === undefined) {
        newWidth = this.minWidth;
    }
    if (newHeight === undefined) {
        newHeight = this.minHeight;
    }
    this.resize(newWidth, newHeight);

    // Layout children
    var child, childConfig, padding;
    var startX = this.left,
        startY = this.top;
    var x, y, width, height; // Align zone

    // Layout text child
    // Skip invisible child
    child = this.textObject;
    if (!child.rexSizer.hidden) {
        childConfig = child.rexSizer;
        padding = childConfig.padding;
        x = (startX + padding.left);
        y = (startY + padding.top);
        width = this.width - padding.left - padding.right;
        height = this.height - padding.top - padding.bottom;
        textblock_ResizeText.call(this, child, width, height);
        GlobZone.setPosition(x, y).setSize(width, height);
        in_QuickSet(child, GlobZone, childConfig.align);

        childConfig.preOffsetY = 0; // Clear preOffsetY
        textblock_ResetTextObjectPosition.call(this);

        if (this.textMask) {
            this.textMask.setPosition().resize();
            this.resetChildPositionState(this.textMask);
        }

    }

    // Layout background children
    this.layoutBackgrounds();

    return this.postLayout();
}

/* harmony default export */ var textblock_Layout = (textblock_Layout_Layout);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/textblock/Methods.js





/* harmony default export */ var textblock_Methods = ({
    setTextObject: textblock_SetTextObject,
    setText: textblock_SetText,
    updateTextObject: textblock_UpdateTextObject,
    layout: textblock_Layout,
});
// CONCATENATED MODULE: ./lib/rexui/lib/ui/textblock/TextBlock.js





const TextBlock_IsPlainObject = Phaser.Utils.Objects.IsPlainObject;
const TextBlock_GetValue = Phaser.Utils.Objects.GetValue;

class TextBlock_TextBlock extends BaseSizer {
    constructor(scene, x, y, minWidth, minHeight, config) {
        if (TextBlock_IsPlainObject(x)) {
            config = x;
            x = TextBlock_GetValue(config, 'x', 0);
            y = TextBlock_GetValue(config, 'y', 0);
            minWidth = TextBlock_GetValue(config, 'width', undefined);
            minHeight = TextBlock_GetValue(config, 'height', undefined);
        } else if (TextBlock_IsPlainObject(minWidth)) {
            config = minWidth;
            minWidth = TextBlock_GetValue(config, 'width', undefined);
            minHeight = TextBlock_GetValue(config, 'height', undefined);
        }

        super(scene, x, y, minWidth, minHeight, config);

        this.type = 'rexTextBlock';
        this.textObject = undefined;
        this.textMask = undefined;
        this.textObjectType = undefined;
        this.lines = undefined; // array (default text object), or pens-manager (tag text object)
        this.text = TextBlock_GetValue(config, 'content', '');
        this._textOY = 0;
        this.execeedTopState = false;
        this.execeedBottomState = false;

        this.setClampMode(TextBlock_GetValue(config, 'clamplTextOY', true));

        // Add elements
        var background = TextBlock_GetValue(config, 'background', undefined);
        var textObject = TextBlock_GetValue(config, 'text', undefined);
        if (textObject === undefined) {
            textObject = createDefaultTextObject(scene);
        }
        var textMaskEnable = TextBlock_GetValue(config, 'textMask', true);

        if (background) {
            this.addBackground(background);
        }

        this.setTextObject(textObject, textMaskEnable);

        this.addChildrenMap('background', background);
        this.addChildrenMap('text', textObject);
    }

    destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
            return;
        }
        this.textObject = undefined;
        this.textMask = undefined;
        if (this.lines === undefined) {
            // Do nothing
        } else if (this.textObjectType === 0) {
            this.lines.length = 0;
        } else {
            this.lines.destroy();
        }
        super.destroy(fromScene);
    }

    setClampMode(mode) {
        this.clampTextOYMode = mode;
        return this;
    }

    get textLineHeight() {
        var style = this.textObject.style;
        return style.metrics.fontSize + style.strokeThickness;
    }

    get textLineSpacing() {
        return this.textObject.lineSpacing;
    }

    get linesCount() {
        var count;
        if (this.lines === undefined) {
            count = 0;
        } else if (this.textObjectType === 0) {
            count = this.lines.length;
        } else {
            count = this.lines.linesCount;
        }
        return count;
    }

    get visibleLinesCount() {
        return Math.floor(textblock_TextHeightToLinesCount.call(this, this.textObject.height));
    }

    get topTextOY() {
        return 0;
    }

    get bottomTextOY() {
        return -this.textVisibleHeight;
    }

    get textHeight() {
        return textblock_LinesCountToTextHeight.call(this, this.linesCount);
    }

    get textObjectHeight() {
        return this.textObject.height - this.textLineHeight - this.textLineSpacing; // Remove 1 text line
    }

    get textVisibleHeight() {
        var h;
        var textHeight = this.textHeight;
        var textObjectHeight = this.textObjectHeight;
        if (textHeight > textObjectHeight) {
            h = textHeight - textObjectHeight;
        } else {
            h = 0;
        }

        return h;
    }

    textOYExceedTop(oy) {
        if (oy === undefined) {
            oy = this.textOY;
        }
        return (oy > this.topTextOY);
    }

    textOYExeceedBottom(oy) {
        if (oy === undefined) {
            oy = this.textOY;
        }
        return (oy < this.bottomTextOY);
    }

    get textOY() {
        return this._textOY;
    }

    set textOY(oy) {
        var topTextOY = this.topTextOY;
        var bottomTextOY = this.bottomTextOY;
        var textOYExceedTop = this.textOYExceedTop(oy);
        var textOYExeceedBottom = this.textOYExeceedBottom(oy);

        if (this.clampTextOYMode) {
            if (this.visibleLinesCount > this.linesCount) {
                oy = 0;
            } else if (textOYExceedTop) {
                oy = topTextOY
            } else if (textOYExeceedBottom) {
                oy = bottomTextOY;
            }
        }

        if (this._textOY !== oy) {
            this._textOY = oy;
            this.updateTextObject();
        }

        if (textOYExceedTop) {
            if (!this.execeedTopState) {
                this.emit('execeedtop', this, oy, topTextOY);
            }
        }
        this.execeedTopState = textOYExceedTop;

        if (textOYExeceedBottom) {
            if (!this.execeedBottomState) {
                this.emit('execeedbottom', this, oy, bottomTextOY);
            }
        }
        this.execeedBottomState = textOYExeceedBottom;
    }

    setTextOY(oy) {
        this.textOY = oy;
        return this;
    }

    set t(value) {
        this.textOY = -this.textVisibleHeight * value;
    }

    get t() {
        var textVisibleHeight = this.textVisibleHeight;
        if (textVisibleHeight === 0) {
            return 0;
        }
        return (this.textOY / -textVisibleHeight);
    }

    setTextOYByPercentage(percentage) {
        this.t = percentage;
        return this;
    }
}

var createDefaultTextObject = function (scene) {
    return scene.add.text(0, 0, '');
};

Object.assign(
    TextBlock_TextBlock.prototype,
    textblock_Methods
);

/* harmony default export */ var textblock_TextBlock = (TextBlock_TextBlock);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/textarea/InjectProperties.js
var InjectProperties = function(textBlock) {
    Object.defineProperty(textBlock, 'childOY', {
        configurable: true,
        get: function () {
            return textBlock.textOY;
        },
        set: function (value) {
            textBlock.textOY = value;
        }
    });
    Object.defineProperty(textBlock, 'topChildOY', {
        get: function () {
            return textBlock.topTextOY;
        }
    });
    Object.defineProperty(textBlock, 'bottomChildOY', {
        get: function () {
            return textBlock.bottomTextOY;
        }
    });
};
/* harmony default export */ var textarea_InjectProperties = (InjectProperties);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/textarea/SetText.js
var SetText_SetText = function (text) {
    var textBlock = this.childrenMap.child;
    textBlock.setText(text);

    this.resizeController();
    return this;
}
/* harmony default export */ var textarea_SetText = (SetText_SetText);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/textarea/AppendText.js
var AppendText = function (text) {
    this.setText(this.text + text);
    return this;
}
/* harmony default export */ var textarea_AppendText = (AppendText);
// CONCATENATED MODULE: ./lib/rexui/lib/ui/textarea/TextArea.js






const TextArea_GetValue = Phaser.Utils.Objects.GetValue;

class TextArea_TextArea extends scrollable_Scrollable {
    constructor(scene, config) {
        if (config === undefined) {
            config = {};
        }

        // Create text-block
        var textObject = TextArea_GetValue(config, 'text', undefined);
        var textWidth = TextArea_GetValue(config, 'textWidth', undefined);
        var textHeight = TextArea_GetValue(config, 'textHeight', undefined);
        var textMask = TextArea_GetValue(config, 'textMask', true);
        var content = TextArea_GetValue(config, 'content', '');
        var textBlock = new textblock_TextBlock(scene, {
            width: textWidth,
            height: textHeight,
            text: textObject,
            textMask: textMask,
            content: content,
            clamplTextOY: TextArea_GetValue(config, 'clamplChildOY', false),
        });
        var proportion = (textWidth === undefined) ? 1 : 0;
        var expand = (textHeight === undefined);
        // Inject properties for scrollable interface
        textarea_InjectProperties(textBlock);

        // Fill config of scrollable
        config.scrollMode = 0; // Vertical
        config.type = 'rexTextArea';
        config.child = {
            gameObject: textBlock,
            proportion: proportion,
            expand: expand,
        };
        var spaceConfig = TextArea_GetValue(config, 'space', undefined);
        if (spaceConfig) {
            spaceConfig.child = spaceConfig.text;
        }
        super(scene, config);

        this.addChildrenMap('text', textObject);
    }

    get text() {
        return this.childrenMap.child.text;
    }

    get linesCount() {
        return this.childrenMap.child.linesCount;
    }
}

var TextArea_methods = {
    setText: textarea_SetText,
    appendText: textarea_AppendText,
}
Object.assign(
    TextArea_TextArea.prototype,
    TextArea_methods
);

/* harmony default export */ var textarea_TextArea = (TextArea_TextArea);
// EXTERNAL MODULE: ./lib/rexui/lib/plugins/gameobjects/inputtext/InputText.js + 1 modules
var InputText = __webpack_require__(28);

// EXTERNAL MODULE: ./src/ui/components/ninepatch.button.ts
var ninepatch_button = __webpack_require__(60);

// EXTERNAL MODULE: ./src/utils/resUtil.ts + 1 modules
var resUtil = __webpack_require__(8);

// CONCATENATED MODULE: ./src/ui/components/check.button.ts
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var CheckButton = /** @class */ (function (_super) {
    __extends(CheckButton, _super);
    function CheckButton(scene, x, y, key, normalFrames, selectFrame) {
        var _this = _super.call(this, scene, x, y, key, normalFrames) || this;
        _this.mSelected = false;
        _this.mNormalFrame = normalFrames;
        _this.mSelectFrame = selectFrame;
        _this.setInteractive(new Phaser.Geom.Rectangle(0, 0, _this.width, _this.height), Phaser.Geom.Rectangle.Contains);
        _this.on("pointerup", _this.onSelected, _this);
        return _this;
    }
    CheckButton.prototype.onSelected = function () {
        this.selected = !this.mSelected;
        this.emit("selected", this.mSelected);
    };
    Object.defineProperty(CheckButton.prototype, "selected", {
        get: function () {
            return this.mSelected;
        },
        set: function (val) {
            if (this.mSelected !== val) {
                this.mSelected = val;
                var frame = val ? this.mSelectFrame : this.mNormalFrame;
                this.setFrame(frame);
            }
        },
        enumerable: false,
        configurable: true
    });
    return CheckButton;
}(Phaser.GameObjects.Image));


// EXTERNAL MODULE: ./lib/rexui/lib/plugins/gameobjects/text/textbase/render/WebGLRenderer.js
var render_WebGLRenderer = __webpack_require__(186);
var render_WebGLRenderer_default = /*#__PURE__*/__webpack_require__.n(render_WebGLRenderer);

// EXTERNAL MODULE: ./lib/rexui/lib/plugins/gameobjects/text/textbase/render/CanvasRenderer.js
var render_CanvasRenderer = __webpack_require__(187);
var render_CanvasRenderer_default = /*#__PURE__*/__webpack_require__.n(render_CanvasRenderer);

// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/text/textbase/render/Render.js




var Render_renderWebGL = object_NOOP;
var Render_renderCanvas = object_NOOP;

if (true) {
    Render_renderWebGL = render_WebGLRenderer_default.a;
}

if (true) {
    Render_renderCanvas = render_CanvasRenderer_default.a;
}

/* harmony default export */ var render_Render = ({
    renderWebGL: Render_renderWebGL,
    renderCanvas: Render_renderCanvas

});
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/text/textbase/textstyle/MeasureText.js
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */

const CanvasPool = Phaser.Display.Canvas.CanvasPool;

/**
 * Calculates the ascent, descent and fontSize of a given font style.
 *
 * @function Phaser.GameObjects.Text.MeasureText
 * @since 3.0.0
 *
 * @param {Phaser.GameObjects.Text.TextStyle} textStyle - The TextStyle object to measure.
 *
 * @return {object} An object containing the ascent, descent and fontSize of the TextStyle.
 */
var MeasureText = function (textStyle) {
    // @property {HTMLCanvasElement} canvas - The canvas element that the text is rendered.
    var canvas = CanvasPool.create(this);

    // @property {HTMLCanvasElement} context - The context of the canvas element that the text is rendered to.
    var context = canvas.getContext('2d');

    textStyle.syncFont(canvas, context);

    var width = Math.ceil(context.measureText(textStyle.testString).width * textStyle.baselineX);
    var baseline = width;
    var height = 2 * baseline;

    baseline = baseline * textStyle.baselineY | 0;

    canvas.width = width;
    canvas.height = height;

    context.fillStyle = '#f00';
    context.fillRect(0, 0, width, height);

    context.font = textStyle._font;

    context.textBaseline = 'alphabetic';
    context.fillStyle = '#000';
    context.fillText(textStyle.testString, 0, baseline);

    var output = {
        ascent: 0,
        descent: 0,
        fontSize: 0
    };

    if (!context.getImageData(0, 0, width, height)) {
        output.ascent = baseline;
        output.descent = baseline + 6;
        output.fontSize = output.ascent + output.descent;

        CanvasPool.remove(canvas);

        return output;
    }

    var imagedata = context.getImageData(0, 0, width, height).data;
    var pixels = imagedata.length;
    var line = width * 4;
    var i;
    var j;
    var idx = 0;
    var stop = false;

    // ascent. scan from top to bottom until we find a non red pixel
    for (i = 0; i < baseline; i++) {
        for (j = 0; j < line; j += 4) {
            if (imagedata[idx + j] !== 255) {
                stop = true;
                break;
            }
        }

        if (!stop) {
            idx += line;
        } else {
            break;
        }
    }

    output.ascent = baseline - i;

    idx = pixels - line;
    stop = false;

    // descent. scan from bottom to top until we find a non red pixel
    for (i = height; i > baseline; i--) {
        for (j = 0; j < line; j += 4) {
            if (imagedata[idx + j] !== 255) {
                stop = true;
                break;
            }
        }

        if (!stop) {
            idx -= line;
        } else {
            break;
        }
    }

    output.descent = (i - baseline);
    output.fontSize = output.ascent + output.descent;

    CanvasPool.remove(canvas);

    return output;
};

/* harmony default export */ var textstyle_MeasureText = (MeasureText);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/text/textbase/const.js
var CONST = {
    // new line mode
    NO_NEWLINE: 0,
    RAW_NEWLINE: 1,
    WRAPPED_NEWLINE: 2,

    // wrap mode
    NO_WRAP: 0,
    WORD_WRAP: 1,
    CHAR_WRAP: 2,

    // split lines
    SPLITREGEXP: /(?:\r\n|\r|\n)/
};

/* harmony default export */ var textbase_const = (CONST);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/text/textbase/textstyle/TextStyle.js
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */




const TextStyle_GetAdvancedValue = Phaser.Utils.Objects.GetAdvancedValue;
const TextStyle_GetValue = Phaser.Utils.Objects.GetValue;

//  Key: [ Object Key, Default Value ]

/**
 * A custom function that will be responsible for wrapping the text.
 * @callback TextStyleWordWrapCallback
 *
 * @param {string} text - The string to wrap.
 * @param {Phaser.GameObjects.Text} textObject - The Text instance.
 *
 * @return {(string|string[])} Should return the wrapped lines either as an array of lines or as a string with
 * newline characters in place to indicate where breaks should happen.
 */

var propertyMap = {
    // background
    backgroundColor: ['backgroundColor', null],

    // font
    fontFamily: ['fontFamily', 'Courier'],
    fontSize: ['fontSize', '16px'],
    fontStyle: ['fontStyle', ''],
    color: ['color', '#fff'],
    stroke: ['stroke', '#fff'],
    strokeThickness: ['strokeThickness', 0],
    shadowOffsetX: ['shadow.offsetX', 0],
    shadowOffsetY: ['shadow.offsetY', 0],
    shadowColor: ['shadow.color', '#000'],
    shadowBlur: ['shadow.blur', 0],
    shadowStroke: ['shadow.stroke', false],
    shadowFill: ['shadow.fill', false],

    // underline
    underlineColor: ['underline.color', '#000'],
    underlineThickness: ['underline.thickness', 0],
    underlineOffset: ['underline.offset', 0],

    // align
    halign: ['halign', 'left'],
    valign: ['valign', 'top'],

    // size
    maxLines: ['maxLines', 0],
    fixedWidth: ['fixedWidth', 0],
    fixedHeight: ['fixedHeight', 0],
    resolution: ['resolution', 0],
    lineSpacing: ['lineSpacing', 0],

    rtl: ['rtl', false],
    testString: ['testString', '|MÃ‰qgy'],
    baselineX: ['baselineX', 1.2],
    baselineY: ['baselineY', 1.4],

    // wrap
    wrapMode: ['wrap.mode', 1],
    wrapWidth: ['wrap.width', 0]
    //wrapCallback: ['wrap.callback', null],
    //wrapCallbackScope: ['wrap.callbackScope', null]
};

class TextStyle_TextStyle {
    constructor(text, style) {
        this.parent = text;

        this.backgroundColor;

        this.fontFamily;
        this.fontSize;
        this.fontStyle;
        this.color;
        this.stroke;
        this.strokeThickness;
        this.shadowOffsetX;
        this.shadowOffsetY;
        this.shadowColor;
        this.shadowBlur;
        this.shadowStroke;
        this.shadowFill;

        this.underlineColor;
        this.underlineThickness;
        this.underlineOffset;

        this.halign;
        this.valign;

        this.maxLines;
        this.fixedWidth;
        this.fixedHeight;
        this.resolution;
        this.lineSpacing;

        this.rtl;
        this.testString;


        this.baselineX;
        this.baselineY;

        this._font;

        //  Set to defaults + user style
        this.setStyle(style, false);

        var metrics = TextStyle_GetValue(style, 'metrics', false);

        //  Provide optional TextMetrics in the style object to avoid the canvas look-up / scanning
        //  Doing this is reset if you then change the font of this TextStyle after creation
        if (metrics) {
            this.metrics = {
                ascent: TextStyle_GetValue(metrics, 'ascent', 0),
                descent: TextStyle_GetValue(metrics, 'descent', 0),
                fontSize: TextStyle_GetValue(metrics, 'fontSize', 0)
            };
        } else {
            this.metrics = textstyle_MeasureText(this);
        }
    }

    setStyle(style, updateText) {
        if (updateText === undefined) {
            updateText = true;
        }

        if (style && style.hasOwnProperty('wrap')) {
            var wrap = style.wrap;
            if (wrap.hasOwnProperty('mode')) {
                var mode = wrap.mode;
                if (typeof mode === 'string') {
                    wrap.mode = WRAPMODE[mode];
                }
            } else {
                if (wrap.hasOwnProperty('width')) {
                    wrap.mode = 1;
                }
            }
        }

        //  Avoid type mutation
        if (style && style.hasOwnProperty('fontSize') && typeof style.fontSize === 'number') {
            style.fontSize = style.fontSize.toString() + 'px';
        }

        for (var key in propertyMap) {
            if (key === 'wrapCallback' || key === 'wrapCallbackScope') {
                // Callback & scope should be set without processing the values
                this[key] = TextStyle_GetValue(style, propertyMap[key][0], propertyMap[key][1]);
            } else {
                this[key] = TextStyle_GetAdvancedValue(style, propertyMap[key][0], propertyMap[key][1]);
            }
        }

        //  Allow for 'font' override
        var font = TextStyle_GetValue(style, 'font', null);

        if (font === null) {
            this._font = this.fontStyle + ' ' + this.fontSize + ' ' + this.fontFamily;
        } else {
            this._font = font;
        }

        //  Allow for 'fill' to be used in place of 'color'
        var fill = TextStyle_GetValue(style, 'fill', null);

        if (fill !== null) {
            this.color = fill;
        }

        if (updateText) {
            return this.update(true);
        } else {
            return this.parent;
        }
    }

    syncFont(canvas, context) {
        context.font = this._font;
    }

    syncStyle(canvas, context) {
        context.textBaseline = 'alphabetic';

        context.fillStyle = this.color;
        context.strokeStyle = this.stroke;

        context.lineWidth = this.strokeThickness;
        context.lineCap = 'round';
        context.lineJoin = 'round';
    }

    syncShadow(context, enabled) {
        if (enabled) {
            context.shadowOffsetX = this.shadowOffsetX;
            context.shadowOffsetY = this.shadowOffsetY;
            context.shadowColor = this.shadowColor;
            context.shadowBlur = this.shadowBlur;
        } else {
            context.shadowOffsetX = 0;
            context.shadowOffsetY = 0;
            context.shadowColor = 0;
            context.shadowBlur = 0;
        }
    }

    update(recalculateMetrics) {
        if (recalculateMetrics) {
            this._font = this.fontStyle + ' ' + this.fontSize + ' ' + this.fontFamily;

            this.metrics = textstyle_MeasureText(this);
        }

        return this.parent.updateText(recalculateMetrics);
    }

    buildFont() {
        var newFont = this.fontStyle + ' ' + this.fontSize + ' ' + this.fontFamily;
        if (newFont !== this._font) {
            this._font = newFont;
            //this.metrics = MeasureText(this);
        }
        return this;
    }

    setFont(font) {
        if (typeof font === 'string') {
            this.fontFamily = font;
            this.fontSize = '';
            this.fontStyle = '';
        } else {
            this.fontFamily = TextStyle_GetValue(font, 'fontFamily', 'Courier');
            this.fontSize = TextStyle_GetValue(font, 'fontSize', '16px');
            this.fontStyle = TextStyle_GetValue(font, 'fontStyle', '');
        }

        return this.update(true);
    }

    setFontFamily(family) {
        this.fontFamily = family;

        return this.update(true);
    }

    setFontStyle(style) {
        this.fontStyle = style;

        return this.update(true);
    }

    setFontSize(size) {
        if (typeof size === 'number') {
            size = size.toString() + 'px';
        }

        this.fontSize = size;

        return this.update(true);
    }

    setTestString(string) {
        this.testString = string;

        return this.update(true);
    }

    setFixedSize(width, height) {
        this.fixedWidth = width;
        this.fixedHeight = height;

        if (width) {
            this.parent.width = width;
        }

        if (height) {
            this.parent.height = height;
        }

        return this.update(false);
    }

    setResolution(value) {
        this.resolution = value;

        return this.update(false);
    }

    setLineSpacing(value) {
        this.lineSpacing = value;

        return this.update(false);
    }

    setBackgroundColor(color) {
        this.backgroundColor = color;

        return this.update(false);
    }

    setFill(color) {
        this.color = color;

        return this.update(false);
    }

    setColor(color) {
        this.color = color;

        return this.update(false);
    }

    setStroke(color, thickness) {
        if (color === undefined) {
            //  Reset the stroke to zero (disabling it)
            this.strokeThickness = 0;
        } else {
            if (thickness === undefined) {
                thickness = this.strokeThickness;
            }

            this.stroke = color;
            this.strokeThickness = thickness;
        }

        return this.update(true);
    }

    setShadow(x, y, color, blur, shadowStroke, shadowFill) {
        if (x === undefined) {
            x = 0;
        }
        if (y === undefined) {
            y = 0;
        }
        if (color === undefined) {
            color = '#000';
        }
        if (blur === undefined) {
            blur = 0;
        }
        if (shadowStroke === undefined) {
            shadowStroke = false;
        }
        if (shadowFill === undefined) {
            shadowFill = true;
        }

        this.shadowOffsetX = x;
        this.shadowOffsetY = y;
        this.shadowColor = color;
        this.shadowBlur = blur;
        this.shadowStroke = shadowStroke;
        this.shadowFill = shadowFill;

        return this.update(false);
    }

    setShadowOffset(x, y) {
        if (x === undefined) {
            x = 0;
        }
        if (y === undefined) {
            y = x;
        }

        this.shadowOffsetX = x;
        this.shadowOffsetY = y;

        return this.update(false);
    }

    setShadowColor(color) {
        if (color === undefined) {
            color = '#000';
        }

        this.shadowColor = color;

        return this.update(false);
    }

    setShadowBlur(blur) {
        if (blur === undefined) {
            blur = 0;
        }

        this.shadowBlur = blur;

        return this.update(false);
    }

    setShadowStroke(enabled) {
        this.shadowStroke = enabled;

        return this.update(false);
    }

    setShadowFill(enabled) {
        this.shadowFill = enabled;

        return this.update(false);
    }

    setUnderline(color, thickness, offset) {
        if (color === undefined) {
            color = '#000';
        }
        if (thickness === undefined) {
            thickness = 0;
        }
        if (offset === undefined) {
            offset = 0;
        }

        this.underlineColor = color;
        this.underlineThickness = thickness;
        this.underlineOffset = offset;

        return this.update(false);
    }

    setUnderlineColor(color) {
        if (color === undefined) {
            color = '#000';
        }

        this.underlineColor = color;
        return this.update(false);
    }

    setUnderlineThickness(thickness) {
        if (thickness === undefined) {
            thickness = 0;
        }

        this.underlineThickness = thickness;
        return this.update(false);
    }

    setUnderlineOffset(offset) {
        if (offset === undefined) {
            offset = 0;
        }

        this.underlineOffset = offset;
        return this.update(false);
    }

    setWrapMode(mode) {
        if (typeof mode === 'string') {
            mode = WRAPMODE[mode.toLowerCase()] || 0;
        }
        this.wrapMode = mode;
        return this.update(true);
    }

    setWrapWidth(width) {
        this.wrapWidth = width;
        return this.update(false);
    }

    setAlign(halign, valign) {
        if (halign === undefined) {
            halign = 'left';
        }
        if (valign === undefined) {
            valign = 'top';
        }
        this.halign = halign;
        this.valign = valign;

        return this.update(false);
    }

    setHAlign(halign) {
        if (halign === undefined) {
            halign = 'left';
        }
        this.halign = halign;

        return this.update(false);
    }

    setVAlign(valign) {
        if (valign === undefined) {
            valign = 'top';
        }
        this.valign = valign;

        return this.update(false);
    }

    setMaxLines(max) {
        if (max === undefined) {
            max = 0;
        }

        this.maxLines = max;

        return this.update(false);
    }

    getTextMetrics() {
        var metrics = this.metrics;

        return {
            ascent: metrics.ascent,
            descent: metrics.descent,
            fontSize: metrics.fontSize
        };
    }

    get lineHeight() {
        return this.metrics.fontSize + this.strokeThickness + this.lineSpacing;
    }

    toJSON() {
        var output = {};

        for (var key in propertyMap) {
            output[key] = this[key];
        }

        output.metrics = this.getTextMetrics();

        return output;
    }

    destroy() {
        this.parent = undefined;
    }

}

const HALIGNMODE = {
    left: textbase_const.hleft,
    center: textbase_const.hcenter,
    right: textbase_const.hright,
};
const VALIGNMODE = {
    top: textbase_const.vtop,
    center: textbase_const.vcenter,
    bottom: textbase_const.vbottom,
};
const WRAPMODE = {
    none: textbase_const.NO_WRAP,
    word: textbase_const.WORD_WRAP,
    char: textbase_const.CHAR_WRAP,
    character: textbase_const.CHAR_WRAP
};

/* harmony default export */ var textstyle_TextStyle = (TextStyle_TextStyle);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/text/textbase/canvastext/DrawMethods.js
/* harmony default export */ var DrawMethods = ({
    draw(startX, startY, boxWidth, boxHeight) {
        var penManager = this.penManager;
        this.hitAreaManager.clear();

        var context = this.context;
        context.save();

        // this.clear();
        this.drawBackground(this.defatultStyle.backgroundColor);

        // draw lines
        var defatultStyle = this.defatultStyle;
        startX += this.startXOffset;
        startY += this.startYOffset;
        var halign = defatultStyle.halign,
            valign = defatultStyle.valign;

        var lineWidth, lineHeight = defatultStyle.lineHeight;
        var lines = penManager.lines;
        var totalLinesNum = lines.length,
            maxLines = defatultStyle.maxLines;
        var drawLinesNum, drawLineStartIdx, drawLineEndIdx;
        if ((maxLines > 0) && (totalLinesNum > maxLines)) {
            drawLinesNum = maxLines;
            if (valign === 'center') { // center
                drawLineStartIdx = Math.floor((totalLinesNum - drawLinesNum) / 2);
            } else if (valign === 'bottom') { // bottom
                drawLineStartIdx = totalLinesNum - drawLinesNum;
            } else {
                drawLineStartIdx = 0;
            }
        } else {
            drawLinesNum = totalLinesNum;
            drawLineStartIdx = 0;
        }
        drawLineEndIdx = drawLineStartIdx + drawLinesNum;

        var offsetX, offsetY;
        if (valign === 'center') { // center
            offsetY = Math.max((boxHeight - (drawLinesNum * lineHeight)) / 2, 0);
        } else if (valign === 'bottom') { // bottom
            offsetY = Math.max(boxHeight - (drawLinesNum * lineHeight) - 2, 0);
        } else {
            offsetY = 0;
        }
        offsetY += startY;
        for (var lineIdx = drawLineStartIdx; lineIdx < drawLineEndIdx; lineIdx++) {
            lineWidth = penManager.getLineWidth(lineIdx);
            if (lineWidth === 0) {
                continue;
            }

            if (halign === 'center') { // center
                offsetX = (boxWidth - lineWidth) / 2;
            } else if (halign === 'right') { // right
                offsetX = boxWidth - lineWidth;
            } else {
                offsetX = 0;
            }
            offsetX += startX;

            var pens = lines[lineIdx];
            for (var penIdx = 0, pensLen = pens.length; penIdx < pensLen; penIdx++) {
                this.drawPen(pens[penIdx], offsetX, offsetY);
            }
        }

        context.restore();
    },

    drawPen(pen, offsetX, offsetY) {
        offsetX += pen.x;
        offsetY += pen.y;

        var canvas = this.canvas;
        var context = this.context;
        context.save();

        var curStyle = this.parser.propToContextStyle(
            this.defatultStyle,
            pen.prop
        );
        curStyle.buildFont();
        curStyle.syncFont(canvas, context);
        curStyle.syncStyle(canvas, context);

        // Underline
        if ((curStyle.underlineThickness > 0) && (pen.width > 0)) {
            this.drawUnderline(offsetX, offsetY, pen.width, curStyle);
        }

        // Text
        if (pen.isTextPen) {
            this.drawText(offsetX, offsetY, pen.text, curStyle);
        }

        // Image
        if (pen.isImagePen) {
            this.drawImage(offsetX, offsetY, pen.prop.img, curStyle);
        }

        context.restore();

        if (pen.hasAreaMarker && (pen.width > 0)) {
            this.hitAreaManager.add(
                pen.prop.area,
                offsetX, (offsetY - this.startYOffset),
                pen.width, this.defatultStyle.lineHeight);
        }
    },

    clear() {
        var canvas = this.canvas;
        this.context.clearRect(0, 0, canvas.width, canvas.height);
    },

    drawBackground(color) {
        if (color === null) {
            return;
        }
        this.context.fillStyle = color;
        this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
    },

    drawUnderline(x, y, width, style) {
        y += style.underlineOffset - (style.underlineThickness / 2);
        if (this.autoRound) {
            x = Math.round(x);
            y = Math.round(y);
        }

        var context = this.context;
        var savedLineCap = context.lineCap;
        context.lineCap = 'butt';
        context.beginPath();
        context.strokeStyle = style.underlineColor;
        context.lineWidth = style.underlineThickness;
        context.moveTo(x, y);
        context.lineTo((x + width), y);
        context.stroke();
        context.lineCap = savedLineCap;
    },

    drawText(x, y, text, style) {
        if (this.autoRound) {
            x = Math.round(x);
            y = Math.round(y);
        }

        var context = this.context;
        if (style.strokeThickness) {
            style.syncShadow(context, style.shadowStroke);
            context.strokeText(text, x, y);
        }

        if (style.color && (style.color !== 'none')) {
            style.syncShadow(context, style.shadowFill);
            context.fillText(text, x, y);
        }
    },

    drawImage(x, y, imgKey, style) {
        var imageManager = this.parent.imageManager;
        var imgData = imageManager.get(imgKey);
        var frame = imageManager.getFrame(imgKey);

        x += imgData.left;
        y += - this.startYOffset + imgData.y;
        if (this.autoRound) {
            x = Math.round(x);
            y = Math.round(y);
        }

        var context = this.context;
        context.drawImage(
            frame.source.image,
            frame.cutX, frame.cutY, frame.cutWidth, frame.cutHeight,
            x, y, imgData.width, imgData.height
        );
    }

});
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/struct/Stack.js
class Stack {
    constructor() {
        this.items = [];
    }

    destroy() {
        this.clear();
        this.items = undefined;
    }

    pop() {
        return (this.items.length > 0) ? this.items.pop() : null;
    }

    push(l) {
        this.items.push(l);
        return this;
    }

    pushMultiple(arr) {
        this.items.push.apply(this.items, arr);
        arr.length = 0;
        return this;
    }

    clear() {
        this.items.length = 0;
        return this;
    }
}

/* harmony default export */ var struct_Stack = (Stack);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/pool.js

/* harmony default export */ var pool = (struct_Stack);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/text/textbase/penmanger/Pen.js


const Pen_GetValue = Phaser.Utils.Objects.GetValue;
const NO_NEWLINE = textbase_const.NO_NEWLINE;
const RAW_NEWLINE = textbase_const.RAW_NEWLINE;

class Pen {
    constructor(config) {
        this.prop = {};
        this.resetFromJSON(config);
    }

    resetFromJSON(o) { // (txt, x, y, width, prop, newLineMode, startIndex)
        this.text = Pen_GetValue(o, 'text', '');
        this.x = Pen_GetValue(o, 'x', 0);
        this.y = Pen_GetValue(o, 'y', 0);
        this.width = Pen_GetValue(o, 'width', 0);

        var prop = Pen_GetValue(o, 'prop', null);
        if (prop === null) {
            prop = {};
        }
        this.prop = prop;
        this.newLineMode = Pen_GetValue(o, 'newLineMode', 0);
        this.startIndex = Pen_GetValue(o, 'startIndex', 0);
    }

    get plainText() {
        var txt = this.text
        if (this.newLineMode === RAW_NEWLINE) {
            txt += "\n";
        }

        return txt;
    }

    get wrapText() {
        var txt = this.text;
        if (this.newLineMode !== NO_NEWLINE) {
            txt += "\n";
        }

        return txt;
    }

    get rawTextLength() {
        var len = this.text.length;
        if (this.newLineMode === RAW_NEWLINE) {
            len += 1;
        }
        return len;
    }

    get endIndex() {
        return this.startIndex + this.rawTextLength;
    }

    get lastX() {
        return this.x + this.width;
    }

    get isTextPen() {
        return (this.text !== '');
    }

    get isImagePen() {
        return !!this.prop.img;
    }

    get hasAreaMarker() {
        return !!this.prop.area;
    }
};

/* harmony default export */ var penmanger_Pen = (Pen);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/object/Clear.js
var Clear = function (obj) {
    if (Array.isArray(obj)) {
        obj.length = 0;
    } else {
        for (var key in obj) {
            delete obj[key];
        }
    }
}
/* harmony default export */ var object_Clear = (Clear);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/utils/object/Clone.js


/**
 * Shallow Object Clone. Will not out nested objects.
 * @param {object} obj JSON object
 * @param {object} ret JSON object to return, set null to return a new object
 * @returns {object} this object
 */
var Clone = function (obj, out) {
    var objIsArray = Array.isArray(obj);

    if (out === undefined) {
        out = (objIsArray) ? [] : {};
    } else {
        object_Clear(out);
    }

    if (objIsArray) {
        out.length = obj.length;
        for (var i = 0, cnt = obj.length; i < cnt; i++) {
            out[i] = obj[i];
        }
    } else {
        for (var key in obj) {
            out[key] = obj[key];
        }
    }

    return out;
};

/* harmony default export */ var object_Clone = (Clone);

// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/text/textbase/penmanger/PenManager.js






const GetFastValue = Phaser.Utils.Objects.GetFastValue;
const PenManager_NO_NEWLINE = textbase_const.NO_NEWLINE;
const WRAPPED_NEWLINE = textbase_const.WRAPPED_NEWLINE;

var PensPool = new pool(); // default pens pool
var LinesPool = new pool(); // default lines pool
class PenManager_PenManager {
    constructor(config) {
        this.pens = []; // all pens
        this.lines = []; // pens in lines [ [],[],[],.. ]
        this.maxLinesWidth = undefined;

        this.PensPool = GetFastValue(config, 'pensPool', PensPool);
        this.LinesPool = GetFastValue(config, 'linesPool', LinesPool);
        this.tagToText = GetFastValue(config, 'tagToText', object_NOOP);
        this.tagToTextScope = GetFastValue(config, 'tagToTextScope', undefined);
    }

    destroy() {
        this.freePens();
        this.tagToText = undefined;
        this.tagToTextScope = undefined;
    }

    freePens() {
        for (var i = 0, len = this.lines.length; i < len; i++)
            this.lines[i].length = 0;

        this.PensPool.pushMultiple(this.pens);
        this.LinesPool.pushMultiple(this.lines);
        this.maxLinesWidth = undefined;
    }

    addTextPen(text, x, y, width, prop, newLineMode) {
        var pen = this.PensPool.pop();
        if (pen == null) {
            pen = new penmanger_Pen();
        }
        PEN_CONFIG.text = text;
        PEN_CONFIG.x = x;
        PEN_CONFIG.y = y;
        PEN_CONFIG.width = width;
        PEN_CONFIG.prop = prop;
        PEN_CONFIG.newLineMode = newLineMode;
        pen.resetFromJSON(PEN_CONFIG);
        this.addPen(pen);
        return this;
    }

    addImagePen(x, y, width, prop) {
        this.addTextPen('', x, y, width, prop, PenManager_NO_NEWLINE);
        return this;
    }

    addNewLinePen() {
        var previousPen = this.lastPen;
        var x = (previousPen) ? previousPen.lastX : 0;
        var y = (previousPen) ? previousPen.y : 0;
        var prop = (previousPen) ? object_Clone(previousPen.prop) : null;
        this.addTextPen('', x, y, 0, prop, WRAPPED_NEWLINE);
        return this;
    }

    addPen(pen) {
        var previousPen = this.lastPen;
        if (previousPen == null) {
            pen.startIndex = 0;
        } else {
            pen.startIndex = previousPen.endIndex;
        }
        this.pens.push(pen);

        // maintan lines
        var line = this.lastLine;
        if (line == null) {
            line = this.LinesPool.pop() || [];
            this.lines.push(line);
        }
        line.push(pen);

        // new line, add an empty line
        if (pen.newLineMode !== PenManager_NO_NEWLINE) {
            line = this.LinesPool.pop() || [];
            this.lines.push(line);
        }
        this.maxLinesWidth = undefined;
    }

    clone(targetPenManager) {
        if (targetPenManager == null)
            targetPenManager = new PenManager_PenManager();

        targetPenManager.freePens();

        for (var li = 0, llen = this.lines.length; li < llen; li++) {
            var pens = this.lines[li];
            for (var pi = 0, plen = pens.length; pi < plen; pi++) {
                var pen = pens[pi];
                targetPenManager.addPen(
                    pen.text,
                    pen.x,
                    pen.y,
                    pen.width,
                    object_Clone(pen.prop),
                    pen.newLineMode
                );
            }
        }

        return targetPenManager;
    }

    get lastPen() {
        return this.pens[this.pens.length - 1];
    }

    get lastLine() {
        return this.lines[this.lines.length - 1];
    }

    getLineStartIndex(i) {
        if (i >= this.lines.length) {
            return this.getLineEndIndex(i);
        } else {
            var line = this.lines[i];
            return (line && line[0]) ? line[0].startIndex : 0;
        }
    }

    getLineEndIndex(i) {
        if (i >= this.lines.length) {
            i = this.lines.length - 1;
        }
        var li, hasLastPen = false,
            line;
        for (li = i; li >= 0; li--) {
            line = this.lines[li];
            hasLastPen = (line != null) && (line.length > 0);
            if (hasLastPen) {
                break;
            }
        }
        if (!hasLastPen) {
            return 0;
        }

        var lastPen = line[line.length - 1];
        return lastPen.endIndex;
    }

    getLineWidth(i) {
        var line = this.lines[i];
        if (!line) {
            return 0;
        }

        var lastPen = line[line.length - 1];
        if (lastPen == null) {
            return 0;
        }

        var lineWidth = lastPen.lastX; // start from 0
        return lineWidth;
    }

    getMaxLineWidth() {
        if (this.maxLinesWidth !== undefined) {
            return this.maxLinesWidth;
        }
        var w, maxW = 0;
        for (var i = 0, len = this.lines.length; i < len; i++) {
            w = this.getLineWidth(i);
            if (w > maxW) {
                maxW = w;
            }
        }
        this.maxLinesWidth = maxW;
        return maxW;
    }

    getLineWidths() {
        var result = [];
        for (var i = 0, len = this.lines.length; i < len; i++) {
            result.push(this.getLineWidth(i));
        }
        return result;
    }

    get linesCount() {
        return this.lines.length;
    }

    get plainText() {
        var txt = "",
            pens = this.pens;
        for (var i = 0, len = pens.length; i < len; i++) {
            txt += pens[i].plainText;
        }

        return txt;
    }

    get rawTextLength() {
        var l = 0,
            pens = this.pens;
        for (var i = 0, len = this.pens.length; i < len; i++) {
            l += pens[i].rawTextLength;
        }

        return l;
    }

    getSliceTagText(start, end, wrap) {
        if (start === undefined) {
            start = 0;
        }
        if (end === undefined) {
            var lastPen = this.lastPen;
            if (lastPen == null) {
                return "";
            }

            end = lastPen.endIndex;
        }
        if (wrap === undefined) {
            wrap = false;
        }

        var txt = "",
            formatTxt,
            pen, penTxt, penStartIdx, penEndIdx, isInRange;
        var currentProp, previousProp;
        for (var i = 0, len = this.pens.length; i < len; i++) {
            pen = this.pens[i];
            penEndIdx = pen.endIndex;
            if (penEndIdx <= start) {
                continue;
            }
            pen = this.pens[i];
            penTxt = (!wrap) ? pen.plainText : pen.wrapText;
            currentProp = pen.prop;
            penStartIdx = pen.startIndex;

            isInRange = (penStartIdx >= start) && (penEndIdx <= end);
            if (!isInRange) {
                penTxt = penTxt.substring(start - penStartIdx, end - penStartIdx);
            }

            if (this.tagToTextScope) {
                txt += this.tagToText.call(this.tagToTextScope, penTxt, currentProp, previousProp);
            } else {
                txt += this.tagToText(penTxt, currentProp, previousProp);
            }

            previousProp = currentProp;
            if (penEndIdx >= end) {
                break;
            }
        }

        return txt;
    }
};

var PEN_CONFIG = {};

/* harmony default export */ var penmanger_PenManager = (PenManager_PenManager);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/text/textbase/hitareamanager/HitAreaManager.js


const HitAreaManager_Rectangle = Phaser.Geom.Rectangle;

var RectanglePool = new pool();
class HitAreaManager {
    constructor() {
        this.hitAreas = [];
    }

    destroy() {
        this.clear();
    }

    clear() {
        RectanglePool.pushMultiple(this.hitAreas);
        return this;
    }

    add(key, x, y, width, height) {
        var rectangle = RectanglePool.pop();
        if (rectangle === null) {
            rectangle = new HitAreaManager_Rectangle(x, y, width, height);
        } else {
            rectangle.setTo(x, y, width, height);
        }
        rectangle.key = key;
        this.hitAreas.push(rectangle);
        return this;
    }

    contains(x, y) {
        var hitAreas = this.hitAreas, hitArea;
        for (var i = 0, cnt = hitAreas.length; i < cnt; i++) {
            hitArea = hitAreas[i];
            if (hitArea.contains(x, y)) {
                return hitArea.key;
            }
        }
        return false;
    }

    drawBounds(graphics, color, parent) {
        if (color === undefined) {
            color = 0xffffff;
        }

        if (parent) {
            graphics
                .save()
                .scaleCanvas(parent.scaleX, parent.scaleY)
                .rotateCanvas(parent.rotation)
                .translateCanvas(parent.x, parent.y)
        }

        var hitAreas = this.hitAreas, hitArea;
        for (var i = 0, cnt = hitAreas.length; i < cnt; i++) {
            hitArea = hitAreas[i];
            graphics.lineStyle(1, color).strokeRect(hitArea.x, hitArea.y, hitArea.width, hitArea.height);
        }

        if (parent) {
            graphics
                .restore()
        }
        return this;
    }
}
/* harmony default export */ var hitareamanager_HitAreaManager = (HitAreaManager);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/text/textbase/canvastext/SetInteractive.js
var SetInteractive = function () {
    this.parent
        .on('pointerdown', function (pointer, localX, localY, event) {
            FireEvent.call(this, 'areadown', pointer, localX, localY);
        }, this)
        .on('pointerup', function (pointer, localX, localY, event) {
            FireEvent.call(this, 'areaup', pointer, localX, localY);
        }, this)
}

var FireEvent = function (eventName, pointer, localX, localY) {
    var key = this.hitAreaManager.contains(localX, localY);
    if (key === false) {
        return;
    }
    this.parent.emit(`${eventName}-${key}`, pointer, localX, localY)
    this.parent.emit(eventName, key, pointer, localX, localY)
}
/* harmony default export */ var canvastext_SetInteractive = (SetInteractive);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/text/textbase/canvastext/WrapText.js



const WrapText_NO_NEWLINE = textbase_const.NO_NEWLINE;
const WrapText_RAW_NEWLINE = textbase_const.RAW_NEWLINE;
const WrapText_WRAPPED_NEWLINE = textbase_const.WRAPPED_NEWLINE;
const NO_WRAP = textbase_const.NO_WRAP;
const WORD_WRAP = textbase_const.WORD_WRAP;
const CHAR_WRAP = textbase_const.CHAR_WRAP;
const splitRegExp = textbase_const.SPLITREGEXP;

var WRAP_RESULT = [];
var WrapText = function (text, getTextWidth, wrapMode, wrapWidth, offset) {
    if (wrapWidth <= 0) {
        wrapMode = NO_WRAP;
    }

    var retLines = WRAP_RESULT;
    WrapText_LinesPool.pushMultiple(retLines);

    if (!text || !text.length) {
        return retLines;
    }

    var lines = text.split(splitRegExp),
        line, remainWidth, isLaseLine, newLineMode;
    for (var i = 0, linesLen = lines.length; i < linesLen; i++) {
        line = lines[i];
        newLineMode = (i === (linesLen - 1)) ? WrapText_NO_NEWLINE : WrapText_RAW_NEWLINE;

        if (wrapMode === NO_WRAP) {
            var textWidth = getTextWidth(line);
            retLines.push(WrapText_LinesPool.newline(line, textWidth, newLineMode));
            continue;
        } else {
            if (i === 0) {
                remainWidth = wrapWidth - offset;
            } else {
                remainWidth = wrapWidth;
            }
        }

        // short string testing
        if (line.length <= 100) {
            var textWidth = getTextWidth(line);
            if (textWidth <= remainWidth) {
                retLines.push(WrapText_LinesPool.newline(line, textWidth, newLineMode));
                continue;
            }
        }

        // character mode
        var tokenArray;
        if (wrapMode === WORD_WRAP) {
            // word mode
            tokenArray = line.split(' ');
        } else {
            tokenArray = line;
        }
        var token;
        var curLineText = '',
            lineText = '',
            currLineWidth, lineWidth = 0;
        for (var j = 0, tokenLen = tokenArray.length; j < tokenLen; j++) {
            token = tokenArray[j];

            if (wrapMode === WORD_WRAP) {
                curLineText += token;

                if (j < (tokenLen - 1)) {
                    curLineText += ' ';
                }
            } else {
                curLineText += token;
            }

            currLineWidth = getTextWidth(curLineText);
            if (currLineWidth > remainWidth) {
                // new line
                if (j === 0) {
                    retLines.push(WrapText_LinesPool.newline('', 0, WrapText_WRAPPED_NEWLINE));
                } else {
                    retLines.push(WrapText_LinesPool.newline(lineText, lineWidth, WrapText_WRAPPED_NEWLINE));
                    curLineText = token;
                    if (wrapMode === WORD_WRAP) {
                        if (j < (tokenLen - 1)) {
                            curLineText += ' ';
                        }
                    }
                    currLineWidth = getTextWidth(curLineText);
                }

                remainWidth = wrapWidth;
            }

            lineText = curLineText;
            lineWidth = currLineWidth;
        } // for token in tokenArray

        // flush remain text
        retLines.push(WrapText_LinesPool.newline(lineText, lineWidth, newLineMode));

    } // for each line in lines

    return retLines;
};

var WrapText_LinesPool = new pool();
WrapText_LinesPool.newline = function (text, width, newLineMode) {
    var l = this.pop();
    if (l === null) {
        l = {};
    }
    l.text = text;
    l.width = width;
    l.newLineMode = newLineMode;
    return l;
};

/* harmony default export */ var canvastext_WrapText = (WrapText);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/text/textbase/canvastext/CanvasText.js








const CanvasText_GetValue = Phaser.Utils.Objects.GetValue;
const CanvasText_NO_WRAP = textbase_const.NO_WRAP;
const CanvasText_NO_NEWLINE = textbase_const.NO_NEWLINE;

class CanvasText_CanvasText {
    constructor(config) {
        this.parent = config.parent;
        this.context = CanvasText_GetValue(config, 'context', null);
        this.canvas = this.context.canvas;
        this.parser = CanvasText_GetValue(config, 'parser', null);
        this.defatultStyle = CanvasText_GetValue(config, 'style', null);
        this.autoRound = true;

        this.pensPool = CanvasText_GetValue(config, 'pensPool', null);
        this.penManager = this.newPenManager();
        this._tmpPenManager = null;

        this.hitAreaManager = new hitareamanager_HitAreaManager();

        var context = this.context;
        this.getTextWidth = function (text) {
            return context.measureText(text).width;
        }
    }

    destroy() {
        this.context = undefined;
        this.canvas = undefined;
        this.parser = undefined;
        this.defatultStyle = undefined;

        if (this.penManager) {
            this.penManager.destroy();
            this.penManager = undefined;
        }
        if (this._tmpPenManager) {
            this._tmpPenManager.destroy();
            this._tmpPenManager = undefined;
        }
        if (this.hitAreaManager) {
            this.hitAreaManager.destroy();
            this.hitAreaManager = undefined;
        }
    }

    updatePenManager(text, wrapMode, wrapWidth, lineHeight, penManager) {
        if (penManager === undefined) {
            penManager = this.penManager;
        }
        penManager.freePens();
        if (text === "") {
            return penManager;
        }

        var canvas = this.canvas;
        var context = this.context;

        var cursorX = 0,
            cursorY = 0;

        var plainText, curProp, curStyle;
        var match = this.parser.splitText(text),
            result, wrapLines;
        for (var i = 0, len = match.length; i < len; i++) {
            result = this.parser.tagTextToProp(match[i], curProp);
            plainText = result.plainText;
            curProp = result.prop;

            if (curProp.img) { // Image tag                
                var imgWidth = this.imageManager.getOuterWidth(curProp.img);
                if ((wrapWidth > 0) && (wrapMode !== CanvasText_NO_WRAP)) {  // Wrap mode
                    if (wrapWidth < (cursorX + imgWidth)) {
                        penManager.addNewLinePen();
                        cursorY += lineHeight;
                        cursorX = 0;
                    }
                }
                penManager.addImagePen(cursorX, cursorY, imgWidth, object_Clone(curProp));
                cursorX += imgWidth;

            } else if (plainText !== '') {
                // wrap text to lines
                // Save the current context.
                this.context.save();
                curStyle = this.parser.propToContextStyle(
                    this.defatultStyle,
                    curProp
                );
                curStyle.buildFont();
                curStyle.syncFont(canvas, context);
                curStyle.syncStyle(canvas, context);
                wrapLines = canvastext_WrapText(plainText, this.getTextWidth, wrapMode, wrapWidth, cursorX);

                // add pens
                var n;
                for (var j = 0, jLen = wrapLines.length; j < jLen; j++) {
                    n = wrapLines[j];
                    penManager.addTextPen(n.text, cursorX, cursorY, n.width, object_Clone(curProp), n.newLineMode);

                    if (n.newLineMode !== CanvasText_NO_NEWLINE) {
                        cursorX = 0;
                        cursorY += lineHeight;
                    } else {
                        cursorX += n.width;
                    }

                }
                this.context.restore();

            }

        }

        return penManager;
    }

    get startXOffset() {
        var defatultStyle = this.defatultStyle;
        return (defatultStyle.strokeThickness / 2);
    }

    get startYOffset() {
        var defatultStyle = this.defatultStyle;
        return (defatultStyle.strokeThickness / 2) + defatultStyle.metrics.ascent;
    }

    get lines() {
        return this.penManager.lines;
    }

    get desplayLinesCount() {
        var linesCount = this.penManager.linesCount,
            maxLines = this.defatultStyle.maxLines;
        if ((maxLines > 0) && (linesCount > maxLines)) {
            linesCount = maxLines;
        }
        return linesCount;
    }

    get linesWidth() {
        return this.penManager.getMaxLineWidth();
    }

    get linesHeight() {
        var linesCount = this.desplayLinesCount;
        var linesHeight = (this.defatultStyle.lineHeight * linesCount);
        if (linesCount > 0) {
            linesHeight -= this.defatultStyle.lineSpacing;
        }
        return linesHeight;
    }

    get imageManager() {
        return this.parent.imageManager;
    }

    newPenManager() {
        return new penmanger_PenManager({
            pensPool: this.pensPool,
            tagToText: this.parser.propToTagText,
            tagToTextScope: this.parser
        });
    }

    get tmpPenManager() {
        if (this._tmpPenManager === null) {
            this._tmpPenManager = this.newPenManager();
        }
        return this._tmpPenManager;
    }

    getPlainText(text, start, end) {
        var plainText;
        if (text == null) {
            plainText = this.penManager.plainText;
        } else {
            var m, match = this.parser.splitText(text, 1); // PLAINTEXTONLY_MODE
            plainText = "";
            for (var i = 0, len = match.length; i < len; i++) {
                plainText += match[i];
            }
        }

        if ((start != null) || (end != null)) {
            if (start == null) {
                start = 0;
            }
            if (end == null) {
                end = plainText.length;
            }
            plainText = plainText.substring(start, end);
        }

        return plainText;
    }

    getPenManager(text, retPenManager) {
        if (text === undefined) {
            return this.copyPenManager(retPenManager, this.penManager);
        }

        if (retPenManager === undefined) {
            retPenManager = this.newPenManager();
        }

        var defatultStyle = this.defatultStyle;
        this.updatePenManager(
            text,
            defatultStyle.wrapMode,
            defatultStyle.wrapWidth,
            defatultStyle.lineHeight,
            retPenManager
        );
        return retPenManager;
    }

    getText(text, start, end, wrap) {
        if (text == null) {
            return this.penManager.getSliceTagText(start, end, wrap);
        }

        var penManager = this.tmpPenManager;
        var defatultStyle = this.defatultStyle;
        this.updatePenManager(
            text,
            defatultStyle.wrapMode,
            defatultStyle.wrapWidth,
            defatultStyle.lineHeight,
            penManager
        );

        return penManager.getSliceTagText(start, end, wrap);
    }

    copyPenManager(ret, src) {
        if (src === undefined) {
            src = this.penManager;
        }
        return src.copy(ret);
    }

    getTextWidth(penManager) {
        if (penManager === undefined) {
            penManager = this.penManager;
        }

        return penManager.getMaxLineWidth();
    }

    getLastPen(penManager) {
        if (penManager === undefined) {
            penManager = this.penManager;
        }

        return penManager.lastPen;
    }
};

var CanvasText_methods = {
    setInteractive: canvastext_SetInteractive,
}

Object.assign(
    CanvasText_CanvasText.prototype,
    DrawMethods,
    CanvasText_methods
);

/* harmony default export */ var canvastext_CanvasText = (CanvasText_CanvasText);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/text/textbase/imagemanager/ImageManager.js
const ImageManager_GetValue = Phaser.Utils.Objects.GetValue;

class ImageManager {
    constructor(textureManager) {
        this.textureManager = textureManager;
        this.images = {};
    }

    add(key, config) {
        if (typeof (key) === 'string') {
            this._add(key, config);
        } else if (Array.isArray(key)) {
            var data = key;
            for (var i = 0, cnt = data.length; i < cnt; i++) {
                this._add(data[i]);
            }
        } else {
            var data = key;
            for (var key in data) {
                this._add(key, data[key]);
            }
        }
        return this;
    }

    _add(key, config) {
        if (config === undefined) {
            config = {
                key: key
            }
        }

        var textureKey = config.key, frameKey = config.frame;
        var width = config.width, height = config.height;

        if ((width === undefined) || (height === undefined)) {
            var frame = this.textureManager.getFrame(textureKey, frameKey);
            var frameWidth = (frame) ? frame.cutWidth : 0;
            var frameHeight = (frame) ? frame.cutHeight : 0;
            if ((width === undefined) && (height === undefined)) {
                width = frameWidth;
                height = frameHeight;
            } else if (width === undefined) {
                width = frameWidth * (height / frameHeight);
            } else if (height === undefined) {
                height = frameHeight * (width / frameWidth);
            }
        }

        this.images[key] = {
            key: textureKey,
            frame: frameKey,
            width: width,
            height: height,
            y: ImageManager_GetValue(config, 'y', 0),
            left: ImageManager_GetValue(config, 'left', 0),
            right: ImageManager_GetValue(config, 'right', 0)
        }
    }

    remove(key) {
        if (this.images.hasOwnProperty(key)) {
            delete this.images[key];
        }
        return this;
    }

    get(key) {
        if (!this.images.hasOwnProperty(key)) {
            if (this.textureManager.exists(key)) {
                this.add(key);
            }
        }
        return this.images[key];
    }

    getOuterWidth(key) {
        var data = this.get(key);
        return (data) ? (data.width + data.left + data.right) : 0;
    }

    getFrame(key) {
        var data = this.get(key);
        return (data) ? this.textureManager.getFrame(data.key, data.frame) : undefined;
    }

    hasTexture(key) {
        return !!this.getFrame(key);
    }
}
/* harmony default export */ var imagemanager_ImageManager = (ImageManager);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/text/textbase/imagemanager/GetGlobImageManager.js


var globImageManager;

/* harmony default export */ var GetGlobImageManager = (function(textureManager) {
    if (globImageManager === undefined) {
        globImageManager = new imagemanager_ImageManager(textureManager);
    }
    return globImageManager;
});
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/text/textbase/Text.js

 // extended





const AddToDOM = Phaser.DOM.AddToDOM;
const Text_CanvasPool = Phaser.Display.Canvas.CanvasPool;
const GameObject = Phaser.GameObjects.GameObject;
const Text_GetValue = Phaser.Utils.Objects.GetValue;
const RemoveFromDOM = Phaser.DOM.RemoveFromDOM;
const SPLITREGEXP = textbase_const.SPLITREGEXP;

var PensPools = {};

class Text_Text extends GameObject {
    constructor(scene, x, y, text, style, type, parser) {
        if (x === undefined) {
            x = 0;
        }
        if (y === undefined) {
            y = 0;
        }

        super(scene, type);

        this.renderer = scene.sys.game.renderer;

        this.setPosition(x, y);
        this.setOrigin(0, 0);
        this.initPipeline();

        this.canvas = Text_CanvasPool.create(this);

        this.context = this.canvas.getContext('2d');

        if (style) {
            // Override align
            if (style.hasOwnProperty('align')) {
                var halign = style.align;
                delete style.align;
                style.halign = halign;
            }
        }
        this.style = new textstyle_TextStyle(this, style);

        this.autoRound = true;

        this._text = undefined;

        this.padding = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
        };

        this.width = 1;

        this.height = 1;

        this.dirty = false;

        //  If resolution wasn't set, then we get it from the game config
        if (this.style.resolution === 0) {
            this.style.resolution = scene.sys.game.config.resolution;
        }

        this._crop = this.resetCropObject();

        //  Create a Texture for this Text object
        this.texture = scene.sys.textures.addCanvas(null, this.canvas, true);

        //  Get the frame
        this.frame = this.texture.get();

        //  Set the resolution
        this.frame.source.resolution = this.style.resolution;

        if (this.renderer && this.renderer.gl) {
            //  Clear the default 1x1 glTexture, as we override it later

            this.renderer.deleteTexture(this.frame.source.glTexture);

            this.frame.source.glTexture = null;
        }

        if (!PensPools.hasOwnProperty(type)) {
            PensPools[type] = new pool();
        }
        this.canvasText = new canvastext_CanvasText({
            parent: this,
            context: this.context,
            parser: parser,
            style: this.style,
            pensPool: PensPools[type]
        });

        //this.initRTL();

        if (style && style.padding) {
            this.setPadding(style.padding);
        }

        this.setText(text);

        scene.sys.game.events.on('contextrestored', function () {
            this.dirty = true;
        }, this);
    }

    set text(value) {
        this.setText(value);
    }
    get text() {
        return this._text;
    }

    initRTL() {
        if (!this.style.rtl) {
            return;
        }

        //  Here is where the crazy starts.
        //
        //  Due to browser implementation issues, you cannot fillText BiDi text to a canvas
        //  that is not part of the DOM. It just completely ignores the direction property.

        this.canvas.dir = 'rtl';

        //  Experimental atm, but one day ...
        this.context.direction = 'rtl';

        //  Add it to the DOM, but hidden within the parent canvas.
        this.canvas.style.display = 'none';

        AddToDOM(this.canvas, this.scene.sys.canvas);

        //  And finally we set the x origin
        this.originX = 1;
    }

    setText(value) {
        if (!value && value !== 0) {
            value = '';
        }

        if (Array.isArray(value)) {
            value = value.join('\n');
        }

        if (value !== this._text) {
            this._text = value.toString();

            this.updateText();
        }

        return this;
    }

    setStyle(style) {
        return this.style.setStyle(style);
    }

    setFont(font) {
        return this.style.setFont(font);
    }

    setFontFamily(family) {
        return this.style.setFontFamily(family);
    }

    setFontSize(size) {
        return this.style.setFontSize(size);
    }

    setFontStyle(style) {
        return this.style.setFontStyle(style);
    }

    setFixedSize(width, height) {
        return this.style.setFixedSize(width, height);
    }

    setBackgroundColor(color) {
        return this.style.setBackgroundColor(color);
    }

    setFill(color) {
        return this.style.setFill(color);
    }

    setColor(color) {
        return this.style.setColor(color);
    }

    setStroke(color, thickness) {
        return this.style.setStroke(color, thickness);
    }

    setShadow(x, y, color, blur, shadowStroke, shadowFill) {
        return this.style.setShadow(x, y, color, blur, shadowStroke, shadowFill);
    }

    setShadowOffset(x, y) {
        return this.style.setShadowOffset(x, y);
    }

    setShadowColor(color) {
        return this.style.setShadowColor(color);
    }

    setShadowBlur(blur) {
        return this.style.setShadowBlur(blur);
    }

    setShadowStroke(enabled) {
        return this.style.setShadowStroke(enabled);
    }

    setShadowFill(enabled) {
        return this.style.setShadowFill(enabled);
    }

    setWrapMode(mode) {
        return this.style.setWrapMode(mode);
    }

    setWrapWidth(width) {
        return this.style.setWrapWidth(width);
    }

    setAlign(align) {
        return this.style.setHAlign(align);
    }

    setLineSpacing(value) {
        return this.style.setLineSpacing(value);
    }

    setPadding(left, top, right, bottom) {
        if (typeof left === 'object') {
            var config = left;

            //  If they specify x and/or y this applies to all
            var x = Text_GetValue(config, 'x', null);

            if (x !== null) {
                left = x;
                right = x;
            } else {
                left = Text_GetValue(config, 'left', 0);
                right = Text_GetValue(config, 'right', left);
            }

            var y = Text_GetValue(config, 'y', null);

            if (y !== null) {
                top = y;
                bottom = y;
            } else {
                top = Text_GetValue(config, 'top', 0);
                bottom = Text_GetValue(config, 'bottom', top);
            }
        } else {
            if (left === undefined) {
                left = 0;
            }
            if (top === undefined) {
                top = left;
            }
            if (right === undefined) {
                right = left;
            }
            if (bottom === undefined) {
                bottom = top;
            }
        }

        this.padding.left = left;
        this.padding.top = top;
        this.padding.right = right;
        this.padding.bottom = bottom;

        return this.updateText(false);
    }

    setResolution(value) {
        return this.style.setResolution(value);
    }

    setMaxLines(max) {
        return this.style.setMaxLines(max);
    }

    updateText(runWrap) {
        if (runWrap === undefined) {
            runWrap = true;
        }
        var canvasText = this.canvasText;

        // wrap text to pens
        var style = this.style;
        if (runWrap) {
            canvasText.updatePenManager(
                this._text,
                style.wrapMode,
                style.wrapWidth,
                style.lineHeight
            );
        }

        // resize
        var padding = this.padding;
        var textWidth, textHeight;
        if (style.fixedWidth === 0) {
            this.width = canvasText.linesWidth + padding.left + padding.right;
            textWidth = canvasText.linesWidth;
        }
        else {
            this.width = style.fixedWidth;
            textWidth = this.width - padding.left - padding.right;
            if (textWidth < canvasText.linesWidth) {
                textWidth = canvasText.linesWidth;
            }
        }
        if (style.fixedHeight === 0) {
            this.height = canvasText.linesHeight + padding.top + padding.bottom;
            textHeight = canvasText.linesHeight;
        }
        else {
            this.height = style.fixedHeight;
            textHeight = this.height - padding.top - padding.bottom;
            if (textHeight < canvasText.linesHeight) {
                textHeight = canvasText.linesHeight;
            }
        }

        var w = this.width;
        var h = this.height;

        this.updateDisplayOrigin();

        var resolution = style.resolution;
        w *= resolution;
        h *= resolution;

        w = Math.max(Math.ceil(w), 1);
        h = Math.max(Math.ceil(h), 1);

        var canvas = this.canvas;
        var context = this.context;
        if (canvas.width !== w || canvas.height !== h) {
            canvas.width = w;
            canvas.height = h;
            this.frame.setSize(w, h);
        } else {
            context.clearRect(0, 0, w, h);
        }

        context.save();
        context.scale(resolution, resolution);

        // draw
        canvasText.draw(
            padding.left,
            padding.top,
            textWidth,
            textHeight
        );

        context.restore();

        if (this.renderer.gl) {
            this.frame.source.glTexture = this.renderer.canvasToTexture(canvas, this.frame.source.glTexture, true);
            this.frame.glTexture = this.frame.source.glTexture;
        }

        this.dirty = true;

        var input = this.input;

        if (input && !input.customHitArea) {
            input.hitArea.width = this.width;
            input.hitArea.height = this.height;
        }

        return this;
    }

    getTextMetrics() {
        return this.style.getTextMetrics();
    }

    toJSON() {
        var out = Text_Components.ToJSON(this);

        //  Extra Text data is added here

        var data = {
            autoRound: this.autoRound,
            text: this._text,
            style: this.style.toJSON(),
            resolution: this.resolution,
            padding: {
                left: this.padding.left,
                right: this.padding.right,
                top: this.padding.top,
                bottom: this.padding.bottom
            }
        };

        out.data = data;

        return out;
    }

    preDestroy() {
        if (this.style.rtl) {
            RemoveFromDOM(this.canvas);
        }

        Text_CanvasPool.remove(this.canvas);
        this.canvasText.destroy();
    }

    setInteractive(shape, callback, dropZone) {
        GameObject.prototype.setInteractive.call(this, shape, callback, dropZone);
        this.canvasText.setInteractive();
        return this;
    }

    getWrappedText(text, start, end) {
        text = this.canvasText.getText(text, start, end, true);
        return text.split(SPLITREGEXP);
    }

    getPlainText(text, start, end) {
        return this.canvasText.getPlainText(text, start, end);
    }

    getText(text, start, end) {
        return this.canvasText.getText(text, start, end, false);
    }

    getSubString(text, start, end) {
        return this.getText(text, start, end);
    }

    copyPenManager(penManager) {
        return this.canvasText.copyPenManager(penManager);
    }

    getPenManager(text, penManager) {
        return this.canvasText.getPenManager(text, penManager);
    }

    setSize(width, height) {
        return this.setFixedSize(width, height);
    }

    resize(width, height) {
        return this.setFixedSize(width, height);
    }

    set lineSpacing(value) {
        this.setLineSpacing(value);
    }
    get lineSpacing() {
        return this.style.lineSpacing;
    }

    get imageManager() {
        return GetGlobImageManager(this.scene.textures);
    }

    addImage(key, config) {
        this.imageManager.add(key, config);
        return this;
    }

    drawAreaBounds(graphics, color) {
        this.canvasText.hitAreaManager.drawBounds(graphics, color, this);
        return this;
    }
}

const Text_Components = Phaser.GameObjects.Components;
Phaser.Class.mixin(Text_Text,
    [
        Text_Components.Alpha,
        Text_Components.BlendMode,
        Text_Components.ComputedSize,
        Text_Components.Crop,
        Text_Components.Depth,
        Text_Components.Flip,
        Text_Components.GetBounds,
        Text_Components.Mask,
        Text_Components.Origin,
        Text_Components.Pipeline,
        Text_Components.ScrollFactor,
        Text_Components.Tint,
        Text_Components.Transform,
        Text_Components.Visible,
        render_Render
    ]
);

/* harmony default export */ var textbase_Text = (Text_Text);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/text/bbcodetext/Parser.js


var GETPROP_RESULT = {
    plainText: null,
    prevProp: null
};

var STYLE_RESULT = new textstyle_TextStyle();
var EMPTYPROP = {};

var Parser_parser = {
    splitText: function (text, mode) {
        var result = [];
        var arr, m, charIdx = 0,
            totalLen = text.length,
            matchStart = totalLen;

        while (true) {
            arr = RE_SPLITTEXT.exec(text);
            if (!arr) {
                break;
            }

            m = arr[0];
            matchStart = RE_SPLITTEXT.lastIndex - m.length;

            if (charIdx < matchStart) {
                result.push(text.substring(charIdx, matchStart));
            }

            if (mode === undefined) {
                result.push(m);
            }

            charIdx = RE_SPLITTEXT.lastIndex;
        }

        if (charIdx < totalLen) {
            result.push(text.substring(charIdx, totalLen));
        }
        return result; // [text,...]
    },

    tagTextToProp: function (text, prevProp) {
        var plainText, innerMatch;

        if (prevProp == null) {
            prevProp = {};
        }

        // close image tag
        if (prevProp.img) {
            updateProp(prevProp, PROP_REMOVE, 'img');
        }
        // Check if current fragment is a class tag
        if (RE_BLOD_OPEN.test(text)) {
            updateProp(prevProp, PROP_ADD, 'b', true);
            plainText = '';
        } else if (RE_BLOD_CLOSE.test(text)) {
            updateProp(prevProp, PROP_REMOVE, 'b');
            plainText = '';
        } else if (RE_ITALICS_OPEN.test(text)) {
            updateProp(prevProp, PROP_ADD, 'i', true);
            plainText = '';
        } else if (RE_ITALICS_CLOSE.test(text)) {
            updateProp(prevProp, PROP_REMOVE, 'i');
            plainText = '';
        } else if (RE_SIZE_OPEN.test(text)) {
            innerMatch = text.match(RE_SIZE_OPEN);
            updateProp(prevProp, PROP_ADD, 'size', innerMatch[1] + 'px');
            plainText = '';
        } else if (RE_SIZE_CLOSE.test(text)) {
            updateProp(prevProp, PROP_REMOVE, 'size');
            plainText = '';
        } else if (RE_COLOR_OPEN.test(text)) {
            innerMatch = text.match(RE_COLOR_OPEN);
            updateProp(prevProp, PROP_ADD, 'color', innerMatch[1]);
            plainText = '';
        } else if (RE_COLOR_CLOSE.test(text)) {
            updateProp(prevProp, PROP_REMOVE, 'color');
            plainText = '';
        } else if (RE_UNDERLINE_OPEN.test(text)) {
            innerMatch = text.match(RE_UNDERLINE_OPEN);
            updateProp(prevProp, PROP_ADD, 'u', true);
            plainText = '';
        } else if (RE_UNDERLINE_OPENC.test(text)) {
            innerMatch = text.match(RE_UNDERLINE_OPENC);
            updateProp(prevProp, PROP_ADD, 'u', innerMatch[1]);
            plainText = '';
        } else if (RE_UNDERLINE_CLOSE.test(text)) {
            updateProp(prevProp, PROP_REMOVE, 'u');
            plainText = '';
        } else if (RE_SHADOW_OPEN.test(text)) {
            updateProp(prevProp, PROP_ADD, 'shadow', true);
            plainText = '';
        } else if (RE_SHADOW_CLOSE.test(text)) {
            updateProp(prevProp, PROP_REMOVE, 'shadow');
            plainText = '';
        } else if (RE_STROKE_OPEN.test(text)) {
            updateProp(prevProp, PROP_ADD, 'stroke', true);
            plainText = '';
        } else if (RE_STROKE_OPENC.test(text)) {
            innerMatch = text.match(RE_STROKE_OPENC);
            updateProp(prevProp, PROP_ADD, 'stroke', innerMatch[1]);
            plainText = '';
        } else if (RE_STROKE_CLOSE.test(text)) {
            updateProp(prevProp, PROP_REMOVE, 'stroke');
            plainText = '';
        } else if (RE_IMAGE_OPEN.test(text)) {
            innerMatch = text.match(RE_IMAGE_OPEN);
            updateProp(prevProp, PROP_ADD, 'img', innerMatch[1]);
            plainText = '';
        } else if (RE_IMAGE_CLOSE.test(text)) {
            updateProp(prevProp, PROP_REMOVE, 'img');
            plainText = '';
        } else if (RE_AREA_OPEN.test(text)) {
            innerMatch = text.match(RE_AREA_OPEN);
            updateProp(prevProp, PROP_ADD, 'area', innerMatch[1]);
            plainText = '';
        } else if (RE_AREA_CLOSE.test(text)) {
            updateProp(prevProp, PROP_REMOVE, 'area');
            plainText = '';            
        } else {
            plainText = text
        }

        var result = GETPROP_RESULT;
        result.plainText = plainText;
        result.prop = prevProp;
        return result;
    },

    propToContextStyle: function (defaultStyle, prop) {
        var result = STYLE_RESULT;
        if (!prop.hasOwnProperty('img')) {
            result.image = null;

            if (prop.hasOwnProperty('family')) {
                result.fontFamily = prop.family;
            } else {
                result.fontFamily = defaultStyle.fontFamily;
            }

            if (prop.hasOwnProperty('size')) {
                var size = prop.size;
                if (typeof (size) === 'number') {
                    size = size.toString() + 'px';
                }
                result.fontSize = size;
            } else {
                result.fontSize = defaultStyle.fontSize;
            }
            result.fontStyle = getFontStyle(prop.b, prop.i);

            if (prop.hasOwnProperty('color')) {
                result.color = prop.color;
            } else {
                result.color = defaultStyle.color;
            }

            if (prop.hasOwnProperty('stroke')) {
                if (prop.stroke === true) {
                    result.stroke = defaultStyle.stroke;
                    result.strokeThickness = defaultStyle.strokeThickness;
                } else {
                    result.stroke = prop.stroke;
                    result.strokeThickness = defaultStyle.strokeThickness;
                }
            } else {
                result.stroke = defaultStyle.stroke;
                result.strokeThickness = 0;
            }
        } else {
            result.image = prop.img;
        }

        if (prop.hasOwnProperty('shadow')) {
            if (prop.shadow === true) {
                result.shadowColor = defaultStyle.shadowColor;
                result.shadowOffsetX = defaultStyle.shadowOffsetX;
                result.shadowOffsetY = defaultStyle.shadowOffsetY;
                result.shadowBlur = defaultStyle.shadowBlur;
                result.shadowStroke = true;
                result.shadowFill = true;
            } else {
                result.shadowColor = prop.shadow;
                result.shadowOffsetX = defaultStyle.shadowOffsetX;
                result.shadowOffsetY = defaultStyle.shadowOffsetY;
                result.shadowBlur = defaultStyle.shadowBlur;
                result.shadowStroke = true;
                result.shadowFill = true;
            }
        } else {
            result.shadowColor = '#000';
            result.shadowOffsetX = 0;
            result.shadowOffsetY = 0;
            result.shadowBlur = 0;
            result.shadowStroke = false;
            result.shadowFill = false;
        }

        if (prop.hasOwnProperty('u')) {
            if (prop.u === true) {
                result.underlineColor = defaultStyle.underlineColor;
                result.underlineThickness = defaultStyle.underlineThickness;
                result.underlineOffset = defaultStyle.underlineOffset;
            } else {
                result.underlineColor = prop.u;
                result.underlineThickness = defaultStyle.underlineThickness;
                result.underlineOffset = defaultStyle.underlineOffset;
            }
        } else {
            result.underlineColor = '#000';
            result.underlineThickness = 0;
            result.underlineOffset = 0;
        }

        return result;
    },

    propToTagText: function (text, prop, prevProp) {
        if (prevProp == null) {
            prevProp = EMPTYPROP;
        }

        for (var k in prevProp) {
            if (prop.hasOwnProperty(k)) {
                continue;
            }

            text = '[/' + k + ']' + text;
        }

        var header = '';
        for (var k in prop) {
            if (prevProp[k] === prop[k]) {
                continue;
            }

            if (k === 'size') {
                header += ('[size=' + prop[k].replace('px', '') + ']');
            } else if ((k === 'color') || (k === 'stroke') || (k === 'img')) {
                header += ('[' + k + '=' + prop[k] + ']');
            } else if (k === 'u') {
                if (prop[k] === true) {
                    header += '[u]';
                } else {
                    header += ('[u=' + prop[k] + ']');
                }
            } else {
                header += ('[' + k + ']');
            }
        }
        text = header + text;

        return text;
    }
};

var updateProp = function (prop, op, key, value) {
    if (op === PROP_ADD) {
        // PROP_ADD     
        prop[key] = value;
    } else {
        // PROP_REMOVE        
        if (prop.hasOwnProperty(key)) {
            delete prop[key];
        }
    }

    return prop;
};

var getFontStyle = function (isBold, isItalic) {
    if (isBold && isItalic) {
        return 'bold italic';
    } else if (isBold) {
        return 'bold';
    } else if (isItalic) {
        return 'italic';
    } else {
        return '';
    }
};

var RE_SPLITTEXT = /\[b\]|\[\/b\]|\[i\]|\[\/i\]|\[size=(\d+)\]|\[\/size\]|\[color=([a-z]+|#[0-9abcdef]+)\]|\[\/color\]|\[u\]|\[u=([a-z]+|#[0-9abcdef]+)\]|\[\/u\]|\[shadow\]|\[\/shadow\]|\[stroke\]|\[stroke=([a-z]+|#[0-9abcdef]+)\]|\[\/stroke\]|\[img=([^\]]+)\]|\[\/img\]|\[area=([^\]]+)\]|\[\/area\]/ig;

var RE_BLOD_OPEN = /\[b\]/i;
var RE_BLOD_CLOSE = /\[\/b\]/i;
var RE_ITALICS_OPEN = /\[i\]/i;
var RE_ITALICS_CLOSE = /\[\/i\]/i;
var RE_SIZE_OPEN = /\[size=(\d+)\]/i;
var RE_SIZE_CLOSE = /\[\/size\]/i;
var RE_COLOR_OPEN = /\[color=([a-z]+|#[0-9abcdef]+)\]/i;
var RE_COLOR_CLOSE = /\[\/color\]/i;
var RE_UNDERLINE_OPEN = /\[u\]/i;
var RE_UNDERLINE_OPENC = /\[u=([a-z]+|#[0-9abcdef]+)\]/i;
var RE_UNDERLINE_CLOSE = /\[\/u\]/i;
var RE_SHADOW_OPEN = /\[shadow\]/i;
var RE_SHADOW_CLOSE = /\[\/shadow\]/i;
var RE_STROKE_OPEN = /\[stroke\]/i;
var RE_STROKE_OPENC = /\[stroke=([a-z]+|#[0-9abcdef]+)\]/i;
var RE_STROKE_CLOSE = /\[\/stroke\]/i;
var RE_IMAGE_OPEN = /\[img=([^\]]+)\]/i;
var RE_IMAGE_CLOSE = /\[\/img\]/i;
var RE_AREA_OPEN = /\[area=([^\]]+)\]/i;
var RE_AREA_CLOSE = /\[\/area\]/i;
const PROP_REMOVE = false;
const PROP_ADD = true;

/* harmony default export */ var Parser = (Parser_parser);
// CONCATENATED MODULE: ./lib/rexui/lib/plugins/gameobjects/text/bbcodetext/BBCodeText.js



class BBCodeText_BBCodeText extends textbase_Text {
    constructor(scene, x, y, text, style) {
        super(scene, x, y, text, style, 'rexBBCodeText', Parser);
    }
}

/* harmony default export */ var bbcodetext_BBCodeText = (BBCodeText_BBCodeText);
// EXTERNAL MODULE: ./src/ui/components/nine.patch.ts + 1 modules
var nine_patch = __webpack_require__(42);

// EXTERNAL MODULE: ./src/ui/components/BasePanel.ts + 2 modules
var BasePanel = __webpack_require__(41);

// CONCATENATED MODULE: ./src/ui/chat/base.chat.panel.ts
var base_chat_panel_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var BaseChatPanel = /** @class */ (function (_super) {
    base_chat_panel_extends(BaseChatPanel, _super);
    function BaseChatPanel(scene, world) {
        return _super.call(this, scene, world) || this;
    }
    BaseChatPanel.prototype.appendChat = function (val) {
    };
    Object.defineProperty(BaseChatPanel.prototype, "outChannel", {
        get: function () {
            return 0;
        },
        enumerable: false,
        configurable: true
    });
    return BaseChatPanel;
}(BasePanel["a" /* BasePanel */]));


// CONCATENATED MODULE: ./src/ui/chat/chatPanel.pc.ts
var chatPanel_pc_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();









var chatPanel_pc_ChatPanelPC = /** @class */ (function (_super) {
    chatPanel_pc_extends(ChatPanelPC, _super);
    function ChatPanelPC(scene, world) {
        var _this = _super.call(this, scene, world) || this;
        _this.mPreHei = 0;
        _this.mPreWid = 0;
        return _this;
    }
    ChatPanelPC.prototype.appendChat = function (val) {
        if (this.mTextArea) {
            this.mTextArea.appendText(val);
            this.mTextArea.scrollToBottom();
        }
    };
    ChatPanelPC.prototype.tweenExpand = function (show) {
        if (!this.scene)
            return;
        var baseX = 0;
        var toX = show === true ? baseX : baseX - 200;
        var toAlpha = show === true ? 1 : 0;
        this.scene.tweens.add({
            targets: this,
            duration: 200,
            ease: "Cubic.Out",
            props: {
                x: { value: toX },
                alpha: { value: toAlpha },
            },
        });
    };
    ChatPanelPC.prototype.setPosition = function (x, y) {
        if (!this.mInitialized)
            return;
        // DefaultMask在TextBlock中，TextBlock是一个非渲染矩形游戏对象
        var size = this.mWorld.getSize();
        _super.prototype.setPosition.call(this, 0, size.height - this.mPreHei);
        if (this.mTextArea) {
            // this.mTextArea.childrenMap.child.setMinSize(width, (h - 16 * this.dpr) * zoom);
            // this.mTextArea.layout();
            // this.mTextArea.setPosition(this.width / 2 + 4 * this.dpr, this.y + this.mTextArea.height / 2 + 10 * this.dpr * zoom);
            var textMask = this.mTextArea.childrenMap.text;
            textMask.y = size.height - this.height + 25 * this.dpr;
            this.mTextArea.scrollToBottom();
            // 每次resize更新textBlock中的textMask的位置
            // this.mTextArea.childrenMap.child.textMask.setPosition(undefined, size.height - this.height + 30).resize();
        }
        return this;
    };
    ChatPanelPC.prototype.addListen = function () {
        if (!this.mInitialized)
            return;
        if (this.sendMsgBtn)
            this.sendMsgBtn.on("pointerdown", this.onSendMsgHandler, this);
        if (this.mVoiceBtn)
            this.mVoiceBtn.on("selected", this.onSelectedVoiceHandler, this);
        if (this.mMicBtn)
            this.mMicBtn.on("selected", this.onSelectedMicHandler, this);
        if (this.mInputText) {
            this.mInputText.on("focus", this.onFocusHandler, this);
            this.mInputText.on("blur", this.onBlurHandler, this);
        }
    };
    ChatPanelPC.prototype.removeListen = function () {
        _super.prototype.removeListen.call(this);
        if (!this.mInitialized)
            return;
        if (this.sendMsgBtn)
            this.sendMsgBtn.off("pointerdown", this.onSendMsgHandler, this);
        if (this.mVoiceBtn)
            this.mVoiceBtn.off("selected", this.onSelectedVoiceHandler, this);
        if (this.mMicBtn)
            this.mMicBtn.off("selected", this.onSelectedMicHandler, this);
        if (this.mInputText) {
            this.mInputText.off("focus", this.onFocusHandler, this);
            this.mInputText.off("blur", this.onBlurHandler, this);
        }
    };
    ChatPanelPC.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
    };
    ChatPanelPC.prototype.preload = function () {
        if (!this.scene) {
            return;
        }
        this.scene.load.image("button", resUtil["c" /* Url */].getRes("ui/common/button.png"));
        this.scene.load.image("thumbTexture", resUtil["c" /* Url */].getRes("ui/common/common_thumb_texture.png"));
        this.scene.load.image("track", resUtil["c" /* Url */].getRes("ui/common/common_track.png"));
        this.scene.load.image("chat_input_bg", resUtil["c" /* Url */].getRes("ui/chat/input_bg.png"));
        // this.scene.load.image("chat_border_bg", Url.getRes("ui/chat/bg.png"));
        this.scene.load.image(resUtil["a" /* Border */].getName(), resUtil["a" /* Border */].getPNG());
        this.scene.load.atlas("chat_atlas", resUtil["c" /* Url */].getRes("ui/chat/chat_atlas.png"), resUtil["c" /* Url */].getRes("ui/chat/chat_atlas.json"));
        _super.prototype.preload.call(this);
    };
    ChatPanelPC.prototype.init = function () {
        if (this.mInitialized)
            return;
        var size = this.mWorld.getSize();
        this.mPreHei = size.height;
        this.mPreWid = size.width;
        this.setSize(464, 281);
        var border = new nine_patch["a" /* NinePatch */](this.scene, 0, 0, this.width, this.height, resUtil["a" /* Border */].getName(), null, resUtil["a" /* Border */].getConfig());
        border.x = 4 * this.mWorld.uiScale + border.width * border.originX;
        border.y = size.height - 260 * this.mWorld.uiScale + border.height * border.originY;
        this.add(border);
        this.outPut = this.scene.make.container(undefined, false);
        this.add(this.outPut);
        var background = new roundrectangle_RoundRectangle(this.scene, 0, 0, 2, 2, 3, 0x808080, 0.5);
        this.outPut.add(background);
        var track = new ninepatch_button["a" /* NinePatchButton */](this.scene, 0, 0, 4, 7, "track", "", "", {
            left: 0,
            top: 2,
            right: 0,
            bottom: 2
        });
        track.x = 100 * this.mWorld.uiScale;
        track.y = 10 * this.mWorld.uiScale;
        this.outPut.add(track);
        var text = new bbcodetext_BBCodeText(this.scene, 0, 0, "", {
            fontSize: "14px",
            wrap: {
                mode: "char",
                width: 400 * this.mWorld.uiScale
            },
        });
        this.outPut.add(text);
        var thumb = new ninepatch_button["a" /* NinePatchButton */](this.scene, 0, 0, 20, 35, "button", "", "", {
            left: 4,
            top: 4,
            right: 4,
            bottom: 4
        });
        // const indicator = new NinePatchButton(this.scene, 0, 0, 8, 10, "thumbTexture", "", {
        //     left: 0,
        //     top: 0,
        //     right: 0,
        //     bottom: 0
        // });
        this.outPut.add(thumb);
        // this.outPut.add(indicator);
        this.mTextArea = new textarea_TextArea(this.scene, {
            x: 230 * this.mWorld.uiScale,
            y: size.height - 155 * this.mWorld.uiScale,
            textWidth: 430,
            textHeight: 200,
            text: text,
            slider: {
                track: track,
                // indicator,
                thumb: thumb,
            },
        })
            .layout();
        this.outPut.add(this.mTextArea);
        var tracks = this.mTextArea.getElement("child");
        if (tracks) {
            // tracks.x += 150;
        }
        var inputContainer = this.scene.make.container(undefined, false);
        this.add(inputContainer);
        var inputBg = new nine_patch["a" /* NinePatch */](this.scene, 0, 0, 370, 32, "chat_input_bg", null, { left: 4, top: 4, right: 4, bottom: 4 });
        inputBg.x = 8 * this.mWorld.uiScale + inputBg.width * inputBg.originX;
        inputBg.y = size.height - 46 * this.mWorld.uiScale + inputBg.height * inputBg.originY;
        inputContainer.add(inputBg);
        this.mInputText = new InputText["a" /* default */](this.scene, 0, 0, 10, 10, {
            type: "input",
            fontSize: "14px",
            color: "#808080"
        })
            .resize(360, 20)
            .setOrigin(0, 0)
            .setStyle({ font: "bold 16px YaHei" });
        this.mInputText.x = 12 * this.mWorld.uiScale;
        this.mInputText.y = size.height - 40 * this.mWorld.uiScale;
        inputContainer.add(this.mInputText);
        this.sendMsgBtn = new ninepatch_button["a" /* NinePatchButton */](this.scene, 0, 0, 60, 30, "button", "", "发送", {
            left: 4,
            top: 4,
            right: 4,
            bottom: 4
        });
        this.sendMsgBtn.x = this.width - this.sendMsgBtn.width + 10 * this.mWorld.uiScale;
        this.sendMsgBtn.y = size.height - this.sendMsgBtn.height;
        this.add(this.sendMsgBtn);
        this.mSendKey = this.scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.ENTER);
        this.mVoiceBtn = new CheckButton(this.scene, 0, 0, "chat_atlas", "voice_normal.png", "voice_selected.png");
        this.mVoiceBtn.x = this.width - 60 * this.mWorld.uiScale;
        this.mVoiceBtn.y = size.height - this.height;
        this.add(this.mVoiceBtn);
        this.mMicBtn = new CheckButton(this.scene, 0, 0, "chat_atlas", "mic_normal.png", "mic_selected.png");
        this.mMicBtn.x = this.width - 20 * this.mWorld.uiScale;
        this.mMicBtn.y = size.height - this.height;
        this.add(this.mMicBtn);
        this.setPosition();
        _super.prototype.init.call(this);
    };
    ChatPanelPC.prototype.onSelectedVoiceHandler = function (val) {
        if (val === false) {
            this.mMicBtn.selected = false;
        }
        this.emit("selectedVoice", val);
    };
    ChatPanelPC.prototype.onSelectedMicHandler = function (val) {
        if (this.mVoiceBtn.selected === false) {
            this.mMicBtn.selected = false;
            return;
        }
        this.mMicBtn.selected = val;
        this.emit("selectedMic", val);
    };
    ChatPanelPC.prototype.onSendMsgHandler = function () {
        var text = this.mInputText.text;
        if (text.length > 0) {
            this.emit("sendChat", text);
            this.mInputText.setText("");
            this.mInputText.setBlur();
        }
    };
    ChatPanelPC.prototype.onFocusHandler = function () {
        if (!this.mWorld || !this.mWorld.inputManager) {
            return;
        }
        if (this.mSendKey) {
            this.mSendKey.on("down", this.onDownEnter, this);
        }
    };
    ChatPanelPC.prototype.onBlurHandler = function () {
        if (!this.mWorld || !this.mWorld.inputManager) {
            return;
        }
        if (this.mSendKey) {
            this.mSendKey.off("down", this.onDownEnter, this);
        }
    };
    ChatPanelPC.prototype.onDownEnter = function () {
        this.onSendMsgHandler();
    };
    Object.defineProperty(ChatPanelPC.prototype, "outChannel", {
        get: function () {
            return 0;
        },
        enumerable: false,
        configurable: true
    });
    return ChatPanelPC;
}(BaseChatPanel));


// CONCATENATED MODULE: ./src/ui/chat/mobile/chatPanel.mobile.ts
var chatPanel_mobile_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();







var chatPanel_mobile_ChatPanelMobile = /** @class */ (function (_super) {
    chatPanel_mobile_extends(ChatPanelMobile, _super);
    function ChatPanelMobile(scene, world) {
        var _this = _super.call(this, scene, world) || this;
        _this.setTween(false);
        return _this;
    }
    ChatPanelMobile.prototype.addListen = function () {
        this.mSendBtn.on("pointerdown", this.onSendMsgHandler, this);
        this.clickContainer.on("pointerdown", this.clickHandler, this);
        this.mInputText.on("focus", this.onFocusHandler, this);
        this.mInputText.on("blur", this.onBlurHandler, this);
    };
    ChatPanelMobile.prototype.removeListen = function () {
        this.mSendBtn.off("pointerdown", this.onSendMsgHandler, this);
        this.clickContainer.off("pointerdown", this.clickHandler, this);
        this.mInputText.off("focus", this.onFocusHandler, this);
        this.mInputText.off("blur", this.onBlurHandler, this);
    };
    ChatPanelMobile.prototype.appendChat = function (val) {
        if (this.mTextArea) {
            this.mTextArea.appendText(val);
            this.mTextArea.scrollToBottom();
        }
    };
    ChatPanelMobile.prototype.show = function (param) {
        _super.prototype.show.call(this, param);
        this.tweenExpand(true);
    };
    ChatPanelMobile.prototype.setPosition = function (x, y) {
        if (!this.mShow)
            return;
        // DefaultMask在TextBlock中，TextBlock是一个非渲染矩形游戏对象
        var size = this.mWorld.getSize();
        var track;
        var thumb;
        var text;
        if (this.mTextArea) {
            this.mTextArea.destroy();
            this.mTextArea = null;
            text = new bbcodetext_BBCodeText(this.scene, 0, 0, "", {
                fontSize: "20px",
                wrap: {
                    mode: "char",
                    width: this.width >> 1
                },
            });
            track = new ninepatch_button["a" /* NinePatchButton */](this.scene, 0, 0, 4, 7, "track", "", "", {
                left: 0,
                top: 2,
                right: 0,
                bottom: 2
            });
            // track.x = this.width / 2;
            // track.y = 8 * this.mWorld.uiScale;
            thumb = new ninepatch_button["a" /* NinePatchButton */](this.scene, 0, 0, 20, 35, "button", "", "", {
                left: 4,
                top: 4,
                right: 4,
                bottom: 4
            });
            this.add(text);
            this.add(track);
            this.add(thumb);
        }
        if (this.mInputText) {
            this.mInputText.destroy();
            this.mInputText = null;
            this.mInputText = new InputText["a" /* default */](this.scene, 0, 0, 10, 10, {
                type: "input",
                fontSize: "20px",
                color: "#808080"
            })
                .resize(328, 26)
                .setOrigin(0, 0)
                .setStyle({ font: "bold 20px YaHei" });
            // .on("focus", this.onFocusHandler, this)
            // .on("blur", this.onBlurHandler, this);
        }
        if (this.mWorld.game.scale.orientation === Phaser.Scale.Orientation.LANDSCAPE) {
            this.width = size.width >> 1;
            this.height = size.height;
            this.mBorder.resize(this.width / this.mWorld.uiScale, this.height / this.mWorld.uiScale);
            this.x = 0;
            this.y = 0;
            this.clickContainer.x = this.width / this.mWorld.uiScale + this.clickContainer.width / 2;
            this.clickContainer.y = this.height / (this.mWorld.uiScale * 2);
            this.clickContainer.rotation = Math.PI * .5;
            this.arrow.rotation = Math.PI * .5;
            this.mInputBg.y = this.mBorder.height - this.mInputBg.height / 2;
            this.mTextArea = new textarea_TextArea(this.scene, {
                x: this.width * .5 / this.mWorld.uiScale,
                y: this.height / 2,
                textWidth: this.mBorder.width - 20 * this.mWorld.uiScale,
                textHeight: this.height,
                text: text,
                slider: {
                    track: track,
                    thumb: thumb,
                },
                clamplChildOY: true,
            });
            this.mInputText.setPosition(2, this.mInputBg.y - 12 * this.mWorld.uiScale);
        }
        else {
            this.width = size.width;
            this.height = size.height / 2;
            this.mBorder.resize(this.width / this.mWorld.uiScale, this.height / this.mWorld.uiScale);
            this.x = 0;
            this.y = this.height + 20 * this.mWorld.uiScale;
            this.mInputBg.y = this.mBorder.height - this.mInputBg.height;
            this.mTextArea = new textarea_TextArea(this.scene, {
                x: (this.width - 15) / this.mWorld.uiScale >> 1,
                y: (size.height / 2 - this.mSendBtn.height - 20) / this.mWorld.uiScale >> 1,
                textWidth: this.mBorder.width - 20 * this.mWorld.uiScale,
                textHeight: (size.height / 2 - this.mSendBtn.height - 20) / this.mWorld.uiScale,
                text: text,
                slider: {
                    track: track,
                    thumb: thumb,
                },
                scroller: {
                    bounds: [0, this.height >> 1],
                },
                clamplChildOY: true,
                backDeceleration: true,
            });
            // this.mTextArea.x = this.mTextArea.childrenMap.child.minWidth >> 1;
            // this.mTextArea.y = this.mTextArea.childrenMap.child.minHeight >> 1;
            this.clickContainer.x = size.width / (this.mWorld.uiScale * 2);
            this.clickContainer.y = -this.clickContainer.height >> 1;
            var silder = this.mTextArea.getElement("slider");
            silder.y = this.height >> 1;
            this.clickContainer.rotation = Math.PI;
            this.arrow.rotation = Math.PI * 1.5;
            this.mInputText.setPosition(2, this.mInputBg.y - 6 * this.mWorld.uiScale);
        }
        this.mTextArea.layout();
        this.add(this.mTextArea);
        this.mTextArea.childrenMap.child.textMask.setPosition(-5, size.height - this.height).resize(this.width + 18, this.height - this.mSendBtn.height);
        // this.mBorder = new NinePatch(this.scene, 0, 0, this.width / this.mWorld.uiScale, this.height / this.mWorld.uiScale, Border.getName(), null, Border.getConfig());
        this.mBorder.x = this.mBorder.width / 2;
        this.mBorder.y = this.mBorder.height / 2;
        this.setSize(this.width, this.height);
        // this.mTextArea.x = this.mBorder.width + 100 * this.mWorld.uiScale >> 1;
        this.mInputBg.x = this.mInputBg.width >> 1;
        this.mSendBtn.x = this.mBorder.width - this.mSendBtn.width;
        this.mSendBtn.y = this.mInputBg.y;
        this.scale = this.mWorld.uiScale;
        this.add(this.mInputText);
        return this;
    };
    ChatPanelMobile.prototype.destroy = function () {
        // if (this.mSendBtn) this.mSendBtn.destroy(true);
        // if (this.mInputBg) this.mInputBg.destroy(true);
        // if (this.clickContainer) this.clickContainer.destroy(true);
        // if (this.arrow) this.arrow.destroy(true);
        // if (this.mBorder) this.mBorder.destroy(true);
        // if (this.mTextArea) this.mTextArea.destroy();
        // if (this.mInputText) this.mInputText.destroy();
        // this.mTextArea = null;
        // this.mInputText = null;
        // this.mSendBtn = null;
        // this.clickContainer = null;
        // this.arrow = null;
        // this.mBorder = null;
        // this.mInputBg = null;
        _super.prototype.destroy.call(this);
    };
    ChatPanelMobile.prototype.tweenExpand = function (show) {
        var _this = this;
        var toAlpha = show === true ? 1 : 0;
        this.scene.tweens.add({
            targets: this,
            duration: 200,
            ease: "Linear",
            props: {
                alpha: { value: toAlpha },
            },
            onComplete: function (tween, targets, ship) {
                if (!show)
                    _this.hide();
                _this.addListen();
            },
        });
        if (show)
            this.setPosition();
    };
    ChatPanelMobile.prototype.hide = function () {
        this.removeListen();
        _super.prototype.hide.call(this);
    };
    ChatPanelMobile.prototype.preload = function () {
        if (!this.scene) {
            return;
        }
        this.scene.load.image("button", resUtil["c" /* Url */].getRes("ui/common/button.png"));
        this.scene.load.image("thumbTexture", resUtil["c" /* Url */].getRes("ui/common/common_thumb_texture.png"));
        this.scene.load.image("track", resUtil["c" /* Url */].getRes("ui/common/common_track.png"));
        this.scene.load.image("channelSelect", resUtil["c" /* Url */].getRes("ui/common/common_channelSelect.png"));
        this.scene.load.image("channelUnSelect", resUtil["c" /* Url */].getRes("ui/common/common_channelUnSelect.png"));
        this.scene.load.image("arrow", resUtil["c" /* Url */].getRes("ui/common/common_arrow.png"));
        this.scene.load.image("chat_input_bg", resUtil["c" /* Url */].getRes("ui/chat/input_bg.png"));
        this.scene.load.image(resUtil["a" /* Border */].getName(), resUtil["a" /* Border */].getPNG());
        this.scene.load.atlas(resUtil["d" /* WhiteButton */].getName(), resUtil["d" /* WhiteButton */].getPNG(), resUtil["d" /* WhiteButton */].getJSON());
        this.scene.load.atlas("chat_atlas", resUtil["c" /* Url */].getRes("ui/chat/chat_atlas.png"), resUtil["c" /* Url */].getRes("ui/chat/chat_atlas.json"));
        _super.prototype.preload.call(this);
    };
    ChatPanelMobile.prototype.init = function () {
        if (this.mInitialized)
            return;
        var size = this.mWorld.getSize();
        if (this.mWorld.game.scale.orientation === Phaser.Scale.Orientation.LANDSCAPE) {
            this.width = size.width >> 1;
            this.height = size.height;
        }
        else {
            this.width = size.width;
            this.height = size.height >> 1;
        }
        this.setSize(this.width, this.height);
        this.mBorder = new nine_patch["a" /* NinePatch */](this.scene, 0, 0, this.width / this.mWorld.uiScale, this.height / this.mWorld.uiScale, resUtil["a" /* Border */].getName(), null, resUtil["a" /* Border */].getConfig());
        this.mBorder.x = this.mBorder.width / 2;
        this.mBorder.y = this.mBorder.height / 2;
        this.addAt(this.mBorder, 0);
        var text = new bbcodetext_BBCodeText(this.scene, 0, 0, "", {
            fontSize: "20px",
            wrap: {
                mode: "char",
                width: this.width >> 1
            },
        });
        var track = new ninepatch_button["a" /* NinePatchButton */](this.scene, 0, 0, 4, 7, "track", "", "", {
            left: 0,
            top: 2,
            right: 0,
            bottom: 2
        });
        track.x = this.width / 2;
        track.y = 8 * this.mWorld.uiScale;
        var thumb = new ninepatch_button["a" /* NinePatchButton */](this.scene, 0, 0, 20, 35, "button", "", "", {
            left: 4,
            top: 4,
            right: 4,
            bottom: 4
        });
        this.add(text);
        this.add(track);
        this.add(thumb);
        this.mTextArea = new textarea_TextArea(this.scene, {
            x: this.width >> 1,
            y: this.height + 178 * this.mWorld.uiScale >> 1,
            textWidth: this.width,
            textHeight: this.height + 150 * this.mWorld.uiScale,
            text: text,
            slider: {
                track: track,
                thumb: thumb,
            },
        })
            .layout();
        this.add(this.mTextArea);
        this.mInputBg = new nine_patch["a" /* NinePatch */](this.scene, 0, 0, 340, 30, "chat_input_bg", null, { left: 4, top: 4, right: 4, bottom: 4 });
        this.add(this.mInputBg);
        this.mInputText = new InputText["a" /* default */](this.scene, 0, 0, 10, 10, {
            type: "input",
            fontSize: "20px",
            color: "#808080"
        })
            .resize(328, 26)
            .setOrigin(0, 0)
            .setStyle({ font: "bold 20px YaHei" })
            .on("focus", this.onFocusHandler, this)
            .on("blur", this.onBlurHandler, this);
        this.mSendBtn = new ninepatch_button["a" /* NinePatchButton */](this.scene, 0, 0, 60, 30, resUtil["d" /* WhiteButton */].getName(), "", "发送", resUtil["d" /* WhiteButton */].getConfig());
        this.add(this.mSendBtn);
        this.clickContainer = this.scene.make.container(undefined, false);
        var btnBg = new nine_patch["a" /* NinePatch */](this.scene, 0, 0, 53 / this.mWorld.uiScale, 30 / this.mWorld.uiScale, resUtil["a" /* Border */].getName(), null, resUtil["a" /* Border */].getConfig());
        this.arrow = this.scene.make.image(undefined, false);
        this.arrow.setTexture("arrow");
        this.clickContainer.setSize(btnBg.width + 4, btnBg.height + 10);
        this.clickContainer.add(btnBg);
        this.clickContainer.add(this.arrow);
        this.clickContainer.setInteractive();
        this.add(this.clickContainer);
        this.add(this.mInputText);
        this.setPosition();
        _super.prototype.init.call(this);
    };
    ChatPanelMobile.prototype.clickHandler = function () {
        this.scene.tweens.add({
            targets: this.clickContainer,
            duration: 50,
            ease: "Linear",
            props: {
                scaleX: { value: .5 },
                scaleY: { value: .5 },
            },
            yoyo: true,
            repeat: 0,
        });
        this.clickContainer.scaleX = this.clickContainer.scaleY = 1;
        this.tweenExpand(false);
        this.mWorld.uiManager.baseFaceTween(true);
    };
    ChatPanelMobile.prototype.onSendMsgHandler = function () {
        var text = this.mInputText.text;
        if (text.length > 0) {
            this.emit("sendChat", text);
            this.mInputText.setText("");
            this.mInputText.setBlur();
        }
        // // =====================tween out/in baseView
        // const baseViewMed: MainUIMediator = this.mWorld.uiManager.getMediator(MainUIMediator.NAME) as MainUIMediator;
        // if (baseViewMed) {
        //     baseViewMed.tweenView(true);
        // }
    };
    ChatPanelMobile.prototype.onFocusHandler = function () {
        if (!this.mWorld || !this.mWorld.inputManager) {
            return;
        }
        // this.mWorld.inputManager.enable = false;
    };
    ChatPanelMobile.prototype.onBlurHandler = function () {
        if (!this.mWorld || !this.mWorld.inputManager) {
            return;
        }
        // this.mWorld.inputManager.enable = true;
    };
    return ChatPanelMobile;
}(BaseChatPanel));


// CONCATENATED MODULE: ./lib/rexui/lib/ui/interface/baseUI/UIType.ts
/*
 * @Author: gxm
 * @Date: 2020-03-06 13:53:28
 * @Last Modified by: gxm
 * @Last Modified time: 2020-03-26 18:13:14
 */
var UIType;
(function (UIType) {
    UIType[UIType["None"] = 0] = "None";
    UIType[UIType["Scene"] = 1] = "Scene";
    UIType[UIType["Normal"] = 2] = "Normal";
    UIType[UIType["Pop"] = 3] = "Pop";
    UIType[UIType["Tips"] = 4] = "Tips";
    UIType[UIType["Monopoly"] = 5] = "Monopoly";
    UIType[UIType["Activity"] = 6] = "Activity";
})(UIType || (UIType = {}));

// CONCATENATED MODULE: ./lib/rexui/lib/ui/baseUI/BaseMediator.ts

var BaseMediator_BaseMediator = /** @class */ (function () {
    function BaseMediator() {
        /**
         * 面板处于打开状态
         */
        this.mShow = false;
        this.mUIType = UIType.None;
    }
    Object.defineProperty(BaseMediator.prototype, "UIType", {
        get: function () {
            return this.mUIType;
        },
        enumerable: false,
        configurable: true
    });
    BaseMediator.prototype.updateViewPos = function () {
        if (!this.mView)
            return;
        this.mView.updatePos();
    };
    BaseMediator.prototype.tweenExpand = function (show) {
        if (this.mView)
            this.mView.tweenExpand(show);
    };
    BaseMediator.prototype.getView = function () {
        return this.mView;
    };
    BaseMediator.prototype.hide = function () {
        this.mShow = false;
        var view = this.getView();
        if (view)
            view.hide();
    };
    BaseMediator.prototype.isSceneUI = function () {
        return false;
    };
    BaseMediator.prototype.isShow = function () {
        return this.mShow;
    };
    BaseMediator.prototype.resize = function (width, height) {
        var view = this.getView();
        if (view && view.isShow())
            view.resize(width, height);
    };
    BaseMediator.prototype.show = function (param) {
        this.mShow = true;
    };
    BaseMediator.prototype.update = function (param) {
        var view = this.getView();
        if (view)
            view.update(param);
    };
    BaseMediator.prototype.setParam = function (param) {
        this.mParam = param;
    };
    BaseMediator.prototype.getParam = function () {
        return this.mParam;
    };
    BaseMediator.prototype.destroy = function () {
        this.mShow = false;
        this.mParam = null;
        var view = this.getView();
        if (view) {
            view.destroy();
            view = undefined;
        }
    };
    return BaseMediator;
}());


// CONCATENATED MODULE: ./src/ui/chat/Chat.ts
var Chat_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var Chat_Chat = /** @class */ (function (_super) {
    Chat_extends(Chat, _super);
    function Chat(world) {
        var _this = _super.call(this) || this;
        _this.world = world;
        _this.mEvent = new Phaser.Events.EventEmitter();
        return _this;
    }
    Chat.prototype.on = function (event, fn, context) {
        this.mEvent.on(event, fn, context);
    };
    Chat.prototype.off = function (event, fn, context) {
        this.mEvent.off(event, fn, context);
    };
    Chat.prototype.register = function () {
        var connection = this.connection;
        if (connection) {
            this.connection.addPacketListener(this);
            this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_RES_CLIENT_CHAT, this.handleCharacterChat);
            this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_RES_CLIENT_QCLOUD_GME_AUTHBUFFER, this.handleQCLoudGME);
        }
    };
    Chat.prototype.unregister = function () {
        var connection = this.connection;
        if (connection) {
            this.connection.removePacketListener(this);
        }
    };
    Object.defineProperty(Chat.prototype, "connection", {
        get: function () {
            if (this.world) {
                return this.world.connection;
            }
        },
        enumerable: false,
        configurable: true
    });
    Chat.prototype.handleCharacterChat = function (packet) {
        var content = packet.content;
        this.mEvent.emit("characterChat", packet);
    };
    Chat.prototype.handleQCLoudGME = function (packet) {
        var authBuffer = packet.content;
        this.mEvent.emit("QCLoundGME", packet);
    };
    return Chat;
}(dist["PacketHandler"]));


// CONCATENATED MODULE: ./src/ui/chat/chat.mediator.ts
var chat_mediator_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();








var chat_mediator_ChatMediator = /** @class */ (function (_super) {
    chat_mediator_extends(ChatMediator, _super);
    function ChatMediator(world, scene) {
        var _this = _super.call(this) || this;
        _this.mInRoom = false;
        _this.mAllMessage = [];
        _this.mMaxMessageNum = 50;
        _this.world = world;
        _this.mScene = scene;
        _this.chat = new Chat_Chat(world);
        _this.mUIType = _this.world.game.device.os.desktop ? UIType.Scene : UIType.Normal;
        return _this;
    }
    ChatMediator.prototype.getUIType = function () {
        return this.mUIType;
    };
    ChatMediator.prototype.enterRoom = function () {
        if (!this.room)
            return;
        if (!this.room.playerManager.actor)
            return;
        if (!this.mGMEApi)
            return;
        var playerID = this.room.playerManager.actor.id;
        var roomID = this.room.id;
        this.mGMEApi.EnterRoom(roomID.toString(), 1, this.mQCLoudAuth);
        this.mInRoom = true;
        this.sendVoiceRoomStatus(protocols["op_def"].ChatChannel.CurrentScene, roomID, protocols["op_def"].VoiceRoomStatus.InVoiceRoom);
    };
    ChatMediator.prototype.exitRoom = function () {
        if (!this.mGMEApi)
            return;
        this.mGMEApi.EnableMic(false);
        this.mGMEApi.ExitRoom();
        this.mInRoom = false;
        if (!this.room) {
            return;
        }
        this.sendVoiceRoomStatus(protocols["op_def"].ChatChannel.CurrentScene, this.room.id, protocols["op_def"].VoiceRoomStatus.OutsideVoiceRoom);
    };
    ChatMediator.prototype.isSceneUI = function () {
        return true;
    };
    ChatMediator.prototype.tweenView = function (show) {
        if (!this.mView)
            return;
        this.mView.tweenExpand(show);
    };
    ChatMediator.prototype.isShow = function () {
        if (!this.mView) {
            return false;
        }
        return this.mView.isShow();
    };
    ChatMediator.prototype.showing = function () {
        return true;
    };
    ChatMediator.prototype.resize = function () {
        var size = this.world.getSize();
        if (this.mView) {
            this.mView.resize(size.width, size.height);
        }
    };
    ChatMediator.prototype.show = function (param) {
        if (this.mView && this.mView.isShow()) {
            return;
        }
        if (this.world.game.device.os.desktop) {
            this.mView = new chatPanel_pc_ChatPanelPC(this.mScene, this.world);
        }
        else {
            this.mView = new chatPanel_mobile_ChatPanelMobile(this.mScene, this.world);
            this.world.uiManager.checkUIState(ChatMediator.NAME, false);
        }
        this.world.uiManager.getUILayerManager().addToUILayer(this.mView);
        this.addListen();
        this.mView.show();
        this.mView.scale = this.world.uiScale;
    };
    ChatMediator.prototype.update = function (param) {
        this.mView.update(param);
        this.mParam = param;
    };
    ChatMediator.prototype.hide = function () {
        this.removeListen();
        this.mView.hide();
        if (!this.world.game.device.os.desktop)
            this.world.uiManager.checkUIState(ChatMediator.NAME, true);
    };
    ChatMediator.prototype.setParam = function (param) {
        this.mParam = param;
    };
    ChatMediator.prototype.getParam = function () {
        return this.mParam;
    };
    ChatMediator.prototype.destroy = function () {
        this.removeListen();
        if (this.chat) {
            this.chat.unregister();
            this.chat = null;
        }
        if (this.mGMEApi) {
            this.mGMEApi = null;
        }
        this.mScene = null;
        this.world = null;
        this.mInRoom = false;
        this.mQCLoudAuth = null;
        this.mAllMessage.forEach(function (message) {
            if (message)
                message = null;
        });
        this.mAllMessage = null;
        _super.prototype.destroy.call(this);
    };
    ChatMediator.prototype.addListen = function () {
        this.chat.on("characterChat", this.handleCharacterChat, this);
        this.chat.on("QCLoundGME", this.handleQCLoudGME, this);
        this.mView.on("sendChat", this.onSendChatHandler, this);
        this.mView.on("selectedVoice", this.onSelectedVoiceHandler, this);
        this.mView.on("selectedMic", this.onSelectedMicHandler, this);
        this.chat.register();
    };
    ChatMediator.prototype.removeListen = function () {
        this.chat.off("characterChat", this.handleCharacterChat, this);
        this.chat.off("QCLoundGME", this.handleQCLoudGME, this);
        this.mView.off("sendChat", this.onSendChatHandler, this);
        this.mView.off("selectedVoice", this.onSelectedVoiceHandler, this);
        this.mView.off("selectedMic", this.onSelectedMicHandler, this);
        this.chat.unregister();
    };
    ChatMediator.prototype.initGME = function () {
        var _this = this;
        // TODO just for test, need get sdkAppId from settings
        var sdkAppId = "1400209172";
        if (!this.room.playerManager.actor)
            return;
        var playerID = this.room.playerManager.actor.id;
        this.mGMEApi = new WebGMEAPI();
        this.mGMEApi.Init(document, sdkAppId, playerID.toString());
        this.mGMEApi.SetTMGDelegate(function (event, result) {
            switch (event) {
                case _this.mGMEApi.event.ITMG_MAIN_EVENT_TYPE_ENTER_ROOM:
                    log["a" /* Logger */].getInstance().log("[GME]: EnterRoom: " + result);
                    break;
                case _this.mGMEApi.event.ITMG_MAIN_EVNET_TYPE_USER_UPDATE:
                    break;
                case _this.mGMEApi.event.ITMG_MAIN_EVENT_TYPE_EXIT_ROOM:
                    log["a" /* Logger */].getInstance().log("[GME]: ExitRoom");
                    break;
                case _this.mGMEApi.event.ITMG_MAIN_EVENT_TYPE_ROOM_DISCONNECT:
                    log["a" /* Logger */].getInstance().log("[GME]: Room Disconnect!!!");
                    break;
                default:
                    log["a" /* Logger */].getInstance().log("[GME]: Sth wrong...");
                    break;
            }
        });
    };
    ChatMediator.prototype.appendMessage = function (messages, message) {
        messages.push(message);
        if (messages.length > this.mMaxMessageNum) {
            messages.shift();
        }
    };
    ChatMediator.prototype.changeMessageChannel = function () {
        var _this = this;
        if (!this.mView)
            return;
        var showMessages = this.mAllMessage.filter(function (msg) { return msg.channel === _this.mView.outChannel || msg.channel === protocols["op_def"].ChatChannel.System || _this.mView.outChannel === null; });
        var len = showMessages.length;
        var message = null;
        var wrapStr = "\n";
        for (var i = 0; i < len; i++) {
            message = showMessages[i];
            if (i === len - 1)
                wrapStr = "";
            this.mView.appendChat(message.chat + wrapStr);
        }
    };
    ChatMediator.prototype.handleCharacterChat = function (packet) {
        var content = packet.content;
        if (!this.world || !this.world.emitter || !this.room || !this.mView) {
            return;
        }
        var playerManager = this.world.roomManager.currentRoom.playerManager;
        if (!playerManager) {
            return;
        }
        var player = playerManager.get(content.chatSenderid);
        // const chatSendName = player ? player.name : "";
        // this.mChatPanel.appendChat(content.chatContext);
        var nickname = player ? player.model.nickname + ":" : "";
        var color = content.chatSetting && content.chatSetting.textColor ? content.chatSetting.textColor : "#FFFFFF";
        this.appendMessage(this.mAllMessage, { chat: "[color=" + color + "]" + nickname + ":" + content.chatContext + "[/color]", channel: content.chatChannel });
        this.mView.appendChat("[b][color=" + color + "]" + nickname + content.chatContext + "[/color][/b]\n");
    };
    ChatMediator.prototype.onSendChatHandler = function (text) {
        if (this.world.connection) {
            var pkt = new dist["PBpacket"](protocols["op_virtual_world"].OPCODE._OP_GATEWAY_REQ_VIRTUAL_WORLD_CHAT);
            var content = pkt.content;
            content.chatChannel = 0;
            content.chatContext = text;
            this.world.connection.send(pkt);
        }
    };
    ChatMediator.prototype.sendVoiceRoomStatus = function (voiceChannel, voiceRoomId, voiceRoomStatus) {
        if (!this.room.connection) {
            return;
        }
        var pkt = new dist["PBpacket"](protocols["op_virtual_world"].OPCODE._OP_CLIENT_REQ_VIRTUAL_WORLD_VOICE_ROOM_STATUS);
        var context = pkt.content;
        context.voiceChannel = voiceChannel;
        context.voiceRoomId = voiceRoomId;
        context.voiceRoomStatus = voiceRoomStatus;
        this.room.connection.send(pkt);
    };
    ChatMediator.prototype.handleQCLoudGME = function (packet) {
        var authBuffer = packet.content;
        this.mQCLoudAuth = authBuffer.signature;
        this.initGME();
    };
    ChatMediator.prototype.onSelectedVoiceHandler = function (val) {
        if (val) {
            this.enterRoom();
        }
        else {
            this.exitRoom();
        }
    };
    ChatMediator.prototype.onSelectedMicHandler = function (val) {
        if (!this.mGMEApi) {
            return;
        }
        if (this.mInRoom) {
            this.mGMEApi.EnableMic(val);
        }
        if (this.world.connection) {
            var pkt = new dist["PBpacket"]((protocols["op_virtual_world"].OPCODE._OP_CLIENT_REQ_VIRTUAL_WORLD_VOICE_ROOM_STATUS));
            this.world.connection.send(pkt);
        }
    };
    Object.defineProperty(ChatMediator.prototype, "room", {
        get: function () {
            if (!this.world) {
                return;
            }
            if (!this.world.roomManager) {
                return;
            }
            return this.world.roomManager.currentRoom;
        },
        enumerable: false,
        configurable: true
    });
    ChatMediator.NAME = "ChatMediator";
    return ChatMediator;
}(BaseMediator_BaseMediator));


// CONCATENATED MODULE: ./src/ui/layer.manager.ts
var LayerManager = /** @class */ (function () {
    function LayerManager() {
    }
    LayerManager.prototype.setScene = function (scene) {
        if (!scene)
            return;
        this.destroy();
        this.mScene = scene;
        // const view = scene.cameras.main;
        // this.mInteractive = scene.add.container(view.width >> 1, view.height >> 1);
        // this.mInteractive.setSize(view.width, view.height);
        // const rect = scene.add.graphics();
        // rect.lineStyle(1, 0, 1);
        // rect.fillRect(0, 0, view.width, view.height);
        // this.mInteractive.setInteractive();
        this.mUILayer = scene.add.container(0, 0);
        this.mDialogLayer = scene.add.container(0, 0);
        this.mToolTipsLyaer = scene.add.container(0, 0);
    };
    LayerManager.prototype.addToUILayer = function (obj) {
        if (!this.mUILayer) {
            return;
        }
        this.mUILayer.add(obj);
    };
    LayerManager.prototype.addToDialogLayer = function (obj) {
        if (!this.mDialogLayer) {
            return;
        }
        this.mDialogLayer.add(obj);
    };
    LayerManager.prototype.addToToolTipsLayer = function (obj) {
        if (!this.mToolTipsLyaer) {
            return;
        }
        this.mToolTipsLyaer.add(obj);
    };
    LayerManager.prototype.removeToUILayer = function (obj) {
        this.mUILayer.remove(obj);
    };
    LayerManager.prototype.removeToDialogLayer = function (obj) {
        this.mDialogLayer.remove(obj);
    };
    LayerManager.prototype.removeToToolTipsLayer = function (obj) {
        this.mToolTipsLyaer.remove(obj);
    };
    LayerManager.prototype.destroy = function () {
        if (this.mUILayer) {
            this.mUILayer.destroy();
            this.mUILayer = null;
        }
        if (this.mDialogLayer) {
            this.mDialogLayer.destroy();
            this.mDialogLayer = null;
        }
        if (this.mToolTipsLyaer) {
            this.mToolTipsLyaer.destroy();
            this.mToolTipsLyaer = null;
        }
    };
    Object.defineProperty(LayerManager.prototype, "interactive", {
        get: function () {
            return this.mInteractive;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LayerManager.prototype, "scene", {
        get: function () {
            return this.mScene;
        },
        enumerable: false,
        configurable: true
    });
    return LayerManager;
}());


// CONCATENATED MODULE: ./src/ui/ui.mediatorType.ts
var UIMediatorType = /** @class */ (function () {
    function UIMediatorType() {
    }
    UIMediatorType.BagMediator = "BagMediator"; // 角色背包
    UIMediatorType.ChatMediator = "ChatMediator"; // 场景聊天框
    UIMediatorType.NOTICE = "Notice";
    UIMediatorType.DIALOGO = "DIALOGO";
    UIMediatorType.Turn_Btn_Top = "Turn_Btn_Top";
    UIMediatorType.Turn_Btn_Bottom = "Turn_Btn_Bottom";
    UIMediatorType.App_Back = "App_Back";
    UIMediatorType.Editor_Save = "Editor_Save";
    UIMediatorType.Editor_Cancel = "Editor_Cancel";
    UIMediatorType.Close_Btn = "Close_Btn";
    UIMediatorType.ControlF = "ControlF"; // 展示框
    UIMediatorType.Storage = "Storage"; // 物件背包
    UIMediatorType.UserInfo = "UserInfo"; // 人物信息
    UIMediatorType.UserMenu = "UserMenu"; // 人物菜单
    UIMediatorType.MessageBox = "MessageBox"; // 消息框
    UIMediatorType.ComponentRank = "ComponentRank"; // 常驻固定排行榜
    UIMediatorType.Rank = "Rank"; // 排行榜
    UIMediatorType.VoteResult = "VoteResult"; // 投票界面
    UIMediatorType.Shop = "Shop"; // 内购商城
    UIMediatorType.MineSettle = "MineSettle"; // 矿洞结算
    UIMediatorType.EquipUpgrade = "EquipUpgrade"; // 装备升级
    return UIMediatorType;
}());


// CONCATENATED MODULE: ./src/ui/components/inputTextFactory.ts
var inputTextFactory_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var InputTextFactory = /** @class */ (function () {
    function InputTextFactory(world) {
        this.mWorld = world;
    }
    InputTextFactory.prototype.getInputText = function (scene, style) {
        var inputtext = new inputTextFactory_InputTextField(scene, this.mWorld, style);
        return inputtext;
    };
    return InputTextFactory;
}());

var InputTextFieldEvent = {
    textchange: "textchange",
    textclick: "textclick",
    textdblclick: "textdblclick",
    textfocus: "textfocus",
    textblur: "textblur",
    textExit: "textExit",
};
var inputTextFactory_InputTextField = /** @class */ (function (_super) {
    inputTextFactory_extends(InputTextField, _super);
    function InputTextField(scene, world, config) {
        var _this = _super.call(this) || this;
        _this.mDelayTime = 300;
        _this.mScene = scene;
        _this.mWorld = world;
        _this.textConfig = config;
        _this.mTextField = scene.make.text({
            x: config.x || 0,
            y: config.y || 0,
            stroke: "#000000",
            strokeThickness: 2,
            align: config.align || "left",
            style: {
                color: config.color || "#fff",
                font: config.font || "16px YaHei",
                wordWrap: {
                    width: config.textWidt || null,
                }
            }
        }, false).setInteractive(new Phaser.Geom.Rectangle(0, 0, config.textWidth, config.textHeight), Phaser.Geom.Rectangle.Contains);
        _this.mTextField.setOrigin(0.5, 0.5);
        _this.mTextField.setAlign(config.align);
        _this.mTextField.setText(config.text || "");
        _this.mTextField.on("pointerdown", _this.showText, _this);
        return _this;
    }
    InputTextField.prototype.onBlur = function () {
        this.mInputText.onBlur();
    };
    InputTextField.prototype.onFocus = function () {
        this.mInputText.onFocus();
    };
    InputTextField.prototype.getText = function () {
        return this.mTextField.text;
    };
    InputTextField.prototype.getSkin = function () {
        return this.mTextField;
    };
    InputTextField.prototype.destroy = function () {
        if (this.mInputText) {
            this.mInputText.destroy();
        }
        this.mInputText = null;
    };
    InputTextField.prototype.showText = function () {
        var _this = this;
        var textX = this.textConfig.posType === 1 ? -this.textConfig.textWidth >> 1 : -this.mWorld.getSize().width >> 1;
        var defaultText = this.mTextField.text && this.mTextField.text.length > 0 ?
            this.mTextField.text : this.textConfig.minNum;
        if (!this.mInputText) {
            this.mInputText = new InputText["a" /* default */](this.mScene, {
                id: this.textConfig.id || "input",
                x: textX || 0,
                y: this.textConfig.y || 0,
                width: this.textConfig.textWidth || 100,
                height: this.textConfig.textHeight || 100,
                type: this.textConfig.type || "",
                fontSize: this.textConfig.font || "16px YaHei",
                color: this.textConfig.color || "#fff",
                "z-index": 999,
                align: "left",
                text: defaultText,
                posType: this.textConfig.posType
            });
            this.mInputText.setOrigin(0, 0.6);
        }
        else {
            this.mInputText.setText(defaultText);
        }
        // 0 顶部 1 当前文本位置
        if (this.textConfig.posType === 1) {
            this.mTextField.visible = false;
            if (!this.mInputText.parentContainer)
                this.mTextField.parentContainer.add(this.mInputText);
        }
        this.mInputText.visible = true;
        this.mInputText.on("textchange", this.onTextchange, this);
        this.mInputText.on("onclick", this.onTextClick, this);
        this.mInputText.on("ondblclick", this.onTextDbclick, this);
        this.mInputText.on("focus", this.onTextFocus, this);
        this.mInputText.on("blur", this.onTextBlur, this);
        // 监听键盘enter事件，移动端会监听软件盘的enter事件
        this.mInputText.node.addEventListener("keypress", function (e) {
            var keycode = e.keyCode || e.which;
            if (keycode === 13) {
                _this.emit(InputTextFieldEvent.textExit);
                _this.hideText();
            }
        });
        this.mScene.input.on("gameobjectdown", this.sceneDown, this);
        if (this.mWorld.game.device.os.iOS && !this.mWorld.game.device.os.desktop) {
            this.setInputFocus();
        }
        else {
            this.mInputTimeID = this.mScene.setTimeout(function () {
                _this.setInputFocus();
            }, this.mDelayTime);
        }
    };
    InputTextField.prototype.hideText = function () {
        this.mTextField.visible = true;
        if (!this.mInputText)
            return;
        this.mInputText.off("textchange", this.onTextchange, this);
        this.mInputText.off("onclick", this.onTextClick, this);
        this.mInputText.off("ondblclick", this.onTextDbclick, this);
        this.mInputText.off("focus", this.onTextFocus, this);
        this.mInputText.off("blur", this.onTextBlur, this);
        this.mScene.input.off("gameobjectdown", this.sceneDown, this);
        var text = this.mInputText.text;
        if (text.length > 0) {
            this.mTextField.setText(text);
        }
        this.mInputText.setText("");
        this.mInputText.setBlur();
        this.mInputText.visible = false;
        if (this.mInputTimeID) {
            this.mScene.clearTimeout(this.mInputTimeID);
        }
        if (this.textConfig.posType === 1) {
            this.mTextField.visible = true;
        }
    };
    InputTextField.prototype.setInputFocus = function () {
        // 从dom中获取对应id的输入文本
        var input = document.all.namedItem(this.textConfig.id);
        if (input) {
            input.focus();
        }
    };
    InputTextField.prototype.sceneDown = function (pointer, gameobject) {
        if (gameobject && gameobject === this.mTextField) {
            return;
        }
        this.onTextBlur();
    };
    InputTextField.prototype.onTextchange = function () {
        if (this.textConfig.type === "number") {
            var num = Number(this.mInputText.text);
            if (isNaN(num)) {
                num = 0;
            }
            if (this.textConfig.minNum && this.textConfig.maxNum) {
                if (num < this.textConfig.minNum) {
                    num = this.textConfig.minNum;
                }
                else if (num > this.textConfig.maxNum) {
                    num = this.textConfig.maxNum;
                }
            }
            this.mInputText.text = num + "";
        }
        this.emit(InputTextFieldEvent.textchange);
    };
    InputTextField.prototype.onTextClick = function () {
        this.emit(InputTextFieldEvent.textclick);
    };
    InputTextField.prototype.onTextDbclick = function () {
        this.emit(InputTextFieldEvent.textdblclick);
    };
    InputTextField.prototype.onTextFocus = function () {
        this.onFocus();
        this.emit(InputTextFieldEvent.textfocus);
    };
    InputTextField.prototype.onTextBlur = function () {
        this.onBlur();
        this.hideText();
        this.emit(InputTextFieldEvent.textblur);
    };
    return InputTextField;
}(Phaser.Events.EventEmitter));


// CONCATENATED MODULE: ./src/rooms/Animation/ianimationbase.ts
var AnimationUrlData = /** @class */ (function () {
    function AnimationUrlData() {
    }
    AnimationUrlData.prototype.setData = function (resName, resUrl, isbone, extension) {
        if (isbone === void 0) { isbone = false; }
        if (extension === void 0) { extension = ".json"; }
        this.resName = resName;
        this.resUrl = resUrl;
        this.pngUrl = resUrl + "/" + resName + (!isbone ? ".png" : "_tex.png");
        this.jsonUrl = resUrl + "/" + resName + (!isbone ? ".json" : "_tex.json");
        if (isbone)
            this.boneUrl = resUrl + "/" + resName + "_ske" + extension;
        this.responseType = extension === ".dbbin" ? "arraybuffer" : null;
        this.boneXhrSettings = this.responseType ? { responseType: "arraybuffer" } : null;
    };
    AnimationUrlData.prototype.setDisplayData = function (pngUrl, jsonUrl, extension) {
        if (extension === void 0) { extension = ".json"; }
        this.pngUrl = pngUrl;
        this.jsonUrl = jsonUrl;
        this.responseType = extension === ".dbbin" ? "arraybuffer" : null;
        this.boneXhrSettings = this.responseType ? { responseType: "arraybuffer" } : null;
    };
    AnimationUrlData.prototype.dispose = function () {
        this.textureXhrSettings = null;
        this.atlasXhrSettings = null;
        this.boneXhrSettings = null;
    };
    return AnimationUrlData;
}());


// CONCATENATED MODULE: ./src/rooms/Animation/bubble.animation.ts
var bubble_animation_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var bubble_animation_BubbleAnimation = /** @class */ (function (_super) {
    bubble_animation_extends(BubbleAnimation, _super);
    function BubbleAnimation(scene) {
        var _this = _super.call(this, scene) || this;
        _this.loaded = false;
        _this.isPlaying = false;
        _this.loop = false;
        return _this;
    }
    BubbleAnimation.prototype.load = function (resName, resUrl, data) {
        this.resName = resName ? resName : resUrl;
        this.resUrl = resUrl;
        this.animUrlData = new AnimationUrlData();
        if (resName)
            this.animUrlData.setData(this.resName, this.resUrl);
        else
            this.animUrlData.setDisplayData(resUrl, data);
        this.scene.load.image(this.resName, this.animUrlData.pngUrl);
        this.scene.load.image(this.animUrlData.jsonUrl, this.animUrlData.jsonUrl);
        this.scene.load.once(Phaser.Loader.Events.COMPLETE, this.onLoadComplete, this);
        this.scene.load.start();
    };
    BubbleAnimation.prototype.play = function (aniName) {
        this.isPlaying = true;
        if (!this.frameAnim)
            return;
        this.setScale(0.2, 0.2);
        this.y = 50;
        this.scene.tweens.add({
            targets: this,
            y: { value: -100, duration: 300, ease: "Bounce.easeOut" },
            scaleX: { value: 1, duration: 300, ease: "Bounce.easeOut" },
            scaleY: { value: 1, duration: 300, ease: "Bounce.easeOut" },
        });
    };
    BubbleAnimation.prototype.destroy = function () {
        if (this.frameAnim)
            this.frameAnim.destroy();
        if (this.bubblebg)
            this.bubblebg.destroy();
        if (this.animUrlData)
            this.animUrlData.dispose();
        this.frameAnim = null;
        this.animUrlData = null;
        this.bubblebg = null;
    };
    BubbleAnimation.prototype.onLoadComplete = function (loader, totalComplete, totalFailed) {
        this.loaded = true;
        this.bubblebg = this.scene.add.image(0, 0, this.resName);
        this.frameAnim = this.scene.add.image(0, 0, this.animUrlData.jsonUrl);
        this.add([this.bubblebg, this.frameAnim]);
        if (this.isPlaying)
            this.play();
    };
    return BubbleAnimation;
}(Phaser.GameObjects.Container));


// CONCATENATED MODULE: ./src/ui/Bubble/interactionbubble.ts
var interactionbubble_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var interactionbubble_InteractionBubble = /** @class */ (function (_super) {
    interactionbubble_extends(InteractionBubble, _super);
    function InteractionBubble(scene, dpr) {
        var _this = _super.call(this, scene) || this;
        _this.mWdith = 78;
        _this.mHeight = 78;
        _this.width = _this.mWdith * dpr;
        _this.height = _this.mHeight * dpr;
        return _this;
    }
    InteractionBubble.prototype.setContentData = function (content, handler) {
        this.content = content;
        if (this.handler)
            this.handler.clear();
        this.handler = handler;
    };
    InteractionBubble.prototype.load = function (resName, url, jsonUrl) {
        this.createAnimation();
        this.mBubbleAni.load(resName, url, jsonUrl);
        this.mBubbleAni.play();
    };
    InteractionBubble.prototype.show = function () {
        if (this.mBubbleAni) {
            this.add(this.mBubbleAni);
        }
        this.removeDelay();
    };
    InteractionBubble.prototype.hide = function () {
        if (this.mBubbleAni) {
            this.remove(this.mBubbleAni);
        }
        if (this.mRemoveDelay) {
            clearTimeout(this.mRemoveDelay);
            this.mRemoveDelay = null;
        }
    };
    InteractionBubble.prototype.destroy = function () {
        this.hide();
        if (this.mBubbleAni) {
            this.mBubbleAni.destroy();
        }
        if (this.handler)
            this.handler.clear();
        this.mBubbleAni = null;
        this.handler = null;
        _super.prototype.destroy.call(this);
    };
    InteractionBubble.prototype.createAnimation = function () {
        // this.mBubbleAni = new DragonbonesAnimation(this.scene);
        // this.mBubbleAni = new FrameAnimation(this.scene);
        this.mBubbleAni = new bubble_animation_BubbleAnimation(this.scene);
        this.mBubbleAni.width = this.width;
        this.mBubbleAni.height = this.height;
        var POINTER_DOWN = Phaser.Input.Events.POINTER_DOWN;
        this.mBubbleAni.setInteractive(new Phaser.Geom.Rectangle(0, 0, this.mBubbleAni.width * 2, this.mBubbleAni.height * 2), Phaser.Geom.Rectangle.Contains);
        this.mBubbleAni.on(POINTER_DOWN, this.onBubbleClick, this);
    };
    InteractionBubble.prototype.onBubbleClick = function () {
        if (this.handler)
            this.handler.runWith(this.content);
    };
    InteractionBubble.prototype.removeDelay = function () {
        var _this = this;
        this.mRemoveDelay = setTimeout(function () {
            if (_this.handler)
                _this.handler.runWith(_this.content.id);
            _this.hide();
        }, this.content.duration);
    };
    return InteractionBubble;
}(Phaser.GameObjects.Container));


// EXTERNAL MODULE: ./lib/rexui/lib/ui/baseUI/BaseUI.ts
var BaseUI = __webpack_require__(38);

// CONCATENATED MODULE: ./src/ui/Bubble/interactionbubble.container.ts
var interactionbubble_container_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var interactionbubble_container_InteractionBubbleContainer = /** @class */ (function (_super) {
    interactionbubble_container_extends(InteractionBubbleContainer, _super);
    function InteractionBubbleContainer(scene, dpr) {
        return _super.call(this, scene) || this;
    }
    Object.defineProperty(InteractionBubbleContainer.prototype, "show", {
        get: function () {
            return this.mShow;
        },
        set: function (value) {
            this.mShow = value;
        },
        enumerable: false,
        configurable: true
    });
    InteractionBubbleContainer.prototype.hide = function () {
        this.mShow = false;
        if (this.parentContainer) {
            this.parentContainer.remove(this);
        }
    };
    InteractionBubbleContainer.prototype.setFollow = function (gameObject, fromScene, posFunc) {
        _super.prototype.setFollow.call(this, gameObject, fromScene, posFunc);
    };
    InteractionBubbleContainer.prototype.setBubble = function (content, handler) {
        this.id = content.id;
        var resName = content.display["resName"];
        var resUrl = content.display.texturePath;
        var jsonUrl = content.display.dataPath;
        if (!this.mBubble) {
            this.mBubble = new interactionbubble_InteractionBubble(this.scene, this.dpr);
            this.mBubble.load(resName, resUrl, jsonUrl);
            this.add(this.mBubble);
        }
        this.mBubble.setContentData(content, handler);
        this.mBubble.show();
        return this.mBubble;
    };
    InteractionBubbleContainer.prototype.destroy = function () {
        this.hide();
        if (this.mBubble)
            this.mBubble.destroy();
        this.mBubble = null;
        _super.prototype.destroy.call(this);
    };
    return InteractionBubbleContainer;
}(BaseUI["a" /* BaseUI */]));


// EXTERNAL MODULE: ./src/Handler/Handler.ts
var Handler = __webpack_require__(52);

// EXTERNAL MODULE: ./src/utils/pos.ts
var utils_pos = __webpack_require__(6);

// EXTERNAL MODULE: ./src/scenes/play.ts
var play = __webpack_require__(37);

// EXTERNAL MODULE: ./src/utils/tool.ts
var tool = __webpack_require__(44);

// CONCATENATED MODULE: ./src/ui/Bubble/interactivebubble.manager.ts
var interactivebubble_manager_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();









var interactivebubble_manager_InteractiveBubbleManager = /** @class */ (function (_super) {
    interactivebubble_manager_extends(InteractiveBubbleManager, _super);
    function InteractiveBubbleManager(layerMgr, mworld) {
        var _this = _super.call(this) || this;
        _this.map = new Map();
        _this.uilayer = layerMgr;
        _this.mworld = mworld;
        _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_SHOW_INTERACTIVE_BUBBLE, _this.onInteractiveBubble);
        _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORDL_REQ_CLIENT_REMOVE_INTERACTIVE_BUBBLE, _this.onClearInteractiveBubble);
        return _this;
    }
    InteractiveBubbleManager.prototype.setScene = function (scene) {
        this.connection.removePacketListener(this);
        this.scene = scene;
        this.connection.addPacketListener(this);
    };
    Object.defineProperty(InteractiveBubbleManager.prototype, "connection", {
        get: function () {
            if (this.mworld) {
                return this.mworld.connection;
            }
            log["a" /* Logger */].getInstance().log("roomManager is undefined");
            return;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(InteractiveBubbleManager.prototype, "currentRoom", {
        get: function () {
            return this.mworld.roomManager.currentRoom;
        },
        enumerable: false,
        configurable: true
    });
    InteractiveBubbleManager.prototype.destroy = function () {
        this.connection.removePacketListener(this);
        if (this.map) {
            for (var key in this.map) {
                var bubble = this.map.get(Number(key));
                if (bubble)
                    bubble.destroy();
            }
            this.map.clear();
        }
        if (this.mCurRoom)
            this.mCurRoom.frameManager.remove(this, this.update);
        this.map = null;
        this.mBubble = null;
        this.scene = null;
        this.uilayer = null;
        this.mworld = null;
    };
    InteractiveBubbleManager.prototype.onInteractiveBubble = function (packet) {
        var content = packet.content;
        if (this.mCurRoom !== this.currentRoom) {
            if (this.mCurRoom)
                this.mCurRoom.frameManager.remove(this, this.update);
            this.mCurRoom = this.currentRoom;
            this.mCurRoom.frameManager.add(this, this.update);
        }
        var element = this.currentRoom.elementManager.get(content.receiverId);
        if (!element)
            element = this.currentRoom.playerManager.get(content.receiverId);
        if (element) {
            this.showInteractionBubble(content, element);
        }
    };
    InteractiveBubbleManager.prototype.onClearInteractiveBubble = function (packet) {
        var content = packet.content;
        for (var _i = 0, _a = content.ids; _i < _a.length; _i++) {
            var id = _a[_i];
            this.clearInteractionBubble(id);
        }
    };
    InteractiveBubbleManager.prototype.clearInteractionBubble = function (id) {
        if (this.map.has(id)) {
            var bubble = this.map.get(id);
            bubble.destroy();
            this.map.delete(id);
        }
    };
    InteractiveBubbleManager.prototype.showInteractionBubble = function (content, ele) {
        var _this = this;
        var dpr = Math.round(this.mworld.uiRatio || 1);
        content.display["resName"] = null; // "gems";
        content.display.texturePath = resUtil["c" /* Url */].getUIRes(dpr, "bubble/bubblebg.png"); // "resources/test/columns";
        content.display.dataPath = resUtil["c" /* Url */].getUIRes(dpr, "bubble/tipsicon.png"); // "resources/test/columns";
        var key = content.id;
        if (this.mBubble)
            this.mBubble.hide();
        if (this.map.has(key)) {
            this.mBubble = this.map.get(key);
        }
        else {
            this.mBubble = new interactionbubble_container_InteractionBubbleContainer(this.scene, dpr);
            this.map.set(key, this.mBubble);
        }
        this.mBubble.setBubble(content, new Handler["a" /* Handler */](this, this.onInteractiveBubbleHandler));
        var playScene = this.mworld.game.scene.getScene(play["a" /* PlayScene */].name);
        this.updateBublePos(ele, playScene);
        this.mBubble.setFollow(ele, playScene, function (obj) {
            _this.updateBublePos(ele, obj.scene);
        });
        this.mBubble.show = true;
        this.uilayer.addToDialogLayer(this.mBubble);
    };
    InteractiveBubbleManager.prototype.updateBublePos = function (gameObject, scene) {
        var dpr = this.mworld.uiRatio;
        var zoom = this.mworld.uiScale;
        var position = gameObject.getDisplay().getWorldTransformMatrix();
        if (position) {
            var pos = tool["a" /* Tool */].getPosByScenes(scene, new utils_pos["a" /* Pos */](position.tx, (position.ty - 33 * dpr * zoom)));
            this.mBubble.setPosition(pos.x, pos.y);
        }
    };
    InteractiveBubbleManager.prototype.onInteractiveBubbleHandler = function (data) {
        if (typeof data === "number") {
            this.clearInteractionBubble(data);
            return;
        }
        var connection = this.connection;
        var packet = new dist["PBpacket"](protocols["op_virtual_world"].OPCODE._OP_CLIENT_RES_VIRTUAL_WORLD_ACTIVE_BUBBLE);
        var content = packet.content;
        content.id = data.id;
        //  content.receiverId = data.receiverId;
        connection.send(packet);
    };
    InteractiveBubbleManager.prototype.update = function () {
        if (!this.map)
            return;
        this.map.forEach(function (bubble) {
            if (bubble && bubble.show)
                bubble.updatePos();
        });
    };
    return InteractiveBubbleManager;
}(dist["PacketHandler"]));


// EXTERNAL MODULE: ./src/const/MessageType.ts
var MessageType = __webpack_require__(12);

// CONCATENATED MODULE: ./src/ui/ui.manager.ts
var ui_manager_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




// import { RightMediator } from "./baseView/rightGroup/right.mediator";
// import { LeftMediator } from "./baseView/leftGroup/left.mediator";
// import { BottomMediator } from "./baseView/bottomGroup/bottom.mediator";
// import { BagGroupMediator } from "./baseView/bagGroup/bag.group.mediator";
// import { TopMenuMediator } from "./baseView/top.menu/top.menu.mediator";
// import { MessageType } from "../const/MessageType";
// import { InputTextFactory } from "./components/inputTextFactory";
// import { DecorateControlMediator } from "./DecorateControl/DecorateControlMediator";
// import { PicaMainUIMediator } from "./PiCaMainUI/PicaMainUIMediator";
// import { ActivityMediator } from "./Activity/ActivityMediator";
// import { PicaChatMediator } from "./PicaChat/PicaChatMediator";
// import { PicaNavigateMediator } from "./PicaNavigate/PicaNavigateMediator";
// import { MineCarMediator } from "./MineCar/MineCarMediator";
// import { InteractiveBubbleManager } from "./Bubble/interactivebubble.manager";
// import { BaseMediator } from "../../lib/rexui/lib/ui/baseUI/BaseMediator";




// import { UIType } from "../../lib/rexui/lib/ui/interface/baseUI/UIType";
// import { ReAwardTipsMediator } from "./ReAwardTips/ReAwardTipsMediator";
// export const enum UIType {
//     NoneUIType,
// Scene, // 场景内常驻ui
// Normal, // 普通功能ui
// Pop, // 弹出型ui
// Tips, // tips型ui
// Monopoly, // 独占型ui
// Activity, // 热发布活动类型ui，便于单独刷新活动ui
// }
var ui_manager_UiManager = /** @class */ (function (_super) {
    ui_manager_extends(UiManager, _super);
    function UiManager(worldService) {
        var _this = _super.call(this) || this;
        _this.worldService = worldService;
        _this.mCache = [];
        _this.mNoneUIMap = new Map();
        _this.mSceneUIMap = new Map();
        _this.mNormalUIMap = new Map();
        _this.mPopUIMap = new Map();
        _this.mTipUIMap = new Map();
        _this.mMonopolyUIMap = new Map();
        _this.mActivityUIMap = new Map();
        // 用于记录功能ui打开的顺序,最多2个
        _this.mShowuiList = [];
        _this.mConnect = worldService.connection;
        _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_RES_CLIENT_SHOW_UI, _this.handleShowUI);
        _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_RES_CLIENT_UPDATE_UI, _this.handleUpdateUI);
        _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_RES_CLIENT_CLOSE_UI, _this.handleCloseUI);
        _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_ENABLE_MARKET, _this.onEnableMarket);
        _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_MINING_MODE_SHOW_REWARD_PACKAGE, _this.openMineSettle);
        _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_MINING_MODE_SHOW_SELECT_EQUIPMENT_PANEL, _this.openEquipUpgrade);
        _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_RES_CLIENT_PKT_CRAFT_SKILLS, _this.openComposePanel);
        // this.addHandlerFun(op_client.OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_ENABLE_EDIT_MODE, this.onEnableEditMode);
        _this.mUILayerManager = new LayerManager();
        _this.mInputTextFactory = new InputTextFactory(worldService);
        _this.interBubbleMgr = new interactivebubble_manager_InteractiveBubbleManager(_this.mUILayerManager, _this.worldService);
        return _this;
    }
    UiManager.prototype.getInputTextFactory = function () {
        return this.mInputTextFactory;
    };
    UiManager.prototype.addPackListener = function () {
        if (this.mConnect) {
            this.mConnect.addPacketListener(this);
            this.worldService.emitter.on(MessageType["a" /* MessageType */].SHOW_UI, this.handleShowUI, this);
        }
    };
    UiManager.prototype.removePackListener = function () {
        if (this.mConnect) {
            this.mConnect.removePacketListener(this);
            this.worldService.emitter.off(MessageType["a" /* MessageType */].SHOW_UI, this.handleShowUI, this);
        }
    };
    UiManager.prototype.getUILayerManager = function () {
        return this.mUILayerManager;
    };
    UiManager.prototype.setScene = function (scene) {
        this.mScene = scene;
        this.mUILayerManager.setScene(scene);
        this.interBubbleMgr.setScene(scene);
        if (this.mCacheUI) {
            this.mCacheUI();
            this.mCacheUI = undefined;
        }
    };
    UiManager.prototype.showMainUI = function () {
        if (!this.mScene) {
            this.mCacheUI = this.showMainUI;
            return;
        }
        var scene = this.mScene;
        this.clearMediator();
        if (!this.mMedMap) {
            this.mMedMap = new Map();
            // ============场景中固定显示ui
            if (this.worldService.game.device.os.desktop) {
                // this.mMedMap.set(BagGroupMediator.NAME, new BagGroupMediator(this.worldService, scene));
            }
            else {
                // this.mMedMap.set(ActivityMediator.name, new ActivityMediator(this.mUILayerManager, scene, this.worldService));
                // this.mMedMap.set(PicaMainUIMediator.name, new PicaMainUIMediator(this.mUILayerManager, scene, this.worldService));
                // this.mMedMap.set(PicaChatMediator.name, new PicaChatMediator(this.mUILayerManager, scene, this.worldService));
                // this.mMedMap.set(PicaNavigateMediator.name, new PicaNavigateMediator(this.mUILayerManager, scene, this.worldService));
                // this.mMedMap.set(MineCarMediator.name, new MineCarMediator(this.mUILayerManager, scene, this.worldService));
            }
            // this.mMedMap.set(UIMediatorType.BagMediator, new BagMediator(this.mUILayerManager, this.worldService, scene));
            if (this.worldService.game.device.os.desktop)
                this.mMedMap.set(UIMediatorType.ChatMediator, new chat_mediator_ChatMediator(this.worldService, scene));
            // this.mMedMap.set(UIMediatorType.NOTICE, new NoticeMediator(this.mUILayerManager, scene, this.worldService));
            // this.mMedMap.set(FriendMediator.NAME, new FriendMediator(scene, this.worldService));
            // this.mMedMap.set(ReAwardTipsMediator.name, new ReAwardTipsMediator(scene, this.worldService));
            for (var _i = 0, _a = this.mCache; _i < _a.length; _i++) {
                var tmp = _a[_i];
                var ui = tmp[0];
                this.showMed(ui.name, ui);
            }
            this.mCache.length = 0;
        }
        // TOOD 通过统一的方法创建打开
        this.mMedMap.forEach(function (mediator, key) {
            // let map: Map<string, any>;
            // const deskBoo: boolean = this.worldService.game.device.os.desktop ? true : false;
            // switch (key) {
            //     case LeftMediator.NAME:
            //     case RightMediator.NAME:
            //     case BottomMediator.NAME:
            //         map = this.mSceneUIMap;
            //         break;
            //     // case TopMediator.NAME:
            //     //     if (deskBoo) {
            //     //         map = this.mSceneUIMap;
            //     //     }
            //     //     break;
            //     case BagGroupMediator.NAME:
            //         if (deskBoo) {
            //             map = this.mSceneUIMap;
            //         }
            //         break;
            //     case UIMediatorType.ChatMediator:
            //         if (deskBoo) {
            //             map = this.mSceneUIMap;
            //         }
            //         break;
            //     case RankMediator.NAME:
            //         if (deskBoo) {
            //             map = this.mSceneUIMap;
            //         }
            //         break;
            // }
            // if (map) map.set(key, mediator);
            if (mediator.isSceneUI()) {
                mediator.show();
            }
        });
    };
    UiManager.prototype.showDecorateUI = function () {
        if (!this.mScene) {
            this.mCacheUI = this.showDecorateUI;
            return;
        }
        this.clearMediator();
        if (!this.mMedMap) {
            this.mMedMap = new Map();
        }
        // const topMenu = new TopMenuMediator(this.mScene, this.worldService);
        // this.mMedMap.set(ElementStorageMediator.NAME, new ElementStorageMediator(this.mUILayerManager, this.mScene, this.worldService));
        // this.mMedMap.set(DecorateControlMediator.NAME, new DecorateControlMediator(this.mUILayerManager, this.mScene, this.worldService));
        // this.mMedMap.set(UIMediatorType.NOTICE, new NoticeMediator(this.mUILayerManager, this.mScene, this.worldService));
        // this.mMedMap.set(TopMenuMediator.name, topMenu);
        // topMenu.addItem({
        //     key: "Turn_Btn_Top", name: "SaveDecorate", bgResKey: "baseView", bgTextures: ["btnGroup_yellow_normal.png", "btnGroup_yellow_light.png", "btnGroup_yellow_select.png"],
        //     iconResKey: "", iconTexture: "btnGroup_top_expand.png", scale: 1, pngUrl: "ui/baseView/mainui_mobile.png", jsonUrl: "ui/baseView/mainui_mobile.json"
        // });
        this.showAll();
    };
    UiManager.prototype.resize = function (width, height) {
        if (this.mMedMap) {
            // this.mMedMap.forEach((mediator: BaseMediator) => {
            //     if (mediator.isShow) mediator.resize();
            // });
        }
    };
    UiManager.prototype.setMediator = function (value, mediator) {
        this.mMedMap.set(value, mediator);
    };
    UiManager.prototype.getMediator = function (type) {
        if (!this.mMedMap)
            return;
        return this.mMedMap.get(type);
    };
    UiManager.prototype.clearMediator = function () {
        if (!this.mMedMap) {
            return;
        }
        this.mMedMap.forEach(function (med) { return med.destroy(); });
        this.mMedMap.clear();
        this.mMedMap = null;
    };
    UiManager.prototype.destroy = function () {
        this.removePackListener();
        this.clearMediator();
        this.mMedMap = undefined;
        this.mScene = undefined;
    };
    UiManager.prototype.baseFaceResize = function () {
        // const bottomMed = this.getMediator(BottomMediator.NAME);
        // const rightMed = this.getMediator(RightMediator.NAME);
        // const leftMed = this.getMediator(LeftMediator.NAME);
        // // const topMed = this.getMediator(TopMediator.NAME);
        // if (rightMed && rightMed.getView()) rightMed.getView().resize(0, 0);
        // if (leftMed && leftMed.getView()) leftMed.getView().resize(0, 0);
        // if (bottomMed && bottomMed.getView()) bottomMed.getView().resize(0, 0);
        // // if (topMed && topMed.getView()) topMed.getView().resize(0, 0);
    };
    UiManager.prototype.baseFaceTween = function (show) {
        // if (!this.worldService.game.device.os.desktop) {
        //     (this.worldService.inputManager as JoyStickManager).tweenExpand(show);
        // }
        // const rightMed = this.getMediator(RightMediator.NAME);
        // const leftMed = this.getMediator(LeftMediator.NAME);
        // const bottomMed = this.getMediator(BottomMediator.NAME);
        // // const topMed = this.getMediator(TopMediator.NAME);
        // if (rightMed && rightMed.getView()) rightMed.getView().tweenExpand(show);
        // if (leftMed && leftMed.getView()) leftMed.getView().tweenExpand(show);
        // if (bottomMed && bottomMed.getView()) bottomMed.getView().tweenExpand(show);
        // // if (topMed && topMed.getView()) topMed.getView().tweenExpand(show);
    };
    UiManager.prototype.checkUIState = function (medName, show) {
        // const mediator = this.mMedMap.get(medName);
        // if (!mediator) return;
        // const uiType: number = mediator.UIType;
        // const deskBoo: boolean = this.worldService.game.device.os.desktop;
        // let map: Map<string, any>;
        // switch (uiType) {
        //     case UIType.None:
        //         map = this.mNoneUIMap;
        //         break;
        //     case UIType.Scene:
        //         map = this.mSceneUIMap;
        //         break;
        //     case UIType.Normal:
        //         map = this.mNormalUIMap;
        //         // pc端场景ui无需收进，但是功能ui可以共存，需要调整位置
        //         if (deskBoo) {
        //             this.checkNormalUITween(show, medName);
        //         } else {
        //             this.checkBaseUImap(show);
        //         }
        //         break;
        //     case UIType.Monopoly:
        //         map = this.mMonopolyUIMap;
        //         this.checkBaseUImap(show);
        //         this.checkNormalUImap(show);
        //         this.chekcTipUImap(show);
        //         break;
        //     case UIType.Tips:
        //         map = this.mTipUIMap;
        //         break;
        //     case UIType.Pop:
        //         map = this.mPopUIMap;
        //         break;
        //     case UIType.Activity:
        //         map = this.mActivityUIMap;
        //         break;
        // }
        // map.set(medName, mediator);
    };
    UiManager.prototype.showMed = function (type) {
        var param = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            param[_i - 1] = arguments[_i];
        }
        // if (!this.mMedMap) {
        //     this.mCache.push(param);
        //     return;
        // }
        // if (type === "MessageBox") {
        //     type = "PicaMessageBox";
        // }
        // const className: string = type + "Mediator";
        // let mediator: BaseMediator = this.mMedMap.get(className);
        // if (!mediator) {
        //     const path: string = `./${type}/${type}Mediator`;
        //     const ns: any = require(`./${type}/${className}`);
        //     mediator = new ns[className](this.mUILayerManager, this.mScene, this.worldService);
        //     if (!mediator) {
        //         // Logger.getInstance().error(`error ${type} no panel can show!!!`);
        //         return;
        //     }
        //     this.mMedMap.set(type + "Mediator", mediator);
        //     // mediator.setName(type);
        // }
        // // if (mediator.showing) return;
        // if (param) mediator.setParam(param);
        // // if (className === "RankMediator") {
        // //     if (!this.worldService.game.device.os.desktop) {
        // //         const med: TopMediator = this.getMediator(TopMediator.NAME) as TopMediator;
        // //         if (med) {
        // //             if (!med.isShow()) {
        // //                 med.preRefreshBtn(className);
        // //             } else {
        // //                 med.refreshBtn(className, true);
        // //             }
        // //         }
        // //         return;
        // //     }
        // // }
        // this.checkUIState(className, false);
        // mediator.show(param);
    };
    UiManager.prototype.handleShowUI = function (packet) {
        var ui = packet.content;
        this.showMed(ui.name, ui);
    };
    UiManager.prototype.handleUpdateUI = function (packet) {
        var ui = packet.content;
        this.updateMed(ui.name, ui);
    };
    UiManager.prototype.handleCloseUI = function (packet) {
        var ui = packet.content;
        this.hideMed(ui.name);
    };
    UiManager.prototype.onEnableEditMode = function (packet) {
        // let topMenu: TopMenuMediator = <TopMenuMediator>this.mMedMap.get(TopMenuMediator.NAME);
        // if (!topMenu) {
        //     topMenu = new TopMenuMediator(this.mScene, this.worldService);
        //     this.mMedMap.set(TopMenuMediator.NAME, topMenu);
        // }
        // topMenu.addItem({
        //     key: "Turn_Btn_Top", name: "EnterDecorate", bgResKey: "baseView", bgTextures: ["btnGroup_yellow_normal.png", "btnGroup_yellow_light.png", "btnGroup_yellow_select.png"],
        //     iconResKey: "", iconTexture: "btnGroup_top_expand.png", scale: 1, pngUrl: "ui/baseView/mainui_mobile.png", jsonUrl: "ui/baseView/mainui_mobile.json"
        // });
    };
    UiManager.prototype.onEnableMarket = function () {
        if (!this.mMedMap) {
            return;
        }
        // let topMenu: TopMenuMediator = <TopMenuMediator>this.mMedMap.get(TopMenuMediator.NAME);
        // if (!topMenu) {
        //     topMenu = new TopMenuMediator(this.mScene, this.worldService);
        //     this.mMedMap.set(TopMenuMediator.NAME, topMenu);
        // }
        // topMenu.addItem({
        //     key: "Turn_Btn_Top", name: "Market", bgResKey: "baseView", bgTextures: ["btnGroup_yellow_normal.png", "btnGroup_yellow_light.png", "btnGroup_yellow_select.png"],
        //     iconResKey: "", iconTexture: "btnGroup_top_expand.png", scale: 1, pngUrl: "ui/baseView/mainui_mobile.png", jsonUrl: "ui/baseView/mainui_mobile.json"
        // });
    };
    UiManager.prototype.checkBaseUImap = function (show) {
        this.mSceneUIMap.forEach(function (med) {
            if (med)
                med.tweenExpand(show);
        });
    };
    UiManager.prototype.checkNormalUITween = function (show, medName) {
        var size = this.worldService.getSize();
        var len = this.mShowuiList.length;
        var tmpName;
        var med;
        if (!show) {
            if (this.mShowuiList.indexOf(medName) === -1)
                this.mShowuiList.push(medName);
            len = this.mShowuiList.length;
            var mPad = len > 1 ? size.width / 3 : 0;
            for (var i = 0; i < len; i++) {
                tmpName = this.mShowuiList[i];
                med = this.mMedMap.get(tmpName);
                if (len > 2 && i === 0) {
                    med.hide();
                }
                else {
                    med.resize((i * 2 - 1) * mPad, 0);
                }
            }
            if (len > 2)
                this.mShowuiList.shift();
        }
        else {
            var index = void 0;
            for (var i = 0; i < len; i++) {
                tmpName = this.mShowuiList[i];
                med = this.mMedMap.get(tmpName);
                if (tmpName === medName) {
                    index = i;
                    continue;
                }
                med.resize(0, 0);
            }
            this.mShowuiList.splice(index, 1);
        }
    };
    UiManager.prototype.checkNormalUImap = function (show) {
        this.mNormalUIMap.forEach(function (med) {
            if (med) {
                if (show) {
                    // med.show();
                }
                else {
                    med.hide();
                }
            }
        });
        if (!show)
            this.mNormalUIMap.clear();
    };
    UiManager.prototype.chekcTipUImap = function (show) {
        this.mTipUIMap.forEach(function (med) {
            if (med) {
                if (show) {
                    // med.show();
                }
                else {
                    med.hide();
                }
            }
        });
        if (!show)
            this.mNormalUIMap.clear();
    };
    UiManager.prototype.updateMed = function (type) {
        var param = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            param[_i - 1] = arguments[_i];
        }
        if (!this.mMedMap) {
            return;
        }
        var name = type + "Mediator";
        var mediator = this.mMedMap.get(name);
        if (!mediator) {
            // Logger.getInstance().error(`error ${type} no panel can show!!!`);
            return;
        }
        if (param)
            mediator.setParam(param);
        mediator.update(param);
    };
    UiManager.prototype.hideMed = function (type) {
        if (!this.mMedMap) {
            return;
        }
        if (type === "MessageBox") {
            type = "PicaMessageBox";
        }
        var medName = type + "Mediator";
        var mediator = this.mMedMap.get(medName);
        if (!mediator) {
            // Logger.getInstance().error(`error ${type} no panel can show!!!`);
            return;
        }
        // if (!this.worldService.game.device.os.desktop && medName === "RankMediator") {
        //     const med: TopMediator = this.getMediator(TopMediator.NAME) as TopMediator;
        //     if (med) {
        //         if (!med.isShow()) {
        //             med.preRefreshBtn(medName);
        //         } else {
        //             med.refreshBtn(medName, true);
        //         }
        //     }
        // }
        // if (!mediator.isShow()) return;
        this.checkUIState(medName, true);
        mediator.hide();
    };
    UiManager.prototype.showAll = function () {
        if (!this.mMedMap) {
            return;
        }
        this.mMedMap.forEach(function (med) {
            if (med.isSceneUI()) {
                med.show();
            }
        });
    };
    UiManager.prototype.closeAll = function () {
        if (!this.mMedMap) {
            return;
        }
        this.mMedMap.forEach(function (med) { return med.hide(); });
    };
    UiManager.prototype.openMineSettle = function (packge) {
        var content = packge.content;
        this.showMed("MineSettle", content);
    };
    UiManager.prototype.openEquipUpgrade = function (packge) {
        var content = packge.content;
        this.showMed("EquipUpgrade", content);
    };
    UiManager.prototype.openComposePanel = function (packge) {
        var content = packge.content;
        this.showMed("Compose", content);
    };
    return UiManager;
}(dist["PacketHandler"]));


// CONCATENATED MODULE: ./src/ui/index.ts



/***/ }),
/* 199 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ room_manager_RoomManager; });

// UNUSED EXPORTS: Clock

// EXTERNAL MODULE: ./src/rooms/clock.ts + 1 modules
var clock = __webpack_require__(65);

// EXTERNAL MODULE: ./src/rooms/element/element.manager.ts
var element_manager = __webpack_require__(31);

// EXTERNAL MODULE: ./node_modules/net-socket-packet/dist/index.js
var dist = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/pixelpai_proto/protocols.js
var protocols = __webpack_require__(2);

// EXTERNAL MODULE: ./src/utils/log.ts
var log = __webpack_require__(5);

// EXTERNAL MODULE: ./src/utils/pos.ts
var utils_pos = __webpack_require__(6);

// EXTERNAL MODULE: ./src/rooms/element/sprite.ts
var element_sprite = __webpack_require__(13);

// EXTERNAL MODULE: ./src/const/MessageType.ts
var MessageType = __webpack_require__(12);

// EXTERNAL MODULE: ./src/rooms/element/index.ts
var rooms_element = __webpack_require__(36);

// CONCATENATED MODULE: ./src/rooms/player/player.ts
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var player_Player = /** @class */ (function (_super) {
    __extends(Player, _super);
    function Player(sprite, mElementManager) {
        var _this = _super.call(this, sprite, mElementManager) || this;
        _this.mElementManager = mElementManager;
        _this.nodeType = protocols["op_def"].NodeType.CharacterNodeType;
        _this.mOffsetY = undefined;
        if (_this.mDisplay) {
            if (sprite.displayBadgeCards && sprite.displayBadgeCards.length > 0)
                _this.mDisplay.setDisplayBadges(sprite.displayBadgeCards);
        }
        return _this;
    }
    Player.prototype.setModel = function (val) {
        _super.prototype.setModel.call(this, val);
        this.showNickName();
    };
    Player.prototype.move = function (moveData) {
        if (this.getDirection() !== moveData.direction) {
            if (this.roomService.world.moveStyle === protocols["op_def"].MoveStyle.DIRECTION_MOVE_STYLE) {
                if (this.mId !== this.roomService.playerManager.actor.id) {
                    this.setDirection(moveData.direction);
                }
            }
            else {
                this.setDirection(moveData.direction);
            }
        }
        moveData.destinationPoint3f.y += this.offsetY;
        _super.prototype.move.call(this, moveData);
    };
    Player.prototype.movePath = function (movePath) {
        var _this = this;
        if (!this.mDisplay) {
            return;
        }
        var tmpPath = movePath.path;
        if (!tmpPath) {
            return;
        }
        var lastPos = new utils_pos["a" /* Pos */](this.mDisplay.x, this.mDisplay.y - this.offsetY);
        var paths = [];
        this.mMoveData.arrivalTime = movePath.timestemp;
        var angle = null;
        var point = null;
        var now = this.mElementManager.roomService.now();
        var duration = 0;
        var index = 0;
        for (var _i = 0, tmpPath_1 = tmpPath; _i < tmpPath_1.length; _i++) {
            var path = tmpPath_1[_i];
            point = path.point3f;
            if (!(point.y === lastPos.y && point.x === lastPos.x)) {
                angle = Math.atan2(point.y - lastPos.y, point.x - lastPos.x) * (180 / Math.PI);
            }
            now += duration;
            duration = path.timestemp - now;
            paths.push({
                x: point.x,
                y: point.y + this.offsetY,
                duration: duration,
                onStartParams: angle,
                onStart: function (tween, target, params) {
                    _this.onCheckDirection(params);
                },
                onCompleteParams: { duration: duration, index: index },
                onComplete: function (tween, targets, params) {
                    _this.onMovePathPointComplete(params);
                }
            });
            lastPos = new utils_pos["a" /* Pos */](point.x, point.y);
            index++;
        }
        this.mMoveData.posPath = paths;
        this.mMoveData.onCompleteParams = point;
        this.mMoveData.onComplete = this.mMovePathPointFinished;
        this._doMove();
    };
    Player.prototype.setDirection = function (dir) {
        if (dir !== this.mDisplayInfo.avatarDir) {
            this.mDisplayInfo.avatarDir = dir;
            this.mModel.direction = dir;
            // if (this.mDisplay) this.mDisplay.play({ animationName: this.mCurState, flip: false });
            if (this.mDisplay) {
                this.mDisplay.play(this.mModel.currentAnimation);
            }
        }
    };
    Player.prototype.changeState = function (val) {
        if (!this.mDisplay) {
            return;
        }
        if (this.mCurState === val)
            return;
        // if (!val) val = PlayerState.IDLE;
        if (!val) {
            val = rooms_element["b" /* PlayerState */].IDLE;
        }
        if (this.mCheckStateHandle(val)) {
            this.mCurState = val;
            this.mModel.currentAnimationName = this.mCurState;
            this.mDisplay.play(this.mModel.currentAnimation);
        }
    };
    Player.prototype.setPosition = function (pos) {
        pos.y += this.offsetY;
        _super.prototype.setPosition.call(this, pos);
    };
    Player.prototype.getPosition = function () {
        var pos = _super.prototype.getPosition.call(this);
        pos.y -= this.offsetY;
        return pos;
    };
    Player.prototype.onCheckDirection = function (params) {
        if (typeof params !== "number") {
            return;
        }
        // 重叠
        if (params > 90) {
            this.setDirection(3);
        }
        else if (params >= 0) {
            this.setDirection(5);
        }
        else if (params >= -90) {
            this.setDirection(7);
        }
        else {
            this.setDirection(1);
        }
    };
    Player.prototype.onMoveStart = function () {
        this.changeState(rooms_element["b" /* PlayerState */].WALK);
        if (this.mMoveData) {
            this.mMoveData.step = 0;
        }
        _super.prototype.onMoveStart.call(this);
    };
    Player.prototype.onMoveComplete = function () {
        this.preMoveComplete();
        _super.prototype.onMoveComplete.call(this);
        this.changeState(rooms_element["b" /* PlayerState */].IDLE);
    };
    Player.prototype.preMoveComplete = function () {
        if (this.mMoveData && this.mMoveData.posPath) {
            var complete = this.mMoveData.onComplete;
            if (complete) {
                complete.call(this, this.mMoveData.onCompleteParams);
                delete this.mMoveData.onComplete;
                delete this.mMoveData.onCompleteParams;
            }
        }
    };
    Player.prototype.onMovePathPointComplete = function (params) {
        if (!this.mMoveData) {
            return;
        }
        this.mMoveData.step += 1;
        // if (!this.mMoveData.posPath) {
        //     return;
        // }
        // const posPath = this.mMoveData.posPath;
        // posPath.shift();
    };
    Player.prototype.mMovePathPointFinished = function (path) {
        if (!path || !this.mRoomService) {
            return;
        }
        var pkt = new dist["PBpacket"](protocols["op_virtual_world"].OPCODE._OP_CLIENT_REQ_VIRTUAL_WORLD_MOVE_PATH_POINT_FINISHED);
        var content = pkt.content;
        var currentPoint = protocols["op_def"].PBPoint3f.create();
        var pos = this.getPosition();
        currentPoint.x = pos.x;
        currentPoint.y = pos.y;
        currentPoint.z = pos.z;
        var targetPoint = protocols["op_def"].PBPoint3f.create();
        targetPoint.x = path.x;
        targetPoint.y = path.y;
        content.currentPoint = currentPoint;
        content.lastTargetPoint = targetPoint;
        content.timestemp = this.mRoomService.world.clock.unixTime;
        this.mRoomService.connection.send(pkt);
    };
    Object.defineProperty(Player.prototype, "offsetY", {
        get: function () {
            if (this.mOffsetY === undefined) {
                if (!this.mElementManager || !this.mElementManager.roomService || !this.mElementManager.roomService.roomSize) {
                    return 0;
                }
                // this.mOffsetY = 0;
                this.mOffsetY = this.mElementManager.roomService.roomSize.tileHeight >> 2;
            }
            return this.mOffsetY;
        },
        enumerable: false,
        configurable: true
    });
    Player.prototype.mCheckStateHandle = function (val) {
        // if (this.mCurState === val) return false;
        return true;
    };
    return Player;
}(rooms_element["a" /* Element */]));


// CONCATENATED MODULE: ./src/rooms/player/bag/bag.ts
var bag_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var bag_Bag = /** @class */ (function (_super) {
    bag_extends(Bag, _super);
    function Bag(mWorld) {
        var _this = _super.call(this) || this;
        _this.mWorld = mWorld;
        _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_RES_CLIENT_ADD_ITEM, _this.handleAddItem);
        _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_RES_CLIENT_REMOVE_ITEM, _this.handleRemoveItem);
        _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_RES_CLIENT_EXCHANGE_ITEM_POS, _this.handleExchangeItem);
        _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_RES_CLIENT_QUERY_PACKAGE, _this.handleQueryPackage);
        return _this;
    }
    Bag.prototype.initialize = function () {
        return this.mInitialize;
    };
    Bag.prototype.register = function () {
        this.mWorld.connection.addPacketListener(this);
    };
    Bag.prototype.unRegister = function () {
        this.mWorld.connection.removePacketListener(this);
    };
    Bag.prototype.destroy = function () {
        this.mInitialize = false;
        this.mWorld.connection.removePacketListener(this);
    };
    Bag.prototype.requestVirtualWorldQueryPackage = function (bagId, page, perPage) {
        var pkt = new dist["PBpacket"](protocols["op_virtual_world"].OPCODE._OP_CLIENT_REQ_VIRTUAL_WORLD_QUERY_PACKAGE);
        var content = pkt.content;
        content.id = bagId;
        content.page = page;
        content.perPage = perPage;
        this.mWorld.connection.send(pkt);
    };
    Bag.prototype.handleQueryPackage = function (packet) {
        var notice = packet.content;
        this.mInitialize = true;
        this.mWorld.emitter.emit(MessageType["a" /* MessageType */].QUERY_PACKAGE, notice);
    };
    Bag.prototype.handleAddItem = function (packet) {
        var content = packet.content;
        if (content.nodetype === protocols["op_def"].NodeType.ElementNodeType) {
            this.mWorld.roomManager.currentRoom.map.addPackItems(content.id, content.item);
        }
        else if (content.nodetype === protocols["op_def"].NodeType.CharacterNodeType) {
            this.mWorld.roomManager.currentRoom.playerManager.addPackItems(content.id, content.item);
        }
        this.mWorld.emitter.emit(MessageType["a" /* MessageType */].PACKAGE_ITEM_ADD, content);
    };
    Bag.prototype.handleRemoveItem = function (packet) {
        var content = packet.content;
        var len = content.itemId.length;
        for (var i = 0; i < len; i++) {
            this.mWorld.roomManager.currentRoom.playerManager.removePackItems(content.id, content.itemId[i]);
        }
        this.mWorld.emitter.emit(MessageType["a" /* MessageType */].UPDATED_CHARACTER_PACKAGE);
        this.mWorld.emitter.emit(MessageType["a" /* MessageType */].PACKAGE_ITEM_REMOVE, content);
    };
    Bag.prototype.handleExchangeItem = function (packet) {
        var content = packet.content;
        this.mWorld.emitter.emit(MessageType["a" /* MessageType */].PACKAGE_EXCHANGE_ITEM_POS, content);
    };
    return Bag;
}(dist["PacketHandler"]));


// CONCATENATED MODULE: ./src/rooms/player/interactive/interactive.ts
var interactive_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var interactive_Interactive = /** @class */ (function (_super) {
    interactive_extends(Interactive, _super);
    function Interactive(mWorld) {
        var _this = _super.call(this) || this;
        _this.mWorld = mWorld;
        return _this;
    }
    Interactive.prototype.initialize = function () {
        return this.mInitialize;
    };
    Interactive.prototype.register = function () {
        this.mWorld.connection.addPacketListener(this);
    };
    Interactive.prototype.unRegister = function () {
        this.mWorld.connection.removePacketListener(this);
    };
    Interactive.prototype.destroy = function () {
        this.mInitialize = false;
        this.mWorld.connection.removePacketListener(this);
    };
    Interactive.prototype.requestTargetUI = function (uiId, id) {
        var pkt = new dist["PBpacket"](protocols["op_virtual_world"].OPCODE._OP_CLIENT_REQ_VIRTUAL_WORLD_TARGET_UI);
        var content = pkt.content;
        content.uiId = uiId;
        content.componentId = id;
        this.mWorld.connection.send(pkt);
    };
    return Interactive;
}(dist["PacketHandler"]));


// CONCATENATED MODULE: ./src/rooms/player/friend/friend.ts
var Friend = /** @class */ (function () {
    function Friend(world) {
        this.world = world;
        this.mFriendList = [];
    }
    Friend.prototype.requestFriend = function (callBack) {
        var func = callBack;
        this.world.httpService.firend().then(function (response) {
            if (response.code === 200) {
                if (func)
                    func(response.data);
            }
        });
    };
    Friend.prototype.friendList = function () {
        return this.mFriendList || [];
    };
    return Friend;
}());


// CONCATENATED MODULE: ./src/rooms/player/Actor.ts
var Actor_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();







// import { ControlFMediator } from "../../ui/ControlF/ControlFMediator";
var Actor_Actor = /** @class */ (function (_super) {
    Actor_extends(Actor, _super);
    function Actor(sprite, mElementManager) {
        var _this = _super.call(this, sprite, mElementManager) || this;
        _this.mElementManager = mElementManager;
        _this.mBlockable = false;
        // this.mRenderable = true; // Actor is always renderable!!!
        // this.addDisplay();
        _this.mRoom = _this.mElementManager.roomService;
        if (_this.mRoom.world.inputManager)
            _this.mRoom.world.inputManager.addListener(_this);
        // if (this.mElementManager) {
        //     const roomService = this.mElementManager.roomService;
        //     if (roomService && roomService.cameraService) {
        //         roomService.cameraService.startFollow(this.getDisplay());
        //         roomService.cameraService.syncCameraScroll();
        //     }
        // }
        if (_this.mElementManager) {
            var roomService = _this.mElementManager.roomService;
            if (roomService && roomService.cameraService) {
                var pos = sprite.pos;
                var size = _this.mElementManager.scene.scale;
                roomService.cameraService.setScroll(pos.x * roomService.world.scaleRatio - size.width / 2, pos.y * roomService.world.scaleRatio - size.height / 2);
                roomService.cameraService.syncCameraScroll();
            }
        }
        _this.mFriend = new Friend(_this.mRoom.world);
        _this.mRoom.playerManager.set(_this.id, _this);
        _this.mInteractive = new interactive_Interactive(mElementManager.roomService.world);
        _this.mInteractive.register();
        return _this;
    }
    Actor.prototype.getBag = function () {
        return this.mBag;
    };
    Actor.prototype.getFriend = function () {
        return this.mFriend;
    };
    Actor.prototype.getInteractive = function () {
        return this.mInteractive;
    };
    // override super's method.
    Actor.prototype.setRenderable = function (isRenderable) {
        // do nothing!
        // Actor is always renderable!!!
    };
    Actor.prototype.destroy = function () {
        if (this.mBag) {
            this.mBag.destroy();
            this.mBag = null;
        }
        if (this.mRoom.world.inputManager)
            this.mRoom.world.inputManager.removeListener(this);
        _super.prototype.destroy.call(this);
    };
    Actor.prototype.downHandler = function (d, keyList) {
        if (!this.mDisplay) {
            return;
        }
        this.mRoom.playerManager.requestActorMove(d, keyList); // startActorMove();
    };
    Actor.prototype.upHandler = function () {
        // this.mRoom.playerManager.stopActorMove();
        if (!this.mDisplay) {
            return;
        }
        this.stopMove();
    };
    Actor.prototype.startMove = function () {
        _super.prototype.startMove.call(this);
        // TODO modular
        // const med: ControlFMediator = this.mRoom.world.uiManager.getMediator(ControlFMediator.NAME) as ControlFMediator;
        // if (med) med.hide();
    };
    Actor.prototype.stopMove = function () {
        _super.prototype.stopMove.call(this);
        if (this.mRoom && this.mRoom.world.moveStyle === protocols["op_def"].MoveStyle.DIRECTION_MOVE_STYLE) {
            var pkt = new dist["PBpacket"](protocols["op_virtual_world"].OPCODE._OP_CLIENT_REQ_VIRTUAL_WORLD_STOP_SPRITE);
            var ct = pkt.content;
            ct.nodeType = this.nodeType;
            var pos = this.getPosition();
            ct.spritePositions = {
                id: this.id,
                point3f: {
                    x: pos.x,
                    y: pos.y,
                    z: pos.z,
                },
                direction: this.dir
            };
            // Logger.getInstance().debug("nowPox:" + pos.x + "," + pos.y);
            this.mElementManager.connection.send(pkt);
        }
    };
    Actor.prototype.move = function (moveData) {
        // TODO 不能仅判断walk, 移动状态可能还有run
        if (this.mRoom.world.moveStyle === protocols["op_def"].MoveStyle.DIRECTION_MOVE_STYLE) {
            if (this.mCurState !== rooms_element["b" /* PlayerState */].WALK) {
                return;
            }
        }
        else {
            this.startMove();
        }
        _super.prototype.move.call(this, moveData);
    };
    Actor.prototype.movePath = function (movePath) {
        if (this.mRoom.world.moveStyle === protocols["op_def"].MoveStyle.DIRECTION_MOVE_STYLE) {
            if (this.mCurState !== rooms_element["b" /* PlayerState */].WALK) {
                return;
            }
        }
        // movePath.path = [{ x: 885.000000, y: 637.50000}, { x: 915.000000, y: 637.50000}, { x: 945.000000, y: 637.50000}, { x: 975.000000, y: 637.50000}, { x: 1005.00000, y: 637.50000}, { x: 1035.00000, y: 637.50000}, { x: 1065.00000, y: 637.50000}, { x: 1080.00000, y: 645.00000}, { x: 1095.00000, y: 652.50000}, { x: 1110.00000, y: 660.00000}, { x: 1125.00000, y: 667.50000}, { x: 1140.00000, y: 675.00000}, { x: 1155.00000, y: 682.50000}, { x: 1170.00000, y: 690.00000}];
        // movePath.path = [{x: 1140.00000, y: 495.000000}, {x: 1125.00000, y: 502.500000}, {x: 1110.00000, y: 510.000000}, {x: 1095.00000, y: 517.500000}, {x: 1080.00000, y: 525.000000}, {x: 1065.00000, y: 532.500000}, {x: 1050.00000, y: 540.000000}, {x: 1035.00000, y: 547.500000}];
        // movePath.timestemp = 3965;
        var path = movePath.path;
        var now = this.mElementManager.roomService.now();
        var duration = 0;
        var pathAry = path.map(function (value) {
            now += duration;
            duration = value.timestemp - now;
            return {
                x: value.point3f.x, y: value.point3f.y,
                duration: duration,
                timestemp: value.timestemp
            };
        });
        // this.drawPath(movePath.path);
        _super.prototype.movePath.call(this, movePath);
    };
    Actor.prototype.onMoveComplete = function () {
        this.preMoveComplete();
        if (this.mCurState !== rooms_element["b" /* PlayerState */].WALK) {
            this.mMoveData.tweenAnim.stop();
            return;
        }
        if (this.mRoom.world.moveStyle !== protocols["op_def"].MoveStyle.DIRECTION_MOVE_STYLE) {
            this.changeState(rooms_element["b" /* PlayerState */].IDLE);
            this.stopMove();
        }
        this._doMove();
    };
    Actor.prototype.onMoving = function () {
        if (this.mCurState !== rooms_element["b" /* PlayerState */].WALK) {
            this.mMoveData.tweenLineAnim.stop();
            return;
        }
        _super.prototype.onMoving.call(this);
    };
    Actor.prototype.addToBlock = function () {
        this.addDisplay();
    };
    Actor.prototype.drawPath = function (pos) {
        // if (!pos && pos.length > 0) {
        //     return;
        // }
        // if (!this.mMovePath) {
        //     this.mMovePath = this.mElementManager.scene.make.graphics(undefined, false);
        // }
        // this.mMovePath.clear();
        // this.mMovePath.lineStyle(2, 0xFFFF00);
        // this.mMovePath.moveTo(pos[0].point3f.x, pos[0].point3f.y);
        // let point3f = null;
        // for (const point of pos) {
        //     point3f = point.point3f;
        //     if (point3f) this.mMovePath.lineTo(point3f.x, point3f.y);
        // }
        // this.mMovePath.strokePath();
        // this.mRoom.addToSurface(<any> this.mMovePath);
    };
    Object.defineProperty(Actor.prototype, "model", {
        get: function () {
            return this.mModel;
        },
        set: function (val) {
            this.mModel = val;
            if (!val) {
                return;
            }
            if (val.package) {
                this.mPackage = val.package;
                this.mBag = new bag_Bag(this.mElementManager.roomService.world);
                this.mBag.register();
            }
            this.load(this.mModel.displayInfo);
            if (this.mModel.pos)
                this.setPosition(this.mModel.pos);
            this.mDisplay.changeAlpha(this.mModel.alpha);
            if (this.mModel.nickname)
                this.mDisplay.showNickname(this.mModel.nickname);
            this.setDirection(this.mModel.direction);
            // if (this.mElementManager) {
            //     const roomService = this.mElementManager.roomService;
            //     if (roomService && roomService.cameraService) {
            //         roomService.cameraService.startFollow(this.mDisplay);
            //     }
            // }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Actor.prototype, "package", {
        get: function () {
            return this.mPackage;
        },
        set: function (value) {
            this.mPackage = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Actor.prototype, "moveTime", {
        set: function (val) {
            this.mMoveTime = val;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Actor.prototype, "moveData", {
        get: function () {
            return this.mMoveData;
        },
        enumerable: false,
        configurable: true
    });
    return Actor;
}(player_Player));


// CONCATENATED MODULE: ./src/rooms/player/player.model.ts
var player_model_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var player_model_PlayerModel = /** @class */ (function (_super) {
    player_model_extends(PlayerModel, _super);
    function PlayerModel(data) {
        var _this = _super.call(this, data) || this;
        _this.mPos = new utils_pos["a" /* Pos */](data.x, data.y, data.z);
        _this.mAlpha = 1;
        _this.mPackage = data.package;
        _this.mSceneId = data.sceneId;
        _this.mUuid = data.uuid;
        _this.mPlatformId = data.platformId;
        return _this;
    }
    return PlayerModel;
}(element_sprite["a" /* Sprite */]));


// CONCATENATED MODULE: ./src/rooms/player/player.manager.ts
var player_manager_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();








var NodeType = protocols["op_def"].NodeType;

var player_manager_PlayerManager = /** @class */ (function (_super) {
    player_manager_extends(PlayerManager, _super);
    function PlayerManager(mRoom) {
        var _this = _super.call(this) || this;
        _this.mRoom = mRoom;
        _this.hasAddComplete = false;
        _this.mPlayerMap = new Map();
        if (_this.connection) {
            _this.connection.addPacketListener(_this);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_ADD_SPRITE, _this.onAdd);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_ADD_SPRITE_END, _this.addComplete);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_DELETE_SPRITE, _this.onRemove);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_ADJUST_POSITION, _this.onAdjust);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_MOVE_SPRITE, _this.onMove);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_RES_CLIENT_SHOW_EFFECT, _this.onShowEffect);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_RES_CLIENT_ONLY_BUBBLE, _this.onOnlyBubbleHandler);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_RES_CLIENT_CHAT, _this.onShowBubble);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_RES_CLIENT_ONLY_BUBBLE_CLEAN, _this.onClearBubbleHandler);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_SYNC_SPRITE, _this.onSync);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_CHANGE_SPRITE_ANIMATION, _this.onChangeAnimation);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_SET_SPRITE_POSITION, _this.onSetPosition);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_SET_CAMERA_FOLLOW, _this.onCameraFollow);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_MOVE_SPRITE_BY_PATH, _this.onMovePath);
        }
        return _this;
    }
    // public createActor(playModel: PlayerModel) {
    //     this.mActor = new Actor(playModel, this);
    //     if (sprite.attrs) {
    //         for (const attr of sprite.attrs) {
    //             this._addSimulate(sprite.id, attr);
    //         }
    //     }
    // }
    PlayerManager.prototype.createActor = function (actor) {
        var playModel = new player_model_PlayerModel(actor);
        this.mActor = new Actor_Actor(playModel, this);
    };
    Object.defineProperty(PlayerManager.prototype, "actor", {
        get: function () {
            return this.mActor;
        },
        enumerable: false,
        configurable: true
    });
    PlayerManager.prototype.destroy = function () {
        var _this = this;
        if (this.connection) {
            this.connection.removePacketListener(this);
        }
        if (!this.mPlayerMap)
            return;
        this.mPlayerMap.forEach(function (player) { return _this.removeFromMap(player.id); });
        this.mPlayerMap.clear();
    };
    PlayerManager.prototype.removeFromMap = function (id) {
        var player = this.mPlayerMap.get(id);
        if (player) {
            // MineCarSimulateData.destroyMineCar(this.roomService.elementManager, player.model);
            this.mPlayerMap.delete(id);
            player.destroy();
        }
    };
    PlayerManager.prototype.requestActorMove = function (dir, keyArr) {
        this.startActorMove();
        if (!this.roomService.world.game.device.os.desktop) {
            // 按下键盘的时候已经发了一次了，如果再发一次后端会有问题
            var pkt = new dist["PBpacket"](protocols["op_virtual_world"].OPCODE._OP_CLIENT_REQ_GATEWAY_KEYBOARD_DOWN);
            var content = pkt.content;
            content.keyCodes = keyArr;
            this.connection.send(pkt);
        }
    };
    PlayerManager.prototype.startActorMove = function () {
        if (!this.mActor) {
            log["a" /* Logger */].getInstance().error("MainHero miss");
            return;
        }
        this.mActor.startMove();
    };
    PlayerManager.prototype.stopActorMove = function () {
        if (!this.mActor) {
            log["a" /* Logger */].getInstance().error("MainHero miss");
            return;
        }
        this.mActor.stopMove();
    };
    PlayerManager.prototype.get = function (id) {
        if (!this.mPlayerMap) {
            return;
        }
        var player = this.mPlayerMap.get(id);
        if (!player) {
            var actor = this.mActor;
            if (actor && actor.id === id) {
                player = actor;
            }
        }
        return player;
    };
    PlayerManager.prototype.add = function (sprite) {
    };
    PlayerManager.prototype.remove = function (id) {
        var element = this.mPlayerMap.get(id);
        if (element) {
            this.mPlayerMap.delete(id);
            element.destroy();
        }
        if (this.mActor) {
            this.mActor.destroy();
            this.mActor = null;
        }
        return element;
    };
    PlayerManager.prototype.getElements = function () {
        return Array.from(this.mPlayerMap.values());
    };
    PlayerManager.prototype.set = function (id, player) {
        if (!this.mPlayerMap) {
            this.mPlayerMap = new Map();
        }
        this.mPlayerMap.set(id, player);
    };
    Object.defineProperty(PlayerManager.prototype, "camera", {
        get: function () {
            return this.mRoom.cameraService.camera;
        },
        enumerable: false,
        configurable: true
    });
    // public addPlayer(obj: op_client.IActor): void {
    //     const playerInfo: PlayerInfo = new PlayerInfo();
    //     playerInfo.setInfo(obj);
    //     if (obj.walkOriginPoint) {
    //         playerInfo.setOriginWalkPoint(obj.walkOriginPoint);
    //     }
    //     if (obj.originPoint) {
    //         playerInfo.setOriginCollisionPoint(obj.originPoint);
    //     }
    //     this.mPlayerInfoList.push(playerInfo);
    //     this.mModelDispatch.emit(MessageType.SCENE_ADD_PLAYER, playerInfo);
    // }
    PlayerManager.prototype.addPackItems = function (elementId, items) {
        var character = this.mPlayerMap.get(elementId);
        if (character && character.id === this.mActor.id) {
            if (!character.package) {
                character.package = protocols["op_gameconfig"].Package.create();
            }
            character.package.items = character.package.items.concat(items);
            this.mRoom.world.emitter.emit(MessageType["a" /* MessageType */].UPDATED_CHARACTER_PACKAGE);
        }
    };
    PlayerManager.prototype.removePackItems = function (elementId, itemId) {
        var character = this.mPlayerMap.get(elementId);
        if (character && this.mActor.id) {
            var itemList = character.package.items;
            var len = itemList.length;
            for (var i = 0; i < len; i++) {
                if (itemId === itemList[i].id) {
                    itemList.splice(i, 1);
                    return true;
                }
            }
        }
        return false;
    };
    PlayerManager.prototype.onSync = function (packet) {
        var content = packet.content;
        if (content.nodeType !== protocols["op_def"].NodeType.CharacterNodeType) {
            return;
        }
        var player = null;
        var sprites = content.sprites;
        var command = content.command;
        for (var _i = 0, sprites_1 = sprites; _i < sprites_1.length; _i++) {
            var sprite = sprites_1[_i];
            player = this.get(sprite.id);
            if (player) {
                //  MineCarSimulateData.addSimulate(this.roomService, sprite, player.model);
                if (command === protocols["op_def"].OpCommand.OP_COMMAND_UPDATE) {
                    player.model = new element_sprite["a" /* Sprite */](sprite);
                }
                else if (command === protocols["op_def"].OpCommand.OP_COMMAND_PATCH) {
                    player.updateModel(sprite);
                }
            }
        }
    };
    PlayerManager.prototype.onAdjust = function (packet) {
        var content = packet.content;
        var positions = content.spritePositions;
        var type = content.nodeType;
        if (type !== protocols["op_def"].NodeType.CharacterNodeType) {
            return;
        }
        if (this.mActor) {
            var player = void 0;
            var point = void 0;
            for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
                var position = positions_1[_i];
                player = this.mPlayerMap.get(position.id);
                // if (!player) {
                //     if (position.id === this.mActor.id) {
                //         player = this.mActor;
                //     } else {
                //         continue;
                //     }
                // }
                if (player) {
                    point = position.point3f;
                    player.setPosition(new utils_pos["a" /* Pos */](point.x || 0, point.y || 0, point.z || 0));
                }
                // Logger.getInstance().debug(`adjust,x:${point.x},y:${point.y}`);
            }
        }
    };
    PlayerManager.prototype.onAdd = function (packet) {
        if (!this.mPlayerMap) {
            this.mPlayerMap = new Map();
        }
        var content = packet.content;
        var sprites = content.sprites;
        var type = content.nodeType;
        if (type !== protocols["op_def"].NodeType.CharacterNodeType) {
            return;
        }
        for (var _i = 0, sprites_2 = sprites; _i < sprites_2.length; _i++) {
            var sprite = sprites_2[_i];
            this._add(new element_sprite["a" /* Sprite */](sprite));
            // MineCarSimulateData.addSimulate(this.roomService, sprite);
        }
    };
    PlayerManager.prototype._add = function (sprite) {
        if (!this.mPlayerMap)
            this.mPlayerMap = new Map();
        if (!this.mPlayerMap.has(sprite.id)) {
            var player = new player_Player(sprite, this);
            this.mPlayerMap.set(player.id || 0, player);
        }
    };
    PlayerManager.prototype.addComplete = function (packet) {
        this.hasAddComplete = true;
    };
    PlayerManager.prototype.onRemove = function (packet) {
        var content = packet.content;
        var type = content.nodeType;
        var ids = content.ids;
        if (type !== protocols["op_def"].NodeType.CharacterNodeType) {
            return;
        }
        for (var _i = 0, ids_1 = ids; _i < ids_1.length; _i++) {
            var id = ids_1[_i];
            this.removeFromMap(id);
        }
    };
    PlayerManager.prototype.onMove = function (packet) {
        var content = packet.content;
        if (content.moveData) {
            var moveDataList = content.moveData;
            var len = moveDataList.length;
            var type = content.nodeType || null;
            var moveData = void 0;
            var playID = void 0;
            var player = void 0;
            for (var i = 0; i < len; i++) {
                moveData = moveDataList[i];
                playID = moveData.moveObjectId;
                player = this.get(playID);
                if (player) {
                    player.move(moveData);
                }
            }
        }
    };
    PlayerManager.prototype.onSetPosition = function (packet) {
        var content = packet.content;
        var type = content.nodeType;
        var id = content.id;
        if (type !== NodeType.CharacterNodeType) {
            return;
        }
        var role = this.get(id);
        if (role) {
            role.setPosition(new utils_pos["a" /* Pos */](content.position.x, content.position.y, content.position.z));
        }
    };
    PlayerManager.prototype.onShowBubble = function (packet) {
        var content = packet.content;
        var player = this.get(content.chatSenderid);
        if (player) {
            player.showBubble(content.chatContext, content.chatSetting);
        }
    };
    PlayerManager.prototype.onOnlyBubbleHandler = function (packet) {
        var content = packet.content;
        var player = this.get(content.receiverid);
        if (player) {
            player.showBubble(content.context, content.chatsetting);
        }
    };
    PlayerManager.prototype.onClearBubbleHandler = function (packet) {
        var content = packet.content;
        var player = this.get(content.receiverid);
        if (player) {
            player.clearBubble();
        }
    };
    PlayerManager.prototype.onShowEffect = function (packet) {
        var content = packet.content;
        var ids = content.id;
        var player;
        for (var _i = 0, ids_2 = ids; _i < ids_2.length; _i++) {
            var id = ids_2[_i];
            player = this.get(id);
            if (player) {
                player.showEffected();
            }
        }
    };
    PlayerManager.prototype.onChangeAnimation = function (packet) {
        var content = packet.content;
        if (content.nodeType !== NodeType.CharacterNodeType) {
            return;
        }
        var player = null;
        var ids = content.ids;
        for (var _i = 0, ids_3 = ids; _i < ids_3.length; _i++) {
            var id = ids_3[_i];
            player = this.get(id);
            if (player) {
                player.setQueue(content.changeAnimation);
            }
        }
    };
    PlayerManager.prototype.onCameraFollow = function (packet) {
        var content = packet.content;
        var player = this.get(content.id);
        var camera = this.roomService.cameraService;
        if (!camera) {
            return;
        }
        if (player) {
            camera.startFollow(player.getDisplay());
        }
        else {
            camera.stopFollow();
        }
    };
    PlayerManager.prototype.onMovePath = function (packet) {
        var content = packet.content;
        if (content.nodeType !== NodeType.CharacterNodeType) {
            return;
        }
        var play = this.get(content.id);
        if (play) {
            play.movePath(content);
        }
    };
    Object.defineProperty(PlayerManager.prototype, "roomService", {
        get: function () {
            return this.mRoom;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PlayerManager.prototype, "scene", {
        get: function () {
            if (this.mRoom) {
                return this.mRoom.scene;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PlayerManager.prototype, "connection", {
        get: function () {
            if (this.mRoom) {
                return this.mRoom.connection;
            }
            log["a" /* Logger */].getInstance().error("room is undefined");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PlayerManager.prototype, "map", {
        get: function () {
            return [];
        },
        enumerable: false,
        configurable: true
    });
    return PlayerManager;
}(dist["PacketHandler"]));


// EXTERNAL MODULE: ./src/rooms/layer/layer.manager.ts + 1 modules
var layer_manager = __webpack_require__(66);

// EXTERNAL MODULE: ./src/rooms/terrain/terrain.manager.ts
var terrain_manager = __webpack_require__(50);

// EXTERNAL MODULE: ./src/utils/index.ts + 1 modules
var utils = __webpack_require__(64);

// EXTERNAL MODULE: ./src/rooms/cameras/cameras.manager.ts + 1 modules
var cameras_manager = __webpack_require__(67);

// EXTERNAL MODULE: ./src/scenes/play.ts
var play = __webpack_require__(37);

// EXTERNAL MODULE: ./src/rooms/cameras/viewblock.manager.ts + 1 modules
var viewblock_manager = __webpack_require__(98);

// EXTERNAL MODULE: ./src/scenes/loading.ts
var loading = __webpack_require__(24);

// EXTERNAL MODULE: ./src/rooms/display/frames.model.ts
var frames_model = __webpack_require__(35);

// CONCATENATED MODULE: ./src/rooms/map/map.model.ts


var map_model_MapModel = /** @class */ (function () {
    function MapModel() {
        this.mapId = 1;
        this.zStart = 0; // TODO:
        this.zEnd = 0; // TODO:
        this._mapTotalWidth = 0;
        this._bgSound = 1;
        this._voiceChatRoomId = 0;
        this._mapTotalHeight = 0;
    }
    Object.defineProperty(MapModel.prototype, "bgSound", {
        get: function () {
            return this._bgSound;
        },
        set: function (value) {
            this._bgSound = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MapModel.prototype, "mapTotalWidth", {
        get: function () {
            return this._mapTotalWidth;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MapModel.prototype, "mapTotalHeight", {
        get: function () {
            return this._mapTotalHeight;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MapModel.prototype, "tileWidth", {
        /**
         * 获取格子宽（单位：像素）
         */
        get: function () {
            return this._tileWidth;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MapModel.prototype, "tileHeight", {
        /**
         * 获取格子高（单位：像素）
         */
        get: function () {
            return this._tileHeight;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MapModel.prototype, "terrainConfig", {
        get: function () {
            return this._terrainConfig;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MapModel.prototype, "elementConfig", {
        get: function () {
            return this._elementConfig;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MapModel.prototype, "cols", {
        get: function () {
            return this._cols;
        },
        set: function (value) {
            this._cols = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MapModel.prototype, "rows", {
        get: function () {
            return this._rows;
        },
        set: function (value) {
            this._rows = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MapModel.prototype, "voiceChatRoomId", {
        get: function () {
            return this._voiceChatRoomId;
        },
        set: function (value) {
            this._voiceChatRoomId = value;
        },
        enumerable: false,
        configurable: true
    });
    MapModel.prototype.setConfig = function (cols, rows, zStart, zEnd, tileWidth, tileHeight) {
        this._cols = cols; // 水平方向格子数量
        this._rows = rows; // 垂直方向格子数量
        this.zStart = zStart;
        this.zEnd = zEnd;
        this._tileWidth = tileWidth;
        this._tileHeight = tileHeight;
        this._mapTotalWidth = (this._rows + this._cols) * (this._tileWidth / 2);
        this._mapTotalHeight = (this._rows + this._cols) * (this._tileHeight / 2);
    };
    MapModel.prototype.setTerrainInfo = function (value) {
        this._terrainConfig = [];
        var len = value.length;
        var terrain;
        for (var i = 0; i < len; i++) {
            terrain = new frames_model["a" /* FramesModel */](value[i]);
            this._terrainConfig.push(terrain);
        }
    };
    MapModel.prototype.addTerrainInfo = function (value) {
        var len = value.length;
        var terrain;
        for (var i = 0; i < len; i++) {
            terrain = new frames_model["a" /* FramesModel */](value[i]);
            this._terrainConfig.push(terrain);
        }
    };
    MapModel.prototype.setElementInfo = function (value) {
        this._elementConfig = [];
        var len = value.length;
        var element;
        for (var i = 0; i < len; i++) {
            element = new frames_model["a" /* FramesModel */](value[i]);
            this._elementConfig.push(element);
        }
    };
    MapModel.prototype.addElementInfo = function (value) {
        var len = value.length;
        var element;
        for (var i = 0; i < len; i++) {
            element = new frames_model["a" /* FramesModel */](value[i]);
            this._elementConfig.push(element);
        }
    };
    MapModel.prototype.addPackItems = function (elementId, items) {
        var element = this.getElementInfo(elementId);
        if (element) {
            if (!element.package) {
                element.package = protocols["op_gameconfig"].Package.create();
            }
            element.package.items = element.package.items.concat(items);
        }
    };
    MapModel.prototype.removePackItems = function (elementId, itemId) {
        var element = this.getElementInfo(elementId);
        if (element) {
            var len = element.package.items.length;
            for (var i = 0; i < len; i++) {
                if (itemId === element.package.items[i].id) {
                    element.package.items.splice(i, 1);
                    return true;
                }
            }
        }
        return false;
    };
    MapModel.prototype.getElementInfo = function (value) {
        var len = this._elementConfig.length;
        for (var i = 0; i < len; i++) {
            if (this._elementConfig[i].id === value) {
                return this._elementConfig[i];
            }
        }
        return null;
    };
    return MapModel;
}());


// CONCATENATED MODULE: ./src/rooms/map/map.ts
var map_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var map_Map = /** @class */ (function (_super) {
    map_extends(Map, _super);
    function Map(mWorld) {
        var _this = _super.call(this) || this;
        _this.mWorld = mWorld;
        _this.emitter = _this.mWorld.emitter;
        _this.mMapModel = new map_model_MapModel();
        return _this;
    }
    Map.prototype.initialize = function () {
        return this.mInitialize;
    };
    Map.prototype.getMapModel = function () {
        return this.mMapModel;
    };
    Map.prototype.register = function () {
    };
    Map.prototype.unRegister = function () {
    };
    Map.prototype.destroy = function () {
        this.mInitialize = false;
        this.mMapModel = null;
        this.emitter = null;
    };
    Map.prototype.setMapInfo = function (value) {
        this.mMapModel.mapId = value.id;
        this.mMapModel.voiceChatRoomId = value.voiceChatRoomId;
        this.mMapModel.setConfig(value.cols, value.rows, value.zStart, value.zEnd, value.tileWidth, value.tileHeight);
        this.mMapModel.setTerrainInfo(value.terrains);
        this.mMapModel.setElementInfo(value.elements);
        if (this.mInitialize === false) {
            this.mInitialize = true;
            this.emitter.emit(MessageType["a" /* MessageType */].SCENE_DATA_INITIALIZE);
        }
    };
    Map.prototype.addPackItems = function (elementId, items) {
        this.mMapModel.addPackItems(elementId, items);
    };
    Map.prototype.removePackItems = function (elementId, itemId) {
        this.mMapModel.removePackItems(elementId, itemId);
    };
    Map.NAME = "Map";
    return Map;
}(dist["PacketHandler"]));


// EXTERNAL MODULE: ./src/rooms/display/display.object.ts + 1 modules
var display_object = __webpack_require__(29);

// EXTERNAL MODULE: ./src/rooms/editor/reference.area.ts
var reference_area = __webpack_require__(76);

// EXTERNAL MODULE: ./src/utils/resUtil.ts + 1 modules
var resUtil = __webpack_require__(8);

// CONCATENATED MODULE: ./src/rooms/fall.effect/fall.effect.ts
var fall_effect_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var fall_effect_FallEffect = /** @class */ (function (_super) {
    fall_effect_extends(FallEffect, _super);
    function FallEffect(scene, scaleRatio) {
        var _this = _super.call(this, scene) || this;
        _this.scale = scaleRatio;
        return _this;
    }
    FallEffect.prototype.show = function (status) {
        this.mStatus = status;
        this.load();
    };
    FallEffect.prototype.load = function () {
        if (this.scene.textures.exists("fall_effect")) {
            this.onCompleteHandler();
        }
        else {
            this.scene.load.once(Phaser.Loader.Events.COMPLETE, this.onCompleteHandler, this);
            this.scene.load.atlas("fall_effect", resUtil["c" /* Url */].getRes("ui/fall_effect/falleffect.png"), resUtil["c" /* Url */].getRes("ui/fall_effect/falleffect.json"));
            this.scene.load.start();
        }
    };
    FallEffect.prototype.showEnable = function () {
        // const config = {
        //     key: "fill_effect_enable",
        //     frames: this.scene.anims.generateFrameNames("fall_effect", { prefix: "enable", end: 6, zeroPad: 2 }),
        //     frameRate: 8,
        //     repeat: 0
        // };
        // this.mDisplay.setPosition(25, -25);
        // this.scene.anims.create(config);
        // this.mDisplay.play("fill_effect_enable");
        this.mDisplay = new EnableDisplay(this.scene, "fall_effect");
        this.add(this.mDisplay);
    };
    FallEffect.prototype.showDisable = function () {
        // this.mDisplay = this.scene.make.sprite({
        //     key: "fall_effect",
        //     frame: "forbid"
        // }, false).setScale(0.5);
        this.mDisplay = new DisableDisplay(this.scene, "fall_effect");
        this.add(this.mDisplay);
    };
    FallEffect.prototype.onCompleteHandler = function () {
        // this.mDisplay = this.scene.make.sprite({
        //     key: "fall_effect",
        // }, false);
        // this.add(this.mDisplay);
        var _this = this;
        if (this.mStatus === protocols["op_def"].PathReachableStatus.PATH_REACHABLE_AREA || this.mStatus === protocols["op_def"].PathReachableStatus.PATH_REACHABLE_WITH_INTERACTION_SPRITE) {
            this.showEnable();
        }
        else {
            this.showDisable();
        }
        // if (this.mType === FallType.Enable) {
        //     this.createEnable();
        // } else {
        //     this.createDisable();
        // }
        this.scene.tweens.add({
            targets: this,
            duration: 1000,
            ease: "Expo",
            delay: 1000,
            props: { alpha: 0 },
            onComplete: function () {
                _this.destroy();
                _this.emit("remove", _this);
            }
        });
    };
    return FallEffect;
}(Phaser.GameObjects.Container));

var EnableDisplay = /** @class */ (function (_super) {
    fall_effect_extends(EnableDisplay, _super);
    function EnableDisplay(scene, key) {
        var _this = _super.call(this, scene) || this;
        _this.mImage = scene.make.sprite({
            key: key,
            x: 9,
            y: -20
        }, false).setScale(0.5);
        _this.add(_this.mImage);
        // const tween = this.scene.tweens.add({
        //     targets: this.mImage,
        //     duration: 1000,
        //     delay: 600,
        //     props: {
        //         alpha: 0.6
        //     },
        //     onComplete: () => {
        //         tween.destroy();
        //         this.mImage.destroy();
        //         this.mImage = undefined;
        //     }
        // })
        // this.mEllipse = scene.make.graphics(undefined, false);
        // this.mEllipse.fillStyle(0, 0.6);
        // this.mEllipse.fillEllipse(0, 0, 30, 15)
        _this.mEllipse = scene.make.sprite(undefined, false);
        _this.addAt(_this.mEllipse, 0);
        var config = {
            key: "fill_effect_enable",
            frames: _this.scene.anims.generateFrameNames("fall_effect", { prefix: "enable", end: 6, zeroPad: 2 }),
            frameRate: 16,
            repeat: 0
        };
        _this.scene.anims.create(config);
        _this.mImage.play("fill_effect_enable");
        var ellipseConfig = {
            key: "fill_effect_ellipse",
            frames: _this.scene.anims.generateFrameNames("fall_effect", { prefix: "ellipse", end: 7, zeroPad: 2 }),
            frameRate: 10,
            repeat: 0
        };
        _this.scene.anims.create(ellipseConfig);
        _this.mEllipse.play("fill_effect_ellipse");
        return _this;
    }
    return EnableDisplay;
}(Phaser.GameObjects.Container));
var DisableDisplay = /** @class */ (function (_super) {
    fall_effect_extends(DisableDisplay, _super);
    function DisableDisplay(scene, key) {
        var _this = _super.call(this, scene) || this;
        _this.mImage = scene.make.image({
            key: key,
            y: -6,
            frame: "disable",
        }, false).setScale(0.5);
        _this.add(_this.mImage);
        _this.mEllipse = scene.make.image({
            key: key,
            frame: "forbid"
        }, false).setScale(0.5);
        _this.add([_this.mImage, _this.mEllipse]);
        return _this;
    }
    return DisableDisplay;
}(Phaser.GameObjects.Container));

// CONCATENATED MODULE: ./src/rooms/fall.effect/fall.effect.container.ts

var fall_effect_container_FallEffectContainer = /** @class */ (function () {
    function FallEffectContainer(scene, room) {
        this.scene = scene;
        this.room = room;
        this.mFalls = [];
    }
    FallEffectContainer.prototype.addFall = function (pos, enable) {
        if (!pos) {
            return;
        }
        var fall = new fall_effect_FallEffect(this.scene, this.room.world.scaleRatio);
        fall.once("remove", this.onRemoveHandler, this);
        fall.setPosition(pos.x, pos.y);
        this.room.addToSceneUI(fall);
    };
    FallEffectContainer.prototype.onRemoveHandler = function (fall) {
        if (!fall) {
            return;
        }
    };
    return FallEffectContainer;
}());


// EXTERNAL MODULE: ./src/rooms/cameras/block.object.ts
var block_object = __webpack_require__(45);

// CONCATENATED MODULE: ./src/rooms/display/wall.display.ts
var wall_display_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var wall_display_WallDisplay = /** @class */ (function (_super) {
    wall_display_extends(WallDisplay, _super);
    function WallDisplay(scene, roomService) {
        var _this = _super.call(this, scene, 0, 0, undefined) || this;
        _this.roomService = roomService;
        return _this;
    }
    WallDisplay.prototype.loadDisplay = function (texture, data) {
        // const key = texture + data;
        var key = "wall";
        if (this.scene.textures.exists(key)) {
            this.onLoadCompleteHandler();
        }
        else {
            this.scene.load.once(Phaser.Loader.Events.COMPLETE, this.onLoadCompleteHandler, this);
            this.scene.load.atlas(key, texture, data);
            this.scene.load.start();
        }
    };
    WallDisplay.prototype.setDir = function (dir) {
        if (!this.mImage) {
            return;
        }
        this.mImage.setTexture("wall", "wall_" + dir + ".png");
        if (dir === Direction.LEFT) {
            this.mImage.x = -this.mImage.width / 2;
        }
        else if (dir === Direction.RIGHT) {
            this.mImage.x = this.mImage.width / 2;
        }
        this.mImage.y = -this.mImage.height / 2 + 30;
    };
    WallDisplay.prototype.load = function (data) {
    };
    WallDisplay.prototype.changeAlpha = function (val) {
    };
    WallDisplay.prototype.play = function (animationName) { };
    WallDisplay.prototype.removeFromParent = function () {
        if (this.parentContainer) {
            this.parentContainer.remove(this);
        }
    };
    WallDisplay.prototype.fadeIn = function (callback) { };
    WallDisplay.prototype.fadeOut = function (callback) { };
    WallDisplay.prototype.showNickname = function (val) { };
    WallDisplay.prototype.setDisplayBadges = function (cards) { };
    WallDisplay.prototype.showRefernceArea = function () { };
    WallDisplay.prototype.hideRefernceArea = function () { };
    WallDisplay.prototype.showEffect = function () { };
    WallDisplay.prototype.onLoadCompleteHandler = function () {
        this.mImage = this.scene.make.image({
            key: "wall",
            frame: "wall_up.png"
        }, false);
        this.add(this.mImage);
        this.mImage.y = -this.mImage.height / 2 + 10;
        this.emit("initialized", this);
    };
    Object.defineProperty(WallDisplay.prototype, "sortX", {
        get: function () {
            return 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WallDisplay.prototype, "sortY", {
        get: function () {
            return 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WallDisplay.prototype, "sortZ", {
        get: function () {
            return 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WallDisplay.prototype, "baseLoc", {
        get: function () {
            return;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WallDisplay.prototype, "element", {
        get: function () {
            return;
        },
        enumerable: false,
        configurable: true
    });
    return WallDisplay;
}(Phaser.GameObjects.Container));


// CONCATENATED MODULE: ./src/rooms/wall/wall.ts
var wall_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var Direction;
(function (Direction) {
    Direction["UP"] = "up";
    Direction["LEFT"] = "left";
    Direction["RIGHT"] = "right";
    Direction["DOWN"] = "down";
})(Direction || (Direction = {}));
var wall_Wall = /** @class */ (function (_super) {
    wall_extends(Wall, _super);
    function Wall(room, id, pos, dir) {
        var _this = _super.call(this, room) || this;
        _this.room = room;
        // this.mBlockable = false;
        _this.mID = id;
        _this.mDirection = dir;
        _this.mPosition = pos;
        _this.createDisplay();
        return _this;
    }
    Wall.prototype.setPosition = function (pos) {
        this.mPosition = pos;
        if (this.mDisplay) {
            this.mDisplay.x = pos.x;
            this.mDisplay.y = pos.y;
        }
    };
    Wall.prototype.createDisplay = function () {
        // if (!this.mDisplayInfo) {
        //     // Logger.getInstance().error("displayinfo does not exist, Create display failed");
        //     return;
        // }
        if (this.mDisplay) {
            return this.mDisplay;
        }
        var scene = this.room.scene;
        if (scene) {
            this.mDisplay = new wall_display_WallDisplay(scene, this.room);
            // this.setPosition(this.mPosition.x, this.mPosition.y);
            this.setPosition(this.mPosition);
            this.mDisplay.once("initialized", this.onInitializedHandler, this);
            this.mDisplay.loadDisplay(resUtil["c" /* Url */].getRes("wall/wall.png"), resUtil["c" /* Url */].getRes("wall/wall.json"));
            this.addToBlock();
            // this.mDisplay.load(this.mDisplayInfo);
        }
        return this.mDisplay;
    };
    Wall.prototype.onInitializedHandler = function () {
        this.mDisplay.setDir(this.mDirection);
    };
    Wall.prototype.addDisplay = function () {
        this.createDisplay();
        if (!this.mDisplay) {
            // Logger.getInstance().error("display does not exist");
            return;
        }
        this.mRoomService.addToGround(this.mDisplay, 0);
        this.setDepth();
    };
    Wall.prototype.setDepth = function () {
        if (this.mDisplay) {
            this.mDisplay.setDepth(this.mDisplay.y);
            if (!this.mRoomService) {
                throw new Error("roomService is undefined");
            }
            var layerManager = this.mRoomService.layerManager;
            if (!layerManager) {
                throw new Error("layerManager is undefined");
            }
            layerManager.depthGroundDirty = true;
        }
    };
    Object.defineProperty(Wall.prototype, "id", {
        get: function () {
            return this.mID;
        },
        enumerable: false,
        configurable: true
    });
    return Wall;
}(block_object["a" /* BlockObject */]));


// CONCATENATED MODULE: ./src/rooms/wall/wall.manager.ts
var wall_manager_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var wall_manager_WallManager = /** @class */ (function (_super) {
    wall_manager_extends(WallManager, _super);
    function WallManager(mRoom) {
        var _this = _super.call(this) || this;
        _this.mRoom = mRoom;
        _this.mWalls = new Map();
        if (_this.mRoom.connection) {
            _this.mRoom.connection.addPacketListener(_this);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_ADD_SPRITE_END, _this.onDawWallHandler);
        }
        return _this;
    }
    WallManager.prototype.destroy = function () {
        if (this.mRoom.connection) {
            this.mRoom.connection.removePacketListener(this);
        }
        this.mWalls.forEach(function (wall) { return wall.destroy(); });
        this.mWalls.clear();
    };
    WallManager.prototype._add = function (x, y, dir) {
        var pos = this.mRoom.transformTo90(new utils_pos["a" /* Pos */](x, y));
        var wall = new wall_Wall(this.mRoom, x * 1000000 + y * 1000, pos, dir);
        // wall.setPosition(pos);
    };
    WallManager.prototype.onDawWallHandler = function (packet) {
        var terrains = this.mRoom.world.elementStorage.getTerrainCollection();
        if (!terrains) {
            return;
        }
        var tmp = this.mRoom.world.getConfig().game_id.split(".");
        if (tmp.length < 2) {
            return;
        }
        if (tmp[1] !== "5e410ba50681ad5557b4d6e9") {
            return;
        }
        var map = terrains.data;
        for (var i = 0; i < map.length; i++) {
            for (var j = 0; j < map[0].length; j++) {
                if (map[i][j] === 0) {
                    continue;
                }
                if (this.isUp(i, j, map)) {
                    this._add(i, j, Direction.UP);
                }
                else if (this.isLeft(i, j, map)) {
                    this._add(i, j, Direction.RIGHT);
                }
                else if (this.isRight(i, j, map)) {
                    // if (lastW < j) {
                    //   i++;
                    //   break;
                    // }
                    this._add(i, j, Direction.LEFT);
                }
                else if (this.isDown(i, j, map)) {
                    this._add(i, j, Direction.DOWN);
                }
                // lastW = j;
                // break;
            }
        }
    };
    WallManager.prototype.isUp = function (rows, cols, map) {
        if (rows === 0) {
            if (cols === 0) {
                return true;
            }
            else if (map[rows][cols - 1] === 0) {
                return true;
            }
            return false;
        }
        else if (cols === 0) {
            if (rows === 0) {
                return true;
            }
            else if (map[rows - 1][cols] === 0) {
                return true;
            }
            return false;
        }
        if (map[rows - 1][cols] === 0 && map[rows][cols - 1] === 0) {
            return true;
        }
        return false;
    };
    WallManager.prototype.isLeft = function (rows, cols, map) {
        if (cols === 0) {
            if (rows > 0) {
                return true;
            }
        }
        else if (rows > 0) {
            if (cols > 0 && map[rows][cols - 1] === 0) {
                return true;
            }
        }
    };
    WallManager.prototype.isRight = function (rows, cols, map) {
        if (rows === 0) {
            if (cols > 0) {
                return true;
            }
        }
        else if (cols > 0) {
            if (rows > 0 && map[rows - 1][cols] === 0) {
                return true;
            }
        }
    };
    WallManager.prototype.isDown = function (rows, cols, map) {
        if (rows > 0 && cols > 0) {
            if (map[rows - 1][cols - 1] === 0 && map[rows - 1][cols] !== 0 && map[rows][cols - 1] !== 0) {
                return true;
            }
        }
    };
    return WallManager;
}(dist["PacketHandler"]));


// EXTERNAL MODULE: ./src/ui/components/dynamic.image.ts
var dynamic_image = __webpack_require__(33);

// EXTERNAL MODULE: ./src/scenes/basic.scene.ts
var basic_scene = __webpack_require__(16);

// EXTERNAL MODULE: ./src/rooms/cameras/play.camera.ts
var play_camera = __webpack_require__(81);

// CONCATENATED MODULE: ./src/scenes/sky.box.ts
var sky_box_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var sky_box_SkyBoxScene = /** @class */ (function (_super) {
    sky_box_extends(SkyBoxScene, _super);
    function SkyBoxScene() {
        return _super.call(this, {}) || this;
    }
    SkyBoxScene.prototype.init = function (data) {
        if (data) {
            this.skyBoxManager = data;
        }
    };
    SkyBoxScene.prototype.create = function () {
        var oldCamera = this.cameras.main;
        this.cameras.addExisting(new play_camera["a" /* PlayCamera */](0, 0, this.sys.scale.width, this.sys.scale.height, this.skyBoxManager.world.scaleRatio), true);
        this.cameras.remove(oldCamera);
        this.scene.sendToBack();
        this.skyBoxManager.startPlay(this);
    };
    SkyBoxScene.prototype.update = function (time, delta) {
        this.skyBoxManager.check(time, delta);
    };
    return SkyBoxScene;
}(basic_scene["a" /* BasicScene */]));


// CONCATENATED MODULE: ./src/rooms/sky.box/block.manager.ts
var block_manager_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var block_manager_BlockManager = /** @class */ (function () {
    function BlockManager(scenery, room) {
        this.mRows = 1;
        this.mCols = 1;
        this.mSceneName = "";
        this.mGrids = [];
        this.mScenery = scenery;
        this.mUris = scenery.uris;
        this.mRoom = room;
        this.mWorld = room.world;
        this.mCameras = room.cameraService;
        this.mMainCamera = this.mCameras.camera;
        this.mScaleRatio = this.mWorld.scaleRatio;
        this.setSize(scenery.width, scenery.height);
        var playScene = room.scene;
        if (!playScene) {
            log["a" /* Logger */].getInstance().fatal(BlockManager.name + " scene does not exist");
            return;
        }
        this.mSceneName = sky_box_SkyBoxScene.name + ("_" + scenery.id);
        this.mWorld.game.scene.add(this.mSceneName, sky_box_SkyBoxScene, false);
        playScene.scene.launch(this.mSceneName, this);
    }
    BlockManager.prototype.startPlay = function (scene) {
        this.scene = scene;
        this.initBlock();
    };
    BlockManager.prototype.check = function (time, delta) {
        var worldView = this.mMainCamera.worldView;
        var viewPort = new Phaser.Geom.Rectangle(worldView.x - worldView.width / 2, worldView.y - worldView.height / 2, worldView.width * 2, worldView.height * 2);
        for (var _i = 0, _a = this.mGrids; _i < _a.length; _i++) {
            var block = _a[_i];
            block.checkCamera(Phaser.Geom.Intersects.RectangleToRectangle(viewPort, block.rectangle));
        }
    };
    BlockManager.prototype.update = function (scenery) {
        this.mScenery = scenery;
        this.mUris = scenery.uris;
        this.setSize(scenery.width, scenery.height);
        this.initBlock();
    };
    BlockManager.prototype.setSize = function (imageW, imageH, gridW, gridH) {
        if (gridW === undefined)
            gridW = imageW;
        if (gridH === undefined)
            gridH = imageH;
        this.mRows = Math.ceil(imageW / gridW);
        this.mCols = Math.ceil(imageH / gridH);
        this.mGridWidth = gridW;
        this.mGridHeight = gridH;
    };
    BlockManager.prototype.updatePosition = function () {
        var camera = this.scene.cameras.main;
        var size = this.mRoom.roomSize;
        var _a = this.mScenery, width = _a.width, height = _a.height, offset = _a.offset;
        camera.setPosition(((size.sceneWidth - width >> 1) + offset.x) * this.mWorld.scaleRatio, ((size.sceneHeight - height >> 1) + offset.y) * this.mWorld.scaleRatio);
    };
    BlockManager.prototype.destroy = function () {
        if (this.mWorld && this.mWorld.game) {
            this.mWorld.game.scene.remove(this.mSceneName);
        }
        this.mGrids.length = 0;
    };
    BlockManager.prototype.initBlock = function () {
        this.clear();
        this.mContainer = this.scene.add.container(0, 0);
        this.mContainer.setScale(this.mWorld.scaleRatio);
        var len = this.mUris.length;
        for (var i = 0; i < len; i++) {
            var l = this.mUris[i].length;
            for (var j = 0; j < l; j++) {
                var block = new block_manager_Block(this.scene, this.mUris[i][j]);
                block.setRectangle(i % this.mRows * this.mGridWidth, Math.floor(i / this.mRows) * this.mGridHeight, this.mGridWidth, this.mGridHeight, this.mScaleRatio);
                this.mGrids.push(block);
            }
        }
        this.mContainer.add(this.mGrids);
        this.initCamera();
    };
    BlockManager.prototype.initCamera = function () {
        var camera = this.scene.cameras.main;
        if (this.mCameras) {
            var main = this.mCameras.camera;
            var bound = main.getBounds();
            camera.setBounds(bound.x, bound.y, bound.width, bound.height);
            this.updatePosition();
            camera.setScroll(main.scrollX, main.scrollY);
            this.mCameras.addCamera(camera);
        }
    };
    BlockManager.prototype.clear = function () {
        for (var _i = 0, _a = this.mGrids; _i < _a.length; _i++) {
            var grid = _a[_i];
            grid.destroy();
        }
        this.mGrids.length = 0;
        if (this.mContainer) {
            this.mContainer.destroy(true);
        }
    };
    Object.defineProperty(BlockManager.prototype, "world", {
        get: function () {
            return this.mWorld;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BlockManager.prototype, "scenery", {
        get: function () {
            return this.mScenery;
        },
        enumerable: false,
        configurable: true
    });
    return BlockManager;
}());

var block_manager_Block = /** @class */ (function (_super) {
    block_manager_extends(Block, _super);
    function Block(scene, key) {
        var _this = _super.call(this, scene, 0, 0) || this;
        _this.mLoaded = false;
        _this.mInCamera = false;
        _this.mKey = key;
        _this.setOrigin(0);
        return _this;
        // this.mRectangle = new Phaser.Geom.Rectangle(this.x, this.y, 1, 1);
    }
    Block.prototype.checkCamera = function (val) {
        if (this.mInCamera !== val) {
            this.mInCamera = val;
            if (this.mLoaded) {
                // TODO
                // this.setActive(val);
            }
            else {
                this.load(resUtil["c" /* Url */].getOsdRes(this.mKey));
            }
        }
    };
    Block.prototype.setRectangle = function (x, y, width, height, scale) {
        if (scale === void 0) { scale = 1; }
        this.x = x;
        this.y = y;
        this.mRectangle = new Phaser.Geom.Rectangle(x * scale, y * scale, width * scale, height * scale);
    };
    Object.defineProperty(Block.prototype, "rectangle", {
        get: function () {
            return this.mRectangle;
        },
        enumerable: false,
        configurable: true
    });
    Block.prototype.onLoadComplete = function (file) {
        _super.prototype.onLoadComplete.call(this, file);
        if (this.texture) {
            this.mLoaded = true;
            this.texture.setFilter(Phaser.Textures.FilterMode.NEAREST);
            this.mRectangle.setSize(this.width, this.height);
        }
    };
    return Block;
}(dynamic_image["a" /* DynamicImage */]));

// CONCATENATED MODULE: ./src/rooms/sky.box/sky.box.manager.ts
var sky_box_manager_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var sky_box_manager_SkyBoxManager = /** @class */ (function (_super) {
    sky_box_manager_extends(SkyBoxManager, _super);
    function SkyBoxManager(room) {
        var _this = _super.call(this) || this;
        _this.mRoom = room;
        _this.mScenetys = new Map();
        return _this;
    }
    SkyBoxManager.prototype.add = function (scenery) {
        this.mScenetys.set(scenery.id, new block_manager_BlockManager(scenery, this.mRoom));
    };
    SkyBoxManager.prototype.update = function (scenery) {
        var block = this.mScenetys.get(scenery.id);
        if (block) {
            block.update(scenery);
        }
    };
    SkyBoxManager.prototype.remove = function (id) {
        var block = this.mScenetys.get(id);
        if (block) {
            block.destroy();
        }
    };
    SkyBoxManager.prototype.destroy = function () {
        if (this.mRoom) {
            var connection = this.mRoom.connection;
            if (connection) {
                connection.removePacketListener(this);
            }
        }
        this.mScenetys.forEach(function (scenery) { return scenery.destroy(); });
    };
    return SkyBoxManager;
}(dist["PacketHandler"]));


// CONCATENATED MODULE: ./src/rooms/sky.box/index.ts


// EXTERNAL MODULE: ./src/Handler/Handler.ts
var Handler = __webpack_require__(52);

// CONCATENATED MODULE: ./src/Handler/HandlerDispatcher.ts
var HandlerDispatcher_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var HandlerDispatcher = /** @class */ (function () {
    function HandlerDispatcher() {
    }
    HandlerDispatcher.prototype.hasListener = function (type) {
        var listener = this._events && this._events[type];
        return !!listener;
    };
    HandlerDispatcher.prototype.emitter = function (type, data) {
        if (data === void 0) { data = null; }
        if (!this._events || !this._events[type])
            return false;
        var listeners = this._events[type];
        if (listeners.run) {
            if (listeners.once)
                delete this._events[type];
            data != null ? listeners.runWith(data) : listeners.run();
        }
        else {
            for (var i = 0, n = listeners.length; i < n; i++) {
                var listener = listeners[i];
                if (listener) {
                    (data != null) ? listener.runWith(data) : listener.run();
                }
                if (!listener || listener.once) {
                    listeners.splice(i, 1);
                    i--;
                    n--;
                }
            }
            if (listeners.length === 0 && this._events)
                delete this._events[type];
        }
        return true;
    };
    HandlerDispatcher.prototype.on = function (type, caller, listener, args) {
        if (args === void 0) { args = null; }
        return this._createListener(type, caller, listener, args, false);
    };
    HandlerDispatcher.prototype.once = function (type, caller, listener, args) {
        if (args === void 0) { args = null; }
        return this._createListener(type, caller, listener, args, true);
    };
    HandlerDispatcher.prototype.off = function (type, caller, listener, onceOnly) {
        if (onceOnly === void 0) { onceOnly = false; }
        if (!this._events || !this._events[type])
            return this;
        var listeners = this._events[type];
        if (listener != null) {
            if (listeners.run) {
                if ((!caller || listeners.caller === caller) && listeners.method === listener && (!onceOnly || listeners.once)) {
                    delete this._events[type];
                    listeners.recover();
                }
            }
            else {
                var count = 0;
                var len = listeners.length;
                for (var i = 0, n = listeners.length; i < n; i++) {
                    var item = listeners[i];
                    if (item && (!caller || item.caller === caller) && item.method === listener && (!onceOnly || item.once)) {
                        count++;
                        listeners[i] = null;
                        item.recover();
                    }
                }
                if (count === len)
                    delete this._events[type];
            }
        }
        return this;
    };
    HandlerDispatcher.prototype.offAll = function (type) {
        if (type === void 0) { type = null; }
        var events = this._events;
        if (!events)
            return this;
        if (type) {
            this._recoverHandlers(events[type]);
            delete events[type];
        }
        else {
            for (var name_1 in events) {
                this._recoverHandlers(events[name_1]);
            }
            this._events = null;
        }
        return this;
    };
    HandlerDispatcher.prototype.destroy = function () {
        this.offAll();
    };
    HandlerDispatcher.prototype._createListener = function (type, caller, listener, args, once, offBefore) {
        if (offBefore === void 0) { offBefore = true; }
        if (offBefore)
            this.off(type, caller, listener, once);
        var handler = EventHandler.create(caller || this, listener, args, once);
        if (!this._events)
            this._events = {};
        var events = this._events;
        if (!events[type])
            events[type] = handler;
        else {
            if (!events[type].run)
                events[type].push(handler);
            else
                events[type] = [events[type], handler];
        }
        return this;
    };
    HandlerDispatcher.prototype._recoverHandlers = function (arr) {
        if (!arr)
            return;
        if (arr.run) {
            arr.recover();
        }
        else {
            for (var i = arr.length - 1; i > -1; i--) {
                if (arr[i]) {
                    arr[i].recover();
                    arr[i] = null;
                }
            }
        }
    };
    return HandlerDispatcher;
}());

var EventHandler = /** @class */ (function (_super) {
    HandlerDispatcher_extends(EventHandler, _super);
    function EventHandler(caller, method, args, once) {
        return _super.call(this, caller, method, args, once) || this;
    }
    EventHandler.create = function (caller, method, args, once) {
        if (args === void 0) { args = null; }
        if (once === void 0) { once = true; }
        if (EventHandler._mpool.length)
            return EventHandler._mpool.pop().setTo(caller, method, args, once);
        return new EventHandler(caller, method, args, once);
    };
    EventHandler.prototype.recover = function () {
        if (this._id > 0) {
            this._id = 0;
            EventHandler._mpool.push(this.clear());
        }
    };
    EventHandler._mpool = [];
    return EventHandler;
}(Handler["a" /* Handler */]));

// CONCATENATED MODULE: ./src/rooms/group/FollowGroup.ts


var FollowGroup_FollowGroup = /** @class */ (function () {
    function FollowGroup() {
        this.groupType = GroupType.Follow;
        this.eventDisp = new HandlerDispatcher();
        this.childs = [];
    }
    FollowGroup.prototype.addChild = function (child) {
        this.removeChild(child);
        this.childs.push(child);
    };
    FollowGroup.prototype.removeChild = function (child) {
        var index = this.childs.indexOf(child);
        if (index !== -1) {
            this.childs.splice(index, 1);
        }
    };
    FollowGroup.prototype.replaceOwner = function (owner) {
        this.owner = owner;
        this.eventDisp.emitter(GroupEventType.REPLACE_TYPE, owner);
    };
    FollowGroup.prototype.emitter = function (type, data) {
        if (!type)
            type = GroupEventType.DEFAULT_TYPE;
        this.eventDisp.emitter(type, data);
    };
    FollowGroup.prototype.on = function (type, caller, method, args) {
        this.eventDisp.on(type, caller, method, args);
    };
    FollowGroup.prototype.off = function (type, caller, method) {
        this.eventDisp.off(type, caller, method);
    };
    FollowGroup.prototype.destroy = function () {
        this.eventDisp.destroy();
        this.childs.length = 0;
        this.owner = null;
        this.data = null;
    };
    return FollowGroup;
}());


// CONCATENATED MODULE: ./src/rooms/group/GroupManager.ts

var GroupManager_GroupManager = /** @class */ (function () {
    function GroupManager(room) {
        this.room = room;
        this.map = new Map();
    }
    GroupManager.prototype.createGroup = function (owner, groupType) {
        if (!this.hasGroup(owner, groupType)) {
            var groups = this.map.get(owner);
            var group = void 0;
            if (!groups) {
                groups = [];
                this.map.set(owner, groups);
            }
            if (groupType === GroupType.Follow) {
                var item = new FollowGroup_FollowGroup();
                item.owner = owner;
                groups.push(item);
                group = item;
            }
            return group;
        }
    };
    GroupManager.prototype.getGroup = function (owner, groupType) {
        var group;
        if (this.map.has(owner)) {
            var groups = this.map.get(owner);
            for (var _i = 0, groups_1 = groups; _i < groups_1.length; _i++) {
                var item = groups_1[_i];
                if (item.groupType === groupType) {
                    group = item;
                    return group;
                }
            }
        }
        return group;
    };
    GroupManager.prototype.hasGroup = function (owner, groupType) {
        var group = this.getGroup(owner, groupType);
        if (group)
            return true;
        return false;
    };
    GroupManager.prototype.destroy = function () {
        this.map.forEach(function (value, key) {
            for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
                var item = value_1[_i];
                item.destroy();
            }
            value.length = 0;
        });
        this.map.clear();
    };
    return GroupManager;
}());

var GroupType;
(function (GroupType) {
    GroupType[GroupType["Follow"] = 1] = "Follow";
})(GroupType || (GroupType = {}));
var GroupEventType;
(function (GroupEventType) {
    GroupEventType["DEFAULT_TYPE"] = "DEFAULT_TYPE";
    GroupEventType["REPLACE_TYPE"] = "REPLACE_TYPE";
})(GroupEventType || (GroupEventType = {}));

// CONCATENATED MODULE: ./src/rooms/element/frame.manager.ts

var frame_manager_FrameManager = /** @class */ (function () {
    function FrameManager() {
        this.handlers = [];
    }
    FrameManager.prototype.add = function (caller, method, args) {
        this.remove(caller, method);
        var handler = new Handler["a" /* Handler */](caller, method, args);
        this.handlers.push(handler);
    };
    FrameManager.prototype.remove = function (caller, method) {
        var removeid = -1;
        for (var i = 0; i < this.handlers.length; i++) {
            var item = this.handlers[i];
            if (item.caller === caller && item.method === method) {
                removeid = i;
                break;
            }
        }
        if (removeid !== -1) {
            var hander = this.handlers.splice(removeid, 1)[0];
            hander.clear();
        }
    };
    FrameManager.prototype.update = function (time, delta) {
        for (var _i = 0, _a = this.handlers; _i < _a.length; _i++) {
            var item = _a[_i];
            item.runWith([time, delta]);
        }
    };
    FrameManager.prototype.destroy = function () {
        for (var _i = 0, _a = this.handlers; _i < _a.length; _i++) {
            var item = _a[_i];
            item.clear();
        }
        this.handlers.length = 0;
    };
    FrameManager.prototype.hasRegistered = function (caller, method) {
        var removeid = -1;
        for (var i = 0; i < this.handlers.length; i++) {
            var item = this.handlers[i];
            if (item.caller === caller && item.method === method) {
                removeid = i;
                break;
            }
        }
        return (removeid !== -1);
    };
    return FrameManager;
}());


// CONCATENATED MODULE: ./src/rooms/room.ts
var room_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
























// 这一层管理数据和Phaser之间的逻辑衔接
// 消息处理让上层[RoomManager]处理
var room_Room = /** @class */ (function (_super) {
    room_extends(Room, _super);
    function Room(manager) {
        var _this = _super.call(this) || this;
        _this.manager = manager;
        _this.mEnableEdit = false;
        _this.mWorld = _this.manager.world;
        _this.moveStyle = _this.mWorld.moveStyle;
        _this.mScaleRatio = _this.mWorld.scaleRatio;
        if (_this.mWorld) {
            if (_this.connection) {
                _this.connection.addPacketListener(_this);
                _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_ENABLE_EDIT_MODE, _this.onEnableEditModeHandler);
                _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_UNWALKABLE_BIT_MAP, _this.onShowMapTitle);
                _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_MOVE_SPRITE_BY_PATH, _this.onMovePathHandler);
            }
        }
        return _this;
    }
    Room.prototype.enter = function (data) {
        var _this = this;
        var size = this.mWorld.getSize();
        if (!data) {
            // Logger.getInstance().error("wrong room");
            return;
        }
        this.mID = data.id;
        this.mSize = {
            cols: data.cols,
            rows: data.rows,
            tileHeight: data.tileHeight,
            tileWidth: data.tileWidth,
            sceneWidth: (data.rows + data.cols) * (data.tileWidth / 2),
            sceneHeight: (data.rows + data.cols) * (data.tileHeight / 2),
        };
        this.mMiniSize = {
            cols: data.cols * 2,
            rows: data.rows * 2,
            tileWidth: data.tileWidth / 2,
            tileHeight: data.tileHeight / 2,
        };
        this.mMap = new map_Map(this.mWorld);
        this.mMap.setMapInfo(data);
        // if (!this.mWorld.game.scene.getScene(LoadingScene.name))
        //     this.mWorld.game.scene.add(LoadingScene.name, LoadingScene);
        // this.mWorld.game.scene.start(LoadingScene.name, {
        //     world: this.world,
        //     room: this,
        // });
        this.world.showLoading().then(function () {
            _this.completeLoad();
        });
        this.mCameraService = new cameras_manager["a" /* CamerasManager */](this);
    };
    Room.prototype.onFullPacketReceived = function (sprite_t) {
        if (sprite_t !== protocols["op_def"].NodeType.TerrainNodeType) {
            return;
        }
    };
    Room.prototype.onClockReady = function () {
        // TODO: Unload loading-scene
    };
    Room.prototype.startLoad = function () { };
    Room.prototype.completeLoad = function () {
        this.mWorld.game.scene.add(play["a" /* PlayScene */].name, play["a" /* PlayScene */], true, {
            room: this,
        });
    };
    Room.prototype.startPlay = function () {
        var _this = this;
        if (this.mLayManager) {
            this.layerManager.destroy();
        }
        this.mScene = this.world.game.scene.getScene(play["a" /* PlayScene */].name);
        this.mTerrainManager = new terrain_manager["a" /* TerrainManager */](this, this);
        this.mElementManager = new element_manager["a" /* ElementManager */](this);
        this.mPlayerManager = new player_manager_PlayerManager(this);
        this.mWallManager = new wall_manager_WallManager(this);
        this.mBlocks = new viewblock_manager["a" /* ViewblockManager */](this.mCameraService);
        this.mLayManager = new layer_manager["a" /* LayerManager */](this);
        this.mGroupManager = new GroupManager_GroupManager(this);
        this.mFrameManager = new frame_manager_FrameManager();
        this.mSkyboxManager = new sky_box_manager_SkyBoxManager(this);
        if (this.scene) {
            var camera = this.scene.cameras.main;
            this.mCameraService.camera = camera;
            this.mCameraService.setBounds(-camera.width >> 1, -camera.height >> 1, this.mSize.sceneWidth * this.mScaleRatio + camera.width, this.mSize.sceneHeight * this.mScaleRatio + camera.height);
            // init block
            this.mBlocks.int(this.mSize);
            if (this.mWorld.moveStyle !== protocols["op_def"].MoveStyle.DIRECTION_MOVE_STYLE) {
                this.mFallEffectContainer = new fall_effect_container_FallEffectContainer(this.mScene, this);
            }
        }
        // this.mPlayerManager.createActor(new PlayerModel(this.mActorData));
        this.mPlayerManager.createActor(this.mActorData);
        var loadingScene = this.mWorld.game.scene.getScene(loading["a" /* LoadingScene */].name);
        this.world.emitter.on(MessageType["a" /* MessageType */].PRESS_ELEMENT, this.onPressElementHandler, this);
        if (loadingScene)
            loadingScene.sleep();
        this.world.changeRoom(this);
        if (this.world.uiManager)
            this.world.uiManager.showMainUI();
        if (this.connection) {
            this.cameraService.syncCamera();
            this.connection.send(new dist["PBpacket"](protocols["op_virtual_world"].OPCODE._OP_CLIENT_REQ_VIRTUAL_WORLD_SCENE_CREATED));
        }
        this.scene.input.on("pointerdown", this.onPointerDownHandler, this);
        this.scene.input.on("pointerup", this.onPointerUpHandler, this);
        this.world.emitter.on("Tap", this.onTapHandler, this);
        // if (this.mWorld.getConfig().game_id === "5e719a0a68196e416ecf7aad") {
        //     this.mBackgrounds = [];
        //     this.mBackgrounds.push(new BackgroundManager(this, "close", this.mCameraService));
        //     // const close = new BackgroundManager(this, "close", this.mCameraService);
        // }
        // this.addSkyBox();
        // const list = ["forestBgm1.mp3", "mineBgm1.mp3", "fisheryBgm1.mp3", "generalBgm1.mp3"];
        // this.world.playSound({
        //     urls: "https://osd.tooqing.com/b4368e3b7aea51d106044127f9cae95e",
        //     field: SoundField.Element,
        //     soundConfig: { loop: true },
        // });
        var scenerys = this.world.elementStorage.getScenerys();
        if (scenerys) {
            for (var _i = 0, scenerys_1 = scenerys; _i < scenerys_1.length; _i++) {
                var scenery = scenerys_1[_i];
                this.addSkyBox(scenery);
            }
        }
        // this.loadModule("https://unpkg.com/jquery").then((module) => {
        //     Logger.getInstance().log(module);
        // });
        this.loadModule("http://localhost:3000/dist/index.min.js").then(function (_a) {
            var Template = _a.Template;
            var plugin = new Template();
            plugin.init(_this.world);
        });
    };
    Room.prototype.loadModule = function (url) {
        return __awaiter(this, void 0, void 0, function () {
            var toExport, esm, esmKeys, exported;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        toExport = {};
                        window.exports = toExport;
                        window.module = { exports: toExport };
                        return [4 /*yield*/, import(/* webpackIgnore: true */ url)];
                    case 1:
                        esm = _a.sent();
                        esmKeys = Object.keys(esm);
                        if (esmKeys.length === 1 && esmKeys[0] === "default")
                            return [2 /*return*/, esm.default];
                        if (esmKeys.length)
                            return [2 /*return*/, esm];
                        exported = window.module.exports;
                        delete window.exports;
                        delete window.module;
                        return [2 /*return*/, exported];
                }
            });
        });
    };
    Room.prototype.pause = function () {
        if (this.mScene)
            this.mScene.scene.pause();
        if (this.mWorld && this.mWorld.inputManager)
            this.mWorld.inputManager.enable = false;
    };
    Room.prototype.resume = function (name) {
        if (this.mScene)
            this.mScene.scene.resume(name);
        if (this.mWorld && this.mWorld.inputManager)
            this.mWorld.inputManager.enable = true;
        // this.mClock.sync(-1);
    };
    Room.prototype.addActor = function (data) {
        this.mActorData = data;
    };
    Room.prototype.addBlockObject = function (object) {
        if (this.blocks) {
            this.blocks.add(object);
        }
    };
    Room.prototype.removeBlockObject = function (object) {
        if (this.blocks) {
            this.blocks.remove(object);
        }
    };
    Room.prototype.updateBlockObject = function (object) {
        if (this.blocks) {
            this.blocks.check(object);
        }
    };
    Room.prototype.addToGround = function (element, index) {
        this.layerManager.addToGround(element, index);
    };
    Room.prototype.addToSurface = function (element) {
        this.layerManager.addToSurface(element);
    };
    Room.prototype.addToSceneUI = function (element) {
        this.layerManager.addToSceneToUI(element);
    };
    Room.prototype.addToUI = function (element) {
        this.layerManager.addToUI(element);
    };
    Room.prototype.resize = function (width, height) {
        if (this.layerManager)
            this.layerManager.resize(width, height);
        if (this.mCameraService)
            this.mCameraService.resize(width, height);
    };
    Room.prototype.transformTo90 = function (p) {
        if (!this.mSize) {
            // Logger.getInstance().error("position object is undefined");
            return;
        }
        return utils["b" /* Position45 */].transformTo90(p, this.mSize);
    };
    Room.prototype.transformTo45 = function (p) {
        if (!this.mSize) {
            // Logger.getInstance().error("position object is undefined");
            return;
        }
        return utils["b" /* Position45 */].transformTo45(p, this.mSize);
    };
    Room.prototype.transformToMini90 = function (p) {
        if (!this.mMiniSize) {
            return;
        }
        return utils["b" /* Position45 */].transformTo90(p, this.miniSize);
    };
    Room.prototype.transformToMini45 = function (p) {
        if (!this.mMiniSize) {
            return;
        }
        return utils["b" /* Position45 */].transformTo45(p, this.mMiniSize);
    };
    Room.prototype.addMouseListen = function () {
        this.layerManager.addMouseListen();
    };
    Room.prototype.moveable = function (pos) {
        var pos45 = this.transformToMini45(pos);
        var map = this.mElementManager.map;
        if (pos45.x < 0 || pos45.x > map.length || pos45.y < 0 || pos45.y > map[0].length) {
            return false;
        }
        if (map[pos45.y][pos45.x] === 0) {
            return false;
        }
        return true;
    };
    Room.prototype.update = function (time, delta) {
        // 角色管理器和地块，物件管理器中在登陆时，add_sprite完成后，把交互管理器的交互开放
        // if (this.mPlayerManager.hasAddComplete && this.mTerainManager.hasAddComplete && this.mElementManager.hasAddComplete) {
        //   if (this.mWorld.inputManager.enable === false && this.world.game.loop.actualFps >= 20) {
        //     this.mWorld.inputManager.enable = true;
        //   }
        // }
        this.updateClock(time, delta);
        this.mBlocks.update(time, delta);
        // this.startCheckBlock();
        if (this.layerManager)
            this.layerManager.update(time, delta);
        if (this.elementManager)
            this.elementManager.update(time, delta);
        if (this.mFrameManager)
            this.frameManager.update(time, delta);
    };
    Room.prototype.updateClock = function (time, delta) {
        // 客户端自己通过delta来更新游戏时间戳
        if (this.mWorld.clock)
            this.mWorld.clock.update(time, delta);
    };
    Room.prototype.now = function () {
        return this.mWorld.clock.unixTime;
    };
    Room.prototype.clear = function () {
        if (this.mLayManager)
            this.mLayManager.destroy();
        if (this.mTerrainManager)
            this.mTerrainManager.destroy();
        if (this.mElementManager)
            this.mElementManager.destroy();
        if (this.mPlayerManager)
            this.mPlayerManager.destroy();
        if (this.mBlocks)
            this.mBlocks.destroy();
        if (this.mSkyboxManager)
            this.mSkyboxManager.destroy();
        if (this.mWallManager)
            this.mWallManager.destroy();
        if (this.mActorData) {
            this.mActorData = null;
        }
    };
    Room.prototype.destroy = function () {
        this.clear();
        this.world.emitter.off("Tap", this.onTapHandler, this);
        if (this.connection)
            this.connection.removePacketListener(this);
        this.mWorld.game.scene.remove(play["a" /* PlayScene */].name);
        this.world.emitter.off(MessageType["a" /* MessageType */].PRESS_ELEMENT, this.onPressElementHandler, this);
        // if (this.mScene) {
        //   this.mScene = null;
        // }
    };
    Room.prototype.addSkyBox = function (scenery) {
        this.mSkyboxManager.add(scenery);
    };
    Room.prototype.onPointerDownHandler = function (pointer) {
        this.addPointerMoveHandler();
    };
    Room.prototype.onPointerUpHandler = function (pointer) {
        this.removePointerMoveHandler();
    };
    Room.prototype.addPointerMoveHandler = function () {
        this.mScene.input.on("pointermove", this.onPointerMoveHandler, this);
        this.mScene.input.on("gameout", this.onGameOutHandler, this);
    };
    Room.prototype.removePointerMoveHandler = function () {
        this.mScene.input.off("pointermove", this.onPointerMoveHandler, this);
        this.mScene.input.off("gameout", this.onGameOutHandler, this);
        if (this.cameraService.moving) {
            this.cameraService.syncCameraScroll();
            this.cameraService.moving = false;
        }
    };
    Room.prototype.onPointerMoveHandler = function (pointer) {
        if (!this.mCameraService.targetFollow) {
            this.cameraService.offsetScroll(pointer.prevPosition.x - pointer.position.x, pointer.prevPosition.y - pointer.position.y);
        }
    };
    Room.prototype.onGameOutHandler = function () {
        this.removePointerMoveHandler();
    };
    Object.defineProperty(Room.prototype, "scene", {
        get: function () {
            return this.mScene || undefined;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Room.prototype, "terrainManager", {
        get: function () {
            return this.mTerrainManager || undefined;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Room.prototype, "elementManager", {
        get: function () {
            return this.mElementManager || undefined;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Room.prototype, "playerManager", {
        get: function () {
            return this.mPlayerManager || undefined;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Room.prototype, "map", {
        get: function () {
            return this.mMap;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Room.prototype, "layerManager", {
        get: function () {
            return this.mLayManager || undefined;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Room.prototype, "groupManager", {
        get: function () {
            return this.mGroupManager || undefined;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Room.prototype, "frameManager", {
        get: function () {
            return this.mFrameManager || undefined;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Room.prototype, "cameraService", {
        get: function () {
            return this.mCameraService || undefined;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Room.prototype, "id", {
        get: function () {
            return this.mID;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Room.prototype, "roomSize", {
        get: function () {
            return this.mSize || undefined;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Room.prototype, "miniSize", {
        get: function () {
            return this.mMiniSize;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Room.prototype, "blocks", {
        get: function () {
            return this.mBlocks;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Room.prototype, "world", {
        get: function () {
            return this.mWorld;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Room.prototype, "enableEdit", {
        get: function () {
            return this.mEnableEdit;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Room.prototype, "connection", {
        get: function () {
            if (this.manager) {
                return this.manager.connection;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Room.prototype, "sceneType", {
        get: function () {
            return protocols["op_def"].SceneTypeEnum.NORMAL_SCENE_TYPE;
        },
        enumerable: false,
        configurable: true
    });
    Room.prototype.onPressElementHandler = function (pointer, gameObject) {
        if (!gameObject || !gameObject.parentContainer) {
            return;
        }
        var com = gameObject.parentContainer;
        if (!(com instanceof display_object["a" /* DisplayObject */])) {
            return;
        }
        var ele = com.element;
        if (!(ele instanceof rooms_element["a" /* Element */])) {
            return;
        }
        if (this.mEnableEdit) {
            var packet = new dist["PBpacket"](protocols["op_virtual_world"].OPCODE._OP_CLIENT_REQ_VIRTUAL_WORLD_EDIT_MODE_ENTER);
            this.connection.send(packet);
        }
    };
    Room.prototype.onEnableEditModeHandler = function (packet) {
        this.mEnableEdit = true;
        // if (this.world) {
        //     this.world.emitter.emit(MessageType.ADD_ICON_TO_TOP, {
        //         key: "Turn_Btn_Top",
        //         name: "EnterDecorate",
        //         bgResKey: "baseView",
        //         bgTextures: ["btnGroup_yellow_normal.png", "btnGroup_yellow_light.png", "btnGroup_yellow_select.png"],
        //         iconResKey: "",
        //         iconTexture: "btnGroup_top_expand.png",
        //         pngUrl: "ui/baseView/mainui_mobile.png", jsonUrl: "ui/baseView/mainui_mobile.json",
        //         scale: 1
        //     });
        // }
    };
    Room.prototype.onShowMapTitle = function (packet) {
        if (!this.scene) {
            return;
        }
        var content = packet.content;
        var area = new reference_area["a" /* ReferenceArea */](this.scene, this);
        var num = [];
        var intArray = content.intArray;
        for (var i = 0; i < intArray.length; i++) {
            num[i] = [];
            for (var j = 0; j < intArray[i].value.length; j++) {
                num[i][j] = intArray[i].value[j];
            }
            // num[i] = intArray[i];
        }
        area.draw(num, new Phaser.Geom.Point(0, 0));
        area.setAlpha(0.1);
        if (area.size) {
            area.setPosition(area.size.sceneWidth / 2, 0);
            this.mLayManager.addToMiddle(area);
        }
    };
    Room.prototype.addFillEffect = function (pos, status) {
        if (!this.scene) {
            utils["a" /* Logger */].getInstance().log("Room scene  does not exist");
            return;
        }
        var fall = new fall_effect_FallEffect(this.scene, this.mScaleRatio);
        fall.show(status);
        fall.setPosition(pos.x * this.mScaleRatio, pos.y * this.mScaleRatio);
        this.addToSceneUI(fall);
        // test
        // const content = new op_client.OP_VIRTUAL_WORLD_REQ_CLIENT_SHOW_INTERACTIVE_BUBBLE();
        // content.duration = 2000;
        // this.playerManager.actor.showInteractionBubble(content);
    };
    Room.prototype.onMovePathHandler = function (packet) {
        var content = packet.content;
        var status = content.pathStatus;
        if (!status) {
            return;
        }
        var pos = content.targetPos;
        this.addFillEffect({ x: pos.x, y: pos.y }, status);
    };
    Room.prototype.move = function (x, y, gameObject) {
        if (this.moveStyle !== protocols["op_def"].MoveStyle.PATH_MOVE_STYLE) {
            return;
        }
        if (!this.mPlayerManager) {
            return;
        }
        var actor = this.mPlayerManager.actor;
        if (!actor) {
            return;
        }
        var pos45 = actor.getPosition45();
        var click45 = this.transformTo45(new utils_pos["a" /* Pos */](x, y));
        if (Math.abs(pos45.x - click45.x) > 20 || Math.abs(pos45.y - click45.y) > 20) {
            this.addFillEffect({ x: x, y: y }, protocols["op_def"].PathReachableStatus.PATH_UNREACHABLE_AREA);
            return;
        }
        var pkt = new dist["PBpacket"](protocols["op_virtual_world"].OPCODE._OP_CLIENT_REQ_VIRTUAL_WORLD_MOVE_TO_TARGET_BY_PATH);
        var content = pkt.content;
        // const pkt: PBpacket = new PBpacket(op_virtual_world.OPCODE._OP_CLIENT_REQ_VIRTUAL_WORLD_MOUSE_EVENT);
        // const content: op_virtual_world.IOP_CLIENT_REQ_VIRTUAL_WORLD_MOUSE_EVENT = pkt.content;
        if (gameObject) {
            var displsy = gameObject.parentContainer;
            if (displsy && displsy instanceof display_object["a" /* DisplayObject */]) {
                var ele = displsy.element;
                if (ele && ele.model) {
                    content.id = ele.model.id;
                    content.nodeType = ele.model.nodeType;
                }
            }
        }
        // content.mouseEvent = [9];
        content.point3f = { x: x, y: y };
        this.connection.send(pkt);
        this.tryMove();
    };
    Room.prototype.tryMove = function () {
        var player = this.mPlayerManager.actor;
        if (!player) {
            return;
        }
        var moveData = player.moveData;
        var pos = moveData.posPath;
        if (!pos || pos.length < 0) {
            return;
        }
        var step = moveData.step;
        if (step >= pos.length) {
            return;
        }
        var playerPosition = player.getPosition();
        var position = protocols["op_def"].PBPoint3f.create();
        position.x = playerPosition.x;
        position.y = playerPosition.y;
        var nextPosition = protocols["op_def"].PBPoint3f.create();
        nextPosition.x = pos[step].x;
        nextPosition.y = pos[step].y;
        var packet = new dist["PBpacket"](protocols["op_virtual_world"].OPCODE._OP_CLIENT_REQ_VIRTUAL_WORLD_CHECK_MOVE_PATH_NEXT_POINT);
        var conten = packet.content;
        conten.timestemp = this.now();
        conten.position = position;
        conten.nextPoint = nextPosition;
        this.connection.send(packet);
    };
    // Move through the location returned by the server
    Room.prototype.onTapHandler = function (pointer, gameObject) {
        this.move(pointer.worldX / this.mScaleRatio, pointer.worldY / this.mScaleRatio, gameObject);
    };
    Room.prototype.enterRoom = function () {
        this.mWorld.game.scene.run(play["a" /* PlayScene */].name, {
            room: this,
        });
    };
    return Room;
}(dist["PacketHandler"]));


// EXTERNAL MODULE: ./src/utils/position45.ts
var position45 = __webpack_require__(17);

// CONCATENATED MODULE: ./src/const/brush.ts
var BrushEnum;
(function (BrushEnum) {
    BrushEnum["MOVE"] = "move";
    BrushEnum["BRUSH"] = "brush";
    BrushEnum["SELECT"] = "select";
    BrushEnum["ERASER"] = "eraser";
    BrushEnum["FILL"] = "FILL";
})(BrushEnum || (BrushEnum = {}));
var Brush = /** @class */ (function () {
    function Brush(mEditorRoom) {
        this.mEditorRoom = mEditorRoom;
        this.mMode = BrushEnum.SELECT;
    }
    Object.defineProperty(Brush.prototype, "mode", {
        get: function () {
            return this.mMode;
        },
        set: function (mode) {
            this.mMode = mode;
        },
        enumerable: false,
        configurable: true
    });
    return Brush;
}());


// EXTERNAL MODULE: ./src/scenes/edit.ts
var edit = __webpack_require__(82);

// EXTERNAL MODULE: ./src/rooms/display/frames.display.ts
var frames_display = __webpack_require__(34);

// CONCATENATED MODULE: ./src/rooms/editor/mouse.follow.ts
var mouse_follow_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var mouse_follow_NodeType = protocols["op_def"].NodeType;



var mouse_follow_MouseFollow = /** @class */ (function () {
    function MouseFollow(mScene, mRoomService) {
        this.mScene = mScene;
        this.mRoomService = mRoomService;
        this.mScaleRatio = 1;
        /**
         * 笔触大小
         */
        this.mSize = 1;
        this.mLayerManager = this.mRoomService.layerManager;
        this.mScaleRatio = this.mRoomService.world.scaleRatio;
    }
    MouseFollow.prototype.setDisplay = function (content) {
        if (!this.mScene)
            return;
        if (this.mDisplay) {
            this.mDisplay.destroy();
            this.mDisplay = null;
        }
        this.mNodeType = content.nodeType;
        this.isMoss = content.isMoss;
        this.key = content.key;
        this.mSprite = new element_sprite["a" /* Sprite */](content.sprite, content.nodeType);
        this.mDisplay = new mouse_follow_MouseDisplayContainer(this.mScene, this.mRoomService);
        var size = this.mNodeType === mouse_follow_NodeType.TerrainNodeType ? this.mSize : 1;
        this.mDisplay.setDisplay(this.mSprite, size);
        this.mDisplay.scale = this.mScaleRatio;
        this.mLayerManager.addToSceneToUI(this.mDisplay);
        if (this.mNodeType === mouse_follow_NodeType.TerrainNodeType) {
            this.mElementManager = this.mRoomService.terrainManager;
        }
        else if (this.mNodeType === mouse_follow_NodeType.ElementNodeType || this.mNodeType === mouse_follow_NodeType.SpawnPointType) {
            this.mElementManager = this.mRoomService.elementManager;
        }
        this.mScene.input.on("pointermove", this.onPointerMoveHandler, this);
        this.mScene.input.on("wheel", this.onWheelHandler, this);
    };
    MouseFollow.prototype.showEraserArea = function () {
        if (!this.mScene)
            return;
        if (this.mDisplay) {
            this.mDisplay.destroy();
        }
        this.mDisplay = new mouse_follow_EraserArea(this.mScene, this.mRoomService);
        this.mDisplay.setDisplay(null, this.mSize);
        this.mNodeType = mouse_follow_NodeType.TerrainNodeType;
        this.mLayerManager.addToSceneToUI(this.mDisplay);
        this.mScene.input.on("pointermove", this.onPointerMoveHandler, this);
        this.mScene.input.on("wheel", this.onWheelHandler, this);
    };
    MouseFollow.prototype.createTerrainsOrMossesData = function () {
        var _this = this;
        var locs = this.mDisplay.displays.map(function (display) { return _this.getPosition(display.x, display.y); });
        return { locs: locs, key: this.key };
    };
    MouseFollow.prototype.createSprites = function () {
        if (!this.mSprite) {
            return;
        }
        var result = [];
        var sprite = null;
        var displays = this.mDisplay.displays;
        for (var _i = 0, displays_1 = displays; _i < displays_1.length; _i++) {
            var display = displays_1[_i];
            // deep clone
            sprite = Object.assign(Object.create(Object.getPrototypeOf(this.mSprite)), this.mSprite);
            sprite.newID();
            sprite.pos = this.getPosition(display.x, display.y);
            sprite.bindID = this.mSprite.id;
            sprite.sn = this.mSprite.sn;
            // sprite.nodeType = this.mSprite.node
            result.push(sprite);
        }
        return result;
    };
    MouseFollow.prototype.getEaserPosition = function () {
        var result = [];
        if (!this.display) {
            return;
        }
        var pos = null;
        for (var i = 0; i < this.mSize; i++) {
            for (var j = 0; j < this.mSize; j++) {
                pos = this.display.transformTo90(i, j);
                result.push(this.getPosition(pos.x, pos.y));
                // result.push(this.mRoomService.transformTo45(new Pos(i, j)));
            }
        }
        // result.push(this.getPosition());
        return result;
    };
    MouseFollow.prototype.transitionGrid = function (x, y) {
        var source = new utils_pos["a" /* Pos */](x, y);
        var pos = this.mNodeType === protocols["op_def"].NodeType.TerrainNodeType
            ? this.mRoomService.transformTo45(source)
            : this.mRoomService.transformToMini45(source);
        if (this.mAlignGrid === false) {
            return this.checkBound(pos, source);
        }
        return this.checkBound(pos);
    };
    /**
     * 边界检查
     * @param pos 45度坐标，
     * @param source 没有超出边界并不贴边就返回原始坐标
     */
    MouseFollow.prototype.checkBound = function (pos, source) {
        var bound = new utils_pos["a" /* Pos */](pos.x, pos.y);
        var size = this.mNodeType === protocols["op_def"].NodeType.TerrainNodeType
            ? this.mRoomService.roomSize
            : this.mRoomService.miniSize;
        if (pos.x < 0) {
            bound.x = 0;
        }
        else if (pos.x > size.cols) {
            bound.x = size.cols;
        }
        if (pos.y < 0) {
            bound.y = 0;
        }
        else if (pos.y > size.rows) {
            bound.y = size.rows;
        }
        if (bound.equal(pos) && source) {
            return source;
        }
        if (this.mNodeType === protocols["op_def"].NodeType.TerrainNodeType) {
            return this.mRoomService.transformTo90(bound);
        }
        return this.mRoomService.transformToMini90(bound);
    };
    MouseFollow.prototype.destroy = function () {
        if (this.mScene) {
            this.mScene.input.off("pointermove", this.onPointerMoveHandler, this);
            this.mScene.input.off("wheel", this.onWheelHandler, this);
        }
        if (this.mDisplay) {
            this.mDisplay.destroy();
            this.mDisplay = null;
        }
        this.mNodeType = mouse_follow_NodeType.UnknownNodeType;
    };
    MouseFollow.prototype.onPointerMoveHandler = function (pointer) {
        this.updatePos(pointer.worldX / this.mScaleRatio, pointer.worldY / this.mScaleRatio);
    };
    MouseFollow.prototype.getPosition = function (rows, cols) {
        if (rows === void 0) { rows = 0; }
        if (cols === void 0) { cols = 0; }
        if (this.mNodeType === protocols["op_def"].NodeType.TerrainNodeType) {
            var pos45 = this.mRoomService.transformTo45(new utils_pos["a" /* Pos */](this.mDisplay.x / this.mScaleRatio + rows, this.mDisplay.y / this.mScaleRatio + cols));
            return pos45;
        }
        // TODO 多个物件仅支持地块
        var pos = new utils_pos["a" /* Pos */](this.mDisplay.x / this.mScaleRatio + rows, this.mDisplay.y / this.mScaleRatio + cols, this.mDisplay.z);
        return pos;
    };
    MouseFollow.prototype.onWheelHandler = function (pointer) {
        if (this.mNodeType !== mouse_follow_NodeType.TerrainNodeType) {
            return;
        }
        if (pointer.deltaY < 0) {
            this.size--;
        }
        else {
            this.size++;
        }
        this.updatePos(pointer.worldX / this.mScaleRatio, pointer.worldY / this.mScaleRatio);
    };
    MouseFollow.prototype.updatePos = function (worldX, worldY) {
        if (!this.mDisplay) {
            return;
        }
        var pos = this.transitionGrid(worldX, worldY);
        if (!pos) {
            return;
        }
        this.mDisplay.setLocation(pos.x * this.mScaleRatio, pos.y * this.mScaleRatio);
    };
    Object.defineProperty(MouseFollow.prototype, "alignGrid", {
        set: function (val) {
            this.mAlignGrid = val;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MouseFollow.prototype, "display", {
        get: function () {
            return this.mDisplay;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MouseFollow.prototype, "sprite", {
        get: function () {
            return this.mSprite;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MouseFollow.prototype, "nodeType", {
        get: function () {
            return this.mNodeType;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MouseFollow.prototype, "elementManager", {
        get: function () {
            return this.mElementManager;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MouseFollow.prototype, "size", {
        get: function () {
            return this.mSize;
        },
        set: function (val) {
            if (val < 1) {
                val = 1;
            }
            if (val > 20) {
                val = 20;
            }
            this.mSize = val;
            this.mDisplay.setDisplay(this.mSprite, this.mSize);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MouseFollow.prototype, "isMoss", {
        get: function () {
            return this._isMoss;
        },
        set: function (val) {
            this._isMoss = val;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MouseFollow.prototype, "key", {
        get: function () {
            return this._key;
        },
        set: function (val) {
            this._key = val;
        },
        enumerable: false,
        configurable: true
    });
    return MouseFollow;
}());

var mouse_follow_MouseDisplayContainer = /** @class */ (function (_super) {
    mouse_follow_extends(MouseDisplayContainer, _super);
    function MouseDisplayContainer(scene, mRoomService) {
        var _this = _super.call(this, scene) || this;
        _this.mRoomService = mRoomService;
        _this.mScaleRatio = 1;
        _this.mScaleRatio = _this.mRoomService.world.scaleRatio;
        _this.mOffset = new Phaser.Geom.Point();
        return _this;
    }
    MouseDisplayContainer.prototype.setDisplay = function (sprite, size) {
        this.clear();
        this.mDisplay = [];
        if (!sprite) {
            return;
        }
        var frame = sprite.displayInfo;
        this.mNodeType = sprite.nodeType;
        var frameDisplay;
        var _a = this.mRoomService.roomSize, tileWidth = _a.tileWidth, tileHeight = _a.tileHeight;
        this.mTileSize = {
            tileWidth: tileWidth,
            tileHeight: tileHeight,
            rows: size,
            cols: size,
            sceneWidth: (size + size) * (tileWidth / 2),
            sceneHeight: (size + size) * (tileHeight / 2),
        };
        this.mOffset.x = -((this.mTileSize.sceneWidth / 2) * this.mScaleRatio);
        this.mOffset.y = -((this.mTileSize.sceneHeight / this.mScaleRatio - (size % 2 === 0 ? 0 : tileHeight)) / 2);
        for (var i = 0; i < size; i++) {
            for (var j = 0; j < size; j++) {
                frameDisplay = new frames_display["a" /* FramesDisplay */](this.scene, this.mRoomService);
                frameDisplay.setAlpha(0.8);
                frameDisplay.once("initialized", this.onInitializedHandler, this);
                frameDisplay.load(frame);
                var pos = position45["a" /* Position45 */].transformTo90(new utils_pos["a" /* Pos */](i, j), this.mTileSize);
                frameDisplay.x = pos.x;
                frameDisplay.y = pos.y;
                this.add(frameDisplay);
                this.mDisplay.push(frameDisplay);
            }
        }
    };
    MouseDisplayContainer.prototype.transformTo90 = function (row, col) {
        return position45["a" /* Position45 */].transformTo90(new utils_pos["a" /* Pos */](row, col), this.mTileSize);
    };
    MouseDisplayContainer.prototype.transformTo45 = function (x, y) {
        return position45["a" /* Position45 */].transformTo45(new utils_pos["a" /* Pos */](x, y), this.mTileSize);
    };
    MouseDisplayContainer.prototype.setLocation = function (x, y) {
        this.x = x + this.mOffset.x;
        this.y = y + this.mOffset.y;
        return this;
    };
    MouseDisplayContainer.prototype.clear = function () {
        this.removeAll(true);
        this.mDisplay = undefined;
    };
    MouseDisplayContainer.prototype.destroy = function (fromScene) {
        this.clear();
        _super.prototype.destroy.call(this, fromScene);
    };
    Object.defineProperty(MouseDisplayContainer.prototype, "displays", {
        get: function () {
            return this.mDisplay;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MouseDisplayContainer.prototype, "tileWidth", {
        get: function () {
            var tmp = this.mTileSize.tileHeight;
            if (this.mTileSize.rows % 2 === 0) {
                tmp = 0;
            }
            return this.mTileSize.sceneWidth - tmp;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MouseDisplayContainer.prototype, "tileHeight", {
        get: function () {
            return this.mTileSize.sceneHeight;
        },
        enumerable: false,
        configurable: true
    });
    MouseDisplayContainer.prototype.onInitializedHandler = function (obj) {
        if (obj) {
            if (this.mNodeType !== protocols["op_def"].NodeType.TerrainNodeType) {
                obj.showRefernceArea();
            }
        }
    };
    return MouseDisplayContainer;
}(Phaser.GameObjects.Container));
var mouse_follow_EraserArea = /** @class */ (function (_super) {
    mouse_follow_extends(EraserArea, _super);
    function EraserArea(scene, roomService) {
        return _super.call(this, scene, roomService) || this;
    }
    EraserArea.prototype.setDisplay = function (frame, size) {
        if (this.area) {
            this.area.clear();
        }
        var _a = this.mRoomService.roomSize, tileWidth = _a.tileWidth, tileHeight = _a.tileHeight;
        this.mTileSize = {
            tileWidth: tileWidth,
            tileHeight: tileHeight,
            rows: size,
            cols: size,
            sceneWidth: (size + size) * (tileWidth / 2),
            sceneHeight: (size + size) * (tileHeight / 2),
        };
        this.mOffset.x = -(this.mTileSize.sceneWidth / 2);
        this.mOffset.y = -((this.mTileSize.sceneHeight - (size % 2 === 0 ? 0 : tileHeight)) / 2);
        var p1;
        var p2;
        var p3;
        var p4;
        this.area = this.scene.make.graphics(undefined, false);
        for (var y = 0; y < size; y++) {
            for (var x = 0; x < size; x++) {
                this.area.lineStyle(2, 0);
                p1 = position45["a" /* Position45 */].transformTo90(new utils_pos["a" /* Pos */](x, y), this.mTileSize);
                p2 = position45["a" /* Position45 */].transformTo90(new utils_pos["a" /* Pos */](x + 1, y), this.mTileSize);
                p3 = position45["a" /* Position45 */].transformTo90(new utils_pos["a" /* Pos */](x + 1, y + 1), this.mTileSize);
                p4 = position45["a" /* Position45 */].transformTo90(new utils_pos["a" /* Pos */](x, y + 1), this.mTileSize);
                this.area.beginPath();
                this.area.fillStyle(0, 0.5);
                this.area.strokePoints([p1.toPoint(), p2.toPoint(), p3.toPoint(), p4.toPoint()], true, true);
                this.area.fillPath();
            }
        }
        this.add(this.area);
    };
    return EraserArea;
}(mouse_follow_MouseDisplayContainer));

// EXTERNAL MODULE: ./src/rooms/display/terrain.display.ts
var terrain_display = __webpack_require__(51);

// CONCATENATED MODULE: ./src/rooms/editor/selected.element.ts


var selected_element_SelectedElement = /** @class */ (function () {
    function SelectedElement(mScene, mLayerManager) {
        this.mScene = mScene;
        this.mLayerManager = mLayerManager;
        this.mEffecte = new dynamic_image["a" /* DynamicImage */](this.mScene, 0, 0);
        this.mEffecte.load(resUtil["c" /* Url */].getRes("ui/editor/selectFlag.png"));
    }
    SelectedElement.prototype.setElement = function (display) {
        if (this.mDisplay) {
            this.mDisplay.hideRefernceArea();
            this.mDisplay.showNickname("");
            this.mSprite = undefined;
        }
        this.mDisplay = display;
        display.showRefernceArea();
        var ele = display.element;
        if (ele) {
            ele.showNickname();
            this.mSprite = ele.model;
        }
        this.mLayerManager.addToSceneToUI(this.mEffecte);
        this.mSelecting = true;
        this.update();
    };
    SelectedElement.prototype.remove = function () {
        this.mSelecting = false;
        if (!this.mEffecte) {
            return;
        }
        if (this.mEffecte.parentContainer) {
            this.mEffecte.parentContainer.remove(this.mEffecte);
        }
        if (!this.mDisplay) {
            return;
        }
        if (this.mDisplay.parentContainer) {
            this.mDisplay.hideRefernceArea();
            this.mDisplay.showNickname("");
        }
        this.mDisplay = null;
        this.mSprite = undefined;
    };
    SelectedElement.prototype.update = function () {
        if (!this.mDisplay) {
            return;
        }
        var baseLoc = this.mDisplay.baseLoc;
        this.mEffecte.x = this.mDisplay.x + baseLoc.x + (this.mDisplay.spriteWidth >> 1);
        this.mEffecte.y = this.mDisplay.y + baseLoc.y;
    };
    SelectedElement.prototype.setDisplayPos = function (x, y) {
        if (!this.mDisplay) {
            return;
        }
        this.mDisplay.x = x;
        this.mDisplay.y = y;
        if (this.mSprite) {
            var pos = this.mSprite.pos;
            if (pos) {
                pos.x = x;
                pos.y = y;
            }
        }
    };
    SelectedElement.prototype.destroy = function () {
        if (!this.mEffecte) {
            return;
        }
        this.remove();
        this.mEffecte.destroy();
        this.mEffecte = null;
    };
    Object.defineProperty(SelectedElement.prototype, "display", {
        get: function () {
            return this.mDisplay;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SelectedElement.prototype, "selecting", {
        /**
         * 鼠标按下选中物件, 松开取消选择
         */
        get: function () {
            return this.mSelecting;
        },
        set: function (val) {
            this.mSelecting = val;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SelectedElement.prototype, "sprite", {
        get: function () {
            return this.mSprite;
        },
        enumerable: false,
        configurable: true
    });
    return SelectedElement;
}());


// CONCATENATED MODULE: ./src/rooms/element/editor.element.manager.ts
var editor_element_manager_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();





var editor_element_manager_NodeType = protocols["op_def"].NodeType;
var editor_element_manager_EditorElementManager = /** @class */ (function (_super) {
    editor_element_manager_extends(EditorElementManager, _super);
    function EditorElementManager(mRoom) {
        var _this = _super.call(this, mRoom) || this;
        _this.mRoom = mRoom;
        _this.taskQueue = new Map();
        if (_this.connection) {
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_EDITOR_REQ_CLIENT_CREATE_SPRITE, _this.handleCreateElements);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_EDITOR_REQ_CLIENT_DELETE_SPRITE, _this.handleDeleteElements);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_EDITOR_REQ_CLIENT_SYNC_SPRITE, _this.handleSyncElements);
        }
        return _this;
    }
    EditorElementManager.prototype.update = function () {
        this.batchActionSprites();
    };
    EditorElementManager.prototype.addElements = function (sprites) {
        for (var _i = 0, sprites_1 = sprites; _i < sprites_1.length; _i++) {
            var sprite = sprites_1[_i];
            this.taskQueue.set(sprite.id, {
                action: "ADD",
                sprite: sprite,
            });
        }
        this.callEditorCreateElementData(sprites);
    };
    EditorElementManager.prototype.callEditorCreateElementData = function (sprites) {
        var pkt = new dist["PBpacket"](protocols["op_editor"].OPCODE._OP_CLIENT_REQ_EDITOR_CREATE_SPRITE);
        var content = pkt.content;
        content.nodeType = sprites[0].nodeType;
        content.sprites = sprites.map(function (sprite) { return sprite.toSprite(); });
        this.connection.send(pkt);
        log["a" /* Logger */].getInstance().log("add sprites: ", content);
    };
    EditorElementManager.prototype.updateElements = function (sprites) {
        this.callEditorUpdateElementData(sprites);
    };
    EditorElementManager.prototype.callEditorUpdateElementData = function (sprites) {
        var pkt = new dist["PBpacket"](protocols["op_editor"].OPCODE._OP_CLIENT_REQ_EDITOR_SYNC_SPRITE);
        var content = pkt.content;
        content.sprites = sprites;
        this.connection.send(pkt);
    };
    // removeEditor(id: number) {
    //     const ele = this.tryRemove(id);
    //     if (ele) {
    //         const pkt = new PBpacket(op_editor.OPCODE._OP_CLIENT_REQ_EDITOR_DELETE_SPRITE);
    //         const content: op_editor.IOP_CLIENT_REQ_EDITOR_DELETE_SPRITE = pkt.content;
    //         content.ids = [id];
    //         this.connection.send(pkt);
    //     }
    //     return ele;
    // }
    EditorElementManager.prototype.deleteElements = function (ids) {
        for (var _i = 0, ids_1 = ids; _i < ids_1.length; _i++) {
            var id = ids_1[_i];
            this.taskQueue.set(id, {
                action: "DELETE",
                sprite: { id: id },
            });
        }
        this.callEditorDeleteElementData(ids);
    };
    EditorElementManager.prototype.callEditorDeleteElementData = function (ids) {
        var pkt = new dist["PBpacket"](protocols["op_editor"].OPCODE._OP_CLIENT_REQ_EDITOR_DELETE_SPRITE);
        var content = pkt.content;
        content.ids = ids;
        content.nodeType = protocols["op_def"].NodeType.ElementNodeType;
        this.connection.send(pkt);
    };
    EditorElementManager.prototype.handleCreateElements = function (packet) {
        if (!this.mRoom.layerManager) {
            log["a" /* Logger */].getInstance().error("layer manager does not exist");
            return;
        }
        var content = packet.content;
        var sprites = content.sprites, nodeType = content.nodeType;
        for (var _i = 0, sprites_2 = sprites; _i < sprites_2.length; _i++) {
            var sprite = sprites_2[_i];
            this.taskQueue.set(sprite.id, {
                action: "ADD",
                sprite: new element_sprite["a" /* Sprite */](sprite),
            });
        }
        // if (!sprites) return;
        // if (nodeType !== NodeType.ElementNodeType && nodeType !== NodeType.SpawnPointType) {
        //     return;
        // }
        // let point: op_def.IPBPoint3f;
        // const displays = [];
        // let ele: Element = null;
        // for (const sprite of sprites) {
        //     point = sprite.point3f;
        //     if (point) {
        //         ele = this._add(new Sprite(sprite, nodeType));
        //         if (ele.getDisplay()) displays.push(ele.getDisplay());
        //     }
        // }
        // this.mRoom.addToSurface(displays);
    };
    EditorElementManager.prototype.handleDeleteElements = function (packet) {
        var content = packet.content;
        var ids = content.ids, nodeType = content.nodeType;
        if (nodeType !== editor_element_manager_NodeType.ElementNodeType && nodeType !== editor_element_manager_NodeType.SpawnPointType) {
            return;
        }
        // for (const id of ids) {
        //     this.tryRemove(id);
        // }
        // this.roomService.removeSelected();
        for (var _i = 0, ids_2 = ids; _i < ids_2.length; _i++) {
            var id = ids_2[_i];
            this.taskQueue.set(id, {
                action: "DELETE",
                sprite: { id: id },
            });
        }
        this.roomService.removeSelected();
    };
    EditorElementManager.prototype.handleSyncElements = function (packet) {
        var content = packet.content;
        var sprites = content.sprites;
        if (content.nodeType !== protocols["op_def"].NodeType.ElementNodeType) {
            return;
        }
        for (var _i = 0, sprites_3 = sprites; _i < sprites_3.length; _i++) {
            var sprite = sprites_3[_i];
            // this.trySync(sprite);
            this.taskQueue.set(sprite.id, {
                action: "UPDATE",
                sprite: new element_sprite["a" /* Sprite */](sprite),
            });
        }
    };
    // protected _add(sprite: ISprite): Element {
    //     let ele = this.mElements.get(sprite.id);
    //     if (!ele) ele = new Element(sprite, this);
    //     ele.setBlockable(false);
    //     ele.setRenderable(true);
    //     ele.setInputEnable(InputEnable.Enable);
    //     this.mElements.set(ele.id, ele);
    //     return ele;
    // }
    // protected tryRemove(id) {
    //     const element = this.mElements.get(id);
    //     if (element) {
    //         this.mElements.delete(id);
    //         element.destroy();
    //         if (this.roomService) {
    //             this.roomService.blocks.remove(element);
    //         }
    //         return element;
    //     }
    // }
    // protected trySync(sprite: op_client.ISprite) {
    //     const element = this.mElements.get(sprite.id);
    //     if (!element) {
    //         Logger.getInstance().log("can't find element", sprite);
    //         return;
    //     }
    //     const point = sprite.point3f;
    //     if (point) {
    //         element.setPosition(new Pos(point.x, point.y, point.z));
    //     }
    //     if (sprite.direction) {
    //         element.setDirection(sprite.direction);
    //     }
    // }
    EditorElementManager.prototype.batchActionSprites = function () {
        if (!Array.from(this.taskQueue.keys()).length) {
            return;
        }
        var batchTasksKeys = Array.from(this.taskQueue.keys()).splice(0, 200);
        for (var _i = 0, batchTasksKeys_1 = batchTasksKeys; _i < batchTasksKeys_1.length; _i++) {
            var key = batchTasksKeys_1[_i];
            var _a = this.taskQueue.get(key), action = _a.action, sprite = _a.sprite;
            this.taskQueue.delete(key);
            if (action === "ADD") {
                this.mRoom.displayObjectPool.push("elements", sprite.id.toString(), sprite, this);
            }
            else if (action === "DELETE") {
                this.mRoom.displayObjectPool.remove("elements", sprite.id.toString());
            }
            else if (action === "UPDATE") {
                this.mRoom.displayObjectPool.update("elements", sprite.id.toString(), sprite);
            }
        }
    };
    Object.defineProperty(EditorElementManager.prototype, "roomService", {
        get: function () {
            return this.mRoom;
        },
        enumerable: false,
        configurable: true
    });
    return EditorElementManager;
}(element_manager["a" /* ElementManager */]));


// CONCATENATED MODULE: ./src/rooms/terrain/editor.terrain.manager.ts
var editor_terrain_manager_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};




var editor_terrain_manager_EditorTerrainManager = /** @class */ (function (_super) {
    editor_terrain_manager_extends(EditorTerrainManager, _super);
    function EditorTerrainManager(mRoom, listener) {
        var _this = _super.call(this, mRoom, listener) || this;
        _this.mRoom = mRoom;
        _this.taskQueue = new Map();
        _this.mEditorTerrains = new Map();
        if (_this.connection) {
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_EDITOR_REQ_CLIENT_ADD_SPRITES_WITH_LOCS, _this.handleAddTerrains);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_EDITOR_REQ_CLIENT_DELETE_SPRITES_WITH_LOCS, _this.handleDeleteTerrains);
        }
        return _this;
    }
    EditorTerrainManager.prototype.addTerrains = function (terrainCoorData) {
        var _this = this;
        var locs = terrainCoorData.locs, key = terrainCoorData.key;
        var drawLocs = locs.filter(function (loc) { return _this.canPut(loc, key); });
        for (var _i = 0, drawLocs_1 = drawLocs; _i < drawLocs_1.length; _i++) {
            var loc = drawLocs_1[_i];
            var locId = this.genLocId(loc.x, loc.y);
            var oldKey = this.mEditorTerrains.get(locId);
            if (oldKey && oldKey !== key) {
                this.taskQueue.set(locId, {
                    action: "UPDATE",
                    loc: __assign(__assign({}, loc), { key: key }),
                });
            }
            else {
                this.taskQueue.set(locId, {
                    action: "ADD",
                    loc: __assign(__assign({}, loc), { key: key }),
                });
            }
        }
        this.reqEditorAddTerrainsData(drawLocs, key);
    };
    EditorTerrainManager.prototype.reqEditorAddTerrainsData = function (locs, key) {
        var pkt = new dist["PBpacket"](protocols["op_editor"].OPCODE._OP_CLIENT_REQ_EDITOR_ADD_TERRAINS);
        var content = pkt.content;
        content.locs = locs;
        content.key = key;
        this.connection.send(pkt);
    };
    EditorTerrainManager.prototype.removeTerrains = function (locations) {
        for (var _i = 0, locations_1 = locations; _i < locations_1.length; _i++) {
            var pos = locations_1[_i];
            var locId = this.genLocId(pos.x, pos.y);
            this.taskQueue.set(locId, {
                action: "DELETE",
                loc: {
                    x: pos.x,
                    y: pos.y,
                },
            });
        }
        this.reqEditorDeleteTerrainsData(locations);
    };
    EditorTerrainManager.prototype.reqEditorDeleteTerrainsData = function (loc) {
        var pkt = new dist["PBpacket"](protocols["op_editor"].OPCODE._OP_CLIENT_REQ_EDITOR_DELETE_TERRAINS);
        var content = pkt.content;
        content.locs = loc.map(function (item) { return ({ x: item.x, y: item.y, z: item.z }); });
        this.connection.send(pkt);
    };
    EditorTerrainManager.prototype.update = function () {
        this.batchActionSprites();
    };
    EditorTerrainManager.prototype.handleAddTerrains = function (packet) {
        if (!this.mRoom.layerManager) {
            log["a" /* Logger */].getInstance().error("layer manager does not exist");
            return;
        }
        var content = packet.content;
        var locs = content.locs;
        var nodeType = content.nodeType;
        if (nodeType !== protocols["op_def"].NodeType.TerrainNodeType) {
            return;
        }
        for (var _i = 0, locs_1 = locs; _i < locs_1.length; _i++) {
            var loc = locs_1[_i];
            var locId = this.genLocId(loc.x, loc.y);
            var oldKey = this.mEditorTerrains.get(locId);
            if (oldKey && oldKey === loc.key)
                continue;
            this.taskQueue.set(locId, {
                action: "ADD",
                loc: loc,
            });
        }
    };
    EditorTerrainManager.prototype.handleDeleteTerrains = function (packet) {
        if (!this.mRoom.layerManager) {
            log["a" /* Logger */].getInstance().error("layer manager does not exist");
            return;
        }
        var content = packet.content;
        var locs = content.locs;
        var nodeType = content.nodeType;
        if (nodeType !== protocols["op_def"].NodeType.TerrainNodeType) {
            return;
        }
        for (var _i = 0, locs_2 = locs; _i < locs_2.length; _i++) {
            var loc = locs_2[_i];
            var locId = this.genLocId(loc.x, loc.y);
            this.taskQueue.set(locId, {
                action: "DELETE",
                loc: loc,
            });
        }
    };
    EditorTerrainManager.prototype.canPut = function (pos, key) {
        var locId = this.genLocId(pos.x, pos.y);
        var roomSize = this.roomService.roomSize;
        if (!roomSize)
            return false;
        if (pos.x < 0 || pos.y < 0 || pos.x >= roomSize.cols || pos.y >= roomSize.rows) {
            return false;
        }
        if (this.mEditorTerrains.get(locId) === key) {
            return false;
        }
        return true;
    };
    EditorTerrainManager.prototype.batchActionSprites = function () {
        if (!Array.from(this.taskQueue.keys()).length) {
            return;
        }
        var batchTasksKeys = Array.from(this.taskQueue.keys()).splice(0, 200);
        for (var _i = 0, batchTasksKeys_1 = batchTasksKeys; _i < batchTasksKeys_1.length; _i++) {
            var key = batchTasksKeys_1[_i];
            var _a = this.taskQueue.get(key), action = _a.action, loc = _a.loc;
            var locId = this.genLocId(loc.x, loc.y);
            this.taskQueue.delete(key);
            if (action === "ADD") {
                var palette = this.mRoom.world.elementStorage.getTerrainPalette(loc.key);
                if (!palette)
                    continue;
                var sprite = palette.createSprite({
                    nodeType: protocols["op_def"].NodeType.TerrainNodeType,
                    x: loc.x,
                    y: loc.y,
                });
                this.mEditorTerrains.set(locId, loc.key);
                this.mRoom.displayObjectPool.push("terrains", locId, sprite, this);
            }
            else if (action === "DELETE") {
                this.mEditorTerrains.delete(locId);
                this.mRoom.displayObjectPool.remove("terrains", locId);
            }
            else if (action === "UPDATE") {
                var palette = this.mRoom.world.elementStorage.getTerrainPalette(loc.key);
                if (!palette)
                    continue;
                var sprite = palette.createSprite({
                    nodeType: protocols["op_def"].NodeType.TerrainNodeType,
                    x: loc.x,
                    y: loc.y,
                });
                this.mEditorTerrains.set(locId, loc.key);
                this.mRoom.displayObjectPool.update("terrains", locId, sprite);
            }
        }
    };
    EditorTerrainManager.prototype.genLocId = function (x, y) {
        return x + "_" + y;
    };
    return EditorTerrainManager;
}(terrain_manager["a" /* TerrainManager */]));


// CONCATENATED MODULE: ./src/rooms/cameras/editor.cameras.manager.ts
var editor_cameras_manager_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var editor_cameras_manager_EditorCamerasManager = /** @class */ (function (_super) {
    editor_cameras_manager_extends(EditorCamerasManager, _super);
    function EditorCamerasManager() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    EditorCamerasManager.prototype.centerCameas = function () {
        if (!this.mMain || !this.mRoomService) {
            return;
        }
        var roomSize = this.mRoomService.roomSize;
        this.mMain.setScroll((roomSize.sceneWidth - this.mMain.width) >> 1, (roomSize.sceneHeight - this.mMain.height) >> 1);
        var cameraView = this.mMain.worldView;
        var pkt = new dist["PBpacket"](protocols["op_editor"].OPCODE._OP_CLIENT_REQ_EDITOR_RESET_CAMERA);
        var content = pkt.content;
        content.x = this.mMain.scrollX;
        content.y = this.mMain.scrollY;
        content.width = this.mMain.width;
        content.height = this.mMain.height;
        this.connection.send(pkt);
    };
    EditorCamerasManager.prototype.offsetScroll = function (x, y) {
        if (!this.mMain) {
            return;
        }
        for (var _i = 0, _a = this.mCameras; _i < _a.length; _i++) {
            var camera = _a[_i];
            camera.scrollX += x / this.zoom;
            camera.scrollY += y / this.zoom;
        }
        // this.mMain.scrollX += x / this.zoom;
        // this.mMain.scrollY += y / this.zoom;
        // this.mCamera.setScroll(x, y);
        // const pkt = new PBpacket(op_editor.OPCODE._OP_CLIENT_REQ_EDITOR_RESET_CAMERA);
        // const content: op_editor.IOP_CLIENT_REQ_EDITOR_RESET_CAMERA = pkt.content;
        // content.x = this.mMain.scrollX / this.zoom;
        // content.y = this.mMain.scrollY / this.zoom;
        // content.width = 0;
        // content.height = 0;
        // this.connection.send(pkt);
    };
    EditorCamerasManager.prototype.syncCameraScroll = function () {
        var pkt = new dist["PBpacket"](protocols["op_editor"].OPCODE._OP_CLIENT_REQ_EDITOR_RESET_CAMERA);
        var content = pkt.content;
        content.x = this.mMain.scrollX / this.zoom;
        content.y = this.mMain.scrollY / this.zoom;
        content.width = 0;
        content.height = 0;
        this.connection.send(pkt);
    };
    return EditorCamerasManager;
}(cameras_manager["a" /* CamerasManager */]));


// EXTERNAL MODULE: ./src/utils/helpers.ts
var helpers = __webpack_require__(47);

// CONCATENATED MODULE: ./src/rooms/element/editor.moss.manager.ts
var editor_moss_manager_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var editor_moss_manager_assign = (undefined && undefined.__assign) || function () {
    editor_moss_manager_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return editor_moss_manager_assign.apply(this, arguments);
};




var editor_moss_manager_EditorMossManager = /** @class */ (function (_super) {
    editor_moss_manager_extends(EditorMossManager, _super);
    function EditorMossManager(mRoom) {
        var _this = _super.call(this, mRoom) || this;
        _this.mRoom = mRoom;
        _this.taskQueue = new Map();
        _this.editorMosses = new Map();
        if (_this.connection) {
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_EDITOR_REQ_CLIENT_ADD_MOSSES, _this.handleAddMosses);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_EDITOR_REQ_CLIENT_DELETE_MOSSES, _this.handleDeleteMosses);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_EDITOR_REQ_CLIENT_SYNC_MOSSES, _this.handleUpdateMosses);
        }
        return _this;
    }
    EditorMossManager.prototype.update = function () {
        this.batchActionSprites();
    };
    EditorMossManager.prototype.addMosses = function (coorData) {
        var placeLocs = [];
        var locs = coorData.locs, key = coorData.key;
        for (var _i = 0, locs_1 = locs; _i < locs_1.length; _i++) {
            var loc = locs_1[_i];
            var id = helpers["a" /* default */].genId();
            var placeLoc = {
                x: loc.x,
                y: loc.y,
                z: loc.z,
                key: key,
                id: id,
            };
            this.taskQueue.set(id, {
                action: "ADD",
                loc: placeLoc,
            });
            placeLocs.push(placeLoc);
        }
        this.reqEditorCreateMossData(placeLocs);
    };
    EditorMossManager.prototype.reqEditorCreateMossData = function (locs) {
        var pkt = new dist["PBpacket"](protocols["op_editor"].OPCODE._OP_CLIENT_REQ_EDITOR_CREATE_MOSSES);
        var content = pkt.content;
        content.locs = locs;
        this.connection.send(pkt);
    };
    EditorMossManager.prototype.updateMosses = function (elements) {
        var updateLocs = [];
        for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
            var element = elements_1[_i];
            var sprite = element.display.element.model.toSprite();
            var originLoc = this.editorMosses.get(sprite.id);
            var loc = {
                x: sprite.point3f.x,
                y: sprite.point3f.y,
                z: sprite.point3f.z,
                id: sprite.id,
                dir: sprite.direction,
                key: originLoc.key,
            };
            this.taskQueue.set(sprite.id, {
                action: "UPDATE",
                loc: loc,
            });
            updateLocs.push(loc);
        }
        this.reqEditorUpdateMossData(updateLocs);
    };
    EditorMossManager.prototype.reqEditorUpdateMossData = function (locs) {
        var pkt = new dist["PBpacket"](protocols["op_editor"].OPCODE._OP_CLIENT_REQ_EDITOR_SYNC_MOSSES);
        var content = pkt.content;
        content.locs = locs;
        this.connection.send(pkt);
    };
    EditorMossManager.prototype.deleteMosses = function (ids) {
        var deleteLocs = [];
        for (var _i = 0, ids_1 = ids; _i < ids_1.length; _i++) {
            var id = ids_1[_i];
            var loc = this.editorMosses.get(id);
            deleteLocs.push(loc);
            this.taskQueue.set(id, {
                action: "DELETE",
                loc: loc,
            });
        }
        this.reqEditorDeleteMossData(deleteLocs);
    };
    EditorMossManager.prototype.reqEditorDeleteMossData = function (locs) {
        var pkt = new dist["PBpacket"](protocols["op_editor"].OPCODE._OP_CLIENT_REQ_EDITOR_DELETE_MOSSES);
        var content = pkt.content;
        content.locs = locs;
        this.connection.send(pkt);
    };
    EditorMossManager.prototype.handleAddMosses = function (packet) {
        var content = packet.content;
        var locs = content.locs;
        for (var _i = 0, locs_2 = locs; _i < locs_2.length; _i++) {
            var loc = locs_2[_i];
            this.taskQueue.set(loc.id, {
                action: "ADD",
                loc: loc,
            });
        }
    };
    EditorMossManager.prototype.handleDeleteMosses = function (packet) {
        var content = packet.content;
        var ids = content.ids;
        for (var _i = 0, ids_2 = ids; _i < ids_2.length; _i++) {
            var id = ids_2[_i];
            this.taskQueue.set(id, {
                action: "DELETE",
                loc: this.editorMosses.get(id),
            });
        }
        this.roomService.removeSelected();
    };
    EditorMossManager.prototype.handleUpdateMosses = function (packet) {
        var content = packet.content;
        var locs = content.locs;
        for (var _i = 0, locs_3 = locs; _i < locs_3.length; _i++) {
            var loc = locs_3[_i];
            this.taskQueue.set(loc.id, {
                action: "UPDATE",
                loc: loc,
            });
        }
    };
    EditorMossManager.prototype.batchActionSprites = function () {
        if (!Array.from(this.taskQueue.keys()).length) {
            return;
        }
        var batchTasksKeys = Array.from(this.taskQueue.keys()).splice(0, 200);
        for (var _i = 0, batchTasksKeys_1 = batchTasksKeys; _i < batchTasksKeys_1.length; _i++) {
            var key = batchTasksKeys_1[_i];
            var _a = this.taskQueue.get(key), action = _a.action, loc = _a.loc;
            this.taskQueue.delete(key);
            if (action === "ADD") {
                var moss = this.mRoom.world.elementStorage.getMossPalette(loc.key);
                if (!moss)
                    continue;
                var sprite = moss.createSprite(editor_moss_manager_assign(editor_moss_manager_assign({}, loc), { nodeType: protocols["op_def"].NodeType.ElementNodeType, isMoss: true }));
                this.editorMosses.set(loc.id, loc);
                this.mRoom.displayObjectPool.push("mosses", loc.id.toString(), sprite, this);
            }
            else if (action === "DELETE") {
                if (loc) {
                    this.editorMosses.delete(loc.id);
                    this.mRoom.displayObjectPool.remove("mosses", loc.id.toString());
                }
            }
            else if (action === "UPDATE") {
                var moss = this.mRoom.world.elementStorage.getMossPalette(loc.key);
                if (!moss)
                    continue;
                var sprite = moss.createSprite(editor_moss_manager_assign(editor_moss_manager_assign({}, loc), { nodeType: protocols["op_def"].NodeType.ElementNodeType, isMoss: true }));
                this.editorMosses.set(loc.id, loc);
                this.mRoom.displayObjectPool.update("mosses", loc.id.toString(), sprite);
            }
        }
    };
    Object.defineProperty(EditorMossManager.prototype, "roomService", {
        get: function () {
            return this.mRoom;
        },
        enumerable: false,
        configurable: true
    });
    return EditorMossManager;
}(element_manager["a" /* ElementManager */]));


// EXTERNAL MODULE: ./src/rooms/terrain/terrain.ts
var terrain_terrain = __webpack_require__(79);

// EXTERNAL MODULE: ./src/rooms/element/element.ts + 16 modules
var element_element = __webpack_require__(11);

// CONCATENATED MODULE: ./src/rooms/display-object.pool.ts


var display_object_pool_DisplayObjectPool = /** @class */ (function () {
    function DisplayObjectPool() {
        this.terrains = new Map();
        this.mosses = new Map();
        this.elements = new Map();
        this.POOLOBJECTCONFIG = {
            terrains: terrain_terrain["a" /* Terrain */],
            mosses: element_element["b" /* Element */],
            elements: element_element["b" /* Element */],
        };
    }
    DisplayObjectPool.prototype.getPool = function (poolName) {
        return this[poolName];
    };
    DisplayObjectPool.prototype.push = function (poolName, id, sprite, manager) {
        var pool = this[poolName];
        var obj = new this.POOLOBJECTCONFIG[poolName](sprite, manager);
        obj.setBlockable(false);
        obj.setRenderable(true);
        if (obj instanceof element_element["b" /* Element */]) {
            obj.setInputEnable(element_element["c" /* InputEnable */].Enable);
        }
        pool.set(id, obj);
    };
    DisplayObjectPool.prototype.remove = function (poolName, id) {
        var obj = this[poolName].get(id);
        if (obj) {
            obj.isUsed = false;
            obj.destroy();
        }
        this[poolName].delete(id);
    };
    DisplayObjectPool.prototype.update = function (poolName, id, newSprite) {
        var pool = this[poolName];
        var obj = pool.get(id);
        if (obj) {
            obj.isUsed = true;
            obj.setModel(newSprite);
        }
    };
    DisplayObjectPool.prototype.destroy = function () {
        for (var _i = 0, _a = Object.keys(this.POOLOBJECTCONFIG); _i < _a.length; _i++) {
            var key = _a[_i];
            this[key].clear();
        }
    };
    return DisplayObjectPool;
}());


// CONCATENATED MODULE: ./src/rooms/sky.box/scenery.ts

var scenery_Scenery = /** @class */ (function () {
    function Scenery(scenery) {
        this.mID = scenery.id;
        this.mDepth = scenery.depth;
        this.mUris = [];
        var uris = null;
        if (Array.isArray(scenery.uris)) {
            uris = scenery.uris;
        }
        else {
            uris = scenery.uris.value;
        }
        if (uris.length < 1) {
            log["a" /* Logger */].getInstance().error(Scenery.name + ": scenery uris is empty");
        }
        for (var i = 0; i < uris.length; i++) {
            var val = uris[i].value || uris;
            this.mUris[i] = new Array(val.length);
            for (var j = 0; j < val.length; j++) {
                this.mUris[i][j] = val[j];
            }
        }
        this.mSpeed = scenery.speed || 1;
        if (!scenery.width) {
            log["a" /* Logger */].getInstance().error(Scenery.name + ": scenery width is " + scenery.width);
        }
        if (!scenery.height) {
            log["a" /* Logger */].getInstance().error(Scenery.name + ": scenery height is " + scenery.height);
        }
        this.mWidth = scenery.width;
        this.mHeight = scenery.height;
        this.mFit = scenery.fit;
        this.mOffset = scenery.offset || { x: 0, y: 0 };
    }
    Object.defineProperty(Scenery.prototype, "width", {
        get: function () {
            return this.mWidth;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Scenery.prototype, "height", {
        get: function () {
            return this.mHeight;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Scenery.prototype, "id", {
        get: function () {
            return this.mID;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Scenery.prototype, "depth", {
        get: function () {
            return this.mDepth;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Scenery.prototype, "offset", {
        get: function () {
            return this.mOffset;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Scenery.prototype, "speed", {
        get: function () {
            return this.mSpeed;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Scenery.prototype, "uris", {
        get: function () {
            return this.mUris;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Scenery.prototype, "fit", {
        get: function () {
            return this.mFit;
        },
        enumerable: false,
        configurable: true
    });
    return Scenery;
}());

var Fit;
(function (Fit) {
    Fit[Fit["Center"] = 1] = "Center";
    Fit[Fit["Fill"] = 2] = "Fill";
})(Fit || (Fit = {}));

// CONCATENATED MODULE: ./src/rooms/sky.box/editor.sky.box.manager.ts
var editor_sky_box_manager_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();





var editor_sky_box_manager_EditorSkyBoxManager = /** @class */ (function (_super) {
    editor_sky_box_manager_extends(EditorSkyBoxManager, _super);
    function EditorSkyBoxManager(room) {
        var _this = _super.call(this, room) || this;
        var connection = room.connection;
        if (connection) {
            connection.addPacketListener(_this);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_EDITOR_REQ_CLIENT_ADD_SCENERY, _this.onAddSceneryHandler);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_EDITOR_REQ_CLIENT_UPDATE_SCENERY, _this.onUpdateSceneryHandler);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_EDITOR_REQ_CLIENT_DELETE_SCENERY, _this.onDeleteSceneryHandler);
        }
        return _this;
    }
    EditorSkyBoxManager.prototype.fetch = function (id) {
        if (!this.mScenetys) {
            return;
        }
        this.mSelected = this.mScenetys.get(id);
    };
    EditorSkyBoxManager.prototype.move = function (pointer) {
        if (!this.selected) {
            return;
        }
        var scenery = this.mSelected.scenery;
        if (!scenery) {
            return;
        }
        var offset = scenery.offset;
        offset.x += (pointer.x - pointer.prevPosition.x) / this.mRoom.world.scaleRatio;
        offset.y += (pointer.y - pointer.prevPosition.y) / this.mRoom.world.scaleRatio;
        this.mSelected.updatePosition();
        this.onSyncSceneryOffset();
    };
    EditorSkyBoxManager.prototype.keyboardMove = function (keyCode) {
        if (!this.mSelected) {
            return;
        }
        var scenery = this.mSelected.scenery;
        if (!scenery) {
            return;
        }
        var offset = scenery.offset;
        switch (keyCode) {
            case 37:
            case 65:
                offset.x--;
                break;
            case 38:
            case 87:
                offset.y--;
                break;
            case 39:
            case 68:
                offset.x++;
                break;
            case 40:
            case 83:
                offset.y++;
                break;
        }
        this.mSelected.updatePosition();
        this.onSyncSceneryOffset();
    };
    EditorSkyBoxManager.prototype.removeSelect = function () {
        if (this.mSelected) {
            this.mSelected = undefined;
        }
    };
    EditorSkyBoxManager.prototype.onAddSceneryHandler = function (packet) {
        var content = packet.content;
        this.add(new scenery_Scenery(content));
    };
    EditorSkyBoxManager.prototype.onUpdateSceneryHandler = function (packet) {
        var content = packet.content;
        this.update(new scenery_Scenery(content));
    };
    EditorSkyBoxManager.prototype.onDeleteSceneryHandler = function (packet) {
        var content = packet.content;
        var ids = content.ids;
        for (var _i = 0, ids_1 = ids; _i < ids_1.length; _i++) {
            var id = ids_1[_i];
            this.remove(id);
        }
    };
    EditorSkyBoxManager.prototype.onSyncSceneryOffset = function () {
        var scenery = this.mSelected.scenery;
        var packet = new dist["PBpacket"](protocols["op_editor"].OPCODE._OP_CLIENT_REQ_EDITOR_UPDATE_SCENERY);
        var content = packet.content;
        content.id = scenery.id;
        var offset = protocols["op_def"].PBPoint2f.create();
        Object.assign(offset, scenery.offset);
        content.offset = offset;
        this.mRoom.connection.send(packet);
    };
    Object.defineProperty(EditorSkyBoxManager.prototype, "selected", {
        get: function () {
            return this.mSelected;
        },
        enumerable: false,
        configurable: true
    });
    return EditorSkyBoxManager;
}(sky_box_manager_SkyBoxManager));


// CONCATENATED MODULE: ./src/rooms/editor.room.ts
var editor_room_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



















var editor_room_EditorRoom = /** @class */ (function (_super) {
    editor_room_extends(EditorRoom, _super);
    function EditorRoom(manager) {
        var _this = _super.call(this, manager) || this;
        _this.mBrush = new Brush(_this);
        if (_this.connection) {
            _this.connection.addPacketListener(_this);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_EDITOR_REQ_CLIENT_SET_EDITOR_MODE, _this.onSetEditorModeHandler);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_EDITOR_REQ_CLIENT_ALIGN_GRID, _this.onAlignGridHandler);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_EDITOR_REQ_CLIENT_VISIBLE_GRID, _this.onVisibleGridHandler);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_EDITOR_REQ_CLIENT_MOUSE_FOLLOW, _this.onMouseFollowHandler);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_EDITOR_REQ_CLIENT_MOUSE_SELECTED_SPRITE, _this.onMouseFollowHandler);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_EDITOR_REQ_CLIENT_FETCH_SPRITE, _this.onFetchSpriteHandler);
            _this.addHandlerFun(protocols["op_client"].OPCODE._OP_EDITOR_REQ_CLIENT_FETCH_SCENERY, _this.onFetchSceneryHandler);
        }
        return _this;
    }
    EditorRoom.prototype.enter = function (data) {
        if (!data) {
            log["a" /* Logger */].getInstance().error("wrong room");
            return;
        }
        this.mID = data.id;
        var rows = data.rows, cols = data.cols, tileWidth = data.tileWidth, tileHeight = data.tileHeight;
        this.mSize = {
            cols: cols,
            rows: rows,
            tileHeight: tileHeight,
            tileWidth: tileWidth,
            sceneWidth: (rows + cols) * (tileWidth / 2),
            sceneHeight: (rows + cols) * (tileHeight / 2),
        };
        rows *= 2;
        cols *= 2;
        tileWidth /= 2;
        tileHeight /= 2;
        this.mNimiSize = {
            cols: cols,
            rows: rows,
            tileHeight: tileHeight,
            tileWidth: tileWidth,
            sceneWidth: (rows + cols) * (tileWidth / 2),
            sceneHeight: (rows + cols) * (tileHeight / 2),
        };
        this.editorTerrainManager = new editor_terrain_manager_EditorTerrainManager(this);
        this.editorElementManager = new editor_element_manager_EditorElementManager(this);
        this.editorMossManager = new editor_moss_manager_EditorMossManager(this);
        this.editorSkyboxManager = new editor_sky_box_manager_EditorSkyBoxManager(this);
        this.mCameraService = new editor_cameras_manager_EditorCamerasManager(this);
        this.displayObjectPool = new display_object_pool_DisplayObjectPool();
        this.mWorld.game.scene.start(edit["a" /* EditScene */].name, { room: this });
    };
    EditorRoom.prototype.startPlay = function () {
        this.mScene = this.mWorld.game.scene.getScene(edit["a" /* EditScene */].name);
        this.mLayManager = new layer_manager["a" /* LayerManager */](this);
        this.mLayManager.drawGrid(this);
        var camera = this.scene.cameras.main;
        this.mCameraService.camera = camera;
        var zoom = this.world.scaleRatio;
        // mainCameras.setBounds(-200, -200, this.mSize.sceneWidth + 400, this.mSize.sceneHeight + 400);
        this.mCameraService.setBounds(-camera.width >> 1, -camera.height >> 1, this.mSize.sceneWidth * zoom + camera.width, this.mSize.sceneHeight * zoom + camera.height);
        this.connection.send(new dist["PBpacket"](protocols["op_virtual_world"].OPCODE._OP_CLIENT_REQ_VIRTUAL_WORLD_SCENE_CREATED));
        this.mCameraService.centerCameas();
        this.mScene.input.on("pointerdown", this.onPointerDownHandler, this);
        this.mScene.input.on("pointerup", this.onPointerUpHandler, this);
        this.mScene.input.on("gameobjectdown", this.onGameobjectDownHandler, this);
        this.mScene.input.on("gameout", this.onGameOutHandler, this);
        this.mScene.input.keyboard.on("keydown", this.onKeyDownHandler, this);
        // this.addSkyBox();
    };
    EditorRoom.prototype.destroy = function () {
        if (this.mWorld && this.mWorld.connection) {
            this.mWorld.connection.removePacketListener(this);
        }
        if (this.editorTerrainManager) {
            this.editorTerrainManager.destroy();
        }
        if (this.editorMossManager) {
            this.editorMossManager.destroy();
        }
        if (this.editorElementManager) {
            this.editorElementManager.destroy();
        }
        if (this.displayObjectPool) {
            this.displayObjectPool.destroy();
        }
        if (this.editorSkyboxManager) {
            this.editorSkyboxManager.destroy();
        }
        _super.prototype.destroy.call(this);
    };
    EditorRoom.prototype.update = function (time, delta) {
        if (this.layerManager)
            this.layerManager.update(time, delta);
        if (this.mSelectedElementEffect) {
            this.mSelectedElementEffect.update();
        }
        if (this.editorTerrainManager) {
            this.editorTerrainManager.update();
        }
        if (this.editorMossManager) {
            this.editorMossManager.update();
        }
        if (this.editorElementManager) {
            this.editorElementManager.update();
        }
    };
    EditorRoom.prototype.transformToMini90 = function (p) {
        if (!this.mNimiSize) {
            log["a" /* Logger */].getInstance().error("position object is undefined");
            return;
        }
        return position45["a" /* Position45 */].transformTo90(p, this.mNimiSize);
    };
    EditorRoom.prototype.transformToMini45 = function (p) {
        if (!this.mNimiSize) {
            log["a" /* Logger */].getInstance().error("position object is undefined");
            return;
        }
        return position45["a" /* Position45 */].transformTo45(p, this.mNimiSize);
    };
    EditorRoom.prototype.removeSelected = function () {
        if (this.mSelectedElementEffect) {
            this.mSelectedElementEffect.remove();
        }
    };
    EditorRoom.prototype.addPointerMoveHandler = function () {
        this.mScene.input.on("pointermove", this.onPointerMoveHandler, this);
    };
    EditorRoom.prototype.removePointerMoveHandler = function () {
        this.mScene.input.off("pointermove", this.onPointerMoveHandler, this);
    };
    EditorRoom.prototype.addPointerDownHandler = function () {
        this.mScene.input.on("pointerdown", this.onPointerDownHandler, this);
    };
    EditorRoom.prototype.removePointerDownHandler = function () {
        this.mScene.input.off("pointerdown", this.onPointerDownHandler, this);
    };
    EditorRoom.prototype.addPointerUpHandler = function () {
        this.mScene.input.on("pointerup", this.onPointerUpHandler, this);
    };
    EditorRoom.prototype.removePointerUpHandler = function () {
        this.mScene.input.off("pointerup", this.onPointerUpHandler, this);
    };
    EditorRoom.prototype.addGameObjectDownHandler = function () {
        this.mScene.input.on("gameobjectdown", this.onGameobjectDownHandler, this);
    };
    EditorRoom.prototype.removeGameObjectDownHandler = function () {
        this.mScene.input.off("gameobjectdown", this.onGameobjectDownHandler, this);
    };
    EditorRoom.prototype.addKeydownHandler = function () {
        this.mScene.input.keyboard.on("keydown", this.onKeyDownHandler, this);
    };
    EditorRoom.prototype.removeKeydownHandler = function () {
        this.mScene.input.keyboard.off("keydown", this.onKeyDownHandler, this);
    };
    EditorRoom.prototype.onPointerDownHandler = function () {
        var nodeType = this.mouseFollow.nodeType;
        if (this.mouseFollow.key) {
            if (nodeType === protocols["op_def"].NodeType.TerrainNodeType) {
                if (!this.world.elementStorage.getTerrainPalette(this.mouseFollow.key)) {
                    this.reqEditorSyncPaletteOrMoss(this.mouseFollow.key, this.mouseFollow.nodeType);
                }
            }
            else if (nodeType === protocols["op_def"].NodeType.ElementNodeType) {
                if (!this.world.elementStorage.getMossPalette(this.mouseFollow.key)) {
                    this.reqEditorSyncPaletteOrMoss(this.mouseFollow.key, this.mouseFollow.nodeType);
                }
            }
        }
        this.addPointerMoveHandler();
    };
    EditorRoom.prototype.onPointerUpHandler = function (pointer) {
        this.removePointerMoveHandler();
        switch (this.brush.mode) {
            case BrushEnum.BRUSH:
                this.createElements();
                break;
            case BrushEnum.SELECT:
                if (this.mSelectedElementEffect && this.mSelectedElementEffect.selecting) {
                    if (pointer.downX !== pointer.upX && pointer.downY !== pointer.upY) {
                        if (this.mSelectedElementEffect.sprite.isMoss) {
                            this.editorMossManager.updateMosses([this.mSelectedElementEffect]);
                        }
                        else {
                            var sprite = this.mSelectedElementEffect
                                .display.element.model.toSprite();
                            this.editorElementManager.updateElements([sprite]);
                        }
                    }
                    this.mSelectedElementEffect.selecting = false;
                }
                break;
            case BrushEnum.ERASER:
                this.eraserTerrains();
                break;
            case BrushEnum.MOVE:
                this.mCameraService.syncCameraScroll();
                break;
        }
    };
    EditorRoom.prototype.onPointerMoveHandler = function (pointer) {
        if (!this.mScene.cameras) {
            return;
        }
        switch (this.mBrush.mode) {
            case BrushEnum.BRUSH:
                if (this.mMouseFollow.nodeType === protocols["op_def"].NodeType.TerrainNodeType) {
                    this.createElements();
                }
                break;
            case BrushEnum.MOVE:
                this.moveCameras(pointer);
                break;
            case BrushEnum.SELECT:
                if (this.editorSkyboxManager) {
                    this.editorSkyboxManager.move(pointer);
                }
                this.moveElement(pointer);
                break;
            case BrushEnum.ERASER:
                this.eraserTerrains();
                break;
        }
    };
    EditorRoom.prototype.moveCameras = function (pointer) {
        this.cameraService.offsetScroll(pointer.prevPosition.x - pointer.position.x, pointer.prevPosition.y - pointer.position.y);
    };
    EditorRoom.prototype.reqEditorSyncPaletteOrMoss = function (key, nodeType) {
        var pkt = new dist["PBpacket"](protocols["op_editor"].OPCODE._OP_CLIENT_REQ_EDITOR_SYNC_PALETTE_MOSS);
        var content = pkt.content;
        content.key = key;
        content.type = nodeType;
        this.connection.send(pkt);
    };
    EditorRoom.prototype.createElements = function () {
        if (!this.mMouseFollow.sprite) {
            return;
        }
        if (this.mMouseFollow.nodeType === protocols["op_def"].NodeType.TerrainNodeType) {
            var terrainCoorData = this.mMouseFollow.createTerrainsOrMossesData();
            if (this.editorTerrainManager) {
                this.editorTerrainManager.addTerrains(terrainCoorData);
            }
        }
        else if (this.mMouseFollow.nodeType === protocols["op_def"].NodeType.ElementNodeType) {
            var sprites = this.mMouseFollow.createSprites();
            if (!sprites) {
                return;
            }
            if (!this.editorElementManager) {
                return;
            }
            if (this.mMouseFollow.isMoss) {
                var mossesCoorData = this.mMouseFollow.createTerrainsOrMossesData();
                this.editorMossManager.addMosses(mossesCoorData);
            }
            else {
                this.editorElementManager.addElements(sprites);
            }
        }
        else if (this.mMouseFollow.nodeType === protocols["op_def"].NodeType.SpawnPointType) {
            var sprites = this.mMouseFollow.createSprites();
            this.editorElementManager.addElements(sprites);
        }
    };
    EditorRoom.prototype.eraserTerrains = function () {
        var positions = this.mMouseFollow.getEaserPosition();
        this.editorTerrainManager.removeTerrains(positions);
    };
    EditorRoom.prototype.onSetEditorModeHandler = function (packet) {
        var mode = packet.content;
        this.mBrush.mode = mode.mode;
        if (this.mMouseFollow)
            this.mMouseFollow.destroy();
        if (this.mBrush.mode !== BrushEnum.SELECT) {
            if (this.mSelectedElementEffect) {
                this.mSelectedElementEffect.destroy();
                this.mSelectedElementEffect = null;
            }
        }
        if (this.mBrush.mode === BrushEnum.SELECT) {
            this.removeGameObjectDownHandler();
            this.addGameObjectDownHandler();
        }
        else {
            this.removeGameObjectDownHandler();
        }
        if (this.mBrush.mode === BrushEnum.ERASER) {
            if (!this.mMouseFollow) {
                this.mMouseFollow = new mouse_follow_MouseFollow(this.mScene, this);
            }
            this.mMouseFollow.showEraserArea();
        }
        if (this.editorSkyboxManager) {
            this.editorSkyboxManager.removeSelect();
        }
        this.layerManager.setSurfaceInteractive(this.mBrush.mode !== BrushEnum.ERASER);
    };
    EditorRoom.prototype.onAlignGridHandler = function (packet) {
        var content = packet.content;
        this.mouseFollow.alignGrid = content.align;
    };
    EditorRoom.prototype.onVisibleGridHandler = function (packet) {
        var content = packet.content;
        this.layerManager.setGridVisible(content.visible);
    };
    EditorRoom.prototype.onMouseFollowHandler = function (packet) {
        var content = packet.content;
        if (this.mScene) {
            this.mouseFollow.setDisplay(content);
        }
    };
    EditorRoom.prototype.onFetchSpriteHandler = function (packet) {
        var _a;
        var content = packet.content;
        var ids = content.ids, nodeType = content.nodeType;
        var map = (_a = {},
            _a[protocols["op_def"].NodeType.SpawnPointType] = "elements",
            _a[protocols["op_def"].NodeType.ElementNodeType] = "elements",
            _a[protocols["op_def"].NodeType.MossCollectionType] = "mosses",
            _a);
        for (var _i = 0, ids_1 = ids; _i < ids_1.length; _i++) {
            var id = ids_1[_i];
            var poolName = map[nodeType];
            var pool = this.displayObjectPool.getPool(poolName);
            var displayObj = pool.get(id.toString());
            if (displayObj) {
                this.selectedElement(displayObj.getDisplay());
            }
        }
    };
    EditorRoom.prototype.sendFetch = function (ids, nodetype, isMoss) {
        if (!this.mSelectedElementEffect || !this.mSelectedElementEffect.display) {
            return;
        }
        var pkt = new dist["PBpacket"](protocols["op_editor"].OPCODE._OP_CLIENT_REQ_EDITOR_FETCH_SPRITE);
        var content = pkt.content;
        content.ids = ids;
        content.isMoss = isMoss;
        content.nodeType = nodetype;
        this.connection.send(pkt);
        log["a" /* Logger */].getInstance().log("fetch sprite", content);
    };
    EditorRoom.prototype.onFetchSceneryHandler = function (packet) {
        if (this.mSelectedElementEffect) {
            this.mSelectedElementEffect.destroy();
            this.mSelectedElementEffect = null;
        }
        if (!this.editorSkyboxManager) {
            return;
        }
        var content = packet.content;
        this.editorSkyboxManager.fetch(content.id);
    };
    EditorRoom.prototype.onGameobjectDownHandler = function (pointer, gameobject) {
        var com = gameobject.parentContainer;
        if (!com) {
            return;
        }
        var selected = this.selectedElement(com);
        if (selected) {
            this.sendFetch([selected.element.id], protocols["op_def"].NodeType.ElementNodeType, selected.element.model.isMoss);
        }
    };
    EditorRoom.prototype.selectedElement = function (com) {
        if (!(com instanceof display_object["a" /* DisplayObject */])) {
            return;
        }
        if (com instanceof terrain_display["a" /* TerrainDisplay */]) {
            return;
        }
        if (!this.mSelectedElementEffect) {
            this.mSelectedElementEffect = new selected_element_SelectedElement(this.mScene, this.layerManager);
        }
        this.mSelectedElementEffect.setElement(com);
        if (this.editorSkyboxManager) {
            this.editorSkyboxManager.removeSelect();
        }
        return com;
    };
    EditorRoom.prototype.onKeyDownHandler = function (event) {
        if (this.editorSkyboxManager) {
            this.editorSkyboxManager.keyboardMove(event.keyCode);
        }
        if (!this.mSelectedElementEffect) {
            return;
        }
        switch (event.keyCode) {
            case 37:
            case 38:
            case 39:
            case 40:
            case 65:
            case 87:
            case 83:
            case 68:
                this.keyboardMoveElement(event.keyCode);
                break;
            // case 8:
            // case 46:
            //     this.removeDisplay(this.mSelectedElementEffect);
            //     break;
        }
    };
    EditorRoom.prototype.keyboardMoveElement = function (keyCode) {
        var display = this.mSelectedElementEffect.display;
        if (!display) {
            return;
        }
        var pos = new utils_pos["a" /* Pos */](display.x, display.y, display.z);
        switch (keyCode) {
            case 37:
                pos.x--;
                break;
            case 38:
                pos.y--;
                break;
            case 39:
                pos.x++;
                break;
            case 40:
                pos.y++;
                break;
        }
        display.setPosition(pos.x, pos.y, pos.z);
        // TOOD 通过统一接口设置depth
        this.layerManager.depthSurfaceDirty = true;
    };
    EditorRoom.prototype.moveElement = function (pointer) {
        if (!this.mSelectedElementEffect) {
            return;
        }
        if (!this.mSelectedElementEffect.selecting) {
            return;
        }
        if (!this.mouseFollow) {
            return;
        }
        var pos = this.mMouseFollow.transitionGrid(pointer.worldX / this.mScaleRatio, pointer.worldY / this.mScaleRatio);
        if (pos) {
            this.mSelectedElementEffect.setDisplayPos(pos.x, pos.y);
            this.mLayManager.depthSurfaceDirty = true;
        }
    };
    Object.defineProperty(EditorRoom.prototype, "brush", {
        get: function () {
            return this.mBrush;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EditorRoom.prototype, "miniSize", {
        get: function () {
            return this.mNimiSize;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EditorRoom.prototype, "mouseFollow", {
        get: function () {
            if (!this.mMouseFollow) {
                this.mMouseFollow = new mouse_follow_MouseFollow(this.mScene, this);
            }
            return this.mMouseFollow;
        },
        enumerable: false,
        configurable: true
    });
    EditorRoom.prototype.removeDisplay = function (element) {
        if (element.sprite.isMoss) {
            this.editorMossManager.deleteMosses([element.sprite.id]);
        }
        else {
            this.editorElementManager.deleteElements([element.sprite.id]);
        }
        this.removeSelected();
    };
    return EditorRoom;
}(room_Room));


// EXTERNAL MODULE: ./src/rooms/decorate.room.ts + 8 modules
var decorate_room = __webpack_require__(96);

// CONCATENATED MODULE: ./src/rooms/room.manager.ts
var room_manager_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();






var room_manager_RoomManager = /** @class */ (function (_super) {
    room_manager_extends(RoomManager, _super);
    function RoomManager(world) {
        var _this = _super.call(this) || this;
        _this.mRooms = [];
        _this.mWorld = world;
        _this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_RES_CLIENT_ENTER_SCENE, _this.onEnterSceneHandler);
        _this.addHandlerFun(protocols["op_client"].OPCODE._OP_EDITOR_REQ_CLIENT_CHANGE_TO_EDITOR_MODE, _this.onEnterEditor);
        return _this;
        // this.addHandlerFun(op_client.OPCODE._OP_VIRTUAL_WORLD_RES_CLIENT_EDIT_MODE_READY, this.onEnterDecorate);
    }
    RoomManager.prototype.addPackListener = function () {
        if (this.connection) {
            this.connection.addPacketListener(this);
        }
    };
    RoomManager.prototype.removePackListener = function () {
        if (this.connection) {
            this.connection.removePacketListener(this);
        }
    };
    RoomManager.prototype.getRoom = function (id) {
        // const idx = this.mRooms.findIndex((room: Room, index: number) => id === room.id);
        // if (idx >= 0) {
        //     return this.mRooms[idx];
        // }
        return this.mRooms.find(function (room) {
            return room.id === id;
        });
    };
    RoomManager.prototype.onFocus = function () {
        this.mRooms.forEach(function (room) {
            if (room && room.scene)
                room.resume(room.scene.scene.key);
        });
    };
    RoomManager.prototype.onBlur = function () {
        this.mRooms.forEach(function (room) {
            if (room && room.scene)
                room.pause();
        });
    };
    RoomManager.prototype.pasuseRoom = function (id) {
        var idx = this.mRooms.findIndex(function (room, index) { return id === room.id; });
        if (idx >= 0) {
            var room = this.mRooms[idx];
            room.pause();
        }
    };
    RoomManager.prototype.resumeRoom = function (id) {
        var idx = this.mRooms.findIndex(function (room, index) { return id === room.id; });
        if (idx >= 0) {
            var room = this.mRooms[idx];
            if (room && room.scene)
                room.resume(room.scene.scene.key);
        }
    };
    RoomManager.prototype.stop = function () {
        this.mRooms.forEach(function (room) {
            if (room && room.scene)
                room.destroy();
        });
    };
    RoomManager.prototype.resize = function (width, height) {
        this.mRooms.forEach(function (room) {
            if (room)
                room.resize(width, height);
        });
    };
    RoomManager.prototype.destroy = function () {
        this.removePackListener();
        for (var _i = 0, _a = this.mRooms; _i < _a.length; _i++) {
            var room = _a[_i];
            room.destroy();
            room = null;
        }
        this.mRooms.length = 0;
    };
    RoomManager.prototype.hasRoom = function (id) {
        var idx = this.mRooms.findIndex(function (room, index) { return id === room.id; });
        return idx >= 0;
    };
    RoomManager.prototype.onEnterScene = function (scene) {
        var _this = this;
        // this.destroy();
        var vw = scene;
        var room;
        if (this.hasRoom(vw.scene.id)) {
            room = this.getRoom(vw.scene.id);
            room.addActor(vw.actor);
            room.enter(vw.scene);
            this.mCurRoom = room;
        }
        else {
            if (this.mCurRoom) {
                this.leaveScene(this.mCurRoom);
            }
            // load this scene config in gameConfig
            this.world.loadSceneConfig(vw.scene.id.toString()).then(function (config) {
                _this.world.elementStorage.setSceneConfig(config);
                room = new room_Room(_this);
                _this.mRooms.push(room);
                room.addActor(vw.actor);
                room.enter(vw.scene);
                _this.mCurRoom = room;
            });
        }
    };
    RoomManager.prototype.onEnterDecorate = function (scene) {
        if (this.mCurRoom) {
            this.leaveScene(this.mCurRoom);
        }
        var room = new decorate_room["a" /* DecorateRoom */](this);
        room.enter(scene.scene);
        var actor = scene.actor;
        if (actor)
            room.setEnterPos(actor.x, actor.y);
        this.mRooms.push(room);
        this.mCurRoom = room;
    };
    RoomManager.prototype.onEditRoom = function (packet) {
        var content = packet.content;
        log["a" /* Logger */].getInstance().log("edit: ", content);
    };
    RoomManager.prototype.onEnterEditor = function (packet) {
        var content = packet.content;
        var room = new editor_room_EditorRoom(this);
        room.enter(content.scene);
        this.mCurRoom = room;
        this.mRooms.push(room);
    };
    RoomManager.prototype.leaveScene = function (room) {
        if (!room)
            return;
        this.mRooms = this.mRooms.filter(function (r) { return r.id !== room.id; });
        room.destroy();
    };
    RoomManager.prototype.onEnterSceneHandler = function (packet) {
        var content = packet.content;
        var scene = content.scene;
        switch (scene.sceneType) {
            case protocols["op_def"].SceneTypeEnum.NORMAL_SCENE_TYPE:
                this.onEnterScene(content);
                break;
            case protocols["op_def"].SceneTypeEnum.EDIT_SCENE_TYPE:
                this.onEnterDecorate(content);
                break;
        }
    };
    Object.defineProperty(RoomManager.prototype, "world", {
        get: function () {
            return this.mWorld;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RoomManager.prototype, "currentRoom", {
        get: function () {
            return this.mCurRoom;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(RoomManager.prototype, "connection", {
        get: function () {
            if (this.mWorld) {
                return this.mWorld.connection;
            }
            log["a" /* Logger */].getInstance().error("world manager is undefined");
        },
        enumerable: false,
        configurable: true
    });
    return RoomManager;
}(dist["PacketHandler"]));


// CONCATENATED MODULE: ./src/rooms/index.ts




/***/ }),
/* 200 */,
/* 201 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ HttpService; });

// UNUSED EXPORTS: SocketConnection, SocketConnectionError

// CONCATENATED MODULE: ./src/net/http.service.ts
var HttpService = /** @class */ (function () {
    function HttpService(mWorld) {
        this.mWorld = mWorld;
    }
    /**
     * 用户关注其他用户
     * @param uids
     */
    HttpService.prototype.follow = function (fuid) {
        return this.post("user/follow", { fuid: fuid });
    };
    /**
     * 用户取消关注其他用户
     * @param fuid
     */
    HttpService.prototype.unfollow = function (fuid) {
        return this.post("user/unfollow", { fuid: fuid });
    };
    /**
     * 检查用户列表是否有关注的用户
     * @param uids
     */
    HttpService.prototype.checkFollowed = function (uids) {
        return this.post("user/check_followed", { "uids": uids });
    };
    /**
     * 登录
     * @param name
     * @param password
     */
    HttpService.prototype.login = function (account, password) {
        return fetch("" + "http://172.18.0.100:17170/" + "account/signin", {
            body: JSON.stringify({ account: account, password: password }),
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            }
        }).then(function (response) { return response.json(); });
    };
    /**
     * 请求手机验证码
     * @param name
     */
    HttpService.prototype.requestPhoneCode = function (phone) {
        return fetch("" + "http://172.18.0.100:17170/" + "account/sms_code", {
            body: JSON.stringify({ phone: phone }),
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            }
        }).then(function (response) { return response.json(); });
    };
    HttpService.prototype.loginByPhoneCode = function (phone, code) {
        return fetch("" + "http://172.18.0.100:17170/" + "account/phone_signin", {
            body: JSON.stringify({ phone: phone, code: code }),
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            }
        }).then(function (response) { return response.json(); });
    };
    HttpService.prototype.quickLogin = function () {
        return fetch("" + "http://172.18.0.100:17170/" + "account/quick_signin", {
            method: "POST",
        }).then(function (response) { return response.json(); });
    };
    /**
     *
     * 获取用户好友列表
     */
    HttpService.prototype.firend = function () {
        return this.get("user/friends");
    };
    /**
     * 获取用户信息
     * @param uid
     */
    HttpService.prototype.userDetail = function (uid) {
        return this.get("account/" + uid + "/detail");
    };
    /**
     * 用户徽章
     * @param uid
     */
    HttpService.prototype.badgecards = function (uid) {
        return this.get("userpackage/" + uid + "/badgecards");
    };
    HttpService.prototype.post = function (uri, body) {
        var account = this.mWorld.account;
        if (!account) {
            return Promise.reject("account does not exist");
        }
        if (!account.accountData) {
            return Promise.reject("token does not exist");
        }
        var data = {
            body: JSON.stringify(body),
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "X-Pixelpai-TK": account.accountData.token
            }
        };
        return fetch("" + "http://172.18.0.100:17170/" + uri, data).then(function (response) { return response.json(); });
    };
    HttpService.prototype.get = function (uri) {
        var account = this.mWorld.account;
        if (!account) {
            return Promise.reject("account does not exist");
        }
        if (!account.accountData) {
            return Promise.reject("token does not exist");
        }
        var data = {
            method: "GET",
            headers: {
                "X-Pixelpai-TK": account.accountData.token
            }
        };
        return fetch("" + "http://172.18.0.100:17170/" + uri, data).then(function (response) { return response.json(); });
    };
    return HttpService;
}());


// EXTERNAL MODULE: ./node_modules/events/events.js
var events = __webpack_require__(189);

// CONCATENATED MODULE: ./src/net/transport/websocket.ts
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

// @ts-ignore
var Socket = WebSocket || MozWebSocket;
var ReadyState;
(function (ReadyState) {
    ReadyState[ReadyState["CONNECTING"] = 0] = "CONNECTING";
    ReadyState[ReadyState["OPEN"] = 1] = "OPEN";
    ReadyState[ReadyState["CLOSING"] = 2] = "CLOSING";
    ReadyState[ReadyState["CLOSED"] = 3] = "CLOSED";
})(ReadyState || (ReadyState = {}));
var WSWrapper = /** @class */ (function (_super) {
    __extends(WSWrapper, _super);
    function WSWrapper(host, port, autoReconnect) {
        var _this = _super.call(this) || this;
        _this.secure = true;
        _this._connection = undefined;
        _this._readyState = ReadyState.CLOSED;
        _this._packets_q = [];
        _this._writable = false;
        _this._sent_count = 0;
        _this._auto_reconnect = false;
        _this._force_close = false;
        _this._host = host || "localhost";
        _this._port = port || 80;
        if (typeof autoReconnect !== "undefined")
            _this._auto_reconnect = autoReconnect;
        return _this;
    }
    WSWrapper.prototype.Open = function (host, port) {
        if (typeof host !== "undefined" && typeof port !== "undefined") {
            this._host = host;
            this._port = port;
        }
        this.doOpen();
    };
    WSWrapper.prototype.Close = function () {
        if (ReadyState.OPEN === this._readyState || ReadyState.CONNECTING === this._readyState) {
            this.doClose();
        }
    };
    WSWrapper.prototype.Send = function (packet) {
        if (ReadyState.OPEN === this._readyState) {
            this._packets_q.push(packet);
            this.write();
        }
        else {
            this.emit("error", "Transport not open yet.");
        }
    };
    // Frees all resources for garbage collection.
    WSWrapper.prototype.destroy = function () {
        // TODO
    };
    WSWrapper.prototype.addCallBacks = function () {
        var _this = this;
        this._connection.onopen = function () {
            _this.onOpen();
        };
        this._connection.onclose = function () {
            _this.onClose();
        };
        this._connection.onmessage = function (ev) {
            // console.info(`_connection.onmessage`);
            _this.onData(ev.data);
        };
        this._connection.onerror = function (e) {
            _this.emit("error", e);
        };
    };
    WSWrapper.prototype.onOpen = function () {
        this._readyState = ReadyState.OPEN;
        this._writable = true;
        this.emit("open");
    };
    WSWrapper.prototype.onClose = function () {
        this._readyState = ReadyState.CLOSED;
        this._writable = false;
        this.emit("close");
        if (this._auto_reconnect && !this._force_close) {
            this.emit("reopen");
            this.doOpen();
        }
    };
    WSWrapper.prototype.onData = function (data) {
        this.emit("packet", data);
    };
    WSWrapper.prototype.doOpen = function () {
        /**
         * Get either the `WebSocket` or `MozWebSocket` globals
         * in the browser
         */
        if (typeof Socket === "undefined") {
            this.emit("error", "WebSocket is NOT support by this Browser.");
            return;
        }
        var uri = this.uri();
        try {
            this._connection = new Socket(uri);
            this._connection.binaryType = "arraybuffer";
            this.addCallBacks();
        }
        catch (e) {
            this.emit("error", e);
        }
    };
    WSWrapper.prototype.doClose = function () {
        if (typeof this._connection !== "undefined") {
            this._force_close = true;
            this._connection.close();
            this._readyState = ReadyState.CLOSING;
            this.emit("closing");
        }
    };
    WSWrapper.prototype.uri = function () {
        var schema = this.secure ? "wss" : "ws";
        var port = "";
        if (this._port && (("wss" === schema && Number(this._port) !== 443) ||
            ("ws" === schema && Number(this._port) !== 80))) {
            port = ":" + this._port;
        }
        return schema + "://" + this._host + port;
    };
    WSWrapper.prototype.write = function () {
        var _this = this;
        if (this._packets_q.length > 0 && this._writable) {
            var packet_1 = this._packets_q.shift();
            this._writable = false; // write lock!
            new Promise(function (resolve, reject) {
                try {
                    _this._connection.send(packet_1);
                    resolve();
                }
                catch (e) {
                    reject(e);
                }
            }).then(function () {
                // send ok
                _this.emit("sent", [++_this._sent_count, packet_1]);
                _this._writable = true;
                _this.write();
            }).catch(function (reason) {
                _this.emit("error", reason);
            });
        }
    };
    return WSWrapper;
}(events["EventEmitter"]));


// EXTERNAL MODULE: ./src/utils/log.ts
var log = __webpack_require__(5);

// CONCATENATED MODULE: ./src/net/socket.ts
var socket_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var SocketConnectionError = /** @class */ (function (_super) {
    socket_extends(SocketConnectionError, _super);
    function SocketConnectionError(reason) {
        var _this = _super.call(this, "SocketConnectionError: " + JSON.stringify(reason)) || this;
        _this.name = "SocketConnectionError";
        _this.stack = new Error().stack;
        return _this;
    }
    return SocketConnectionError;
}(Error));

// 实际工作在Web-Worker内的WebSocket客户端
var socket_SocketConnection = /** @class */ (function () {
    function SocketConnection($listener) {
        var _this = this;
        this.mServerAddr = { host: "localhost", port: 80 };
        this.mTransport = new WSWrapper();
        this.mConnectListener = $listener;
        // add connection event to listener
        if (typeof this.mTransport !== "undefined" && typeof this.mConnectListener !== "undefined") {
            var listener_1 = this.mConnectListener;
            this.mTransport.on("open", function () {
                log["a" /* Logger */].getInstance().info("SocketConnection ready.[" + _this.mServerAddr.host + ":" + _this.mServerAddr.port + "]");
                listener_1.onConnected(_this);
                _this.onConnected();
            });
            this.mTransport.on("close", function () {
                log["a" /* Logger */].getInstance().info("SocketConnection close.");
                listener_1.onDisConnected(_this);
            });
            this.mTransport.on("error", function (reason) {
                log["a" /* Logger */].getInstance().info("SocketConnection error.");
                listener_1.onError(reason);
            });
        }
    }
    SocketConnection.prototype.startConnect = function (addr) {
        this.mServerAddr = addr;
        this.doConnect();
    };
    SocketConnection.prototype.stopConnect = function () {
        // TODO Maybe not necessary.
    };
    SocketConnection.prototype.send = function (data) {
        if (!this.mTransport) {
            return log["a" /* Logger */].getInstance().error("Empty transport.");
        }
        this.mTransport.Send(data);
    };
    // Frees all resources for garbage collection.
    SocketConnection.prototype.destroy = function () {
        if (this.mTransport) {
            this.mTransport.destroy();
        }
    };
    SocketConnection.prototype.onConnected = function () {
        if (!this.mTransport) {
            return log["a" /* Logger */].getInstance().error("Empty transport.");
        }
        this.mTransport.on("packet", this.onData);
    };
    SocketConnection.prototype.onData = function (data) {
        // do nothing.
        // override by subclass.
    };
    SocketConnection.prototype.doConnect = function () {
        if (!this.mTransport) {
            return log["a" /* Logger */].getInstance().error("Empty transport.");
        }
        if (this.mServerAddr.secure !== undefined)
            this.mTransport.secure = this.mServerAddr.secure;
        this.mTransport.Open(this.mServerAddr.host, this.mServerAddr.port);
    };
    return SocketConnection;
}());


// CONCATENATED MODULE: ./src/net/index.ts




/***/ }),
/* 202 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ role_manager_RoleManager; });

// EXTERNAL MODULE: ./node_modules/net-socket-packet/dist/index.js
var dist = __webpack_require__(3);

// EXTERNAL MODULE: ./src/scenes/loading.ts
var loading = __webpack_require__(24);

// EXTERNAL MODULE: ./src/scenes/basic.scene.ts
var basic_scene = __webpack_require__(16);

// CONCATENATED MODULE: ./src/scenes/create.character.ts
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var create_character_CreateRoleScene = /** @class */ (function (_super) {
    __extends(CreateRoleScene, _super);
    function CreateRoleScene() {
        return _super.call(this, { key: CreateRoleScene.name }) || this;
    }
    CreateRoleScene.prototype.init = function (data) {
        if (data.role) {
            this.role = data.role;
        }
    };
    CreateRoleScene.prototype.create = function () {
        if (this.role) {
            this.game.scene.stop(loading["a" /* LoadingScene */].name);
            this.role.start(this);
        }
    };
    return CreateRoleScene;
}(basic_scene["a" /* BasicScene */]));


// EXTERNAL MODULE: ./src/ui/components/BasePanel.ts + 2 modules
var BasePanel = __webpack_require__(41);

// EXTERNAL MODULE: ./src/ui/components/ninepatch.button.ts
var ninepatch_button = __webpack_require__(60);

// EXTERNAL MODULE: ./lib/rexui/lib/plugins/gameobjects/inputtext/InputText.js + 1 modules
var InputText = __webpack_require__(28);

// EXTERNAL MODULE: ./src/ui/components/nine.patch.ts + 1 modules
var nine_patch = __webpack_require__(42);

// EXTERNAL MODULE: ./src/rooms/display/dragonbones.display.ts + 1 modules
var dragonbones_display = __webpack_require__(97);

// EXTERNAL MODULE: ./src/rooms/display/dragonbones.model.ts
var dragonbones_model = __webpack_require__(77);

// EXTERNAL MODULE: ./src/utils/font.ts
var font = __webpack_require__(32);

// CONCATENATED MODULE: ./src/role/create.role.panel.ts
var create_role_panel_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();







// import InputText from "../../../../lib/rexui/plugins/gameobjects/inputtext/InputText";
var create_role_panel_CreateRolePanel = /** @class */ (function (_super) {
    create_role_panel_extends(CreateRolePanel, _super);
    function CreateRolePanel(scene, world) {
        var _this = _super.call(this, scene, world) || this;
        _this.key = "createCharacter";
        _this.mCurPageNum = 0;
        _this.setTween(false);
        var container = _this.scene.add.container(0, 0);
        container.add(_this);
        scene.scale.on("resize", _this.onResize, _this);
        return _this;
        // container.scale = 1 / this.mWorld.uiScale;
    }
    CreateRolePanel.prototype.show = function (param) {
        if (param) {
            this.avatars = param.avatars;
        }
        _super.prototype.show.call(this, param);
    };
    CreateRolePanel.prototype.preload = function () {
        // this.scene.load.atlas(
        //   this.key,
        //   Url.getRes("ui/create_role/create_role.png"),
        //   Url.getRes("ui/create_role/create_role.json")
        // );
        this.addAtlas(this.key, "create_role/create_role.png", "create_role/create_role.json");
        _super.prototype.preload.call(this);
    };
    CreateRolePanel.prototype.resize = function (wid, hei) {
        var size = this.mWorld.getSize();
        this.setSize(size.width, size.height);
        if (!this.mBackground) {
            return;
        }
        // this.scale = 1 / this.mWorld.uiScale;
        // this.mBackground.x = this.width >> 1;
        // this.mBackground.y = 60 + (this.mBackground.height >> 1);
        // const scale = this.scene.cameras.main.height / 1920;
        var scale = this.scale;
        var width = this.scene.cameras.main.width / scale;
        var height = this.scene.cameras.main.height / scale;
        var centerX = this.scene.cameras.main.centerX / scale;
        // this.setScale(scale);
        // this.mBackground.setScale(scale);
        this.mBackground.x = centerX;
        // this.mBackground.y = 700;
        this.mFoot.x = centerX;
        this.mFoot.y = height - (this.mFoot.height >> 1);
        this.mBackgroundColor.clear();
        this.mBackgroundColor.fillGradientStyle(0x6f75ff, 0x6f75ff, 0x04cbff, 0x04cbff);
        this.mBackgroundColor.fillRect(0, 0, width, height);
        this.mSubmit.x = centerX;
        this.inputText.x = centerX;
        this.mInputTextBg.x = centerX;
        this.dragonbones.x = centerX;
        this.mNextPageBtn.x = width - 150;
        this.mRandomBtn.x = this.mInputTextBg.x + this.mInputTextBg.width / 2 - 26 * this.dpr;
    };
    CreateRolePanel.prototype.init = function () {
        var _this = this;
        var size = this.mWorld.getSize();
        this.mBackground = this.scene.make.image({
            key: this.key,
            frame: "bg.png",
            x: size.width >> 1,
        });
        this.mBackground.y = this.mBackground.height / 2 + 92 * this.dpr;
        this.add(this.mBackground);
        this.mFoot = this.scene.make.image({
            key: this.key,
            frame: "bg_foot.png"
        }, false);
        this.add(this.mFoot);
        this.mBackgroundColor = this.scene.make.graphics(undefined, false);
        this.mBackgroundColor.fillGradientStyle(0x6f75ff, 0x6f75ff, 0x04cbff, 0x04cbff);
        this.mBackgroundColor.fillRect(0, 0, size.width, size.height);
        this.addAt(this.mBackgroundColor, 0);
        this.mInputTextBg = new nine_patch["a" /* NinePatch */](this.scene, size.width >> 1, 350 * this.dpr, 255 * this.dpr, 50 * this.dpr, this.key, "input_bg.png", {
            left: 27 * this.dpr,
            top: 24 * this.dpr,
            right: 28 * this.dpr,
            bottom: 24 * this.dpr
        });
        this.add(this.mInputTextBg);
        this.inputText = new InputText["a" /* default */](this.scene, size.width >> 1, 350 * this.dpr, 160 * this.dpr, 80, {
            type: "input",
            fontSize: 18 * this.dpr + "px",
            color: "#717171",
            align: "center",
            placeholder: "请输入昵称"
        }).setOrigin(0.5);
        this.add(this.inputText);
        var text = "提 交";
        if (this.mShowData && this.mShowData.button) {
            text = this.mShowData.button.text;
        }
        var frame = this.scene.textures.getFrame(this.key, "submit_button_normal");
        var w = 42;
        var h = 43;
        if (frame) {
            w = frame.width;
            h = frame.height;
        }
        this.mSubmit = new ninepatch_button["a" /* NinePatchButton */](this.scene, size.width >> 1, 445 * this.dpr, 202 * this.dpr, 55 * this.dpr, this.key, "submit_button", text, {
            left: 19 * this.dpr,
            top: 20 * this.dpr,
            right: w - 2 - 19 * this.dpr,
            bottom: h - 2 - 20 * this.dpr
        });
        this.mSubmit.setTextStyle({
            color: "#976400",
            fontSize: 18 * this.dpr,
            fontFamily: font["a" /* Font */].DEFULT_FONT,
        });
        this.mSubmit.setFontStyle("bold");
        this.mSubmit.on("pointerup", this.onSubmitHandler, this);
        this.add(this.mSubmit);
        this.mPrePageBtn = this.scene.make.image({
            x: 60 * this.dpr,
            y: 216 * this.dpr,
            key: this.key,
            frame: "arrow_left.png"
        }).setInteractive();
        this.mPrePageBtn.on("pointerup", this.onPrePageHandler, this);
        this.mNextPageBtn = this.scene.make.image({
            x: size.width - 60 * this.dpr,
            y: this.mPrePageBtn.y,
            key: this.key,
            frame: "arrow.png"
        }).setFlipX(true).setInteractive();
        this.mNextPageBtn.on("pointerup", this.onNextPageHandler, this);
        this.mRandomBtn = this.scene.make.image({
            x: this.mInputTextBg.x,
            y: this.mInputTextBg.y,
            key: this.key,
            frame: "random.png"
        }).setInteractive();
        this.add([this.mPrePageBtn, this.mNextPageBtn, this.mRandomBtn]);
        this.mRandomBtn.on("pointerup", this.onRandomNameHandler, this);
        // const role = this.scene.make.image({
        //   x: size.width >> 1,
        //   y: 560,
        //   key: "role",
        // }, false);
        // this.add(role);
        this.mErrorBg = this.scene.make.image({
            key: this.key,
            frame: "tips_bg.png",
            x: 220 * this.dpr,
            y: 57 * this.dpr
        }).setVisible(false);
        this.mError = this.scene.make.text({
            x: 127 * this.dpr,
            y: 30 * this.dpr,
            style: {
                color: "#26265d",
                font: "bold 34px YaHei",
                wordWrap: {
                    width: 420,
                    useAdvancedWrap: true
                },
            },
        }, false).setVisible(false);
        this.add([this.mErrorBg, this.mError]);
        this.dragonbones = new dragonbones_display["a" /* DragonbonesDisplay */](this.scene, undefined);
        this.dragonbones.scale = this.dpr * 3;
        this.dragonbones.x = size.width >> 1;
        this.dragonbones.y = this.mNextPageBtn.y + 70 * this.dpr;
        // this.dragonbones.y = 286 * this.dpr;
        // this.dragonbones.play("idle");
        this.dragonbones.once("initialized", function () {
            _this.dragonbones.play({ animationName: "idle", flip: false });
        });
        this.add(this.dragonbones);
        this.setPageNum(0);
        _super.prototype.init.call(this);
        this.resize(0, 0);
    };
    CreateRolePanel.prototype.setAvatars = function (avatars) {
        this.avatars = avatars;
        // this.dragonbones.load(new DragonbonesModel({
        //   id: 0,
        //   avatar: avatars[0]
        // }));
    };
    CreateRolePanel.prototype.showError = function (msg) {
        if (this.mError) {
            this.mError.text = msg;
            this.mError.setVisible(true);
            this.mErrorBg.setVisible(true);
        }
    };
    CreateRolePanel.prototype.setNickName = function (val) {
        if (this.inputText) {
            this.inputText.text = val;
        }
    };
    CreateRolePanel.prototype.destroy = function () {
        if (this.scene)
            this.scene.scale.off("resize", this.onResize, this);
        _super.prototype.destroy.call(this);
    };
    CreateRolePanel.prototype.onRandomNameHandler = function () {
        this.emit("randomName");
        this.inputText.setBlur();
    };
    CreateRolePanel.prototype.onSubmitHandler = function () {
        this.emit("submit", this.inputText.text, this.avatars[this.mCurPageNum]);
        this.inputText.setBlur();
        if (this.mError) {
            this.mError.setVisible(false);
            this.mErrorBg.setVisible(false);
        }
    };
    CreateRolePanel.prototype.onPrePageHandler = function () {
        this.setPageNum(this.mCurPageNum - 1);
        this.inputText.setBlur();
    };
    CreateRolePanel.prototype.onNextPageHandler = function () {
        this.setPageNum(this.mCurPageNum + 1);
        this.inputText.setBlur();
    };
    CreateRolePanel.prototype.setPageNum = function (val) {
        this.mCurPageNum = val;
        if (this.mCurPageNum < 0) {
            this.mCurPageNum = this.avatars.length - 1;
        }
        else if (this.mCurPageNum >= this.avatars.length) {
            this.mCurPageNum = 0;
        }
        this.dragonbones.load(new dragonbones_model["a" /* DragonbonesModel */]({
            id: 0,
            avatar: this.avatars[this.mCurPageNum]
        }));
    };
    CreateRolePanel.prototype.onResize = function (gameSize) {
        this.resize(gameSize.width, gameSize.height);
    };
    return CreateRolePanel;
}(BasePanel["a" /* BasePanel */]));


// EXTERNAL MODULE: ./node_modules/pixelpai_proto/protocols.js
var protocols = __webpack_require__(2);

// CONCATENATED MODULE: ./src/role/create.role.ts
var create_role_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var create_role_CreateRole = /** @class */ (function (_super) {
    create_role_extends(CreateRole, _super);
    function CreateRole($roleManager) {
        var _this = _super.call(this) || this;
        _this.roleManager = $roleManager;
        _this.world = _this.roleManager.world;
        return _this;
    }
    CreateRole.prototype.enter = function (content) {
        this.mAvatars = content.avatars;
        this.mParam = content;
        if (!this.world.game.scene.getScene(create_character_CreateRoleScene.name))
            this.world.game.scene.add(create_character_CreateRoleScene.name, create_character_CreateRoleScene);
        this.world.game.scene.start(create_character_CreateRoleScene.name, {
            world: this.world,
            role: this
        });
    };
    CreateRole.prototype.start = function (scene) {
        this.createPanel = new create_role_panel_CreateRolePanel(scene, this.world);
        this.createPanel.show(this.mParam);
        this.createPanel.on("randomName", this.onRandomNameHandler, this);
        this.createPanel.on("submit", this.onSubmitHandler, this);
        if (this.world.connection) {
            this.world.connection.addPacketListener(this);
            this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_RES_CLIENT_CREATE_ROLE_ERROR_MESSAGE, this.onCreateErrorHandler);
            this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_RES_CLIENT_CREATE_ROLE_GENERATE_NEW_NAME, this.onGenerateNameHandler);
        }
    };
    CreateRole.prototype.destroy = function () {
        if (this.world.connection) {
            this.world.connection.removePacketListener(this);
        }
        this.world.game.scene.remove(create_character_CreateRoleScene.name);
        // if (this.createPanel) this.createPanel.destroy();
    };
    CreateRole.prototype.onRandomNameHandler = function () {
        var connection = this.world.connection;
        var packet = new dist["PBpacket"](protocols["op_virtual_world"].OPCODE._OP_CLIENT_REQ_VIRTUAL_WORLD_CREATE_ROLE_GENERATE_NEW_NAME);
        connection.send(packet);
    };
    CreateRole.prototype.onSubmitHandler = function (name, avatar) {
        var connection = this.world.connection;
        var packet = new dist["PBpacket"](protocols["op_virtual_world"].OPCODE._OP_CLIENT_REQ_VIRTUAL_WORLD_CREATE_ROLE);
        var content = packet.content;
        content.name = name;
        content.avatar = avatar;
        connection.send(packet);
    };
    CreateRole.prototype.onCreateErrorHandler = function (packet) {
        if (!this.createPanel) {
            return;
        }
        var content = packet.content;
        this.createPanel.showError(content.errorMsg);
    };
    CreateRole.prototype.onGenerateNameHandler = function (packet) {
        if (!this.createPanel) {
            return;
        }
        var content = packet.content;
        this.createPanel.setNickName(content.name);
    };
    return CreateRole;
}(dist["PacketHandler"]));


// CONCATENATED MODULE: ./src/role/role.manager.ts
var role_manager_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



/**
 * 角色创建，选择管理
 */
var role_manager_RoleManager = /** @class */ (function (_super) {
    role_manager_extends(RoleManager, _super);
    function RoleManager($world) {
        var _this = _super.call(this) || this;
        _this.world = $world;
        return _this;
    }
    RoleManager.prototype.register = function () {
        if (this.world) {
            var connection = this.world.connection;
            if (connection) {
                connection.addPacketListener(this);
                this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_SHOW_CREATE_ROLE_UI, this.onOpenCreateCharacter);
                this.addHandlerFun(protocols["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_CLOSE_CREATE_ROLE_UI, this.onCloseCreateCharacterHandler);
            }
        }
    };
    RoleManager.prototype.unregister = function () {
        if (this.world) {
            var connection = this.world.connection;
            if (connection) {
                connection.removePacketListener(this);
            }
        }
    };
    RoleManager.prototype.onOpenCreateCharacter = function (packet) {
        this.mCreateCharacter = new create_role_CreateRole(this);
        this.mCreateCharacter.enter(packet.content);
    };
    RoleManager.prototype.onCloseCreateCharacterHandler = function () {
        if (this.mCreateCharacter) {
            this.mCreateCharacter.destroy();
            this.mCreateCharacter = undefined;
        }
    };
    return RoleManager;
}(dist["PacketHandler"]));



/***/ }),
/* 203 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ login_LoginScene; });

// EXTERNAL MODULE: ./lib/rexui/lib/plugins/gameobjects/inputtext/InputText.js + 1 modules
var InputText = __webpack_require__(28);

// EXTERNAL MODULE: ./src/ui/components/BasePanel.ts + 2 modules
var BasePanel = __webpack_require__(41);

// CONCATENATED MODULE: ./src/ui/alert/PopUpTextUI.ts
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var PopUpTextUI = /** @class */ (function (_super) {
    __extends(PopUpTextUI, _super);
    function PopUpTextUI(world, scene) {
        var _this = _super.call(this, scene, world) || this;
        _this.mWorld = world;
        _this.scene = scene;
        _this.disInteractive();
        return _this;
    }
    PopUpTextUI.prototype.show = function (param) {
        var _this = this;
        var size = this.mWorld.getSize();
        var text = this.scene.make.text({
            x: 0,
            y: 0,
            text: param,
            style: { fill: "#FF0000", fontSize: 20 }
        });
        this.add(text);
        this.setSize(text.width, text.height);
        this.setPosition(size.width - this.width >> 1, size.height >> 1);
        this.scene.tweens.add({
            targets: this,
            duration: 1000,
            ease: "Linear",
            props: {
                y: { value: (size.height >> 1) - 80 },
                alhpa: { value: 0 },
            },
            onComplete: function (tween, targets, element) {
                _this.destroy();
            },
            onCompleteParams: [this],
        });
        _super.prototype.show.call(this, param);
    };
    PopUpTextUI.prototype.resize = function () {
        if (!this.mInitialized)
            return;
        var size = this.mWorld.getSize();
        this.x = size.width - this.width >> 1;
    };
    PopUpTextUI.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
    };
    return PopUpTextUI;
}(BasePanel["a" /* BasePanel */]));


// EXTERNAL MODULE: ./src/utils/log.ts
var log = __webpack_require__(5);

// EXTERNAL MODULE: ./src/utils/size.ts
var utils_size = __webpack_require__(25);

// EXTERNAL MODULE: ./src/scenes/basic.scene.ts
var basic_scene = __webpack_require__(16);

// EXTERNAL MODULE: ./lib/rexui/lib/ui/baseUI/BaseUI.ts
var BaseUI = __webpack_require__(38);

// CONCATENATED MODULE: ./lib/rexui/lib/ui/combobox/Combobox.ts
var Combobox_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var SelectCallItem = /** @class */ (function (_super) {
    Combobox_extends(SelectCallItem, _super);
    function SelectCallItem(scene, selectCallUI, wid, hei, music) {
        var _this = _super.call(this, scene) || this;
        _this.mSelect = false;
        _this.mSelectCallUI = selectCallUI;
        _this.soundGroup = music;
        _this.mText = _this.scene.make.text({
            x: -wid >> 1, y: -hei >> 1,
            style: { fill: "#F7EDED", fontSize: 18 }
        }, false);
        var COLOR = 0xffcc00;
        _this.mSelectBG = scene.make.graphics(undefined, false);
        _this.mSelectBG.fillStyle(COLOR, .8);
        _this.mSelectBG.fillRect(-wid >> 1, -hei >> 1, wid, hei);
        _this.mSelectBG.visible = false;
        _this.add([_this.mSelectBG, _this.mText]);
        _this.width = wid;
        _this.height = hei;
        _this.setSize(wid, hei);
        _this.setInteractive();
        return _this;
    }
    SelectCallItem.prototype.setInteractive = function () {
        _super.prototype.setInteractive.call(this, new Phaser.Geom.Rectangle(0, 0, this.width, this.height), Phaser.Geom.Rectangle.Contains);
        return this;
    };
    SelectCallItem.prototype.addListen = function () {
        this.on("pointerover", this.overHandler, this);
        this.on("pointerout", this.outHandler, this);
        this.on("pointerdown", this.selectHandler, this);
    };
    SelectCallItem.prototype.removeListen = function () {
        this.off("pointerover", this.overHandler, this);
        this.off("pointerout", this.outHandler, this);
        this.off("pointerdown", this.selectHandler, this);
    };
    Object.defineProperty(SelectCallItem.prototype, "itemData", {
        get: function () {
            return this.mItemData;
        },
        set: function (val) {
            this.mItemData = val;
            this.mText.text = this.mItemData.text;
            this.mText.x = -this.width / 2 + (this.width - this.mText.width >> 1);
            this.mText.y = -this.height / 2 + (this.height - this.mText.height >> 1);
        },
        enumerable: false,
        configurable: true
    });
    SelectCallItem.prototype.destroy = function () {
        if (!this.mInitialized)
            return;
        this.mText.destroy(true);
        this.mSelectBG.destroy(true);
        this.mItemData = null;
        this.mText = null;
        this.mSelectBG = null;
        this.mSelectCallUI = null;
        _super.prototype.destroy.call(this);
    };
    Object.defineProperty(SelectCallItem.prototype, "selected", {
        get: function () {
            return this.mSelect;
        },
        set: function (val) {
            this.mSelectBG.visible = val;
            this.mSelect = val;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SelectCallItem.prototype, "interactive", {
        get: function () {
            return this.interactiveBoo;
        },
        enumerable: false,
        configurable: true
    });
    SelectCallItem.prototype.overHandler = function () {
        if (!this.interactiveBoo)
            return;
        this.mSelectBG.visible = true;
    };
    SelectCallItem.prototype.selectHandler = function () {
        if (!this.interactiveBoo) {
            if (this.soundGroup && this.soundGroup.disabled)
                this.mSelectCallUI.playSound(this.soundGroup.disabled);
            return;
        }
        if (this.soundGroup && this.soundGroup.down)
            this.mSelectCallUI.playSound(this.soundGroup.down);
        this.overHandler();
        this.mSelectCallUI.selectCall(this.mItemData);
    };
    SelectCallItem.prototype.outHandler = function () {
        if (!this.interactiveBoo)
            return;
        this.mSelectBG.visible = false;
    };
    return SelectCallItem;
}(BaseUI["a" /* BaseUI */]));

var ComboBox = /** @class */ (function (_super) {
    Combobox_extends(ComboBox, _super);
    function ComboBox(scene, config) {
        var _this = _super.call(this, scene) || this;
        _this.mIsopen = false;
        _this.mInitialize = false;
        _this.mConfig = config;
        _this.soundGroup = config.boxMusic;
        _this.init();
        return _this;
    }
    ComboBox.prototype.selectCall = function (itemData) {
        this.mtxt.text = itemData.text;
        this.mtxt.x = this.mConfig.wid - this.mtxt.width >> 1;
        this.mtxt.y = this.mConfig.hei - this.mtxt.height >> 1;
        this.showTween(false);
        if (this.mConfig.clickCallBack) {
            this.mConfig.clickCallBack.call(this, itemData);
        }
    };
    ComboBox.prototype.addListen = function () {
        _super.prototype.addListen.call(this);
        this.on("uiClick", this.openHandler, this);
    };
    ComboBox.prototype.removeListen = function () {
        _super.prototype.removeListen.call(this);
        this.off("uiClick", this.openHandler, this);
    };
    Object.defineProperty(ComboBox.prototype, "text", {
        set: function (value) {
            if (!this.mInitialize) {
                this.mSelectData = this.itemList[0].itemData;
                return;
            }
            if (this.itemList) {
                var itemLen = this.itemList.length;
                for (var i = 0; i < itemLen; i++) {
                    var item = this.itemList[i];
                    if (!item)
                        continue;
                    item.destroy();
                    item = null;
                }
                this.itemList.length = 0;
            }
            this.itemList = [];
            var len = value.length;
            for (var i = 0; i < len; i++) {
                var item = new SelectCallItem(this.scene, this, this.mConfig.wid, this.mConfig.hei, this.mConfig.itemMusic);
                var str = value[i];
                item.itemData = {
                    index: i,
                    text: str,
                    data: {},
                    selected: false,
                    enabled: true,
                };
                this.itemList.push(item);
            }
            // 默認顯示第0個
            this.selectCall(this.itemList[0].itemData);
        },
        enumerable: false,
        configurable: true
    });
    ComboBox.prototype.destroy = function () {
        if (this.itemList) {
            var len = this.itemList.length;
            for (var i = 0; i < len; i++) {
                var item = this.itemList[i];
                if (!item)
                    continue;
                item.destroy();
            }
            this.itemList.length = 0;
            this.itemList = null;
        }
        _super.prototype.destroy.call(this);
    };
    ComboBox.prototype.init = function () {
        var resKey = this.mConfig.resKey;
        var resPng = this.mConfig.resPng;
        var resJson = this.mConfig.resJson;
        this.mInitialize = false;
        if (!this.scene.textures.exists(resKey)) {
            this.scene.load.atlas(resKey, resPng, resJson);
            this.scene.load.once(Phaser.Loader.Events.COMPLETE, this.onLoadCompleteHandler, this);
            this.scene.load.start();
        }
        else {
            this.onLoadCompleteHandler();
        }
    };
    ComboBox.prototype.onLoadCompleteHandler = function () {
        var resKey = this.mConfig.resKey;
        this.mBg = this.scene.make.image(undefined, false);
        this.mBg.setTexture(resKey, this.mConfig.resBg);
        this.mBg.x = this.mConfig.wid / 2;
        this.mBg.y = this.mConfig.hei / 2;
        this.mBg.setSize(this.mConfig.wid, this.mConfig.hei);
        this.mArrow = this.scene.make.image(undefined, false);
        this.mArrow.setTexture(resKey, this.mConfig.resArrow);
        this.mArrow.scaleY = this.mConfig.up ? -1 : 1;
        this.mArrow.x = this.mConfig.wid - this.mArrow.width;
        this.mArrow.y = (this.mConfig.hei - this.mArrow.height >> 1) + 4;
        this.mtxt = this.scene.make.text({
            x: 0, y: 0,
            style: { fill: "#F7EDED", fontSize: 18 }
        }, false);
        this.add([this.mBg, this.mArrow, this.mtxt]);
        this.mInitialize = true;
        if (this.mSelectData) {
            this.selectCall(this.mSelectData);
        }
    };
    ComboBox.prototype.openHandler = function () {
        if (!this.interactiveBoo) {
            if (this.soundGroup && this.soundGroup.disabled)
                this.playSound(this.soundGroup.disabled);
            return;
        }
        if (this.soundGroup && this.soundGroup.expand)
            this.playSound(this.soundGroup.expand);
        if (!this.itemList || this.itemList.length < 1)
            return;
        this.showTween(this.mIsopen);
    };
    ComboBox.prototype.showTween = function (open) {
        if (open) {
            this.mItemBG = this.createTexture();
            this.addAt(this.mItemBG, 0);
        }
        else {
            if (this.mItemBG) {
                if (this.mItemBG.parentContainer) {
                    this.mItemBG.parentContainer.remove(this.mItemBG);
                }
                this.mItemBG.destroy();
            }
        }
        this.mArrow.scaleY = open ? 1 : -1;
        this.showTweenItem(open);
        this.mIsopen = !this.mIsopen;
    };
    ComboBox.prototype.showTweenItem = function (open) {
        var _this = this;
        var len = this.itemList.length;
        var _loop_1 = function (i) {
            var item = this_1.itemList[i];
            if (!item) {
                return "continue";
            }
            item.x = this_1.mConfig.wid >> 1;
            this_1.add(item);
            this_1.scene.tweens.add({
                targets: item,
                duration: 50 * i,
                props: {
                    y: { value: open ? -this_1.mConfig.hei * i - this_1.mConfig.hei / 2 : -this_1.mConfig.hei >> 1 },
                    alpha: { value: open ? 1 : 0 }
                },
                onComplete: function (tween, targets, element) {
                    if (!open) {
                        _this.remove(item);
                    }
                },
                onCompleteParams: [this_1],
            });
        };
        var this_1 = this;
        for (var i = 0; i < len; i++) {
            _loop_1(i);
        }
    };
    ComboBox.prototype.createTexture = function () {
        var COLOR = 0x3D3838;
        var height = this.mConfig.hei * this.itemList.length;
        var bgGraphics = this.scene.make.graphics(undefined, false);
        bgGraphics.fillStyle(COLOR, .8);
        bgGraphics.fillRect(0, -height, this.mConfig.wid, height);
        return bgGraphics;
    };
    return ComboBox;
}(BaseUI["a" /* BaseUI */]));


// CONCATENATED MODULE: ./src/scenes/login.ts
var login_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();






// 编辑器用 Phaser.Scene
var login_LoginScene = /** @class */ (function (_super) {
    login_extends(LoginScene, _super);
    function LoginScene() {
        var _this = _super.call(this, { key: LoginScene.name }) || this;
        _this.mCurTabIndex = 0;
        _this.mHei = 0;
        return _this;
    }
    LoginScene.prototype.preload = function () {
        this.load.atlas("login", "./resources/ui/login/login.png", "./resources/ui/login/login.json");
    };
    LoginScene.prototype.create = function () {
        var loginRes = "login";
        var width = this.scale.gameSize.width;
        var height = this.scale.gameSize.height;
        this.rect = this.add.graphics();
        this.rect.fillStyle(0);
        this.rect.fillRect(0, 0, width, height);
        var accountData = localStorage.getItem("account");
        var logo = this.make.image(undefined, false);
        logo.setTexture(loginRes, "login_logo");
        this.mHei += logo.height;
        this.mParentCon = this.add.container(width >> 1, (height >> 1) + 100);
        this.mBg = this.make.image(undefined, false);
        this.mHei += this.mBg.height + 10;
        this.mEnterBtn = this.make.image(undefined, false);
        this.mEnterBtn.setTexture(loginRes, "login_loginBtn");
        this.mEnterBtn.x = 123;
        this.mQuickBtn = this.make.image(undefined, false);
        this.mQuickBtn.setTexture(loginRes, "login_quickBtn");
        this.mQuickBtn.x = 123;
        this.mQuickBtn.y = -38;
        this.mSendCodeBtn = this.make.image(undefined, false);
        this.mSendCodeBtn.setTexture(loginRes, "login_sendBtn");
        this.mSendCodeBtn.x = 10;
        this.mSendCodeBtn.y = 67;
        this.mTab0 = this.make.image(undefined, false);
        this.mTab0.setTexture(loginRes, "login_tabSelect");
        this.mTab0.x = -105;
        this.mTab0.y = -38;
        this.mTab1 = this.make.image(undefined, false);
        this.mTab1.setTexture(loginRes, "login_tabUnSelect");
        this.mTab1.x = 7;
        this.mTab1.y = -38;
        this.mInputBg_long0 = this.make.image(undefined, false);
        this.mInputBg_long0.setTexture(loginRes, "login_inputLong");
        this.mInputBg_long0.x = -50;
        this.mInputBg_long0.y = 15;
        this.mInputBg_long1 = this.make.image(undefined, false);
        this.mInputBg_long1.setTexture(loginRes, "login_inputLong");
        this.mInputBg_long1.x = -50;
        this.mInputBg_long1.y = 67;
        this.mInputBg_small = this.make.image(undefined, false);
        this.mInputBg_small.setTexture(loginRes, "login_inputBg");
        this.mInputBg_small.x = -105;
        this.mInputBg_small.y = 67;
        this.mSizeTF = this.add.text(10, 50, "", {
            style: { color: "#000000" },
            wordWrap: { width: 800, useAdvancedWrap: true },
        });
        this.mSizeTF.setFontSize(20);
        this.mTabDic = new Map();
        this.mNameInputTxt = new InputText["a" /* default */](this, 0, 0, 190, 15, {
            type: "input",
            placeholder: "用戶名",
            fontFamily: "YaHei",
            fontSize: "14px",
            color: "#847C7C",
        })
            .resize(200, 20)
            .setOrigin(0, 0);
        this.mPassWordInputTxt = new InputText["a" /* default */](this, 0, 0, 190, 15, {
            type: "password",
            placeholder: "密码",
            fontFamily: "YaHei",
            fontSize: "14px",
            color: "#847C7C",
        })
            .resize(200, 20)
            .setOrigin(0, 0);
        this.mVerificationCodeTxt = new InputText["a" /* default */](this, 0, 0, 100, 15, {
            type: "input",
            placeholder: "验证码",
            fontFamily: "YaHei",
            fontSize: "14px",
            color: "#847C7C",
        })
            .resize(100, 20)
            .setOrigin(0, 0);
        this.mNameInputTxt.x = -140;
        this.mNameInputTxt.y = 4;
        this.mPassWordInputTxt.x = -140;
        this.mPassWordInputTxt.y = 55;
        this.mVerificationCodeTxt.x = -140;
        this.mVerificationCodeTxt.y = 55;
        // this.mtxt0 = this.add.text(-145, -46, "手机号登录", { fontFamily: "YaHei" });
        // this.mtxt1 = this.add.text(-35, -46, "用户号登录", { fontFamily: "YaHei" });
        // this.mtxt2 = this.add.text(90, -46, "快速游戏", { fontFamily: "YaHei" });
        // this.mtxt3 = this.add.text(108, 33, "登录", { fontFamily: "YaHei" });
        // this.mtxt4 = this.add.text(-97, 37, "登录其他账号", { fontFamily: "YaHei" });
        // this.mtxt5 = this.add.text(-6, 57, "发送", { fontFamily: "YaHei" });
        this.mtxt0 = this.make.text(undefined, false);
        this.mtxt1 = this.make.text(undefined, false);
        this.mtxt2 = this.make.text(undefined, false);
        this.mtxt3 = this.make.text(undefined, false);
        this.mtxt4 = this.make.text(undefined, false);
        this.mtxt5 = this.make.text(undefined, false);
        this.mtxt0.x = -145;
        this.mtxt0.y = -46;
        this.mtxt1.x = -35;
        this.mtxt1.y = -46;
        this.mtxt2.x = 90;
        this.mtxt2.y = -46;
        this.mtxt3.x = 108;
        this.mtxt3.y = 33;
        this.mtxt4.x = -97;
        this.mtxt4.y = 37;
        this.mtxt5.x = -6;
        this.mtxt5.y = 57;
        this.mtxt0.setFontFamily("YaHei");
        this.mtxt0.setText("手机号登录");
        this.mtxt1.setFontFamily("YaHei");
        this.mtxt1.setText("用户号登录");
        this.mtxt2.setFontFamily("YaHei");
        this.mtxt2.setText("快速游戏");
        this.mtxt3.setFontFamily("YaHei");
        this.mtxt3.setText("登录");
        this.mtxt4.setFontFamily("YaHei");
        this.mtxt4.setText("登录其他账号");
        this.mtxt5.setFontFamily("YaHei");
        this.mtxt5.setText("发送");
        var config = {
            wid: 220,
            hei: 36,
            resKey: "login",
            resPng: "./resources/ui/login/login.png",
            resJson: "./resources/ui/login/login.json",
            resBg: "login_inputLong",
            resArrow: "login_downArrow",
            fontStyle: { size: 20, color: "#ffcc00", bold: false },
            up: true,
            clickCallBack: this.changeID,
        };
        this.combobox = new ComboBox(this, config);
        this.combobox.x = -158;
        this.combobox.y = -28;
        logo.x = -25;
        logo.y = -logo.height / 2;
        this.changePanelState(accountData);
        this.mParentCon.add(logo);
        this.mParentCon.add(this.mBg);
        this.mParentCon.add(this.mTab0);
        this.mParentCon.add(this.mTab1);
        this.mParentCon.add(this.mQuickBtn);
        this.mParentCon.add(this.mEnterBtn);
        this.mParentCon.add(this.mSendCodeBtn);
        this.mParentCon.add(this.mInputBg_long0);
        this.mParentCon.add(this.mInputBg_long1);
        this.mParentCon.add(this.mInputBg_small);
        this.mParentCon.add(this.mNameInputTxt);
        this.mParentCon.add(this.mPassWordInputTxt);
        this.mParentCon.add(this.mVerificationCodeTxt);
        this.mParentCon.add(this.mtxt0);
        this.mParentCon.add(this.mtxt1);
        this.mParentCon.add(this.mtxt2);
        this.mParentCon.add(this.mtxt3);
        this.mParentCon.add(this.mtxt4);
        this.mParentCon.add(this.mtxt5);
        this.mParentCon.add(this.combobox);
        this.mTab0.setInteractive();
        this.mTab1.setInteractive();
        this.mQuickBtn.setInteractive();
        this.mEnterBtn.setInteractive();
        this.mSendCodeBtn.setInteractive();
        this.mtxt4.setInteractive();
        this.mTab0.tabIndex = 0;
        this.mTab1.tabIndex = 1;
        this.mTabDic.set(this.mTab0.tabIndex, this.mTab0);
        this.mTabDic.set(this.mTab1.tabIndex, this.mTab1);
        this.mCurTabIndex = 0;
        this.mTab0.on("pointerdown", this.tab0Handler, this);
        this.mTab1.on("pointerdown", this.tab1Handler, this);
        this.mQuickBtn.on("pointerdown", this.quickHandler, this);
        this.mEnterBtn.on("pointerdown", this.enterHandler, this);
        this.mSendCodeBtn.on("pointerdown", this.sendCodeHandler, this);
        this.mtxt4.on("pointerdown", this.changeAccount, this);
        this.scale.on("resize", this.checkSize, this);
        this.scale.on("orientationchange", this.onOrientationChange, this);
        this.checkSize(new utils_size["a" /* Size */](width, height));
    };
    LoginScene.prototype.init = function (data) {
        this.mConnect = data.connect;
        this.mCallBack = data.callBack;
        this.mWorld = data.world;
    };
    LoginScene.prototype.update = function () {
        var orientation = this.mWorld.getSize().width > this.mWorld.getSize().height ? "LANDSCAPE" : "PORTRAIT";
        this.mSizeTF.text =
            "width:" +
                this.mWorld.getSize().width +
                "\n" +
                "height:" +
                this.mWorld.getSize().height +
                "\n" +
                "orientation:" +
                orientation +
                "\n" +
                "devicePixelRatio:" +
                window.devicePixelRatio;
    };
    LoginScene.prototype.awake = function () {
        this.mTab0.on("pointerdown", this.tab0Handler, this);
        this.mTab1.on("pointerdown", this.tab1Handler, this);
        this.mQuickBtn.on("pointerdown", this.quickHandler, this);
        this.mEnterBtn.on("pointerdown", this.enterHandler, this);
        this.mSendCodeBtn.on("pointerdown", this.sendCodeHandler, this);
        this.mtxt4.on("pointerdown", this.changeAccount, this);
        this.scale.on("resize", this.checkSize, this);
        this.scale.on("orientationchange", this.onOrientationChange, this);
        this.scene.wake();
    };
    LoginScene.prototype.sleep = function () {
        this.mTab0.off("pointerdown", this.tab0Handler, this);
        this.mTab1.off("pointerdown", this.tab1Handler, this);
        this.mQuickBtn.off("pointerdown", this.quickHandler, this);
        this.mEnterBtn.off("pointerdown", this.enterHandler, this);
        this.mSendCodeBtn.off("pointerdown", this.sendCodeHandler, this);
        this.mtxt4.off("pointerdown", this.changeAccount, this);
        this.scale.off("resize", this.checkSize, this);
        this.scale.off("orientationchange", this.onOrientationChange, this);
        this.scene.sleep();
    };
    LoginScene.prototype.remove = function () {
        this.mTab0.off("pointerdown", this.tab0Handler, this);
        this.mTab1.off("pointerdown", this.tab1Handler, this);
        this.mQuickBtn.off("pointerdown", this.quickHandler, this);
        this.mEnterBtn.off("pointerdown", this.enterHandler, this);
        this.mSendCodeBtn.off("pointerdown", this.sendCodeHandler, this);
        this.mtxt4.off("pointerdown", this.changeAccount, this);
        this.scale.off("resize", this.checkSize, this);
        this.scale.off("orientationchange", this.onOrientationChange, this);
        this.scene.remove();
    };
    LoginScene.prototype.getKey = function () {
        return this.sys.config.key;
    };
    LoginScene.prototype.onOrientationChange = function () {
        if (this.mWorld.getConfig().platform === "app")
            return;
        var width = window.screen.width;
        var height = window.screen.height;
        this.game.scale.resize(width, height);
        this.game.canvas.style.width = window.screen.width + "";
        this.game.canvas.style.height = window.screen.height + "";
        this.mParentCon.x = width >> 1;
        if (!this.mWorld.game.device.os.desktop) {
            if (this.mWorld.game.scale.orientation === Phaser.Scale.Orientation.LANDSCAPE) {
                this.mParentCon.y = (height >> 1) + 50;
            }
            else {
                this.mParentCon.y = (height >> 1) + 50;
            }
        }
    };
    LoginScene.prototype.checkSize = function (size) {
        this.mParentCon.x = size.width >> 1;
        this.mParentCon.y = (size.height >> 1) + 50;
        log["a" /* Logger */].getInstance().log("width:" + size.width);
    };
    LoginScene.prototype.changeID = function (data) {
        // Logger.debug("============combobox 123" + data.text);
    };
    LoginScene.prototype.changeAccount = function () {
        this.changePanelState(undefined);
    };
    LoginScene.prototype.changePanelState = function (accountData) {
        var boo = !accountData;
        this.verificaHandler(boo);
        var bgRes = !accountData ? "login_loginBgBig" : "login_quickLoginBg";
        this.mBg.setTexture("login", bgRes);
        this.mEnterBtn.y = !accountData ? 40 : 15;
        this.mInputBg_long0.visible = !accountData ? true : false;
        // this.mInputBg_long0.y = accountData === undefined ? 15 : -10;
        this.mtxt3.y = !accountData ? 35 : 8;
        this.mNameInputTxt.visible = !accountData ? true : false;
        this.combobox.visible = !accountData ? false : true;
        // this.mNameInputTxt.y = accountData === undefined ? 5 : -20;
        this.mQuickBtn.visible = !accountData ? true : false;
        this.mTab0.visible = !accountData ? true : false;
        this.mTab1.visible = !accountData ? true : false;
        this.mInputBg_long1.visible = !accountData && this.mCurTabIndex !== 0 ? true : false;
        this.mPassWordInputTxt.visible = !accountData && this.mCurTabIndex !== 0 ? true : false;
        this.mtxt0.visible = !accountData ? true : false;
        this.mtxt1.visible = !accountData ? true : false;
        this.mtxt2.visible = !accountData ? true : false;
        this.mtxt4.visible = !accountData ? false : true;
        var accountObj = accountData !== undefined ? JSON.parse(accountData) : undefined;
        this.mNameInputTxt.text = !accountObj ? "" : accountObj.account;
        this.combobox.text = !accountObj ? [""] : [accountObj.account + ""];
        this.mPassWordInputTxt.text = !accountObj ? "" : accountObj.password;
        this.mParentCon.setSize(this.mBg.width, this.mHei);
        this.mParentCon.scale = window.devicePixelRatio;
        // this.mParentCon.scaleX = this.mParentCon.scaleY = this.mWorld.uiScale;
    };
    LoginScene.prototype.verificaHandler = function (show) {
        this.mVerificationCodeTxt.visible = show;
        this.mtxt5.visible = show;
        this.mInputBg_small.visible = show;
        this.mSendCodeBtn.visible = show;
        this.mInputBg_long1.visible = !show;
        this.mPassWordInputTxt.visible = !show;
    };
    LoginScene.prototype.quickHandler = function () {
        this.addTween(this.mQuickBtn);
        this.requestQuickLogin();
    };
    LoginScene.prototype.sendCodeHandler = function () {
        this.addTween(this.mSendCodeBtn);
        this.requestGetPhoneCode();
    };
    LoginScene.prototype.enterHandler = function () {
        this.addTween(this.mEnterBtn);
        if (!this.mSendCodeBtn.visible) {
            this.requestLogin();
        }
        else {
            this.loginByPhoneCode();
        }
    };
    LoginScene.prototype.addTween = function (img) {
        this.tweens.add({
            targets: img,
            duration: 50,
            ease: "Linear",
            props: {
                scaleX: { value: 0.5 },
                scaleY: { value: 0.5 },
            },
            yoyo: true,
            repeat: 0,
        });
        img.scaleX = img.scaleY = 1;
    };
    LoginScene.prototype.tab0Handler = function (pointer) {
        this.mCurTabIndex = 0;
        this.tabHandler();
    };
    LoginScene.prototype.tab1Handler = function (pointer) {
        this.mCurTabIndex = 1;
        this.tabHandler();
    };
    LoginScene.prototype.tabHandler = function () {
        var _this = this;
        this.mTabDic.forEach(function (image) {
            var tabRes = "";
            tabRes = image.tabIndex === _this.mCurTabIndex ? "login_tabSelect" : "login_tabUnSelect";
            image.setTexture("login", tabRes);
        });
        this.verificaHandler(!this.mCurTabIndex);
    };
    LoginScene.prototype.requestLogin = function () {
        var login = this;
        this.mWorld.httpService.login(login.mNameInputTxt.text, login.mPassWordInputTxt.text).then(function (response) {
            if (response.code === 200 || response.code === 201) {
                if (login.mNameInputTxt.text && login.mPassWordInputTxt.text)
                    localStorage.setItem("account", JSON.stringify({ account: login.mNameInputTxt.text, password: login.mPassWordInputTxt.text }));
                login.mWorld.account.setAccount(response.data);
                login.mCallBack(response.data);
            }
            else {
                var alert_1 = new PopUpTextUI(login.mWorld, login);
                alert_1.show("账号密码错误");
            }
        });
    };
    LoginScene.prototype.requestGetPhoneCode = function () {
        var login = this;
        this.mWorld.httpService.requestPhoneCode(login.mNameInputTxt.text).then(function (response) {
            if (response.code === 200) {
                login.mVerificationCodeTxt.setText(response.data);
            }
            else {
                var alert_2 = new PopUpTextUI(login.mWorld, login);
                alert_2.show("验证码获取失败");
            }
        });
    };
    LoginScene.prototype.loginByPhoneCode = function () {
        var login = this;
        this.mWorld.httpService
            .loginByPhoneCode(login.mNameInputTxt.text, login.mVerificationCodeTxt.text)
            .then(function (response) {
            if (response.code === 200 || response.code === 201) {
                localStorage.setItem("accountphone", JSON.stringify({ account: login.mNameInputTxt.text }));
                login.mWorld.account.setAccount(response.data);
                login.mCallBack(response.data);
            }
            else {
                var alert_3 = new PopUpTextUI(login.mWorld, login);
                alert_3.show("登录失败");
            }
        });
    };
    LoginScene.prototype.requestQuickLogin = function () {
        var login = this;
        this.mWorld.httpService.quickLogin().then(function (response) {
            if (response.code === 200 || response.code === 201) {
                localStorage.setItem("accountphone", JSON.stringify({ account: login.mNameInputTxt.text }));
                login.mWorld.account.setAccount(response.data);
                login.mCallBack(response.data);
            }
            else {
                var alert_4 = new PopUpTextUI(login.mWorld, login);
                alert_4.show("登录失败");
            }
        });
    };
    return LoginScene;
}(basic_scene["a" /* BasicScene */]));



/***/ }),
/* 204 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(__dirname) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "World", function() { return World; });
/* harmony import */ var phaser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(68);
/* harmony import */ var phaser__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(phaser__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var dragonBones__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(100);
/* harmony import */ var dragonBones__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(dragonBones__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var net_socket_packet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var net_socket_packet__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(net_socket_packet__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var pixelpai_proto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2);
/* harmony import */ var pixelpai_proto__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(pixelpai_proto__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _net_connection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(130);
/* harmony import */ var _scenes_loading__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(24);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(64);
/* harmony import */ var _rooms__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(199);
/* harmony import */ var _keyboard_manager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(135);
/* harmony import */ var _mouse_manager__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(136);
/* harmony import */ var _scenes_main_ui__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(80);
/* harmony import */ var _joystick_manager__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(137);
/* harmony import */ var _element_storage__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(138);
/* harmony import */ var _utils_resUtil__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(8);
/* harmony import */ var game_capsule__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(139);
/* harmony import */ var game_capsule__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(game_capsule__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var _ui__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(198);
/* harmony import */ var _scenes_login__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(203);
/* harmony import */ var _account__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(188);
/* harmony import */ var _net__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(201);
/* harmony import */ var _scenes_gamepause__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(190);
/* harmony import */ var _scenes_edit__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(82);
/* harmony import */ var _rooms_clock__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(65);
/* harmony import */ var _role_role_manager__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(202);
/* harmony import */ var _i18n__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(191);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(194);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_24___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_24__);
/* harmony import */ var _sound_manager__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(196);
/* harmony import */ var _loading_loading_manager__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(197);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};




























// The World act as the global Phaser.World instance;
var World = /** @class */ (function (_super) {
    __extends(World, _super);
    function World(config, callBack) {
        var _this = _super.call(this) || this;
        _this.DEFAULT_WIDTH = 360;
        _this.DEFAULT_HEIGHT = 640;
        _this.mMoveStyle = 1;
        _this.isFullStart = false;
        _this.mOrientation = 0;
        _this.gameConfigUrls = new Map();
        _this.gameConfigUrl = "";
        _this._isIOS = -1;
        // 软键盘弹出的事件处理
        _this.focusoutFunc = function () {
            // isIOS函数在前面
            if (_this.game && _this.game.device.os.iOS) {
                window.scrollTo(0, 0);
            }
        };
        _this.mCallBack = callBack;
        _this.mConfig = config;
        // TODO 检测config内的必要参数如确实抛异常.
        if (!config.game_id) {
            throw new Error("Config.game_id is required.");
        }
        if (!config.devicePixelRatio) {
            config.devicePixelRatio = window.devicePixelRatio || 1;
        }
        if (config.width === undefined) {
            config.width = window.innerWidth;
        }
        if (config.height === undefined) {
            config.height = window.innerHeight;
        }
        if (config.modulePath === undefined) {
            config.modulePath = Object({"debug":true,"api_root":"http://172.18.0.100:17170/","osd":"https://osd.tooqing.com/","gateway":Object({"host":"172.18.0.103","port":12100,"secure":false}),"game_id":"5e9a7dace87abc390c4b1b73","virtual_world_id":"65541"}).modulePath || "";
        }
        _this.mScaleRatio = Math.ceil(config.devicePixelRatio || 1);
        _this.mUIRatio = Math.round(config.devicePixelRatio || 1);
        var scaleW = config.width / _this.DEFAULT_WIDTH;
        // const scaleH = config.height / this.DEFAULT_HEIGHT;
        _this.mUIScale = scaleW;
        // if (!config.scale_ratio) {
        // config.scale_ratio = Math.round(window.innerWidth / this.DEFAULT_WIDTH * window.devicePixelRatio);
        // }
        // this.mScaleRatio = config.scale_ratio ? config.scale_ratio : window.innerWidth / this.DEFAULT_WIDTH * window.devicePixelRatio;
        _utils_resUtil__WEBPACK_IMPORTED_MODULE_13__[/* Url */ "c"].OSD_PATH = _this.mConfig.osd || "https://osd.tooqing.com/";
        _utils_resUtil__WEBPACK_IMPORTED_MODULE_13__[/* Url */ "c"].RES_PATH = "./resources/";
        _utils_resUtil__WEBPACK_IMPORTED_MODULE_13__[/* Url */ "c"].RESUI_PATH = "./resources/ui/";
        _this._newGame();
        _this.mConnection = config.connection || new _net_connection__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"](_this);
        _this.mConnection.addPacketListener(_this);
        _this.mClock = new _rooms_clock__WEBPACK_IMPORTED_MODULE_21__[/* Clock */ "a"](_this.mConnection, _this);
        // add Packet listener.
        _this.addHandlerFun(pixelpai_proto__WEBPACK_IMPORTED_MODULE_3__["op_client"].OPCODE._OP_GATEWAY_RES_CLIENT_VIRTUAL_WORLD_INIT, _this.onInitVirtualWorldPlayerInit);
        _this.addHandlerFun(pixelpai_proto__WEBPACK_IMPORTED_MODULE_3__["op_client"].OPCODE._OP_GATEWAY_RES_CLIENT_ERROR, _this.onClientErrorHandler);
        _this.addHandlerFun(pixelpai_proto__WEBPACK_IMPORTED_MODULE_3__["op_client"].OPCODE._OP_VIRTUAL_WORLD_RES_CLIENT_SELECT_CHARACTER, _this.onSelectCharacter);
        _this.addHandlerFun(pixelpai_proto__WEBPACK_IMPORTED_MODULE_3__["op_client"].OPCODE._OP_VIRTUAL_WORLD_REQ_CLIENT_GOTO_ANOTHER_GAME, _this.onGotoAnotherGame);
        _this.addHandlerFun(pixelpai_proto__WEBPACK_IMPORTED_MODULE_3__["op_client"].OPCODE._OP_GATEWAY_RES_CLIENT_PONG, _this.heartBeatCallBack);
        _this.mGameEmitter = new Phaser.Events.EventEmitter();
        _this.mRoomMamager = new _rooms__WEBPACK_IMPORTED_MODULE_7__[/* RoomManager */ "a"](_this);
        _this.mUiManager = new _ui__WEBPACK_IMPORTED_MODULE_15__[/* UiManager */ "a"](_this);
        _this.mMouseManager = new _mouse_manager__WEBPACK_IMPORTED_MODULE_9__[/* MouseManager */ "a"](_this);
        _this.mElementStorage = new _element_storage__WEBPACK_IMPORTED_MODULE_12__[/* ElementStorage */ "a"]();
        _this.mHttpService = new _net__WEBPACK_IMPORTED_MODULE_18__[/* HttpService */ "a"](_this);
        _this.mRoleManager = new _role_role_manager__WEBPACK_IMPORTED_MODULE_22__[/* RoleManager */ "a"](_this);
        _this.mSoundManager = new _sound_manager__WEBPACK_IMPORTED_MODULE_25__[/* SoundManager */ "a"](_this);
        _this.mLoadingManager = new _loading_loading_manager__WEBPACK_IMPORTED_MODULE_26__[/* LoadingManager */ "a"](_this);
        _this.mRoleManager.register();
        // this.mCharacterManager = new CharacterManager(this);
        // this.mCharacterManager.register();
        _this.mRoomMamager.addPackListener();
        _this.mUiManager.addPackListener();
        var gateway = _this.mConfig.server_addr || Object({"host":"172.18.0.103","port":12100,"secure":false});
        if (gateway) {
            // connect to game server.
            _this.mConnection.startConnect(gateway);
        }
        document.body.addEventListener("focusout", _this.focusoutFunc); // 软键盘收起的事件处理
        return _this;
    }
    Object.defineProperty(World.prototype, "moveStyle", {
        get: function () {
            return this.mMoveStyle;
        },
        enumerable: false,
        configurable: true
    });
    World.prototype.getConfig = function () {
        return this.mConfig;
    };
    World.prototype.setGameConfig = function (config) {
        this.elementStorage.setGameConfig(config);
    };
    World.prototype.updatePalette = function (palette) {
        this.elementStorage.updatePalette(palette);
    };
    World.prototype.updateMoss = function (moss) {
        this.elementStorage.updateMoss(moss);
    };
    World.prototype.destroy = function () {
        this.mConnection.closeConnect();
        document.body.removeEventListener("focusout", this.focusoutFunc); // 软键盘收起的事件处理
        this.clearGame();
    };
    World.prototype.onConnected = function (connection) {
        // Logger.getInstance().info(`enterVirtualWorld`);
        this.enterVirtualWorld();
        // this.login();
    };
    World.prototype.onDisConnected = function (connection) { };
    World.prototype.onError = function (reason) { };
    World.prototype.onClientErrorHandler = function (packet) {
        var content = packet.content;
        _utils__WEBPACK_IMPORTED_MODULE_6__[/* Logger */ "a"].getInstance().error("Remote Error[" + content.responseStatus + "]: " + content.msg);
    };
    /**
     * 当scene发生改变时，调用该方法并传入各个需要调整监听的manager中去
     */
    World.prototype.changeRoom = function (room) {
        if (this.mInputManager)
            this.mInputManager.onRoomChanged(room);
        this.mMouseManager.changeRoom(room);
        this.mSoundManager.changeRoom(room);
    };
    World.prototype.getSize = function () {
        if (!this.mGame)
            return;
        return this.mGame.scale.gameSize;
    };
    World.prototype.scaleChange = function (scale) {
        this.emitter.emit(World.SCALE_CHANGE);
    };
    World.prototype.closeGame = function () {
        if (this.mConfig.closeGame) {
            this.destroy();
            this.mConfig.closeGame();
        }
    };
    World.prototype.resize = function (width, height) {
        var w = width * window.devicePixelRatio;
        var h = height * window.devicePixelRatio;
        // if (this.mGame) {
        //     this.mGame.scale.resize(w, h);
        //     const scenes = this.mGame.scene.scenes;
        //     for (const scene of scenes) {
        //         scene.setViewPort(0, 0, w, h);
        //         // scene.cameras.main.setViewport(0, 0, w, h);
        //     }
        // }
        // if (this.mRoomMamager) {
        //     this.mRoomMamager.resize(w, h);
        // }
        // if (this.mUiManager) {
        //     this.mUiManager.resize(w, h);
        // }
        // if (this.mInputManager) {
        //     this.mInputManager.resize(w, h);
        // }
        _utils__WEBPACK_IMPORTED_MODULE_6__[/* Logger */ "a"].getInstance().log("resize" + w + "|" + h);
    };
    World.prototype.onOrientationChange = function (orientation, width, height) {
        if (this.mConfig.platform === "app")
            return;
        this.mOrientation = orientation;
        if (this.mConfig.screenWidth > this.mConfig.screenHeight) {
            // 基础是横屏
            if ((orientation <= 135 && orientation >= 45) || (orientation <= -45 && orientation >= -135)) {
                this.orientationResize(this.mConfig.screenWidth, this.mConfig.screenHeight, width, height);
            }
            else {
                this.orientationResize(this.mConfig.screenHeight, this.mConfig.screenWidth, width, height);
            }
        }
        else {
            // 基础是竖屏
            if ((orientation <= 135 && orientation >= 45) || (orientation <= -45 && orientation >= -135)) {
                this.orientationResize(this.mConfig.screenHeight, this.mConfig.screenWidth, width, height);
            }
            else {
                this.orientationResize(this.mConfig.screenWidth, this.mConfig.screenHeight, width, height);
            }
        }
    };
    World.prototype.startFullscreen = function () {
        if (!this.mGame) {
            return;
        }
        this.isFullStart = true;
        this.mGame.scale.startFullscreen();
    };
    World.prototype.stopFullscreen = function () {
        if (!this.mGame) {
            return;
        }
        this.isFullStart = false;
        this.mGame.scale.stopFullscreen();
    };
    World.prototype.onGotoAnotherGame = function (packet) {
        var content = packet.content;
        this._createAnotherGame(content.gameId, content.virtualWorldId);
    };
    World.prototype.changeScene = function () {
        return __awaiter(this, void 0, void 0, function () {
            var gameID, worldID;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        gameID = this.mConfig.game_id;
                        worldID = this.mConfig.virtual_world_id;
                        return [4 /*yield*/, this.clearGame()];
                    case 1:
                        _a.sent();
                        this.mConfig.game_id = gameID;
                        this.mConfig.virtual_world_id = worldID;
                        this._newGame();
                        this.loginEnterWorld();
                        return [2 /*return*/];
                }
            });
        });
    };
    World.prototype.reconnect = function () {
        var gameID = this.mConfig.game_id;
        var worldID = this.mConfig.virtual_world_id;
        this._createAnotherGame(gameID, worldID);
    };
    World.prototype.startHeartBeat = function () {
        var pkt = new net_socket_packet__WEBPACK_IMPORTED_MODULE_2__["PBpacket"](pixelpai_proto__WEBPACK_IMPORTED_MODULE_3__["op_gateway"].OPCODE._OP_CLIENT_REQ_GATEWAY_PING);
        this.mConnection.send(pkt);
        this.mClock.sync(-1);
    };
    World.prototype.playSound = function (config) {
        this.mSoundManager.play(config);
    };
    Object.defineProperty(World.prototype, "uiScale", {
        get: function () {
            return this.mUIScale;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World.prototype, "uiRatio", {
        get: function () {
            return this.mUIRatio;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World.prototype, "scaleRatio", {
        get: function () {
            return this.mScaleRatio;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World.prototype, "game", {
        get: function () {
            return this.mGame;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World.prototype, "roomManager", {
        get: function () {
            return this.mRoomMamager;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World.prototype, "orientation", {
        get: function () {
            return this.mOrientation;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World.prototype, "elementStorage", {
        get: function () {
            return this.mElementStorage;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World.prototype, "uiManager", {
        get: function () {
            return this.mUiManager;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World.prototype, "mouseManager", {
        get: function () {
            return this.mMouseManager;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World.prototype, "inputManager", {
        get: function () {
            return this.mInputManager;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World.prototype, "connection", {
        get: function () {
            return this.mConnection;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World.prototype, "clock", {
        get: function () {
            return this.mClock;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World.prototype, "emitter", {
        get: function () {
            return this.mGameEmitter;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World.prototype, "httpService", {
        get: function () {
            return this.mHttpService;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World.prototype, "account", {
        get: function () {
            return this.mAccount;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(World.prototype, "modulePath", {
        get: function () {
            return this.mConfig.modulePath;
        },
        enumerable: false,
        configurable: true
    });
    World.prototype.enableClick = function () {
        if (this.game &&
            this.mRoomMamager &&
            this.mRoomMamager.currentRoom &&
            this.mRoomMamager.currentRoom.scene &&
            this.mRoomMamager.currentRoom.scene.input) {
            this.mRoomMamager.currentRoom.scene.input.enabled = true;
        }
    };
    World.prototype.disableClick = function () {
        if (this.game &&
            this.mRoomMamager &&
            this.mRoomMamager.currentRoom &&
            this.mRoomMamager.currentRoom.scene &&
            this.mRoomMamager.currentRoom.scene.input) {
            this.mRoomMamager.currentRoom.scene.input.enabled = false;
        }
    };
    World.prototype.showLoading = function () {
        return this.mLoadingManager.start();
    };
    World.prototype.getGameConfig = function () {
        return this.gameConfig;
    };
    World.prototype.onClockReady = function () {
        if (this.mInputManager) {
            this.mInputManager.enable = true;
        }
    };
    World.prototype.onFocus = function () {
        if (this.connection) {
            var pkt = new net_socket_packet__WEBPACK_IMPORTED_MODULE_2__["PBpacket"](pixelpai_proto__WEBPACK_IMPORTED_MODULE_3__["op_virtual_world"].OPCODE._OP_CLIENT_REQ_VIRTUAL_WORLD_GAME_STATUS);
            var context = pkt.content;
            context.gameStatus = pixelpai_proto__WEBPACK_IMPORTED_MODULE_3__["op_def"].GameStatus.Focus;
            this.connection.send(pkt);
            // 同步心跳
            this.mClock.sync(-1);
        }
        else {
            _utils__WEBPACK_IMPORTED_MODULE_6__[/* Logger */ "a"].getInstance().error("connection is undefined");
        }
        this.resumeScene();
    };
    World.prototype.onBlur = function () {
        if (this.connection) {
            var pkt = new net_socket_packet__WEBPACK_IMPORTED_MODULE_2__["PBpacket"](pixelpai_proto__WEBPACK_IMPORTED_MODULE_3__["op_virtual_world"].OPCODE._OP_CLIENT_REQ_VIRTUAL_WORLD_GAME_STATUS);
            var context = pkt.content;
            context.gameStatus = pixelpai_proto__WEBPACK_IMPORTED_MODULE_3__["op_def"].GameStatus.Blur;
            this.connection.send(pkt);
        }
        else {
            _utils__WEBPACK_IMPORTED_MODULE_6__[/* Logger */ "a"].getInstance().error("connection is undefined");
        }
        if (this.game.device.os.desktop) {
            this.pauseScene();
        }
    };
    World.prototype.initgameConfigUrls = function (urls) {
        for (var _i = 0, urls_1 = urls; _i < urls_1.length; _i++) {
            var url = urls_1[_i];
            var sceneId = _utils__WEBPACK_IMPORTED_MODULE_6__[/* Tool */ "c"].baseName(url);
            this.gameConfigUrls.set(sceneId, url);
            if (url.split(sceneId).length === 3) {
                this.gameConfigUrl = url;
            }
        }
    };
    World.prototype.getConfigUrl = function (sceneId) {
        return this.gameConfigUrls.get(sceneId);
    };
    World.prototype.loadSceneConfig = function (sceneId) {
        var url = this.getConfigUrl(sceneId);
        return this.loadGameConfig(url);
    };
    World.prototype.createGame = function (keyEvents) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // start the game. TODO 此方法会多次调用，所以先要卸载已经实例化的游戏再new！
                        this._newGame();
                        // this.mGame.scene.add(PlayScene.name, PlayScene);
                        this.mGame.scene.add(_scenes_main_ui__WEBPACK_IMPORTED_MODULE_10__[/* MainUIScene */ "a"].name, _scenes_main_ui__WEBPACK_IMPORTED_MODULE_10__[/* MainUIScene */ "a"]);
                        this.mGame.scene.add(_scenes_edit__WEBPACK_IMPORTED_MODULE_20__[/* EditScene */ "a"].name, _scenes_edit__WEBPACK_IMPORTED_MODULE_20__[/* EditScene */ "a"]);
                        // this.mGame.events.on(Phaser.Core.Events.FOCUS, this.onFocus, this);
                        this.mGame.events.on(Phaser.Core.Events.BLUR, this.onBlur, this);
                        if (this.moveStyle === pixelpai_proto__WEBPACK_IMPORTED_MODULE_3__["op_def"].MoveStyle.DIRECTION_MOVE_STYLE || this.moveStyle === 1) {
                            if (this.mGame.device.os.desktop) {
                                this.mInputManager = new _keyboard_manager__WEBPACK_IMPORTED_MODULE_8__[/* KeyBoardManager */ "a"](this, keyEvents);
                            }
                            else {
                                this.mInputManager = new _joystick_manager__WEBPACK_IMPORTED_MODULE_11__[/* JoyStickManager */ "a"](this, keyEvents);
                            }
                        }
                        else {
                            if (this.mGame.device.os.desktop) {
                                this.mInputManager = new _keyboard_manager__WEBPACK_IMPORTED_MODULE_8__[/* KeyBoardManager */ "a"](this, keyEvents);
                            }
                        }
                        if (this.mInputManager)
                            this.mInputManager.enable = false;
                        if (window.screen.width > window.screen.height) {
                            if (this.mConfig.width > this.mConfig.height) {
                                this.resize(this.mConfig.width, this.mConfig.height);
                            }
                            else {
                                this.resize(this.mConfig.height, this.mConfig.width);
                            }
                        }
                        else {
                            if (this.mConfig.width < this.mConfig.height) {
                                this.resize(this.mConfig.width, this.mConfig.height);
                            }
                            else {
                                this.resize(this.mConfig.height, this.mConfig.width);
                            }
                        }
                        return [4 /*yield*/, this.mLoadingManager.addAssets(this.mElementStorage.getAssets())];
                    case 1:
                        _a.sent();
                        this.gameCreated();
                        return [2 /*return*/];
                }
            });
        });
    };
    World.prototype._createAnotherGame = function (gameId, worldId) {
        return __awaiter(this, void 0, void 0, function () {
            var gateway, loginScene;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.clearGame()];
                    case 1:
                        _a.sent();
                        if (this.mConnection) {
                            this.mConnection.closeConnect();
                        }
                        if (this.mClock) {
                            this.mClock.destroy();
                            this.mClock = null;
                        }
                        this.mConfig.game_id = gameId;
                        this.mConfig.virtual_world_id = worldId;
                        this.mConnection.addPacketListener(this);
                        gateway = this.mConfig.server_addr || Object({"host":"172.18.0.103","port":12100,"secure":false});
                        if (gateway) {
                            // connect to game server.
                            this.mConnection.startConnect(gateway);
                        }
                        this.mClock = new _rooms_clock__WEBPACK_IMPORTED_MODULE_21__[/* Clock */ "a"](this.mConnection, this);
                        // setTimeout(() => {
                        this._newGame();
                        loginScene = this.mGame.scene.getScene(_scenes_login__WEBPACK_IMPORTED_MODULE_16__[/* LoginScene */ "a"].name);
                        if (loginScene)
                            loginScene.remove();
                        this.mLoadingManager.start();
                        return [2 /*return*/];
                }
            });
        });
    };
    World.prototype.onFullScreenChange = function () {
        this.resize(this.mGame.scale.gameSize.width, this.mGame.scale.gameSize.height);
    };
    World.prototype.onSelectCharacter = function () {
        var pkt = new net_socket_packet__WEBPACK_IMPORTED_MODULE_2__["PBpacket"](pixelpai_proto__WEBPACK_IMPORTED_MODULE_3__["op_virtual_world"].OPCODE._OP_CLIENT_REQ_GATEWAY_CHARACTER_CREATED);
        this.connection.send(pkt);
    };
    World.prototype.clearGame = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (_this.mGame) {
                _this.mGame.events.off(Phaser.Core.Events.BLUR, _this.onBlur, _this);
                _this.mGame.scale.off("enterfullscreen", _this.onFullScreenChange, _this);
                _this.mGame.scale.off("leavefullscreen", _this.onFullScreenChange, _this);
                _this.mGame.scale.off("orientationchange", _this.onOrientationChange, _this);
                _this.mGame.plugins.removeGlobalPlugin("rexButton");
                _this.mGame.plugins.removeGlobalPlugin("rexNinePatchPlugin");
                _this.mGame.plugins.removeGlobalPlugin("rexInputText");
                _this.mGame.plugins.removeGlobalPlugin("rexBBCodeTextPlugin");
                _this.mGame.plugins.removeGlobalPlugin("rexMoveTo");
                _this.mGame.plugins.removeScenePlugin("DragonBones");
                _this.mGame.plugins.removeScenePlugin("rexUI");
                _this.mGameEmitter.destroy();
                _this.roomManager.destroy();
                _this.uiManager.destroy();
                _this.mElementStorage.destroy();
                _this.mGame.events.once(Phaser.Core.Events.DESTROY, function () {
                    _this.mGame = undefined;
                    resolve();
                });
                _this.mGame.destroy(true);
            }
            else {
                resolve();
            }
        });
    };
    World.prototype.heartBeatCallBack = function () {
        this.mConnection.clearHeartBeat();
    };
    // private initUiScale() {
    //     const width: number = this.mConfig.width;
    //     const height: number = this.mConfig.height;
    //     const baseWidth: number = this.mConfig.baseWidth;
    //     const baseHeight: number = this.mConfig.baseHeight;
    //     if (!this.mGame.device.os.desktop) {
    //         if (width < height) {
    //             this.mConfig.ui_scale = (width / baseHeight) * 2;
    //             this.mGame.scale.orientation = Phaser.Scale.Orientation.PORTRAIT;
    //         } else if (width > height) {
    //             this.mConfig.ui_scale = (width / baseWidth) * 2;
    //             this.mGame.scale.orientation = Phaser.Scale.Orientation.LANDSCAPE;
    //         }
    //     }
    // }
    World.prototype.login = function () {
        var _this = this;
        if (!this.mGame.scene.getScene(_scenes_login__WEBPACK_IMPORTED_MODULE_16__[/* LoginScene */ "a"].name)) {
            this.mGame.scene.add(_scenes_login__WEBPACK_IMPORTED_MODULE_16__[/* LoginScene */ "a"].name, _scenes_login__WEBPACK_IMPORTED_MODULE_16__[/* LoginScene */ "a"]);
        }
        this.mGame.scene.start(_scenes_login__WEBPACK_IMPORTED_MODULE_16__[/* LoginScene */ "a"].name, {
            connect: this.mConnection,
            world: this,
            callBack: function () {
                _this.loginEnterWorld();
                var loginScene = _this.mGame.scene.getScene(_scenes_login__WEBPACK_IMPORTED_MODULE_16__[/* LoginScene */ "a"].name);
                loginScene.remove();
                _this.mLoadingManager.start();
                // this.mGame.scene.start(LoadingScene.name, { world: this });
            },
        });
    };
    World.prototype.orientationResize = function (screenWidth, screenHeight, width, height) {
        if (this.mGame) {
            if (width < height) {
                // 基础竖版
                // this.mConfig.ui_scale = width / this.mConfig.baseHeight;
                this.mGame.scale.orientation = Phaser.Scale.Orientation.PORTRAIT;
                if (!this.isFullStart) {
                    _utils__WEBPACK_IMPORTED_MODULE_6__[/* Logger */ "a"].getInstance().log("竖版" + this.mGame.scale.orientation);
                }
            }
            else {
                // 基础横版
                // this.mConfig.ui_scale = width / this.mConfig.baseWidth;
                this.mGame.scale.orientation = Phaser.Scale.Orientation.LANDSCAPE;
                if (!this.isFullStart) {
                    _utils__WEBPACK_IMPORTED_MODULE_6__[/* Logger */ "a"].getInstance().log("横版" + this.mGame.scale.orientation);
                }
            }
            this.mGame.scale.resize(screenWidth, screenHeight);
            _utils__WEBPACK_IMPORTED_MODULE_6__[/* Logger */ "a"].getInstance().log("orientation" + this.mGame.scale.orientation);
        }
        if (this.mRoomMamager) {
            this.mRoomMamager.resize(width, height);
        }
        if (this.mUiManager) {
            this.mUiManager.resize(width, height);
        }
        if (this.mInputManager) {
            this.mInputManager.resize(width, height);
        }
    };
    World.prototype.enterVirtualWorld = function () {
        if (!this.mGame) {
            this.reconnect();
            return;
        }
        if (this.mConfig && this.mConnection) {
            this.mAccount = new _account__WEBPACK_IMPORTED_MODULE_17__[/* Account */ "a"]();
            var loadingScene = this.mGame.scene.getScene(_scenes_loading__WEBPACK_IMPORTED_MODULE_5__[/* LoadingScene */ "a"].name);
            if (!loadingScene) {
                this.mGame.scene.add(_scenes_loading__WEBPACK_IMPORTED_MODULE_5__[/* LoadingScene */ "a"].name, _scenes_loading__WEBPACK_IMPORTED_MODULE_5__[/* LoadingScene */ "a"]);
            }
            if (!this.mConfig.auth_token) {
                this.login();
                return;
            }
            else {
                // this.mGame.scene.start(LoadingScene.name, { world: this });
                this.mLoadingManager.start();
                this.mAccount.setAccount({
                    token: this.mConfig.auth_token,
                    expire: this.mConfig.token_expire,
                    fingerprint: this.mConfig.token_fingerprint,
                });
            }
            this.loginEnterWorld();
        }
    };
    World.prototype.loginEnterWorld = function () {
        return __awaiter(this, void 0, void 0, function () {
            var pkt, content;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Object(_i18n__WEBPACK_IMPORTED_MODULE_23__[/* initLocales */ "a"])(path__WEBPACK_IMPORTED_MODULE_24__["relative"](__dirname, "../resources/locales/{{lng}}.json"))];
                    case 1:
                        _a.sent();
                        pkt = new net_socket_packet__WEBPACK_IMPORTED_MODULE_2__["PBpacket"](pixelpai_proto__WEBPACK_IMPORTED_MODULE_3__["op_gateway"].OPCODE._OP_CLIENT_REQ_VIRTUAL_WORLD_PLAYER_INIT);
                        content = pkt.content;
                        // Logger.getInstance().log(`VW_id: ${this.mConfig.virtual_world_id}`);
                        content.virtualWorldUuid = "" + this.mConfig.virtual_world_id;
                        if (!this.mConfig.game_id ||
                            !this.mAccount ||
                            !this.mAccount.accountData ||
                            !this.mAccount.accountData.token ||
                            !this.mAccount.accountData.expire ||
                            !this.mAccount.accountData.fingerprint) {
                            // Logger.getInstance().debug("缺少必要参数，无法登录游戏");
                            if (this.mGame)
                                this.mGame.destroy(true);
                            return [2 /*return*/];
                        }
                        content.gameId = this.mConfig.game_id;
                        // const accountObj = JSON.parse();
                        content.userToken = this.mConfig.auth_token = this.mAccount.accountData.token; // auth_token;
                        content.expire = this.mConfig.token_expire = this.mAccount.accountData.expire + "";
                        content.fingerprint = this.mConfig.token_fingerprint = this.mAccount.accountData.fingerprint;
                        this.mConnection.send(pkt);
                        return [2 /*return*/];
                }
            });
        });
    };
    World.prototype.onInitVirtualWorldPlayerInit = function (packet) {
        var _this = this;
        // if (this.mClock) this.mClock.sync(); // Manual sync remote time.
        // TODO 进游戏前预加载资源
        var content = packet.content;
        var configUrls = content.configUrls;
        this.mMoveStyle = content.moveStyle;
        this.clock.sync(-1);
        this.initgameConfigUrls(configUrls);
        if (!configUrls || configUrls.length <= 0) {
            _utils__WEBPACK_IMPORTED_MODULE_6__[/* Logger */ "a"].getInstance().error("configUrls error: , " + configUrls + ", gameId: " + this.mConfig.game_id);
            this.createGame(content.keyEvents);
            return;
        }
        _utils__WEBPACK_IMPORTED_MODULE_6__[/* Logger */ "a"].getInstance().log("mMoveStyle:" + content.moveStyle);
        var game_id = this.mConfig.game_id;
        if (game_id.indexOf(".") > -1) {
            game_id = game_id.split(".")[1];
        }
        var mainGameConfigUrl = this.gameConfigUrl;
        this.loadGameConfig(mainGameConfigUrl)
            .then(function (gameConfig) {
            _this.mElementStorage.setGameConfig(gameConfig);
            _this.createGame(content.keyEvents);
            _utils__WEBPACK_IMPORTED_MODULE_6__[/* Logger */ "a"].getInstance().debug("created game suc");
        })
            .catch(function (err) {
            _utils__WEBPACK_IMPORTED_MODULE_6__[/* Logger */ "a"].getInstance().log(err);
        });
    };
    World.prototype._newGame = function () {
        if (this.mGame) {
            return this.mGame;
        }
        this.gameConfig = {
            type: Phaser.AUTO,
            parent: this.mConfig.parent || "game",
            scene: null,
            disableContextMenu: true,
            transparent: false,
            backgroundColor: 0x0,
            resolution: 1,
            fps: {
                target: 30,
            },
            dom: {
                createContainer: true,
            },
            plugins: {
                //     global: [
                //         {
                //             key: "rexButton",
                //             plugin: ButtonPlugin,
                //             start: true,
                //         },
                //         {
                //             key: "rexNinePatchPlugin",
                //             plugin: NinePatchPlugin,
                //             start: true,
                //         },
                //         {
                //             key: "rexInputText",
                //             plugin: InputTextPlugin,
                //             start: true,
                //         },
                //         {
                //             key: "rexBBCodeTextPlugin",
                //             plugin: BBCodeTextPlugin,
                //             start: true,
                //         },
                //     ],
                scene: [
                    {
                        key: "DragonBones",
                        plugin: dragonBones.phaser.plugin.DragonBonesScenePlugin,
                        mapping: "dragonbone",
                    },
                ],
            },
            render: {
                pixelArt: false,
                roundPixels: true,
            },
            scale: {
                mode: Phaser.Scale.NONE,
                width: this.mConfig.width * window.devicePixelRatio,
                height: this.mConfig.height * window.devicePixelRatio,
                zoom: 1 / window.devicePixelRatio,
            },
        };
        Object.assign(this.gameConfig, this.mConfig);
        this.mGame = new phaser__WEBPACK_IMPORTED_MODULE_0__["Game"](this.gameConfig);
        this.mGame.input.mouse.capture = true;
        if (this.mGame.device.os.desktop) {
            this.mUIScale = 1;
        }
        if (this.mRoomMamager)
            this.mRoomMamager.addPackListener();
        if (this.mUiManager)
            this.mUiManager.addPackListener();
        if (this.mRoleManager)
            this.mRoleManager.register();
        if (this.mElementStorage) {
            this.mElementStorage.on("SCENE_PI_LOAD_COMPELETE", this.loadSceneConfig);
        }
        // if (this.mCharacterManager) this.mCharacterManager.register();
        return this.mGame;
    };
    World.prototype.gameCreated = function () {
        if (this.connection) {
            var pkt = new net_socket_packet__WEBPACK_IMPORTED_MODULE_2__["PBpacket"](pixelpai_proto__WEBPACK_IMPORTED_MODULE_3__["op_virtual_world"].OPCODE._OP_CLIENT_REQ_GATEWAY_GAME_CREATED);
            this.connection.send(pkt);
            if (this.mCallBack) {
                this.mCallBack();
            }
            if (this.mConfig.game_created) {
                this.mConfig.game_created();
            }
        }
        else {
            // Logger.getInstance().error("connection is undefined");
        }
        this.mGame.scale.on("enterfullscreen", this.onFullScreenChange, this);
        this.mGame.scale.on("leavefullscreen", this.onFullScreenChange, this);
        // this.mGame.scale.on("orientationchange", this.onOrientationChange, this);
    };
    World.prototype.loadGameConfig = function (remotePath) {
        var _this = this;
        var configPath = _utils_resUtil__WEBPACK_IMPORTED_MODULE_13__[/* ResUtils */ "b"].getGameConfig(remotePath);
        return Object(_utils__WEBPACK_IMPORTED_MODULE_6__[/* load */ "d"])(configPath, "arraybuffer").then(function (req) {
            _utils__WEBPACK_IMPORTED_MODULE_6__[/* Logger */ "a"].getInstance().log("start decodeConfig");
            return _this.decodeConfigs(req);
        });
    };
    World.prototype.decodeConfigs = function (req) {
        return new Promise(function (resolve, reject) {
            var arraybuffer = req.response;
            if (arraybuffer) {
                try {
                    var gameConfig = new game_capsule__WEBPACK_IMPORTED_MODULE_14__["Lite"]();
                    gameConfig.deserialize(new Uint8Array(arraybuffer));
                    _utils__WEBPACK_IMPORTED_MODULE_6__[/* Logger */ "a"].getInstance().log("TCL: World -> gameConfig", gameConfig);
                    resolve(gameConfig);
                }
                catch (error) {
                    reject(error);
                }
            }
            else {
                reject("error");
            }
        });
    };
    World.prototype.resumeScene = function () {
        if (this.mConfig.isEditor) {
            return;
        }
        this.mRoomMamager.onFocus();
        if (this.mGame && this.mConfig.platform === "pc") {
            var pauseScene = this.mGame.scene.getScene(_scenes_gamepause__WEBPACK_IMPORTED_MODULE_19__[/* GamePauseScene */ "a"].name);
            if (pauseScene) {
                pauseScene.sleep();
                this.mGame.scene.stop(_scenes_gamepause__WEBPACK_IMPORTED_MODULE_19__[/* GamePauseScene */ "a"].name);
            }
        }
    };
    World.prototype.pauseScene = function () {
        if (this.mConfig.isEditor) {
            return;
        }
        this.mRoomMamager.onBlur();
        if (this.mGame && this.mConfig.platform === "pc") {
            if (!this.mGame.scene.getScene(_scenes_gamepause__WEBPACK_IMPORTED_MODULE_19__[/* GamePauseScene */ "a"].name)) {
                this.mGame.scene.add(_scenes_gamepause__WEBPACK_IMPORTED_MODULE_19__[/* GamePauseScene */ "a"].name, _scenes_gamepause__WEBPACK_IMPORTED_MODULE_19__[/* GamePauseScene */ "a"]);
            }
            this.mGame.scene.start(_scenes_gamepause__WEBPACK_IMPORTED_MODULE_19__[/* GamePauseScene */ "a"].name, { world: this });
        }
    };
    World.SCALE_CHANGE = "scale_change";
    return World;
}(net_socket_packet__WEBPACK_IMPORTED_MODULE_2__["PacketHandler"]));


/* WEBPACK VAR INJECTION */}.call(this, "/"))

/***/ })
]]);